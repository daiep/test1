/*
 *  epi2.host.cpp
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Nov 24 2018
 *  Time : 13:36:59
 */

#include <values.h>
#include <string.h>
#include "epic_macros.h"
#include "epic_struct.h"
#include "epi2.global.h"
#include "pgen_tmpl.h"
#include "epi2.allcv.h"
#include "epi2.tgtex.h"
#include "epi2.hostdecl.h"
#include "epi2.tgtdecl.h"
#include "epi2.exportstr.h"
#include "epi2.runtime.h"
int omegathetamod_func(int dur, 
		       int isodelay,
		       short *om_in, 
		       int om_res, 
		       int om_amp_hz, 
		       short *th_in, 
		       int th_res, 
		       short *gz_in, 
		       int gz_res, 
		       float gz_amp_gcm, 
		       float zoffset,
		       short *om_out_iamp, 
		       LONG *om_out_wave, 
		       LONG *th_out_wave)
{
  int res_out;		       /* Resolution of output waveforms */
  float *kz_omth;	       /* Excitation k-space */
  float *freq_in_omth;     /* Floating-point frequency waveform */
  float *phase_in_omth;    /* Floating-point phase waveform */
  int idx;		       /* temp index */
  int gzidx;	       /* temp index */
  int kzidx;	       /* temp index */
  int omidx;	       /* temp index */
  int thidx;	       /* temp index */
  int zm, zmidx;	       /* zoom factor and index */
  float gscale_to_kz;      /* Conversion to cycles/cm */
  float kzint;	       /* Current Kz integral */
  float kzref;	       /* Kz reference value */
  float freq_ideal_max; 
  float *phase_ideal_omth; /* Ideal output phase waveform */
  float *freq_ideal_omth; /* Ideal output frequency waveform */
  float *phase_correct_omth; /* Phase correction to apply after non-ideal frequency */
  short *freq_out_omth;
  short *phase_out_omth;
  float phase_wrap_off;    /* phase unwrapping offset */
  float phase_save;    /* temp variable used during phase unwrapping */
  float phaseref;	       /* Kz reference value */
  float phdiff;	       /* temp value */

  WF_PULSE temp_om_omth = INITPULSE;  /* temp Omega waveform pulse */
  WF_PULSE temp_th_omth = INITPULSE;  /* temp Theta waveform pulse */

  static const CHAR *routine = "omegathetamod";

  /* Calculate resolution of omega-theta waveforms */
  res_out = dur/ RF_UPDATE_TIME;

  kz_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for floating-point frequency / phase inputs */
  freq_in_omth = (float *)AllocNode(res_out * sizeof(float));

  phase_in_omth = (float *)AllocNode(res_out * sizeof(float));
      
  /* Initialize frequency and phase input waveforms to zero */
  for (idx = 0; idx < res_out; idx++) {
    freq_in_omth[idx] = 0.0;
    phase_in_omth[idx] = 0.0;
  }

  /* Allocate memory for ideal phase */
  phase_ideal_omth = (float *)AllocNode(res_out * sizeof(float));

  freq_ideal_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for phase correction to omega quantization */
  phase_correct_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for temporary phase / frequency final results */
  phase_out_omth = (short *)AllocNode(res_out * sizeof(short));
  freq_out_omth = (short *)AllocNode(res_out * sizeof(short));

  /* Calculate interpolation required to apply to gradient */
  zm = res_out/ gz_res;

  /* Calculate excitation k-space at RF_UPDATE_TIME spacing */
  /* NOTE - Excitation k-space is integrated from t to T (end of pulse)!! */
  kzidx = res_out-1;
  kzint = 0.0;
  gscale_to_kz = -GAM * gz_amp_gcm * 1.0e-6 * RF_UPDATE_TIME/ max_pg_wamp;
  for (gzidx = gz_res-1; gzidx >= 0; gzidx--)
    for (zmidx = 0; zmidx <zm; zmidx++) {
      kzint = kzint + gscale_to_kz * gz_in[gzidx];
      kz_omth[kzidx--] = kzint;
    }
      
  /* Remove offset to k-space origin reference -- this will keep excitation profile / phase
     constant independent of the offset applied */
  kzref = kz_omth[((int) (res_out - isodelay/RF_UPDATE_TIME))];
  for (kzidx = 0; kzidx < res_out; kzidx++) 
    kz_omth[kzidx] -= kzref;

  /* Now read in external frequency waveform if it exists */
  if (om_res != 0) { /* Check for non-null input */
    /* Assign freq_omth to input frequency waveform - do NOT interpolate */
    zm = res_out/ om_res;
    if (om_res * zm != res_out) {
        MsgHndlr(routine,
                 MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "OMEGA resolution");
      return FAILURE;
    }

    idx = 0;
    for (omidx = 0; omidx < om_res; omidx++)
      for (zmidx = 0; zmidx <zm; zmidx++) 
	freq_in_omth[idx++] = (om_in[omidx] * om_amp_hz/ max_pg_wamp) * 1.0;
  } /* non-null omega */

  /* Now read in external phase waveform if it exists */
  if (th_res != 0) {	/* Check for non-null string filename */
    /* Assign freq_omth to input frequency waveform - do NOT interpolate */
    zm = res_out/ th_res;
    if (th_res * zm != res_out) {
        MsgHndlr(routine,
                 MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "THETA resolution");
      return FAILURE;
    }

    idx = 0;
    for (thidx = 0; thidx < th_res; thidx++)
      for (zmidx = 0; zmidx <zm; zmidx++) 
	phase_in_omth[idx++] = th_in[thidx] * PI/ max_pg_wamp;
  } /* non-null theta file string */

  /* Reserve waveform memory for omega / theta waveforms */
  *th_out_wave = createwreserve(&temp_th_omth, TYPTHETA, res_out);
  *om_out_wave = createwreserve(&temp_om_omth, TYPOMEGA, res_out);

  /* Calculate ideal phase waveform by first integrating frequency */
  for (idx = 0; idx < res_out; idx++) 
    if (idx == 0)
      phase_ideal_omth[idx] = 2 * PI * freq_in_omth[idx] * RF_UPDATE_TIME * 1e-6;
    else
      phase_ideal_omth[idx] = phase_ideal_omth[idx-1] + 2 * PI * freq_in_omth[idx] * RF_UPDATE_TIME * 1e-6;
  /* Set phase to 0 at reference point in pulse */
  phaseref = phase_ideal_omth[((int) (res_out - isodelay/RF_UPDATE_TIME))];
  for (idx = 0; idx < res_out; idx++) {
    phase_ideal_omth[idx] -= phaseref;
  }

  /* Calculate phase contribution from Z offset and input phase waveform */
  for (idx = 0; idx < res_out; idx++) {
    phase_ideal_omth[idx] = phase_ideal_omth[idx] + phase_in_omth[idx] - omegatheta_pol * 2 * PI * kz_omth[idx] * zoffset;
    phase_ideal_omth[idx] = MODTWOPI(phase_ideal_omth[idx]);
  }
	
  /* Unwrap phase waveform */
  phase_wrap_off = 0.0;
  phase_save = phase_ideal_omth[0];
  for (idx = 1; idx < res_out; idx++) {
    phdiff = phase_ideal_omth[idx] - phase_save;
    phase_save = phase_ideal_omth[idx];
    if (phdiff < -PI)
      phase_wrap_off += 2 * PI;
    if (phdiff > PI) 
      phase_wrap_off -= 2 * PI;
    phase_ideal_omth[idx] += phase_wrap_off;
  }

  /* Calculate ideal frequency waveforms and max frequency */
  freq_ideal_max = 0.0;
  for (idx = 0; idx < res_out-1; idx++) {
    freq_ideal_omth[idx] = (phase_ideal_omth[idx+1]-phase_ideal_omth[idx])/(2*PI*RF_UPDATE_TIME*1e-6);
    freq_ideal_max = FMax(2, freq_ideal_max, FABS(freq_ideal_omth[idx]));
  }
  freq_ideal_omth[res_out-1] = freq_ideal_omth[res_out-2];
  /* We must now quantize the ideal frequency waveform onto a 16-bit
     time-varying waveform and a 16-bit instruciton multiplier. The effective
     frequency that will be encoded by the waveform / instruction
     amplitude product is in the 24 MSBs of the product. e.g. 

     freq = (wamp * iamp / 2^7) * TARDIS_FREQ_RES

     If we scale the max wamp to a full signed 16 bits, then the instruction
     amplitude will be scaled by 2^15

     freq = (max_wamp * iamp / 2^7) * TARDIS_FREQ_RES

     or 

     iamp = freq * 2^7 / (TARDIS_FREQ_RES * 2^15)
     iamp = freq / (TARDIS_FREQ_RES * 2^8)
  */

  for (idx = 0; idx < res_out; idx++) {
    if (freq_ideal_max > 0.0)
      freq_out_omth[idx] = (int)(freq_ideal_omth[idx]/ freq_ideal_max * max_pg_wamp);
    else
      freq_out_omth[idx] = max_pg_wamp;
    freq_out_omth[idx] &= 0xfffe; /* Set LSB to 0 */
  }
  freq_out_omth[res_out-1] |= 1; /* Set LSB to 1 */
	
  /* Move frequency waveform to hardware, save instruction amplitude */
  movewavememimm(&temp_om_omth, TYPOMEGA, freq_out_omth, *om_out_wave, res_out, TOHARDWARE);
  *om_out_iamp = (int) (freq_ideal_max/ (TARDIS_FREQ_RES * 256.0));

  /* Now calculate phase correction to apply to achieve the ideal desired
     phase at each time point. This corrects for quantization errors in the
     frequency waveform. Start with calculating the integral of the frequency
     waveform, then calculate the correction to apply. */
  for (idx = 0; idx < res_out; idx++) 
    if (idx == 0)
      phase_correct_omth[idx] = ((int) ((freq_out_omth[idx] * (*om_out_iamp)) >> 7)) * TARDIS_FREQ_RES * RF_UPDATE_TIME * 1e-6 * 2 * PI;  
    else
      phase_correct_omth[idx] = phase_correct_omth[idx-1] + ((int) ((freq_out_omth[idx] * (*om_out_iamp)) >> 7)) * TARDIS_FREQ_RES * RF_UPDATE_TIME * 1e-6 * 2 * PI;  

  for (idx = 0; idx < res_out; idx++) 
    phase_correct_omth[idx] = phase_ideal_omth[idx] - phase_correct_omth[idx];

  /* Convert phase correction into [-pi, pi] range and convert to digital scale */
  for (idx = 0; idx < res_out; idx++) {
    phase_correct_omth[idx] = MODTWOPI(phase_correct_omth[idx]);
    phase_out_omth[idx] = (short)(phase_correct_omth[idx] * max_pg_wamp/ PI);
    phase_out_omth[idx] &= 0xfffe;
  }
  phase_out_omth[res_out-1] |= 0x0001;

  /* Move phase waveform to hardware */
  movewavememimm(&temp_th_omth, TYPTHETA, phase_out_omth, *th_out_wave, res_out, TOHARDWARE);

  /* Now free up all the memory we reserved */
  FreeNode((ADDRESS) kz_omth);
  FreeNode((ADDRESS) freq_in_omth);
  FreeNode((ADDRESS) phase_in_omth);
  FreeNode((ADDRESS) phase_ideal_omth);
  FreeNode((ADDRESS) freq_ideal_omth);
  FreeNode((ADDRESS) phase_correct_omth);
  FreeNode((ADDRESS) phase_out_omth);
  FreeNode((ADDRESS) freq_out_omth);

  return(SUCCESS);
}


/* System includes */
#include <ctype.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h> /*RTB0 correction*/
#include <sys/stat.h>

/* Local includes */
#include "calcdelta.h"
#include "dBdt.h"
#ifndef SIM
/* Needed for epic_warning() */
#include "epic_warning.h"
#endif /* SIM */
#include "grad_rf_epi2.h"
#include "grad_navmonitor.h"
#include "printDebug.h"
#include "psd.h"
#include "psdIF.h"
#include "psdopt.h"
#include "rfsspsummary.h"
#include "sar_burst_api.h"
#include "sar_display_api.h"
#include "sar_limit_api.h"
#include "sar_pm.h"
#include "sokPortable.h"   /* includes for option key functionality */
#include "supp_macros.h"
#include "sysDep.h"
#include "sysDepSupport.h"
/* t1flair_stir */
#include "T1flair.h"
#include "time_profiler_client.h"

#ifdef EMULATE_HW
#define checkOptionKey(x) 0
#endif

#include "physics.h"
#include "psdIF.h"

MODEL_PARAMETERS_STRUCT model_parameters;
PURE_MIX_STRUCT pure_mix;
SCENIC_STRUCT scenic;

int anatomy_channel_compr_enable = PSD_OFF;
int anatomy_optimal_recon_enable = PSD_OFF;
int anatomy_self_uni_corr_enable = PSD_OFF;

int apps_channel_compr_enable = PSD_OFF;
int apps_self_uni_corr_enable = PSD_OFF;


/* Private function prototypes */
static INT setEpiEsp(void);

static void SetCyclingCVs(void);

/* Private function prototypes for ASPIR TI */
static void init_ASPIR_TI(void);
static INT calc_ASPIR_TI(int);
static void set_ASPIR_TI(int);

/*dbdt_model related functions*/
STATUS optGradAndEsp_conv(void);
STATUS optGradAndEsp_rect(void);
STATUS epigradopt_rect(float, int);
float calcdbdtper_conv(void);
float intercept(float, float, int, int);
STATUS searchEspLonger_rect(int, int);
int getEspOutOfUnwantedRange(int, int, int);
int isGradAndEspReoptNeeded(void);
int getReadoutPhyAxis(void);
int isEspOutOfUnwantedRange(int,int,float);
STATUS readEspRange(void);
void procNoEspRangeFile(FILE *);
void printEpigradoptLog(void);
void printEpigradoptResult(void);
void printCornerPoint(int, int *, float *, float *);
void printDbdtper(float, int nump, int *, float *, float *, float *);
void printEspRange(void);
void procNoEspRangeFile(FILE * fp);
void resetVariables(FILE * fp);

static INT read_grad_res(float wave_number, int* res_gd1, int* res_gd2);/* maybe granty */
static INT get_diffusion_time( void );
static INT update_sse_diffusion_time( void );
static FLOAT calc_incdif(float *DELTA, float *delta, int Delta_time, int pw_gdl, int pw_gdld, int pw_gdla, int pw_gdra, float bvaltemp);
static INT set_tensor_orientations( void );
static INT sort_tensor_orientations(void);
static INT calc_orientations( void );
static INT derate_diffusion_amplitude(void);
static INT get_sse_waittime( void );
static STATUS update_opmintedif(void);
/* Local Cvs */
float TENSOR_HOST[3][MAX_DIRECTIONS + MAX_T2];        /* Tensor Amplitude Array (directions + t2) */
float WAVE_HOST[MAX_DIRECTIONS + MAX_T2];/* maybe granty */
float B_MATRIX[6][MAX_DIRECTIONS + MAX_T2];           /* B-Matrix */
int sort_index[MAX_DIRECTIONS + MAX_T2];
float mag[MAX_DIRECTIONS + MAX_T2];
float scale_gmax;


/* SVBranch HCSDM00155611 control of Type I pulse */
/* Starter HCSDM00522509 Add new Type-I and Type-II FOCUS pulse for Starter System */
STATUS type1_control(void)
{

    if(isValueSystem())
    {
        type1_support  = _type1_support.fixedflag ?  ((void)(PSD_ON), type1_support) : PSD_ON;
    }
    else
    {
        type1_support  = _type1_support.fixedflag ?  ((void)(PSD_OFF), type1_support) : PSD_OFF;
    }

    return SUCCESS;
}

/* scale the gradients according to slew rate */
void value_system_grad_scale(void)
{

    if( (154009096 != rfov_type) && 
        (isSVSystem() || isK15TSystem()) )
    {
        /* slew rate of value system is 100 T/m/s, while
           the original RFs are designed for 120 T/m/s system; */
        ex_a_gys     = _ex_a_gys.fixedflag ?     ((void)(ex_a_gys*100.0/120.0), ex_a_gys) : ex_a_gys*100.0/120.0;  
        ex_a_gzs     = _ex_a_gzs.fixedflag ?     ((void)(ex_a_gzs*100.0/120.0), ex_a_gzs) : ex_a_gzs*100.0/120.0;
        ex_nom_thky  = _ex_nom_thky.fixedflag ?     ((void)(ex_nom_thky*120.0/100.0), ex_nom_thky) : ex_nom_thky*120.0/100.0;
        ex_nom_thkz  = _ex_nom_thkz.fixedflag ?     ((void)(ex_nom_thkz*120.0/100.0), ex_nom_thkz) : ex_nom_thkz*120.0/100.0;
    }

}
 
/* Read external RF pulse info files */
STATUS read_rfpulse_info(void)
{
    int tmpacq, tmpslquant; /* HCSDM00155514 */

    /* Representation of the type of RF pulse to use based
       on field strength (FS), phase FOV (FOV), number of
       slices (SLQ) and gradient amplitude (XFS)
       8 digits: (FS)(FS)(FOV)(FOV)(SLQ)(SLQ)(XFS)(XFS) */

    switch ((int)cffield)
    {
        case B0_15000:
            rfov_type  = _rfov_type.fixedflag ?    ((void)(15*1e6), rfov_type) : 15*1e6;
            break;
        default:
        case B0_30000:
            rfov_type  = _rfov_type.fixedflag ?    ((void)(30*1e6), rfov_type) : 30*1e6;
            break;
    }

    /* Setting up RF filename based on phase FOV */
    /* SVBranch HCSDM00155611 the limit params are recalced for SR = 100T/m/s */
    if(isSVSystem() || isK15TSystem()) 
    {
        if (exist(opfov)*exist(opphasefov) >= 71)
            rfov_type  = _rfov_type.fixedflag ?    ((void)(60*1e4), rfov_type) : rfov_type+60*1e4;
        else if (exist(opfov)*exist(opphasefov) >= 60)
            rfov_type  = _rfov_type.fixedflag ?    ((void)(50*1e4), rfov_type) : rfov_type+50*1e4;
        else
            rfov_type  = _rfov_type.fixedflag ?    ((void)(40*1e4), rfov_type) : rfov_type+40*1e4; 
    }   
    else /* original case */
    {
        if (exist(opfov)*exist(opphasefov) >= 60)
            rfov_type  = _rfov_type.fixedflag ?    ((void)(60*1e4), rfov_type) : rfov_type+60*1e4;
        else if (exist(opfov)*exist(opphasefov) >= 50)
            rfov_type  = _rfov_type.fixedflag ?    ((void)(50*1e4), rfov_type) : rfov_type+50*1e4;
        else
            rfov_type  = _rfov_type.fixedflag ?    ((void)(40*1e4), rfov_type) : rfov_type+40*1e4;
    }        
    
    /* Followed by number of slices per acq */
    if ((exist(opinrangetr) > 0) && (exist(optracq) > 0))
    {
        tmpacq = optracq;
    }
    else
    {
        tmpacq = acqs;
    }

    tmpslquant = exist(opslquant)/tmpacq + (((exist(opslquant)%tmpacq) > 0) ? 1 : 0);

    if (tmpslquant > 8)
        rfov_type  = _rfov_type.fixedflag ?    ((void)(16*100), rfov_type) : rfov_type+16*100;
    else if ( (cffield >= B0_30000) && (tmpslquant <= 6) )
        rfov_type  = _rfov_type.fixedflag ?     ((void)(6*100), rfov_type) : rfov_type+6*100;
    else
        rfov_type  = _rfov_type.fixedflag ?     ((void)(8*100), rfov_type) : rfov_type+8*100;

    /* And if lower gradient amplitude system */
    if (FMin(3, cfxfs, cfyfs, cfzfs) < 4.0)
    {
        rfov_type  = _rfov_type.fixedflag ?  ((void)(33), rfov_type) : rfov_type+33;
    }
    
    /*** SVBranch HCSDM00155611: Use Type I pulse and walk-sat for Value system  ***/
    /*** Starter HCSDM00522509: Add new Type-I and Type-II FOCUS pulse for Starter System ***/

    if( PSD_ON == homogeneity_flag )
    { 
        if (tmpslquant <= 9)
        {   
            if(isSVSystem())
            {
                rfov_type  = _rfov_type.fixedflag ?  ((void)(154009096), rfov_type) : 154009096;
                type1_flag  = _type1_flag.fixedflag ?  ((void)(1), type1_flag) : 1;
                walk_sat_flag  = _walk_sat_flag.fixedflag ?  ((void)(1), walk_sat_flag) : 1;
                excite_ratio  = _excite_ratio.fixedflag ?  ((void)(1), excite_ratio) : 1;
                sat_thk_factor  = _sat_thk_factor.fixedflag ?  ((void)(0.4), sat_thk_factor) : 0.4;
            }
            else if(isStarterSystem())
            {
                rfov_type  = _rfov_type.fixedflag ?  ((void)(155009048), rfov_type) : 155009048;
                type1_flag  = _type1_flag.fixedflag ?  ((void)(1), type1_flag) : 1;
                walk_sat_flag  = _walk_sat_flag.fixedflag ?  ((void)(1), walk_sat_flag) : 1;
                excite_ratio  = _excite_ratio.fixedflag ?  ((void)(1.1), excite_ratio) : 1.1;
                sat_thk_factor  = _sat_thk_factor.fixedflag ?  ((void)(0.5), sat_thk_factor) : 0.5;
            }

        }
        else
        {
            type1_flag  = _type1_flag.fixedflag ?  ((void)(0), type1_flag) : 0;
            walk_sat_flag  = _walk_sat_flag.fixedflag ?  ((void)(1), walk_sat_flag) : 1;
            excite_ratio  = _excite_ratio.fixedflag ?  ((void)(1.1), excite_ratio) : 1.1;
            if(isStarterSystem())
            {
                rfov_type  = _rfov_type.fixedflag ?  ((void)(155016098), rfov_type) : 155016098;
                excite_ratio  = _excite_ratio.fixedflag ?  ((void)(1.5), excite_ratio) : 1.5;
                sat_thk_factor  = _sat_thk_factor.fixedflag ?  ((void)(0.55), sat_thk_factor) : 0.55;
            }

        }
    }    
    else
    {      
        type1_flag  = _type1_flag.fixedflag ?  ((void)(0), type1_flag) : 0;
        walk_sat_flag  = _walk_sat_flag.fixedflag ?  ((void)(0), walk_sat_flag) : 0;
        excite_ratio  = _excite_ratio.fixedflag ?  ((void)(1), excite_ratio) : 1;
    } 

    ex_a_gys_pos          = _ex_a_gys_pos.fixedflag ?  ((void)(0), ex_a_gys_pos) : 0;
    ex_pw_rampy_pos       = _ex_pw_rampy_pos.fixedflag ?  ((void)(0), ex_pw_rampy_pos) : 0;
    ex_pw_constanty_pos   = _ex_pw_constanty_pos.fixedflag ?  ((void)(0), ex_pw_constanty_pos) : 0;  
    
    if (walk_sat_flag)
    {
        /* initialize sat RF amp */
        a_rfwk     = _a_rfwk.fixedflag ?  ((void)(flip_rfwk/180), a_rfwk) : flip_rfwk/180;
        ia_rfwk    = _ia_rfwk.fixedflag ?    ((void)(a_rfwk*MAX_PG_IAMP), ia_rfwk) : a_rfwk*MAX_PG_IAMP;
        ia_thrfwk  = _ia_thrfwk.fixedflag ?  ((void)(MAX_PG_IAMP), ia_thrfwk) : MAX_PG_IAMP; 
    }    
    /***************************/
    
    /* Override */
    if (rfov_override > 0)
        rfov_type  = _rfov_type.fixedflag ?  ((void)(rfov_override), rfov_type) : rfov_override;

    switch((int)rfov_type)
    {
        case 15400800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15400800_RF1_R), ex_res) : PSD_2DRF_15400800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15400800_RF1_PW), ex_pw) : PSD_2DRF_15400800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15400800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15400800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15400800), ex_abswidth) : SAR_ABS_2DRF_15400800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15400800), ex_effwidth) : SAR_EFF_2DRF_15400800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15400800), ex_area) : SAR_AREA_2DRF_15400800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15400800), ex_dtycyc) : SAR_DTC_2DRF_15400800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15400800), ex_maxpw) : SAR_MAXPW_2DRF_15400800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15400800), ex_max_b1) : MAX_B1_2DRF_15400800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15400800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15400800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15400800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15400800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15400800_A_GYS), ex_a_gys) : PSD_2DRF_15400800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15400800_A_GZS), ex_a_gzs) : PSD_2DRF_15400800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15400800_NOM_THKY), ex_nom_thky) : PSD_2DRF_15400800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15400800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15400800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15400800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15400800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15400800_GY_NUML), ex_num_gylobe) : PSD_2DRF_15400800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15400800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15400800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15400800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15400800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15400800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15400800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15400800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15400800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15400800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15400800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15400800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15400800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15400800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15400800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15400800_TBWY), ex_tbwy) : PSD_2DRF_15400800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15400800_TBWZ), ex_tbwz) : PSD_2DRF_15400800_TBWZ;
            break;
        case 15400833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15400833_RF1_R), ex_res) : PSD_2DRF_15400833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15400833_RF1_PW), ex_pw) : PSD_2DRF_15400833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15400833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15400833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15400833), ex_abswidth) : SAR_ABS_2DRF_15400833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15400833), ex_effwidth) : SAR_EFF_2DRF_15400833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15400833), ex_area) : SAR_AREA_2DRF_15400833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15400833), ex_dtycyc) : SAR_DTC_2DRF_15400833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15400833), ex_maxpw) : SAR_MAXPW_2DRF_15400833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15400833), ex_max_b1) : MAX_B1_2DRF_15400833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15400833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15400833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15400833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15400833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15400833_A_GYS), ex_a_gys) : PSD_2DRF_15400833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15400833_A_GZS), ex_a_gzs) : PSD_2DRF_15400833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15400833_NOM_THKY), ex_nom_thky) : PSD_2DRF_15400833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15400833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15400833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15400833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15400833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15400833_GY_NUML), ex_num_gylobe) : PSD_2DRF_15400833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15400833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15400833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15400833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15400833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15400833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15400833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15400833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15400833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15400833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15400833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15400833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15400833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15400833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15400833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15400833_TBWY), ex_tbwy) : PSD_2DRF_15400833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15400833_TBWZ), ex_tbwz) : PSD_2DRF_15400833_TBWZ;
            break;
        case 15401600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15401600_RF1_R), ex_res) : PSD_2DRF_15401600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15401600_RF1_PW), ex_pw) : PSD_2DRF_15401600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15401600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15401600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15401600), ex_abswidth) : SAR_ABS_2DRF_15401600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15401600), ex_effwidth) : SAR_EFF_2DRF_15401600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15401600), ex_area) : SAR_AREA_2DRF_15401600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15401600), ex_dtycyc) : SAR_DTC_2DRF_15401600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15401600), ex_maxpw) : SAR_MAXPW_2DRF_15401600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15401600), ex_max_b1) : MAX_B1_2DRF_15401600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15401600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15401600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15401600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15401600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15401600_A_GYS), ex_a_gys) : PSD_2DRF_15401600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15401600_A_GZS), ex_a_gzs) : PSD_2DRF_15401600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15401600_NOM_THKY), ex_nom_thky) : PSD_2DRF_15401600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15401600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15401600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15401600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15401600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15401600_GY_NUML), ex_num_gylobe) : PSD_2DRF_15401600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15401600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15401600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15401600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15401600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15401600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15401600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15401600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15401600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15401600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15401600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15401600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15401600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15401600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15401600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15401600_TBWY), ex_tbwy) : PSD_2DRF_15401600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15401600_TBWZ), ex_tbwz) : PSD_2DRF_15401600_TBWZ;
            break;
        case 15401633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15401633_RF1_R), ex_res) : PSD_2DRF_15401633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15401633_RF1_PW), ex_pw) : PSD_2DRF_15401633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15401633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15401633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15401633), ex_abswidth) : SAR_ABS_2DRF_15401633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15401633), ex_effwidth) : SAR_EFF_2DRF_15401633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15401633), ex_area) : SAR_AREA_2DRF_15401633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15401633), ex_dtycyc) : SAR_DTC_2DRF_15401633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15401633), ex_maxpw) : SAR_MAXPW_2DRF_15401633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15401633), ex_max_b1) : MAX_B1_2DRF_15401633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15401633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15401633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15401633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15401633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15401633_A_GYS), ex_a_gys) : PSD_2DRF_15401633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15401633_A_GZS), ex_a_gzs) : PSD_2DRF_15401633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15401633_NOM_THKY), ex_nom_thky) : PSD_2DRF_15401633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15401633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15401633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15401633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15401633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15401633_GY_NUML), ex_num_gylobe) : PSD_2DRF_15401633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15401633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15401633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15401633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15401633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15401633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15401633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15401633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15401633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15401633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15401633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15401633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15401633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15401633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15401633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15401633_TBWY), ex_tbwy) : PSD_2DRF_15401633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15401633_TBWZ), ex_tbwz) : PSD_2DRF_15401633_TBWZ;
            break;
        case 15500800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15500800_RF1_R), ex_res) : PSD_2DRF_15500800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15500800_RF1_PW), ex_pw) : PSD_2DRF_15500800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15500800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15500800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15500800), ex_abswidth) : SAR_ABS_2DRF_15500800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15500800), ex_effwidth) : SAR_EFF_2DRF_15500800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15500800), ex_area) : SAR_AREA_2DRF_15500800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15500800), ex_dtycyc) : SAR_DTC_2DRF_15500800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15500800), ex_maxpw) : SAR_MAXPW_2DRF_15500800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15500800), ex_max_b1) : MAX_B1_2DRF_15500800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15500800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15500800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15500800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15500800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15500800_A_GYS), ex_a_gys) : PSD_2DRF_15500800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15500800_A_GZS), ex_a_gzs) : PSD_2DRF_15500800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15500800_NOM_THKY), ex_nom_thky) : PSD_2DRF_15500800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15500800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15500800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15500800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15500800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15500800_GY_NUML), ex_num_gylobe) : PSD_2DRF_15500800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15500800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15500800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15500800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15500800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15500800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15500800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15500800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15500800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15500800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15500800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15500800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15500800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15500800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15500800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15500800_TBWY), ex_tbwy) : PSD_2DRF_15500800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15500800_TBWZ), ex_tbwz) : PSD_2DRF_15500800_TBWZ;
            break;
        case 15500833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15500833_RF1_R), ex_res) : PSD_2DRF_15500833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15500833_RF1_PW), ex_pw) : PSD_2DRF_15500833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15500833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15500833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15500833), ex_abswidth) : SAR_ABS_2DRF_15500833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15500833), ex_effwidth) : SAR_EFF_2DRF_15500833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15500833), ex_area) : SAR_AREA_2DRF_15500833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15500833), ex_dtycyc) : SAR_DTC_2DRF_15500833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15500833), ex_maxpw) : SAR_MAXPW_2DRF_15500833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15500833), ex_max_b1) : MAX_B1_2DRF_15500833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15500833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15500833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15500833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15500833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15500833_A_GYS), ex_a_gys) : PSD_2DRF_15500833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15500833_A_GZS), ex_a_gzs) : PSD_2DRF_15500833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15500833_NOM_THKY), ex_nom_thky) : PSD_2DRF_15500833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15500833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15500833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15500833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15500833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15500833_GY_NUML), ex_num_gylobe) : PSD_2DRF_15500833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15500833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15500833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15500833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15500833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15500833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15500833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15500833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15500833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15500833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15500833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15500833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15500833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15500833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15500833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15500833_TBWY), ex_tbwy) : PSD_2DRF_15500833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15500833_TBWZ), ex_tbwz) : PSD_2DRF_15500833_TBWZ;
            break;
        case 15501600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15501600_RF1_R), ex_res) : PSD_2DRF_15501600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15501600_RF1_PW), ex_pw) : PSD_2DRF_15501600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15501600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15501600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15501600), ex_abswidth) : SAR_ABS_2DRF_15501600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15501600), ex_effwidth) : SAR_EFF_2DRF_15501600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15501600), ex_area) : SAR_AREA_2DRF_15501600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15501600), ex_dtycyc) : SAR_DTC_2DRF_15501600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15501600), ex_maxpw) : SAR_MAXPW_2DRF_15501600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15501600), ex_max_b1) : MAX_B1_2DRF_15501600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15501600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15501600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15501600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15501600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15501600_A_GYS), ex_a_gys) : PSD_2DRF_15501600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15501600_A_GZS), ex_a_gzs) : PSD_2DRF_15501600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15501600_NOM_THKY), ex_nom_thky) : PSD_2DRF_15501600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15501600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15501600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15501600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15501600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15501600_GY_NUML), ex_num_gylobe) : PSD_2DRF_15501600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15501600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15501600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15501600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15501600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15501600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15501600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15501600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15501600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15501600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15501600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15501600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15501600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15501600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15501600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15501600_TBWY), ex_tbwy) : PSD_2DRF_15501600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15501600_TBWZ), ex_tbwz) : PSD_2DRF_15501600_TBWZ;
            break;
        case 15501633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15501633_RF1_R), ex_res) : PSD_2DRF_15501633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15501633_RF1_PW), ex_pw) : PSD_2DRF_15501633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15501633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15501633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15501633), ex_abswidth) : SAR_ABS_2DRF_15501633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15501633), ex_effwidth) : SAR_EFF_2DRF_15501633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15501633), ex_area) : SAR_AREA_2DRF_15501633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15501633), ex_dtycyc) : SAR_DTC_2DRF_15501633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15501633), ex_maxpw) : SAR_MAXPW_2DRF_15501633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15501633), ex_max_b1) : MAX_B1_2DRF_15501633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15501633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15501633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15501633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15501633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15501633_A_GYS), ex_a_gys) : PSD_2DRF_15501633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15501633_A_GZS), ex_a_gzs) : PSD_2DRF_15501633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15501633_NOM_THKY), ex_nom_thky) : PSD_2DRF_15501633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15501633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15501633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15501633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15501633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15501633_GY_NUML), ex_num_gylobe) : PSD_2DRF_15501633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15501633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15501633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15501633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15501633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15501633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15501633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15501633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15501633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15501633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15501633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15501633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15501633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15501633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15501633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15501633_TBWY), ex_tbwy) : PSD_2DRF_15501633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15501633_TBWZ), ex_tbwz) : PSD_2DRF_15501633_TBWZ;
            break;
        case 15600800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15600800_RF1_R), ex_res) : PSD_2DRF_15600800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15600800_RF1_PW), ex_pw) : PSD_2DRF_15600800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15600800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15600800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15600800), ex_abswidth) : SAR_ABS_2DRF_15600800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15600800), ex_effwidth) : SAR_EFF_2DRF_15600800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15600800), ex_area) : SAR_AREA_2DRF_15600800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15600800), ex_dtycyc) : SAR_DTC_2DRF_15600800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15600800), ex_maxpw) : SAR_MAXPW_2DRF_15600800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15600800), ex_max_b1) : MAX_B1_2DRF_15600800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15600800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15600800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15600800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15600800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15600800_A_GYS), ex_a_gys) : PSD_2DRF_15600800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15600800_A_GZS), ex_a_gzs) : PSD_2DRF_15600800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15600800_NOM_THKY), ex_nom_thky) : PSD_2DRF_15600800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15600800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15600800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15600800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15600800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15600800_GY_NUML), ex_num_gylobe) : PSD_2DRF_15600800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15600800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15600800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15600800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15600800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15600800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15600800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15600800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15600800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15600800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15600800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15600800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15600800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15600800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15600800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15600800_TBWY), ex_tbwy) : PSD_2DRF_15600800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15600800_TBWZ), ex_tbwz) : PSD_2DRF_15600800_TBWZ;
            break;
        case 15600833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15600833_RF1_R), ex_res) : PSD_2DRF_15600833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15600833_RF1_PW), ex_pw) : PSD_2DRF_15600833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15600833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15600833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15600833), ex_abswidth) : SAR_ABS_2DRF_15600833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15600833), ex_effwidth) : SAR_EFF_2DRF_15600833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15600833), ex_area) : SAR_AREA_2DRF_15600833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15600833), ex_dtycyc) : SAR_DTC_2DRF_15600833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15600833), ex_maxpw) : SAR_MAXPW_2DRF_15600833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15600833), ex_max_b1) : MAX_B1_2DRF_15600833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15600833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15600833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15600833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15600833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15600833_A_GYS), ex_a_gys) : PSD_2DRF_15600833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15600833_A_GZS), ex_a_gzs) : PSD_2DRF_15600833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15600833_NOM_THKY), ex_nom_thky) : PSD_2DRF_15600833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15600833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15600833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15600833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15600833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15600833_GY_NUML), ex_num_gylobe) : PSD_2DRF_15600833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15600833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15600833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15600833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15600833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15600833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15600833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15600833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15600833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15600833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15600833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15600833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15600833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15600833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15600833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15600833_TBWY), ex_tbwy) : PSD_2DRF_15600833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15600833_TBWZ), ex_tbwz) : PSD_2DRF_15600833_TBWZ;
            break;
        case 15601600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15601600_RF1_R), ex_res) : PSD_2DRF_15601600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15601600_RF1_PW), ex_pw) : PSD_2DRF_15601600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15601600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15601600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15601600), ex_abswidth) : SAR_ABS_2DRF_15601600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15601600), ex_effwidth) : SAR_EFF_2DRF_15601600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15601600), ex_area) : SAR_AREA_2DRF_15601600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15601600), ex_dtycyc) : SAR_DTC_2DRF_15601600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15601600), ex_maxpw) : SAR_MAXPW_2DRF_15601600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15601600), ex_max_b1) : MAX_B1_2DRF_15601600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15601600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15601600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15601600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15601600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15601600_A_GYS), ex_a_gys) : PSD_2DRF_15601600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15601600_A_GZS), ex_a_gzs) : PSD_2DRF_15601600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15601600_NOM_THKY), ex_nom_thky) : PSD_2DRF_15601600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15601600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15601600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15601600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15601600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15601600_GY_NUML), ex_num_gylobe) : PSD_2DRF_15601600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15601600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15601600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15601600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15601600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15601600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15601600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15601600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15601600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15601600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15601600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15601600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15601600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15601600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15601600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15601600_TBWY), ex_tbwy) : PSD_2DRF_15601600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15601600_TBWZ), ex_tbwz) : PSD_2DRF_15601600_TBWZ;
            break;
        case 15601633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_15601633_RF1_R), ex_res) : PSD_2DRF_15601633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_15601633_RF1_PW), ex_pw) : PSD_2DRF_15601633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_15601633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_15601633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_15601633), ex_abswidth) : SAR_ABS_2DRF_15601633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_15601633), ex_effwidth) : SAR_EFF_2DRF_15601633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_15601633), ex_area) : SAR_AREA_2DRF_15601633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_15601633), ex_dtycyc) : SAR_DTC_2DRF_15601633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_15601633), ex_maxpw) : SAR_MAXPW_2DRF_15601633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_15601633), ex_max_b1) : MAX_B1_2DRF_15601633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_15601633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_15601633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_15601633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_15601633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_15601633_A_GYS), ex_a_gys) : PSD_2DRF_15601633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_15601633_A_GZS), ex_a_gzs) : PSD_2DRF_15601633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_15601633_NOM_THKY), ex_nom_thky) : PSD_2DRF_15601633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_15601633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_15601633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_15601633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_15601633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_15601633_GY_NUML), ex_num_gylobe) : PSD_2DRF_15601633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_15601633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_15601633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_15601633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_15601633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_15601633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_15601633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_15601633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_15601633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_15601633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_15601633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_15601633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_15601633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_15601633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_15601633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_15601633_TBWY), ex_tbwy) : PSD_2DRF_15601633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_15601633_TBWZ), ex_tbwz) : PSD_2DRF_15601633_TBWZ;
            break;
        case 30400600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30400600_RF1_R), ex_res) : PSD_2DRF_30400600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30400600_RF1_PW), ex_pw) : PSD_2DRF_30400600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30400600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30400600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30400600), ex_abswidth) : SAR_ABS_2DRF_30400600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30400600), ex_effwidth) : SAR_EFF_2DRF_30400600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30400600), ex_area) : SAR_AREA_2DRF_30400600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30400600), ex_dtycyc) : SAR_DTC_2DRF_30400600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30400600), ex_maxpw) : SAR_MAXPW_2DRF_30400600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30400600), ex_max_b1) : MAX_B1_2DRF_30400600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30400600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30400600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30400600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30400600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30400600_A_GYS), ex_a_gys) : PSD_2DRF_30400600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30400600_A_GZS), ex_a_gzs) : PSD_2DRF_30400600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30400600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30400600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30400600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30400600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30400600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30400600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30400600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30400600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30400600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30400600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30400600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30400600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30400600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30400600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30400600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30400600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30400600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30400600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30400600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30400600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30400600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30400600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30400600_TBWY), ex_tbwy) : PSD_2DRF_30400600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30400600_TBWZ), ex_tbwz) : PSD_2DRF_30400600_TBWZ;
            break;
        case 30400633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30400633_RF1_R), ex_res) : PSD_2DRF_30400633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30400633_RF1_PW), ex_pw) : PSD_2DRF_30400633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30400633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30400633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30400633), ex_abswidth) : SAR_ABS_2DRF_30400633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30400633), ex_effwidth) : SAR_EFF_2DRF_30400633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30400633), ex_area) : SAR_AREA_2DRF_30400633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30400633), ex_dtycyc) : SAR_DTC_2DRF_30400633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30400633), ex_maxpw) : SAR_MAXPW_2DRF_30400633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30400633), ex_max_b1) : MAX_B1_2DRF_30400633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30400633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30400633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30400633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30400633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30400633_A_GYS), ex_a_gys) : PSD_2DRF_30400633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30400633_A_GZS), ex_a_gzs) : PSD_2DRF_30400633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30400633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30400633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30400633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30400633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30400633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30400633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30400633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30400633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30400633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30400633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30400633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30400633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30400633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30400633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30400633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30400633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30400633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30400633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30400633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30400633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30400633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30400633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30400633_TBWY), ex_tbwy) : PSD_2DRF_30400633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30400633_TBWZ), ex_tbwz) : PSD_2DRF_30400633_TBWZ;
            break;
        case 30400800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30400800_RF1_R), ex_res) : PSD_2DRF_30400800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30400800_RF1_PW), ex_pw) : PSD_2DRF_30400800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30400800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30400800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30400800), ex_abswidth) : SAR_ABS_2DRF_30400800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30400800), ex_effwidth) : SAR_EFF_2DRF_30400800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30400800), ex_area) : SAR_AREA_2DRF_30400800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30400800), ex_dtycyc) : SAR_DTC_2DRF_30400800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30400800), ex_maxpw) : SAR_MAXPW_2DRF_30400800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30400800), ex_max_b1) : MAX_B1_2DRF_30400800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30400800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30400800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30400800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30400800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30400800_A_GYS), ex_a_gys) : PSD_2DRF_30400800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30400800_A_GZS), ex_a_gzs) : PSD_2DRF_30400800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30400800_NOM_THKY), ex_nom_thky) : PSD_2DRF_30400800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?     ((void)(PSD_2DRF_30400800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30400800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30400800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30400800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30400800_GY_NUML), ex_num_gylobe) : PSD_2DRF_30400800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30400800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30400800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30400800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30400800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30400800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30400800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30400800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30400800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30400800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30400800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30400800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30400800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30400800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30400800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30400800_TBWY), ex_tbwy) : PSD_2DRF_30400800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30400800_TBWZ), ex_tbwz) : PSD_2DRF_30400800_TBWZ;
            break;
        case 30400833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30400833_RF1_R), ex_res) : PSD_2DRF_30400833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30400833_RF1_PW), ex_pw) : PSD_2DRF_30400833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30400833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30400833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30400833), ex_abswidth) : SAR_ABS_2DRF_30400833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30400833), ex_effwidth) : SAR_EFF_2DRF_30400833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30400833), ex_area) : SAR_AREA_2DRF_30400833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30400833), ex_dtycyc) : SAR_DTC_2DRF_30400833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30400833), ex_maxpw) : SAR_MAXPW_2DRF_30400833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30400833), ex_max_b1) : MAX_B1_2DRF_30400833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30400833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30400833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30400833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30400833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30400833_A_GYS), ex_a_gys) : PSD_2DRF_30400833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30400833_A_GZS), ex_a_gzs) : PSD_2DRF_30400833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30400833_NOM_THKY), ex_nom_thky) : PSD_2DRF_30400833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30400833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30400833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30400833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30400833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30400833_GY_NUML), ex_num_gylobe) : PSD_2DRF_30400833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30400833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30400833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30400833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30400833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30400833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30400833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30400833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30400833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30400833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30400833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30400833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30400833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30400833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30400833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30400833_TBWY), ex_tbwy) : PSD_2DRF_30400833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30400833_TBWZ), ex_tbwz) : PSD_2DRF_30400833_TBWZ;
            break;
        case 30401600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30401600_RF1_R), ex_res) : PSD_2DRF_30401600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30401600_RF1_PW), ex_pw) : PSD_2DRF_30401600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30401600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30401600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30401600), ex_abswidth) : SAR_ABS_2DRF_30401600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30401600), ex_effwidth) : SAR_EFF_2DRF_30401600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30401600), ex_area) : SAR_AREA_2DRF_30401600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30401600), ex_dtycyc) : SAR_DTC_2DRF_30401600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30401600), ex_maxpw) : SAR_MAXPW_2DRF_30401600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30401600), ex_max_b1) : MAX_B1_2DRF_30401600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30401600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30401600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30401600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30401600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30401600_A_GYS), ex_a_gys) : PSD_2DRF_30401600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30401600_A_GZS), ex_a_gzs) : PSD_2DRF_30401600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30401600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30401600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30401600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30401600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30401600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30401600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30401600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30401600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30401600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30401600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30401600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30401600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30401600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30401600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30401600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30401600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30401600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30401600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30401600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30401600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30401600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30401600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30401600_TBWY), ex_tbwy) : PSD_2DRF_30401600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30401600_TBWZ), ex_tbwz) : PSD_2DRF_30401600_TBWZ;
            break;
        case 30401633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30401633_RF1_R), ex_res) : PSD_2DRF_30401633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30401633_RF1_PW), ex_pw) : PSD_2DRF_30401633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30401633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30401633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30401633), ex_abswidth) : SAR_ABS_2DRF_30401633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30401633), ex_effwidth) : SAR_EFF_2DRF_30401633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30401633), ex_area) : SAR_AREA_2DRF_30401633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30401633), ex_dtycyc) : SAR_DTC_2DRF_30401633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30401633), ex_maxpw) : SAR_MAXPW_2DRF_30401633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30401633), ex_max_b1) : MAX_B1_2DRF_30401633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30401633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30401633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30401633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30401633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30401633_A_GYS), ex_a_gys) : PSD_2DRF_30401633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30401633_A_GZS), ex_a_gzs) : PSD_2DRF_30401633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30401633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30401633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30401633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30401633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30401633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30401633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30401633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30401633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30401633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30401633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30401633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30401633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30401633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30401633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30401633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30401633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30401633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30401633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30401633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30401633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30401633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30401633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30401633_TBWY), ex_tbwy) : PSD_2DRF_30401633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30401633_TBWZ), ex_tbwz) : PSD_2DRF_30401633_TBWZ;
            break;
        case 30500600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30500600_RF1_R), ex_res) : PSD_2DRF_30500600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30500600_RF1_PW), ex_pw) : PSD_2DRF_30500600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30500600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30500600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30500600), ex_abswidth) : SAR_ABS_2DRF_30500600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30500600), ex_effwidth) : SAR_EFF_2DRF_30500600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30500600), ex_area) : SAR_AREA_2DRF_30500600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30500600), ex_dtycyc) : SAR_DTC_2DRF_30500600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30500600), ex_maxpw) : SAR_MAXPW_2DRF_30500600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30500600), ex_max_b1) : MAX_B1_2DRF_30500600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30500600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30500600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30500600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30500600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30500600_A_GYS), ex_a_gys) : PSD_2DRF_30500600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30500600_A_GZS), ex_a_gzs) : PSD_2DRF_30500600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30500600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30500600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30500600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30500600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30500600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30500600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30500600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30500600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30500600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30500600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30500600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30500600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30500600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30500600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30500600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30500600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30500600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30500600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30500600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30500600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30500600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30500600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30500600_TBWY), ex_tbwy) : PSD_2DRF_30500600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30500600_TBWZ), ex_tbwz) : PSD_2DRF_30500600_TBWZ;
            break;
        case 30500633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30500633_RF1_R), ex_res) : PSD_2DRF_30500633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30500633_RF1_PW), ex_pw) : PSD_2DRF_30500633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30500633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30500633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30500633), ex_abswidth) : SAR_ABS_2DRF_30500633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30500633), ex_effwidth) : SAR_EFF_2DRF_30500633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30500633), ex_area) : SAR_AREA_2DRF_30500633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30500633), ex_dtycyc) : SAR_DTC_2DRF_30500633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30500633), ex_maxpw) : SAR_MAXPW_2DRF_30500633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30500633), ex_max_b1) : MAX_B1_2DRF_30500633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30500633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30500633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30500633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30500633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30500633_A_GYS), ex_a_gys) : PSD_2DRF_30500633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30500633_A_GZS), ex_a_gzs) : PSD_2DRF_30500633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30500633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30500633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30500633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30500633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30500633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30500633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30500633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30500633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30500633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30500633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30500633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30500633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30500633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30500633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30500633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30500633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30500633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30500633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30500633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30500633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30500633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30500633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30500633_TBWY), ex_tbwy) : PSD_2DRF_30500633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30500633_TBWZ), ex_tbwz) : PSD_2DRF_30500633_TBWZ;
            break;
        case 30500800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30500800_RF1_R), ex_res) : PSD_2DRF_30500800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30500800_RF1_PW), ex_pw) : PSD_2DRF_30500800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30500800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30500800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30500800), ex_abswidth) : SAR_ABS_2DRF_30500800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30500800), ex_effwidth) : SAR_EFF_2DRF_30500800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30500800), ex_area) : SAR_AREA_2DRF_30500800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30500800), ex_dtycyc) : SAR_DTC_2DRF_30500800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30500800), ex_maxpw) : SAR_MAXPW_2DRF_30500800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30500800), ex_max_b1) : MAX_B1_2DRF_30500800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30500800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30500800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30500800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30500800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30500800_A_GYS), ex_a_gys) : PSD_2DRF_30500800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30500800_A_GZS), ex_a_gzs) : PSD_2DRF_30500800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30500800_NOM_THKY), ex_nom_thky) : PSD_2DRF_30500800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30500800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30500800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30500800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30500800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30500800_GY_NUML), ex_num_gylobe) : PSD_2DRF_30500800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30500800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30500800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30500800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30500800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30500800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30500800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30500800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30500800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30500800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30500800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30500800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30500800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30500800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30500800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30500800_TBWY), ex_tbwy) : PSD_2DRF_30500800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30500800_TBWZ), ex_tbwz) : PSD_2DRF_30500800_TBWZ;
            break;
        case 30500833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30500833_RF1_R), ex_res) : PSD_2DRF_30500833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30500833_RF1_PW), ex_pw) : PSD_2DRF_30500833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30500833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30500833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30500833), ex_abswidth) : SAR_ABS_2DRF_30500833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30500833), ex_effwidth) : SAR_EFF_2DRF_30500833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30500833), ex_area) : SAR_AREA_2DRF_30500833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30500833), ex_dtycyc) : SAR_DTC_2DRF_30500833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30500833), ex_maxpw) : SAR_MAXPW_2DRF_30500833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30500833), ex_max_b1) : MAX_B1_2DRF_30500833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30500833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30500833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30500833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30500833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30500833_A_GYS), ex_a_gys) : PSD_2DRF_30500833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30500833_A_GZS), ex_a_gzs) : PSD_2DRF_30500833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30500833_NOM_THKY), ex_nom_thky) : PSD_2DRF_30500833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30500833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30500833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30500833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30500833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30500833_GY_NUML), ex_num_gylobe) : PSD_2DRF_30500833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30500833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30500833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30500833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30500833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30500833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30500833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30500833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30500833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30500833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30500833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30500833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30500833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30500833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30500833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30500833_TBWY), ex_tbwy) : PSD_2DRF_30500833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30500833_TBWZ), ex_tbwz) : PSD_2DRF_30500833_TBWZ;
            break;
        case 30501600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30501600_RF1_R), ex_res) : PSD_2DRF_30501600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30501600_RF1_PW), ex_pw) : PSD_2DRF_30501600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30501600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30501600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30501600), ex_abswidth) : SAR_ABS_2DRF_30501600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30501600), ex_effwidth) : SAR_EFF_2DRF_30501600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30501600), ex_area) : SAR_AREA_2DRF_30501600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30501600), ex_dtycyc) : SAR_DTC_2DRF_30501600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30501600), ex_maxpw) : SAR_MAXPW_2DRF_30501600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30501600), ex_max_b1) : MAX_B1_2DRF_30501600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30501600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30501600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30501600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30501600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30501600_A_GYS), ex_a_gys) : PSD_2DRF_30501600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30501600_A_GZS), ex_a_gzs) : PSD_2DRF_30501600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30501600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30501600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30501600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30501600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30501600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30501600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30501600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30501600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30501600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30501600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30501600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30501600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30501600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30501600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30501600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30501600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30501600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30501600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30501600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30501600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30501600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30501600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30501600_TBWY), ex_tbwy) : PSD_2DRF_30501600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30501600_TBWZ), ex_tbwz) : PSD_2DRF_30501600_TBWZ;
            break;
        case 30501633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30501633_RF1_R), ex_res) : PSD_2DRF_30501633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30501633_RF1_PW), ex_pw) : PSD_2DRF_30501633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30501633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30501633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30501633), ex_abswidth) : SAR_ABS_2DRF_30501633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30501633), ex_effwidth) : SAR_EFF_2DRF_30501633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30501633), ex_area) : SAR_AREA_2DRF_30501633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30501633), ex_dtycyc) : SAR_DTC_2DRF_30501633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30501633), ex_maxpw) : SAR_MAXPW_2DRF_30501633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30501633), ex_max_b1) : MAX_B1_2DRF_30501633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30501633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30501633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30501633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30501633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30501633_A_GYS), ex_a_gys) : PSD_2DRF_30501633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30501633_A_GZS), ex_a_gzs) : PSD_2DRF_30501633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30501633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30501633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30501633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30501633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30501633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30501633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30501633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30501633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30501633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30501633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30501633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30501633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30501633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30501633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30501633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30501633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30501633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30501633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30501633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30501633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30501633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30501633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30501633_TBWY), ex_tbwy) : PSD_2DRF_30501633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30501633_TBWZ), ex_tbwz) : PSD_2DRF_30501633_TBWZ;
            break;
        case 30600600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30600600_RF1_R), ex_res) : PSD_2DRF_30600600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30600600_RF1_PW), ex_pw) : PSD_2DRF_30600600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30600600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30600600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30600600), ex_abswidth) : SAR_ABS_2DRF_30600600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30600600), ex_effwidth) : SAR_EFF_2DRF_30600600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30600600), ex_area) : SAR_AREA_2DRF_30600600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30600600), ex_dtycyc) : SAR_DTC_2DRF_30600600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30600600), ex_maxpw) : SAR_MAXPW_2DRF_30600600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30600600), ex_max_b1) : MAX_B1_2DRF_30600600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30600600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30600600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30600600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30600600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30600600_A_GYS), ex_a_gys) : PSD_2DRF_30600600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30600600_A_GZS), ex_a_gzs) : PSD_2DRF_30600600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30600600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30600600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30600600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30600600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30600600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30600600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30600600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30600600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30600600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30600600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30600600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30600600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30600600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30600600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30600600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30600600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30600600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30600600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30600600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30600600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30600600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30600600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30600600_TBWY), ex_tbwy) : PSD_2DRF_30600600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30600600_TBWZ), ex_tbwz) : PSD_2DRF_30600600_TBWZ;
            break;
        case 30600633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30600633_RF1_R), ex_res) : PSD_2DRF_30600633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30600633_RF1_PW), ex_pw) : PSD_2DRF_30600633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30600633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30600633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30600633), ex_abswidth) : SAR_ABS_2DRF_30600633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30600633), ex_effwidth) : SAR_EFF_2DRF_30600633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30600633), ex_area) : SAR_AREA_2DRF_30600633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30600633), ex_dtycyc) : SAR_DTC_2DRF_30600633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30600633), ex_maxpw) : SAR_MAXPW_2DRF_30600633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30600633), ex_max_b1) : MAX_B1_2DRF_30600633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30600633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30600633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30600633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30600633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30600633_A_GYS), ex_a_gys) : PSD_2DRF_30600633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30600633_A_GZS), ex_a_gzs) : PSD_2DRF_30600633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30600633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30600633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30600633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30600633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30600633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30600633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30600633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30600633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30600633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30600633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30600633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30600633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30600633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30600633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30600633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30600633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30600633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30600633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30600633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30600633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30600633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30600633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30600633_TBWY), ex_tbwy) : PSD_2DRF_30600633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30600633_TBWZ), ex_tbwz) : PSD_2DRF_30600633_TBWZ;
            break;
        case 30600800:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30600800_RF1_R), ex_res) : PSD_2DRF_30600800_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30600800_RF1_PW), ex_pw) : PSD_2DRF_30600800_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30600800_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30600800_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30600800), ex_abswidth) : SAR_ABS_2DRF_30600800;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30600800), ex_effwidth) : SAR_EFF_2DRF_30600800;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30600800), ex_area) : SAR_AREA_2DRF_30600800;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30600800), ex_dtycyc) : SAR_DTC_2DRF_30600800;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30600800), ex_maxpw) : SAR_MAXPW_2DRF_30600800;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30600800), ex_max_b1) : MAX_B1_2DRF_30600800;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30600800), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30600800;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30600800), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30600800;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30600800_A_GYS), ex_a_gys) : PSD_2DRF_30600800_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30600800_A_GZS), ex_a_gzs) : PSD_2DRF_30600800_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30600800_NOM_THKY), ex_nom_thky) : PSD_2DRF_30600800_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30600800_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30600800_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30600800_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30600800_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30600800_GY_NUML), ex_num_gylobe) : PSD_2DRF_30600800_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30600800_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30600800_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30600800_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30600800_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30600800_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30600800_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30600800_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30600800_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30600800_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30600800_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30600800_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30600800_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30600800_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30600800_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30600800_TBWY), ex_tbwy) : PSD_2DRF_30600800_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30600800_TBWZ), ex_tbwz) : PSD_2DRF_30600800_TBWZ;
            break;
        case 30600833:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30600833_RF1_R), ex_res) : PSD_2DRF_30600833_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30600833_RF1_PW), ex_pw) : PSD_2DRF_30600833_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30600833_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30600833_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30600833), ex_abswidth) : SAR_ABS_2DRF_30600833;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30600833), ex_effwidth) : SAR_EFF_2DRF_30600833;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30600833), ex_area) : SAR_AREA_2DRF_30600833;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30600833), ex_dtycyc) : SAR_DTC_2DRF_30600833;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30600833), ex_maxpw) : SAR_MAXPW_2DRF_30600833;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30600833), ex_max_b1) : MAX_B1_2DRF_30600833;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30600833), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30600833;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30600833), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30600833;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30600833_A_GYS), ex_a_gys) : PSD_2DRF_30600833_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30600833_A_GZS), ex_a_gzs) : PSD_2DRF_30600833_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30600833_NOM_THKY), ex_nom_thky) : PSD_2DRF_30600833_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30600833_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30600833_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30600833_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30600833_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30600833_GY_NUML), ex_num_gylobe) : PSD_2DRF_30600833_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30600833_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30600833_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30600833_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30600833_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30600833_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30600833_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30600833_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30600833_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30600833_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30600833_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30600833_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30600833_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30600833_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30600833_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30600833_TBWY), ex_tbwy) : PSD_2DRF_30600833_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30600833_TBWZ), ex_tbwz) : PSD_2DRF_30600833_TBWZ;
            break;
        case 30601600:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30601600_RF1_R), ex_res) : PSD_2DRF_30601600_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30601600_RF1_PW), ex_pw) : PSD_2DRF_30601600_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30601600_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30601600_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30601600), ex_abswidth) : SAR_ABS_2DRF_30601600;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30601600), ex_effwidth) : SAR_EFF_2DRF_30601600;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30601600), ex_area) : SAR_AREA_2DRF_30601600;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30601600), ex_dtycyc) : SAR_DTC_2DRF_30601600;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30601600), ex_maxpw) : SAR_MAXPW_2DRF_30601600;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30601600), ex_max_b1) : MAX_B1_2DRF_30601600;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30601600), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30601600;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30601600), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30601600;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30601600_A_GYS), ex_a_gys) : PSD_2DRF_30601600_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30601600_A_GZS), ex_a_gzs) : PSD_2DRF_30601600_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30601600_NOM_THKY), ex_nom_thky) : PSD_2DRF_30601600_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30601600_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30601600_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30601600_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30601600_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30601600_GY_NUML), ex_num_gylobe) : PSD_2DRF_30601600_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30601600_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30601600_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30601600_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30601600_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30601600_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30601600_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30601600_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30601600_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30601600_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30601600_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30601600_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30601600_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30601600_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30601600_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30601600_TBWY), ex_tbwy) : PSD_2DRF_30601600_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30601600_TBWZ), ex_tbwz) : PSD_2DRF_30601600_TBWZ;
            break;
        case 30601633:
            ex_res  = _ex_res.fixedflag ?  ((void)(PSD_2DRF_30601633_RF1_R), ex_res) : PSD_2DRF_30601633_RF1_R;
            ex_pw  = _ex_pw.fixedflag ?   ((void)(PSD_2DRF_30601633_RF1_PW), ex_pw) : PSD_2DRF_30601633_RF1_PW;
            ex_ttipdown  = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_30601633_RF1_LEFT), ex_ttipdown) : PSD_2DRF_30601633_RF1_LEFT;
            ex_nom_flip  = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth  = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_30601633), ex_abswidth) : SAR_ABS_2DRF_30601633;
            ex_effwidth  = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_30601633), ex_effwidth) : SAR_EFF_2DRF_30601633;
            ex_area  = _ex_area.fixedflag ?      ((void)(SAR_AREA_2DRF_30601633), ex_area) : SAR_AREA_2DRF_30601633;
            ex_dtycyc  = _ex_dtycyc.fixedflag ?    ((void)(SAR_DTC_2DRF_30601633), ex_dtycyc) : SAR_DTC_2DRF_30601633;
            ex_maxpw  = _ex_maxpw.fixedflag ?     ((void)(SAR_MAXPW_2DRF_30601633), ex_maxpw) : SAR_MAXPW_2DRF_30601633;
            ex_max_b1  = _ex_max_b1.fixedflag ?    ((void)(MAX_B1_2DRF_30601633), ex_max_b1) : MAX_B1_2DRF_30601633;
            ex_max_int_b1_sqr  = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_30601633), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_30601633;
            ex_max_rms_b1  = _ex_max_rms_b1.fixedflag ?      ((void)(MAX_RMS_B1_2DRF_30601633), ex_max_rms_b1) : MAX_RMS_B1_2DRF_30601633;
            ex_a_gys  = _ex_a_gys.fixedflag ?       ((void)(PSD_2DRF_30601633_A_GYS), ex_a_gys) : PSD_2DRF_30601633_A_GYS;
            ex_a_gzs  = _ex_a_gzs.fixedflag ?       ((void)(PSD_2DRF_30601633_A_GZS), ex_a_gzs) : PSD_2DRF_30601633_A_GZS;
            ex_nom_thky  = _ex_nom_thky.fixedflag ?    ((void)(PSD_2DRF_30601633_NOM_THKY), ex_nom_thky) : PSD_2DRF_30601633_NOM_THKY;
            ex_nom_thkz  = _ex_nom_thkz.fixedflag ?    ((void)(PSD_2DRF_30601633_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_30601633_NOM_THKZ;
            ex_maxnslices  = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_30601633_MAX_SLICES), ex_maxnslices) : PSD_2DRF_30601633_MAX_SLICES;
            ex_num_gylobe  = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_30601633_GY_NUML), ex_num_gylobe) : PSD_2DRF_30601633_GY_NUML;
            ex_num_gzlobe  = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_30601633_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_30601633_GZ_NUML;
            ex_pw_rampy  = _ex_pw_rampy.fixedflag ?        ((void)(PSD_2DRF_30601633_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_30601633_PW_RAMPY;
            ex_pw_rampz  = _ex_pw_rampz.fixedflag ?        ((void)(PSD_2DRF_30601633_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_30601633_PW_RAMPZ;
            ex_pw_constanty  = _ex_pw_constanty.fixedflag ?    ((void)(PSD_2DRF_30601633_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_30601633_PW_CONSTY;
            ex_pw_constantz  = _ex_pw_constantz.fixedflag ?    ((void)(PSD_2DRF_30601633_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_30601633_PW_CONSTZ;
            ex_refocus_ratioy  = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_30601633_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_30601633_REF_AREAY;
            ex_refocus_ratioz  = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_30601633_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_30601633_REF_AREAZ;
            ex_tbwy   = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_30601633_TBWY), ex_tbwy) : PSD_2DRF_30601633_TBWY;
            ex_tbwz   = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_30601633_TBWZ), ex_tbwz) : PSD_2DRF_30601633_TBWZ;
            break;
        /*** Starter HCSDM00522509 Add new Type-II FOCUS pulse for Starter System */
        case 155016098:
            ex_res                = _ex_res.fixedflag ?  ((void)(PSD_2DRF_155016098_RF1_R), ex_res) : PSD_2DRF_155016098_RF1_R;
            ex_pw                 = _ex_pw.fixedflag ?  ((void)(PSD_2DRF_155016098_RF1_PW), ex_pw) : PSD_2DRF_155016098_RF1_PW;
            ex_ttipdown           = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_155016098_RF1_LEFT), ex_ttipdown) : PSD_2DRF_155016098_RF1_LEFT;
            ex_nom_flip           = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth           = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_155016098), ex_abswidth) : SAR_ABS_2DRF_155016098;
            ex_effwidth           = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_155016098), ex_effwidth) : SAR_EFF_2DRF_155016098;
            ex_area               = _ex_area.fixedflag ?  ((void)(SAR_AREA_2DRF_155016098), ex_area) : SAR_AREA_2DRF_155016098;
            ex_dtycyc             = _ex_dtycyc.fixedflag ?  ((void)(SAR_DTC_2DRF_155016098), ex_dtycyc) : SAR_DTC_2DRF_155016098;
            ex_maxpw              = _ex_maxpw.fixedflag ?  ((void)(SAR_MAXPW_2DRF_155016098), ex_maxpw) : SAR_MAXPW_2DRF_155016098;
            ex_max_b1             = _ex_max_b1.fixedflag ?  ((void)(MAX_B1_2DRF_155016098), ex_max_b1) : MAX_B1_2DRF_155016098;
            ex_max_int_b1_sqr     = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_155016098), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_155016098;
            ex_max_rms_b1         = _ex_max_rms_b1.fixedflag ?  ((void)(MAX_RMS_B1_2DRF_155016098), ex_max_rms_b1) : MAX_RMS_B1_2DRF_155016098;
            ex_a_gys              = _ex_a_gys.fixedflag ?  ((void)(PSD_2DRF_155016098_A_GYS), ex_a_gys) : PSD_2DRF_155016098_A_GYS;
            ex_a_gzs              = _ex_a_gzs.fixedflag ?  ((void)(PSD_2DRF_155016098_A_GZS), ex_a_gzs) : PSD_2DRF_155016098_A_GZS;
            ex_nom_thky           = _ex_nom_thky.fixedflag ?  ((void)(PSD_2DRF_155016098_NOM_THKY), ex_nom_thky) : PSD_2DRF_155016098_NOM_THKY;
            ex_nom_thkz           = _ex_nom_thkz.fixedflag ?  ((void)(PSD_2DRF_155016098_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_155016098_NOM_THKZ;
            ex_maxnslices         = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_155016098_MAX_SLICES), ex_maxnslices) : PSD_2DRF_155016098_MAX_SLICES;
            ex_num_gylobe         = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_155016098_GY_NUML), ex_num_gylobe) : PSD_2DRF_155016098_GY_NUML;
            ex_num_gzlobe         = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_155016098_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_155016098_GZ_NUML;
            ex_pw_rampy           = _ex_pw_rampy.fixedflag ?  ((void)(PSD_2DRF_155016098_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_155016098_PW_RAMPY;
            ex_pw_rampz           = _ex_pw_rampz.fixedflag ?  ((void)(PSD_2DRF_155016098_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_155016098_PW_RAMPZ;
            ex_pw_constanty       = _ex_pw_constanty.fixedflag ?  ((void)(PSD_2DRF_155016098_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_155016098_PW_CONSTY;
            ex_pw_constantz       = _ex_pw_constantz.fixedflag ?  ((void)(PSD_2DRF_155016098_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_155016098_PW_CONSTZ;
            ex_refocus_ratioy     = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_155016098_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_155016098_REF_AREAY;
            ex_refocus_ratioz     = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_155016098_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_155016098_REF_AREAZ;
            ex_tbwy               = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_155016098_TBWY), ex_tbwy) : PSD_2DRF_155016098_TBWY;
            ex_tbwz               = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_155016098_TBWZ), ex_tbwz) : PSD_2DRF_155016098_TBWZ;
            break;
        /*** SVBranch HCSDM00155611 Type I pulses for Value system  */
        case 154009096:
            ex_res                = _ex_res.fixedflag ?  ((void)(PSD_2DRF_154009096_RF1_R), ex_res) : PSD_2DRF_154009096_RF1_R;
            ex_pw                 = _ex_pw.fixedflag ?  ((void)(PSD_2DRF_154009096_RF1_PW), ex_pw) : PSD_2DRF_154009096_RF1_PW;
            ex_ttipdown           = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_154009096_RF1_LEFT), ex_ttipdown) : PSD_2DRF_154009096_RF1_LEFT;
            ex_nom_flip           = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth           = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_154009096), ex_abswidth) : SAR_ABS_2DRF_154009096;
            ex_effwidth           = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_154009096), ex_effwidth) : SAR_EFF_2DRF_154009096;
            ex_area               = _ex_area.fixedflag ?  ((void)(SAR_AREA_2DRF_154009096), ex_area) : SAR_AREA_2DRF_154009096;
            ex_dtycyc             = _ex_dtycyc.fixedflag ?  ((void)(SAR_DTC_2DRF_154009096), ex_dtycyc) : SAR_DTC_2DRF_154009096;
            ex_maxpw              = _ex_maxpw.fixedflag ?  ((void)(SAR_MAXPW_2DRF_154009096), ex_maxpw) : SAR_MAXPW_2DRF_154009096;
            ex_max_b1             = _ex_max_b1.fixedflag ?  ((void)(MAX_B1_2DRF_154009096), ex_max_b1) : MAX_B1_2DRF_154009096;
            ex_max_int_b1_sqr     = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_154009096), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_154009096;
            ex_max_rms_b1         = _ex_max_rms_b1.fixedflag ?  ((void)(MAX_RMS_B1_2DRF_154009096), ex_max_rms_b1) : MAX_RMS_B1_2DRF_154009096;
            ex_a_gys              = _ex_a_gys.fixedflag ?  ((void)(PSD_2DRF_154009096_A_GYS), ex_a_gys) : PSD_2DRF_154009096_A_GYS;
            ex_a_gzs              = _ex_a_gzs.fixedflag ?  ((void)(PSD_2DRF_154009096_A_GZS), ex_a_gzs) : PSD_2DRF_154009096_A_GZS;
            ex_nom_thky           = _ex_nom_thky.fixedflag ?  ((void)(PSD_2DRF_154009096_NOM_THKY), ex_nom_thky) : PSD_2DRF_154009096_NOM_THKY;
            ex_nom_thkz           = _ex_nom_thkz.fixedflag ?  ((void)(PSD_2DRF_154009096_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_154009096_NOM_THKZ;
            ex_maxnslices         = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_154009096_MAX_SLICES), ex_maxnslices) : PSD_2DRF_154009096_MAX_SLICES;
            ex_num_gylobe         = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_154009096_GY_NUML), ex_num_gylobe) : PSD_2DRF_154009096_GY_NUML;
            ex_num_gzlobe         = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_154009096_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_154009096_GZ_NUML;
            ex_pw_rampy           = _ex_pw_rampy.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_154009096_PW_RAMPY;
            ex_pw_rampz           = _ex_pw_rampz.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_154009096_PW_RAMPZ;
            ex_pw_constanty       = _ex_pw_constanty.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_154009096_PW_CONSTY;
            ex_pw_constantz       = _ex_pw_constantz.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_154009096_PW_CONSTZ;
            ex_refocus_ratioy     = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_154009096_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_154009096_REF_AREAY;
            ex_refocus_ratioz     = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_154009096_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_154009096_REF_AREAZ;
            ex_tbwy               = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_154009096_TBWY), ex_tbwy) : PSD_2DRF_154009096_TBWY;
            ex_tbwz               = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_154009096_TBWZ), ex_tbwz) : PSD_2DRF_154009096_TBWZ;
            ex_a_gys_pos          = _ex_a_gys_pos.fixedflag ?  ((void)(PSD_2DRF_154009096_A_GYS_POS), ex_a_gys_pos) : PSD_2DRF_154009096_A_GYS_POS;
            ex_pw_rampy_pos       = _ex_pw_rampy_pos.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_RAMPY_POS), ex_pw_rampy_pos) : PSD_2DRF_154009096_PW_RAMPY_POS;
            ex_pw_constanty_pos   = _ex_pw_constanty_pos.fixedflag ?  ((void)(PSD_2DRF_154009096_PW_CONSTY_POS), ex_pw_constanty_pos) : PSD_2DRF_154009096_PW_CONSTY_POS;            
            break;
        /*** Starter HCSDM00522509 Add new Type-I FOCUS pulse for Starter System */
        case 155009048:
            ex_res                = _ex_res.fixedflag ?  ((void)(PSD_2DRF_155009048_RF1_R), ex_res) : PSD_2DRF_155009048_RF1_R;
            ex_pw                 = _ex_pw.fixedflag ?  ((void)(PSD_2DRF_155009048_RF1_PW), ex_pw) : PSD_2DRF_155009048_RF1_PW;
            ex_ttipdown           = _ex_ttipdown.fixedflag ?  ((void)(PSD_2DRF_155009048_RF1_LEFT), ex_ttipdown) : PSD_2DRF_155009048_RF1_LEFT;
            ex_nom_flip           = _ex_nom_flip.fixedflag ?  ((void)(90.0), ex_nom_flip) : 90.0;
            ex_abswidth           = _ex_abswidth.fixedflag ?  ((void)(SAR_ABS_2DRF_155009048), ex_abswidth) : SAR_ABS_2DRF_155009048;
            ex_effwidth           = _ex_effwidth.fixedflag ?  ((void)(SAR_EFF_2DRF_155009048), ex_effwidth) : SAR_EFF_2DRF_155009048;
            ex_area               = _ex_area.fixedflag ?  ((void)(SAR_AREA_2DRF_155009048), ex_area) : SAR_AREA_2DRF_155009048;
            ex_dtycyc             = _ex_dtycyc.fixedflag ?  ((void)(SAR_DTC_2DRF_155009048), ex_dtycyc) : SAR_DTC_2DRF_155009048;
            ex_maxpw              = _ex_maxpw.fixedflag ?  ((void)(SAR_MAXPW_2DRF_155009048), ex_maxpw) : SAR_MAXPW_2DRF_155009048;
            ex_max_b1             = _ex_max_b1.fixedflag ?  ((void)(MAX_B1_2DRF_155009048), ex_max_b1) : MAX_B1_2DRF_155009048;
            ex_max_int_b1_sqr     = _ex_max_int_b1_sqr.fixedflag ?  ((void)(MAX_INT_B1_SQ_2DRF_155009048), ex_max_int_b1_sqr) : MAX_INT_B1_SQ_2DRF_155009048;
            ex_max_rms_b1         = _ex_max_rms_b1.fixedflag ?  ((void)(MAX_RMS_B1_2DRF_155009048), ex_max_rms_b1) : MAX_RMS_B1_2DRF_155009048;
            ex_a_gys              = _ex_a_gys.fixedflag ?  ((void)(PSD_2DRF_155009048_A_GYS), ex_a_gys) : PSD_2DRF_155009048_A_GYS;
            ex_a_gzs              = _ex_a_gzs.fixedflag ?  ((void)(PSD_2DRF_155009048_A_GZS), ex_a_gzs) : PSD_2DRF_155009048_A_GZS;
            ex_nom_thky           = _ex_nom_thky.fixedflag ?  ((void)(PSD_2DRF_155009048_NOM_THKY), ex_nom_thky) : PSD_2DRF_155009048_NOM_THKY;
            ex_nom_thkz           = _ex_nom_thkz.fixedflag ?  ((void)(PSD_2DRF_155009048_NOM_THKZ), ex_nom_thkz) : PSD_2DRF_155009048_NOM_THKZ;
            ex_maxnslices         = _ex_maxnslices.fixedflag ?  ((void)(PSD_2DRF_155009048_MAX_SLICES), ex_maxnslices) : PSD_2DRF_155009048_MAX_SLICES;
            ex_num_gylobe         = _ex_num_gylobe.fixedflag ?  ((void)(PSD_2DRF_155009048_GY_NUML), ex_num_gylobe) : PSD_2DRF_155009048_GY_NUML;
            ex_num_gzlobe         = _ex_num_gzlobe.fixedflag ?  ((void)(PSD_2DRF_155009048_GZ_NUML), ex_num_gzlobe) : PSD_2DRF_155009048_GZ_NUML;
            ex_pw_rampy           = _ex_pw_rampy.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_RAMPY), ex_pw_rampy) : PSD_2DRF_155009048_PW_RAMPY;
            ex_pw_rampz           = _ex_pw_rampz.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_RAMPZ), ex_pw_rampz) : PSD_2DRF_155009048_PW_RAMPZ;
            ex_pw_constanty       = _ex_pw_constanty.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_CONSTY), ex_pw_constanty) : PSD_2DRF_155009048_PW_CONSTY;
            ex_pw_constantz       = _ex_pw_constantz.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_CONSTZ), ex_pw_constantz) : PSD_2DRF_155009048_PW_CONSTZ;
            ex_refocus_ratioy     = _ex_refocus_ratioy.fixedflag ?  ((void)(PSD_2DRF_155009048_REF_AREAY), ex_refocus_ratioy) : PSD_2DRF_155009048_REF_AREAY;
            ex_refocus_ratioz     = _ex_refocus_ratioz.fixedflag ?  ((void)(PSD_2DRF_155009048_REF_AREAZ), ex_refocus_ratioz) : PSD_2DRF_155009048_REF_AREAZ;
            ex_tbwy               = _ex_tbwy.fixedflag ?  ((void)(PSD_2DRF_155009048_TBWY), ex_tbwy) : PSD_2DRF_155009048_TBWY;
            ex_tbwz               = _ex_tbwz.fixedflag ?  ((void)(PSD_2DRF_155009048_TBWZ), ex_tbwz) : PSD_2DRF_155009048_TBWZ;
            ex_a_gys_pos          = _ex_a_gys_pos.fixedflag ?  ((void)(PSD_2DRF_155009048_A_GYS_POS), ex_a_gys_pos) : PSD_2DRF_155009048_A_GYS_POS;
            ex_pw_rampy_pos       = _ex_pw_rampy_pos.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_RAMPY_POS), ex_pw_rampy_pos) : PSD_2DRF_155009048_PW_RAMPY_POS;
            ex_pw_constanty_pos   = _ex_pw_constanty_pos.fixedflag ?  ((void)(PSD_2DRF_155009048_PW_CONSTY_POS), ex_pw_constanty_pos) : PSD_2DRF_155009048_PW_CONSTY_POS;
            break;
           
        /******************************************/            
        default:
            epic_error( use_ermes,"%s: Error getting definitions for gradient/RF (rfov_type %d)!",
                        EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "read_rfpulse_info", INT_ARG, rfov_type );
            return FAILURE;
            break;
    }
    
    /* SVBranch HCSDM00155611 scale the gradient params for value system */
    value_system_grad_scale(); 

    /* Debugging information */
    if (debug_rfov)
    {
        printf("rfov_type %d\n",rfov_type);
        printf("ex_res %d\n",ex_res);
        printf("ex_pw %d\n",ex_pw);
        printf("ex_ttipdown %d",ex_ttipdown);
        printf("ex_nom_flip %f\n",ex_nom_flip);
        printf("ex_abswidth %f\n",ex_abswidth);
        printf("ex_effwidth %f\n",ex_effwidth);
        printf("ex_area %f\n",ex_area);
        printf("ex_dtycyc %f\n",ex_dtycyc);
        printf("ex_maxpw %f\n",ex_maxpw);
        printf("ex_max_b1 %f\n",ex_max_b1);
        printf("ex_max_int_b1_sqr %f\n",ex_max_int_b1_sqr);
        printf("ex_max_rms_b1 %f\n",ex_max_rms_b1);
        printf("ex_a_gzs %f\n",ex_a_gzs);
        printf("ex_a_gys %f\n",ex_a_gys);
        printf("ex_nom_thkz %f\n",ex_nom_thkz);
        printf("ex_nom_thky %f\n",ex_nom_thky);
        printf("ex_maxnslices %f\n",ex_maxnslices);
        printf("ex_num_gylobe %d\n",ex_num_gylobe);
        printf("ex_num_gzlobe %d\n",ex_num_gzlobe);
        printf("ex_pw_rampy %d\n",ex_pw_rampy);
        printf("ex_pw_rampz %d\n",ex_pw_rampz);
        printf("ex_pw_constanty %d\n",ex_pw_constanty);
        printf("ex_pw_constantz %d\n",ex_pw_constantz);
        printf("ex_refocus_ratioy %f\n",ex_refocus_ratioy);
        printf("ex_refocus_ratioz %f\n",ex_refocus_ratioz);
        printf("ex_tbwy %f\n",ex_tbwy);
        printf("ex_tbwz %f\n",ex_tbwz);
    }

    /* Make sure gradients durations are rounded up. */
    ex_pw_rampy  = _ex_pw_rampy.fixedflag ?  ((void)(RUP_GRD(ex_pw_rampy)), ex_pw_rampy) : RUP_GRD(ex_pw_rampy);
    ex_pw_rampz  = _ex_pw_rampz.fixedflag ?  ((void)(RUP_GRD(ex_pw_rampz)), ex_pw_rampz) : RUP_GRD(ex_pw_rampz);
    ex_pw_constanty  = _ex_pw_constanty.fixedflag ?  ((void)(RUP_GRD(ex_pw_constanty)), ex_pw_constanty) : RUP_GRD(ex_pw_constanty);
    ex_pw_constantz  = _ex_pw_constantz.fixedflag ?  ((void)(RUP_GRD(ex_pw_constantz)), ex_pw_constantz) : RUP_GRD(ex_pw_constantz);

    return SUCCESS;
}

STATUS rfov_cveval(void)
{
    int slice;
    float temp_max_freq_shift = 0.0;

    if (rfov_flag)
    {
        fskillercycling  = _fskillercycling.fixedflag ?  ((void)(1), fskillercycling) : 1;

        cvmin(opfov, FMax(2, (float)FOV_MIN, (float)(MIN_RFOV/exist(opphasefov))));      /*HCSDM00388767*/        

        /* Read info files for external waveforms */
        if (read_rfpulse_info() == FAILURE)
        {
            epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2),
                        STRING_ARG, "read_rfpulse_info", STRING_ARG, "rfov_cveval" );
            return FAILURE;
        }

        if (existcv(opphasefov) && existcv(opfov) && (opphasefov*opfov < ex_nom_thky))
        {
            epic_error( use_ermes, "Minimum FOV (limited in Phase Encode dir.) is %3.1f cm.",
                        EM_PSD_FOV_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, ex_nom_thky/(opphasefov*10.0) );
            return FAILURE;
        }

        if (existcv(opslspace) && (exist(opslspace) < 0.0))
        {
            epic_error( use_ermes, "Increase the slice spacing to %.1f mm",
                        EM_PSD_SLSPACING_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, 0.0 );
            return FAILURE;
        }

        /* HCSDM00157225 */
        if (existcv(opileave) && exist(opileave))
        {
            epic_error( use_ermes, "%s does not support Interleaved Acquisitions.",
                        EM_PSD_INTERLEAVE_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG, "Focus" );
            return FAILURE;
        }

        /* HCSDM00190059: Initialize RF1 parameters */
        setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp0_pw_rf1=pw_rf1,&_temp0_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp1_a_rf1=a_rf1,&_temp1_a_rf1) : &a_rf1, ex_abswidth, ex_effwidth, ex_area,
                     ex_dtycyc, ex_maxpw, 1, ex_max_b1, ex_max_int_b1_sqr, ex_max_rms_b1,
                     ex_nom_flip, _flip_rf1.fixedflag ? (_temp2_flip_rf1=flip_rf1,&_temp2_flip_rf1) : &flip_rf1, (float) pw_rf1, bw_rf1,
                     PSD_APS2_ON+PSD_MPS2_ON+PSD_SCAN_ON, (char ) 0, hrf1b, 1.0,
                     _res_rf1.fixedflag ? (_temp3_res_rf1=res_rf1,&_temp3_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp4_wg_rf1=wg_rf1,&_temp4_wg_rf1) : &wg_rf1, 1, rfpulse);
        
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(ex_nom_flip), flip_rf1) : ex_nom_flip;

        if (rfov_fa_scaling_flag && (PSD_XRMB_COIL == cfgcoiltype || PSD_XRMW_COIL == cfgcoiltype ||
                                     PSD_VRMW_COIL == cfgcoiltype || isRioSystem()))
        {
            float fa_scaling_factor;
            fa_scaling_factor = get_fa_scaling_factor_rfov(_max_rfov_fa.fixedflag ? (_temp5_max_rfov_fa=max_rfov_fa,&_temp5_max_rfov_fa) : &max_rfov_fa, flip_rf1,
                                                           rfpulse[RF1_SLOT].nom_fa,
                                                           rfpulse[RF1_SLOT].max_b1);
            flip_rf1  = _flip_rf1.fixedflag ?  ((void)(floor(flip_rf1*fa_scaling_factor)), flip_rf1) : floor(flip_rf1*fa_scaling_factor);
        }

        a_rf1     = _a_rf1.fixedflag ?  ((void)(flip_rf1/180), a_rf1) : flip_rf1/180;
        pw_rf1    = _pw_rf1.fixedflag ?  ((void)(ex_pw), pw_rf1) : ex_pw;
        res_rf1   = _res_rf1.fixedflag ?  ((void)(ex_res), res_rf1) : ex_res;
        thk_rf1   = _thk_rf1.fixedflag ?    ((void)(exist(opslthick)+exist(opslspace)), thk_rf1) : exist(opslthick)+exist(opslspace);
        thky_rf1  = _thky_rf1.fixedflag ?  ((void)(get_act_phase_fov()), thky_rf1) : get_act_phase_fov();
        hrf1a     = _hrf1a.fixedflag ?  ((void)(ex_ttipdown), hrf1a) : ex_ttipdown;
        hrf1b     = _hrf1b.fixedflag ?    ((void)(pw_rf1-ex_ttipdown), hrf1b) : pw_rf1-ex_ttipdown;
        gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
        alpha_rf1   = _alpha_rf1.fixedflag ?  ((void)(0.46), alpha_rf1) : 0.46;
        pw_gzrf1    = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
        pw_gzrf1a   = _pw_gzrf1a.fixedflag ?  ((void)(0), pw_gzrf1a) : 0;
        pw_gzrf1d   = _pw_gzrf1d.fixedflag ?  ((void)(0), pw_gzrf1d) : 0;
        pw_gyrf1    = _pw_gyrf1.fixedflag ?  ((void)(pw_rf1), pw_gyrf1) : pw_rf1;
        pw_gyrf1a   = _pw_gyrf1a.fixedflag ?  ((void)(0), pw_gyrf1a) : 0;
        pw_gyrf1d   = _pw_gyrf1d.fixedflag ?  ((void)(0), pw_gyrf1d) : 0;
        res_gzrf1   = _res_gzrf1.fixedflag ?  ((void)(res_rf1), res_gzrf1) : res_rf1;
        res_gyrf1   = _res_gyrf1.fixedflag ?  ((void)(res_rf1), res_gyrf1) : res_rf1;

        rfpulse[RF1_SLOT].nom_bw = ex_tbwz*1.0e6/(float)pw_rf1; /* in Hz */
        bw_rf1  = _bw_rf1.fixedflag ?  ((void)(rfpulse[RF1_SLOT].nom_bw), bw_rf1) : rfpulse[RF1_SLOT].nom_bw;                      /* No pulse stretching */

        /* Amplitudes */
        a_gzrf1   = _a_gzrf1.fixedflag ?  ((void)(ex_a_gzs*ex_nom_thkz/thk_rf1), a_gzrf1) : ex_a_gzs*ex_nom_thkz/thk_rf1;
        a_gyrf1   = _a_gyrf1.fixedflag ?  ((void)(ex_a_gys*ex_nom_thky/(thky_rf1*excite_ratio)), a_gyrf1) : ex_a_gys*ex_nom_thky/(thky_rf1*excite_ratio);
        if (type1_flag) /* SVBranch HCSDM00155611 Type I pulse */
        {
            a_gys_pos  = _a_gys_pos.fixedflag ?  ((void)(ex_a_gys_pos*ex_nom_thky/(thky_rf1*excite_ratio)), a_gys_pos) : ex_a_gys_pos*ex_nom_thky/(thky_rf1*excite_ratio);
        }
        else /* regular case */
        {
            a_gys_pos  = _a_gys_pos.fixedflag ?  ((void)(a_gyrf1), a_gys_pos) : a_gyrf1;
        }        

        ia_rf1    = _ia_rf1.fixedflag ?    ((void)(a_rf1*MAX_PG_IAMP), ia_rf1) : a_rf1*MAX_PG_IAMP;
        ia_thrf1  = _ia_thrf1.fixedflag ?  ((void)(MAX_PG_IAMP), ia_thrf1) : MAX_PG_IAMP;
        ia_gzrf1  = _ia_gzrf1.fixedflag ?    ((void)(a_gzrf1*MAX_PG_IAMP/loggrd.tz), ia_gzrf1) : a_gzrf1*MAX_PG_IAMP/loggrd.tz;
        ia_gyrf1  = _ia_gyrf1.fixedflag ?    ((void)(a_gyrf1*MAX_PG_IAMP/loggrd.ty), ia_gyrf1) : a_gyrf1*MAX_PG_IAMP/loggrd.ty;
        ia_gys_pos  = _ia_gys_pos.fixedflag ?     ((void)(a_gys_pos*MAX_PG_IAMP/loggrd.ty), ia_gys_pos) : a_gys_pos*MAX_PG_IAMP/loggrd.ty; /* SVBranch HCSDM00155611 Type I pulse */       

        temp_max_freq_shift = 0.0;
        for( slice = 0; slice < opslquant; ++slice )
        {
            /* Calculate off-iso center shifting params
               in-plane shifting (along phase encode) */
            y_shift  = _y_shift.fixedflag ?  ((void)(rsp_info[slice].rspphasoff), y_shift) : rsp_info[slice].rspphasoff;
            y_to_freq  = _y_to_freq.fixedflag ?       ((void)(y_shift*a_gyrf1*GAM/(10.0*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64)), y_to_freq) : y_shift*a_gyrf1*GAM/(10.0*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64);

            /* Slice shifting (along slice select, uses transmit frequency offset and convert to phase) */
            z_shift  = _z_shift.fixedflag ?  ((void)(rsp_info[slice].rsptloc), z_shift) : rsp_info[slice].rsptloc;
            z_to_freq  = _z_to_freq.fixedflag ?      ((void)(z_shift*a_gzrf1*GAM/(10.0*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64)), z_to_freq) : z_shift*a_gzrf1*GAM/(10.0*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64);

            /* the total slab shift */
            shift_to_freq  = _shift_to_freq.fixedflag ?    ((void)(fabs(y_to_freq)+fabs(z_to_freq)), shift_to_freq) : fabs(y_to_freq)+fabs(z_to_freq);

            if (floatsAlmostEqualEpsilons(shift_to_freq, 0.0, 2))
            {
                y_to_omscale[slice] = 0.0;
                z_to_omscale[slice] = 0.0;
            }
            else
            {
                y_to_omscale[slice] = y_to_freq/shift_to_freq;
                z_to_omscale[slice] = z_to_freq/shift_to_freq;
            }

            shift_to_omscale[slice] = shift_to_freq;

            if(shift_to_freq > temp_max_freq_shift)
            {
                temp_max_freq_shift = shift_to_freq;
            }
        }
        rfov_max_freq_shift  = _rfov_max_freq_shift.fixedflag ?  ((void)(temp_max_freq_shift*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64/1000.0), rfov_max_freq_shift) : temp_max_freq_shift*TARDIS_FREQ_RES*PSD_THETAFREQ_SHIFT*64/1000.0;

        /* Setting up the refocusing gradients */
        /* area_gyex1 is created on the positive polarity when the value is < 0 */
        area_gyex1  = _area_gyex1.fixedflag ?        ((void)(fabs(a_gyrf1*(ex_pw_constanty+ex_pw_rampy)*ex_refocus_ratioy)), area_gyex1) : fabs(a_gyrf1*(ex_pw_constanty+ex_pw_rampy)*ex_refocus_ratioy);

        /* If there are even number of lobes, then the refocusing lobe needs to be
           on the positive polarity. */
        if (0 == (ex_num_gylobe%2)) area_gyex1  = _area_gyex1.fixedflag ?  ((void)(-1.0), area_gyex1) : area_gyex1*-1.0;

        if (fabs(area_gyex1) > 0.0)
        {
            if (amppwgz1(_a_gyex1.fixedflag ? (_temp6_a_gyex1=a_gyex1,&_temp6_a_gyex1) : &a_gyex1, _pw_gyex1.fixedflag ? (_temp7_pw_gyex1=pw_gyex1,&_temp7_pw_gyex1) : &pw_gyex1, _pw_gyex1a.fixedflag ? (_temp8_pw_gyex1a=pw_gyex1a,&_temp8_pw_gyex1a) : &pw_gyex1a, _pw_gyex1d.fixedflag ? (_temp9_pw_gyex1d=pw_gyex1d,&_temp9_pw_gyex1d) : &pw_gyex1d, area_gyex1,
                         TR_MAX, MIN_PLATEAU_TIME, loggrd.yrt, loggrd.ty_xyz) == FAILURE)
            {
                epic_error( use_ermes, "Support routine %s failed.", EM_PSD_SUPPORT_FAILURE,
                            EE_ARGS(1), STRING_ARG, "amppwgz1:a_gyex1" );
                return FAILURE;
            }

            grady[GYEX1_SLOT].num = 1;
        }
        else
        {
            a_gyex1  = _a_gyex1.fixedflag ?  ((void)(0.0), a_gyex1) : 0.0;
            pw_gyex1  = _pw_gyex1.fixedflag ?  ((void)(0), pw_gyex1) : 0;
            pw_gyex1a  = _pw_gyex1a.fixedflag ?  ((void)(0), pw_gyex1a) : 0;
            pw_gyex1d  = _pw_gyex1d.fixedflag ?  ((void)(0), pw_gyex1d) : 0;

            grady[GYEX1_SLOT].num = 0;
        }

        pw_gyex1_tot  = _pw_gyex1_tot.fixedflag ?      ((void)(pw_gyex1a+pw_gyex1+pw_gyex1d), pw_gyex1_tot) : pw_gyex1a+pw_gyex1+pw_gyex1d;

        /* Set ADDITIONAL psd_rf_wait time based on cfpsdrfdly<x,y,z> and rotation matrix */
        addrfdel  = _addrfdel.fixedflag ?  ((void)(set_psd_rf_wait_delta()), addrfdel) : set_psd_rf_wait_delta();

        /* Set value for checking dbdt */
        if (type1_flag) /* SVBranch HCSDM00155611 Type I pulse */
        {
            /* Type I pulse play blips simultaneous 
               with negative fast lobe; */
            rfov_dbdtper  = _rfov_dbdtper.fixedflag ?  ((void)(calcdbdtper_rfov2()), rfov_dbdtper) : calcdbdtper_rfov2();              
        }
        else /* regular case */
        {
            rfov_dbdtper  = _rfov_dbdtper.fixedflag ?  ((void)(calcdbdtper_rfov()), rfov_dbdtper) : calcdbdtper_rfov();
        }

        if ((rfov_dbdtper > cfdbdtper) && (cfdbdtper > 0.0) && existcv(opfov))
        {
            epic_error( use_ermes, "RFOV Focus Stimulation threshold exceeded (%%).",
                        EM_PSD_EPI_DBDTPER, EE_ARGS(0) );
            printf("\ndB/dt value of %f percent exceeds limit of %f percent\n",
                    100.0*rfov_dbdtper, 100.0*cfdbdtper);
            return FAILURE;
        }
        
        grady[GYRF1_SLOT].attack = _ex_pw_rampy.fixedflag ? (_temp10_ex_pw_rampy=ex_pw_rampy,&_temp10_ex_pw_rampy) : &ex_pw_rampy;
        grady[GYRF1_SLOT].decay = _ex_pw_rampy.fixedflag ? (_temp11_ex_pw_rampy=ex_pw_rampy,&_temp11_ex_pw_rampy) : &ex_pw_rampy;
        grady[GYRF1_SLOT].pw = _ex_pw_constanty.fixedflag ? (_temp12_ex_pw_constanty=ex_pw_constanty,&_temp12_ex_pw_constanty) : &ex_pw_constanty;
        grady[GYRF1_SLOT].scale = 1.0;
        grady[GYRF1_SLOT].num = ex_num_gylobe;

        grady[GYEX1_SLOT].attack = _pw_gyex1a.fixedflag ? (_temp13_pw_gyex1a=pw_gyex1a,&_temp13_pw_gyex1a) : &pw_gyex1a;
        grady[GYEX1_SLOT].decay = _pw_gyex1d.fixedflag ? (_temp14_pw_gyex1d=pw_gyex1d,&_temp14_pw_gyex1d) : &pw_gyex1d;
        grady[GYEX1_SLOT].pw = _pw_gyex1.fixedflag ? (_temp15_pw_gyex1=pw_gyex1,&_temp15_pw_gyex1) : &pw_gyex1;
        grady[GYEX1_SLOT].scale = 1.0;

        gradz[GZRF1_SLOT].attack = _ex_pw_rampz.fixedflag ? (_temp16_ex_pw_rampz=ex_pw_rampz,&_temp16_ex_pw_rampz) : &ex_pw_rampz;
        gradz[GZRF1_SLOT].decay = _ex_pw_rampz.fixedflag ? (_temp17_ex_pw_rampz=ex_pw_rampz,&_temp17_ex_pw_rampz) : &ex_pw_rampz;
        gradz[GZRF1_SLOT].pw = _ex_pw_constantz.fixedflag ? (_temp18_ex_pw_constantz=ex_pw_constantz,&_temp18_ex_pw_constantz) : &ex_pw_constantz;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = ex_num_gzlobe;    
   
    }
    else /* For non-RFOV case */
    {
        fskillercycling  = _fskillercycling.fixedflag ?  ((void)(0), fskillercycling) : 0;
        a_gyrf1  = _a_gyrf1.fixedflag ?  ((void)(0.0), a_gyrf1) : 0.0;

        area_gyex1  = _area_gyex1.fixedflag ?  ((void)(0.0), area_gyex1) : 0.0;
        a_gyex1  = _a_gyex1.fixedflag ?  ((void)(0.0), a_gyex1) : 0.0;
        pw_gyex1  = _pw_gyex1.fixedflag ?  ((void)(0), pw_gyex1) : 0;
        pw_gyex1a  = _pw_gyex1a.fixedflag ?  ((void)(0), pw_gyex1a) : 0;
        pw_gyex1d  = _pw_gyex1d.fixedflag ?  ((void)(0), pw_gyex1d) : 0;
        pw_gyex1_tot  = _pw_gyex1_tot.fixedflag ?  ((void)(0), pw_gyex1_tot) : 0;

        addrfdel  = _addrfdel.fixedflag ?  ((void)(0), addrfdel) : 0;
        rfov_dbdtper  = _rfov_dbdtper.fixedflag ?  ((void)(0.0), rfov_dbdtper) : 0.0;

        grady[GYRF1_SLOT].num = 0;
        grady[GYEX1_SLOT].num = 0;

        gradz[GZRF1_SLOT].attack = _pw_gzrf1a.fixedflag ? (_temp19_pw_gzrf1a=pw_gzrf1a,&_temp19_pw_gzrf1a) : &pw_gzrf1a;
        gradz[GZRF1_SLOT].decay = _pw_gzrf1d.fixedflag ? (_temp20_pw_gzrf1d=pw_gzrf1d,&_temp20_pw_gzrf1d) : &pw_gzrf1d;
        gradz[GZRF1_SLOT].pw = _pw_gzrf1.fixedflag ? (_temp21_pw_gzrf1=pw_gzrf1,&_temp21_pw_gzrf1) : &pw_gzrf1;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = 1;
    }

    if (PSD_OBL != exist(opplane))
    {
        grady[GYRF1_SLOT].powscale = 1.0;
        grady[GYEX1_SLOT].powscale = 1.0;
    }
    else
    {
        grady[GYRF1_SLOT].powscale = loggrd.yfs/loggrd.ty_yz;
        grady[GYEX1_SLOT].powscale = loggrd.yfs/loggrd.ty_yz;
    }
    
    /* SVBranch HCSDM00155611 initialize walk sat params */
    if ( (walk_sat_flag) && (rfov_flag) )
    {
        if ( FAILURE == walk_sat_RFinit() ) return FAILURE;        
    }    
    
    /* SVBranch HCSDM00272982: FOCUS-DTI signal void in one direction in SPINE;
       Switch low pass filter width from 8 to 4 for FOCUS-DTI as
       a temporary solution */
    if( (tensor_flag) && (rfov_flag) &&
        (isValueSystem()) )
    {
        rh_low_pass_nex_filter_width  = _rh_low_pass_nex_filter_width.fixedflag ?  ((void)(4.0), rh_low_pass_nex_filter_width) : 4.0;
    }
    else
    {
        rh_low_pass_nex_filter_width  = _rh_low_pass_nex_filter_width.fixedflag ?  ((void)(8.0), rh_low_pass_nex_filter_width) : 8.0;
    }    

    return SUCCESS;
}

/* SVBranch HCSDM00155611 Initialize walk sat pulse params */
STATUS walk_sat_RFinit(void)
{
    wg_rfwk          = _wg_rfwk.fixedflag ?  ((void)(TYPRHO1), wg_rfwk) : TYPRHO1;          /* wave generator sequencer type */
    res_rfwk_orig    = _res_rfwk_orig.fixedflag ?  ((void)(RES_RFWK), res_rfwk_orig) : RES_RFWK;         /* num pts */
    res_rfwk         = _res_rfwk.fixedflag ?  ((void)(res_rfwk_orig), res_rfwk) : res_rfwk_orig;
    pw_rfwk          = _pw_rfwk.fixedflag ?  ((void)(SAR_NOM_PW_RFWK), pw_rfwk) : SAR_NOM_PW_RFWK;  /* us */
    bw_rfwk          = _bw_rfwk.fixedflag ?  ((void)(SAR_NOM_BW_RFWK), bw_rfwk) : SAR_NOM_BW_RFWK;  /* Hz */
    hrfwka           = _hrfwka.fixedflag ?  ((void)(LEFT_RFWK), hrfwka) : LEFT_RFWK;        /* us, left half duration */
    hrfwkb           = _hrfwkb.fixedflag ?    ((void)(pw_rfwk-hrfwka), hrfwkb) : pw_rfwk-hrfwka; /* us, iso-delay */
    cyc_rfwk         = _cyc_rfwk.fixedflag ?  ((void)(3.0), cyc_rfwk) : 3.0;              /* used for hadamard process */
    
    return SUCCESS;
}

/* cveval for walk sat */
STATUS walk_sat_cveval(void)
{  
    float sat_thk_cm = 0.0;

    /* renew some parameters if the RF is stretched */
    if (rfpulseInfo[RFWK_SLOT].change==PSD_ON)     
    {
        /* iso-delay */
        hrfwka  = _hrfwka.fixedflag ?     ((void)(((int)(pw_rfwk/2/4))*4), hrfwka) : ((int)(pw_rfwk/2/4))*4;
        hrfwkb  = _hrfwkb.fixedflag ?    ((void)(pw_rfwk-hrfwka), hrfwkb) : pw_rfwk-hrfwka;
        /* bandwidth */
        bw_rfwk  = _bw_rfwk.fixedflag ?  ((void)(rfpulse[RFWK_SLOT].nom_bw*rfpulse[RFWK_SLOT].nom_pw/pw_rfwk), bw_rfwk) : rfpulse[RFWK_SLOT].nom_bw*rfpulse[RFWK_SLOT].nom_pw/pw_rfwk;        
    }

    /* width of saturation band in cm */        
    sat_thk_cm = sat_thk_factor * (get_act_phase_fov())/ 10.0;
 
    /* calculate the sat slice-select grad */
    a_gyrfwk  = _a_gyrfwk.fixedflag ?   ((void)((float)bw_rfwk/(sat_thk_cm*GAM)), a_gyrfwk) : (float)bw_rfwk/(sat_thk_cm*GAM); 
    ia_gyrfwk  = _ia_gyrfwk.fixedflag ?    ((void)(a_gyrfwk*MAX_PG_IAMP/loggrd.ty), ia_gyrfwk) : a_gyrfwk*MAX_PG_IAMP/loggrd.ty;
    pw_gyrfwk  = _pw_gyrfwk.fixedflag ?  ((void)(pw_rfwk), pw_gyrfwk) : pw_rfwk;
    
    if (optramp(_pw_gyrfwka.fixedflag ? (_temp22_pw_gyrfwka=pw_gyrfwka,&_temp22_pw_gyrfwka) : &pw_gyrfwka, a_gyrfwk, loggrd.ty_xyz, loggrd.yrt, TYPDEF) == FAILURE) 
    {
        epic_error( use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, 
                    EE_ARGS(1), STRING_ARG, "optramp:pw_gyrfwk" );
        return FAILURE;
    }
    pw_gyrfwkd  = _pw_gyrfwkd.fixedflag ?  ((void)(pw_gyrfwka), pw_gyrfwkd) : pw_gyrfwka;   
   
    /* location of sat bands */
    /* sat bands are located right outside the
       top/bottom edges of the pFOV; */
    loc_satcen_cm  = _loc_satcen_cm.fixedflag ?   ((void)(rsp_info[0].rspphasoff/10), loc_satcen_cm) : rsp_info[0].rspphasoff/10;
    loc_satcen_Hz  = _loc_satcen_Hz.fixedflag ?      ((void)(loc_satcen_cm*a_gyrfwk*GAM), loc_satcen_Hz) : loc_satcen_cm*a_gyrfwk*GAM;                  
    sep_sat_ratio   = _sep_sat_ratio.fixedflag ?      ((void)((sat_thk_cm+get_act_phase_fov()/10)/(sat_thk_cm*2.0)), sep_sat_ratio) : (sat_thk_cm+get_act_phase_fov()/10)/(sat_thk_cm*2.0);                      
 
    /* spoiler params */
    /* spoiler needs to cause several cycles
       difference through out the band; */
    float area_wk_sp = 0.0;
    area_wk_sp = walk_sat_cycle/ (GAM*sat_thk_cm) * 1000000.0; /* *1000000 so that s to us */
    amppwgrad(area_wk_sp, 
              FMin(3, (float)loggrd.tx_xyz, (float)loggrd.ty_xyz, (float)loggrd.tz_xyz),
              0, 
              0, 
              FMax(3, (float)loggrd.xrt, (float)loggrd.yrt, (float)loggrd.zrt), 
              MIN_PLATEAU_TIME, 
              _a_gwksp.fixedflag ? (_temp23_a_gwksp=a_gwksp,&_temp23_a_gwksp) : &a_gwksp, 
              _pw_gwkspa.fixedflag ? (_temp24_pw_gwkspa=pw_gwkspa,&_temp24_pw_gwkspa) : &pw_gwkspa, 
              _pw_gwksp.fixedflag ? (_temp25_pw_gwksp=pw_gwksp,&_temp25_pw_gwksp) : &pw_gwksp, 
              _pw_gwkspd.fixedflag ? (_temp26_pw_gwkspd=pw_gwkspd,&_temp26_pw_gwkspd) : &pw_gwkspd); 
              
    /* X axis */
    a_gxwksp    = _a_gxwksp.fixedflag ?  ((void)(a_gwksp), a_gxwksp) : a_gwksp;
    pw_gxwkspa  = _pw_gxwkspa.fixedflag ?  ((void)(pw_gwkspa), pw_gxwkspa) : pw_gwkspa;
    pw_gxwksp   = _pw_gxwksp.fixedflag ?  ((void)(pw_gwksp), pw_gxwksp) : pw_gwksp;
    pw_gxwkspd  = _pw_gxwkspd.fixedflag ?  ((void)(pw_gwkspd), pw_gxwkspd) : pw_gwkspd;
    ia_gxwksp   = _ia_gxwksp.fixedflag ?    ((void)(a_gwksp*MAX_PG_IAMP/loggrd.tx), ia_gxwksp) : a_gwksp*MAX_PG_IAMP/loggrd.tx; 
    /* Y axis */
    a_gywksp    = _a_gywksp.fixedflag ?  ((void)(a_gwksp), a_gywksp) : a_gwksp;
    pw_gywkspa  = _pw_gywkspa.fixedflag ?  ((void)(pw_gwkspa), pw_gywkspa) : pw_gwkspa;
    pw_gywksp   = _pw_gywksp.fixedflag ?  ((void)(pw_gwksp), pw_gywksp) : pw_gwksp;
    pw_gywkspd  = _pw_gywkspd.fixedflag ?  ((void)(pw_gwkspd), pw_gywkspd) : pw_gwkspd;    
    ia_gywksp   = _ia_gywksp.fixedflag ?    ((void)(a_gwksp*MAX_PG_IAMP/loggrd.ty), ia_gywksp) : a_gwksp*MAX_PG_IAMP/loggrd.ty; 
    /* Z axis */
    a_gzwksp    = _a_gzwksp.fixedflag ?  ((void)(a_gwksp), a_gzwksp) : a_gwksp;
    pw_gzwkspa  = _pw_gzwkspa.fixedflag ?  ((void)(pw_gwkspa), pw_gzwkspa) : pw_gwkspa;
    pw_gzwksp   = _pw_gzwksp.fixedflag ?  ((void)(pw_gwksp), pw_gzwksp) : pw_gwksp;
    pw_gzwkspd  = _pw_gzwkspd.fixedflag ?  ((void)(pw_gwkspd), pw_gzwkspd) : pw_gwkspd;    
    ia_gzwksp   = _ia_gzwksp.fixedflag ?    ((void)(a_gwksp*MAX_PG_IAMP/loggrd.tz), ia_gzwksp) : a_gwksp*MAX_PG_IAMP/loggrd.tz;   

    /* Initial timing of the walk sat module in cveval();
       This will be recalled in calcPulseParams(),
       which is run in cvcheck() and predownload(),
       so that the start time of the walking-sat
       module will be updated every time the
       pos_start is udpated;
    */
    if ( FAILURE == walk_sat_timing() ) return FAILURE;                        
               
    return SUCCESS;
}

/*** timing of the walk sat module ***/
STATUS walk_sat_timing(void)
{
    int tmp1 = 0;
    int tmp2 = 0;
    /* duration of sat sl-sel grad */
    tmp1 = pw_gyrfwka + pw_gyrfwk + pw_gyrfwkd;    
    /* duration of sat spoiler */
    tmp2 = pw_gwkspa + pw_gwksp + pw_gwkspd; 
    /* start time of walk-sat RF */    
    pos_rfwk  = _pos_rfwk.fixedflag ?    ((void)(pos_start+pw_gyrfwka), pos_rfwk) : pos_start+pw_gyrfwka; 
    /* start time of walk-sat spoiler */     
    pos_sp_wk  = _pos_sp_wk.fixedflag ?      ((void)(pos_start+tmp1+GRAD_UPDATE_TIME), pos_sp_wk) : pos_start+tmp1+GRAD_UPDATE_TIME;  
    /* total time of walking sat */
    /* Used in cveval1()         to calculate     non_tetime, full_irtime;
       Used in DTI_predownload() to calculate     rf_excite_location;
       Used in rfov_pulsegen()   to calculate     start_rf1; */                
    pw_wksat_tot  = _pw_wksat_tot.fixedflag ?        ((void)(tmp1+GRAD_UPDATE_TIME+tmp2+GRAD_UPDATE_TIME), pw_wksat_tot) : tmp1+GRAD_UPDATE_TIME+tmp2+GRAD_UPDATE_TIME;   
    
    return SUCCESS;
}

int set_psd_rf_wait_delta(void)
{
    /* Reduced FOV 2DRF pulse is especially sensitive to hardware delays
       that are dependent on the gradient axis.  So we attempt to improve the psd_rf_wait
       times from system config values that have been measured.
       The RF delay setting is based on the PHASE-ENCODING direction so if A/P is
       the PE direction with Sagittal plane and supine position, cfpsdrfdlyy is used. */

    int delay = 0;

    if ((0 == cfpsdrfdlyx) || (0 == cfpsdrfdlyy) || (0 == cfpsdrfdlyz))
    {
        /* Safety check against incomplete configuration setup */
        delay = 0;
    }
    else
    {
        float max_vec;
        float pe_vec[3];
 
        /* Take abs as we don't care about the polarity */
        pe_vec[0] = fabs(scan_info[0].oprot[1]);
        pe_vec[1] = fabs(scan_info[0].oprot[4]);
        pe_vec[2] = fabs(scan_info[0].oprot[7]);

        max_vec = FMax(3, pe_vec[0], pe_vec[1], pe_vec[2]);

        /* HCSDM00193590: Using closest plane instead of vectorizing oblique delays
           due to coarseness of time delays. */
        if (floatsAlmostEqualEpsilons(max_vec, pe_vec[0], 2))
        {
            delay = cfpsdrfdlyx;
        }
        else if (floatsAlmostEqualEpsilons(max_vec, pe_vec[1], 2))
        {
            delay = cfpsdrfdlyy;
        }
        else
        {
            delay = cfpsdrfdlyz;
        }
        delay = RDN_RF(delay - psd_rf_wait);
    }

    return delay;
}

float calcdbdtper_rfov(void)
{
    /* The 2D RF gradient waveforms could be considered three parts:
     *    1. The first ramp. There is no blip here.
     *       3 corner points for this part.
     *    2. Parity switching period. There is bilp within this period.
     *       This period is repeated, and 10 corner points needed for each repetition.
     *    3. The last ramp: There is no blip here. 3 corner points for this part.
     */

    int i, j;
    float max_dbdtper;
    float ex_pw_gygap = 0;
    float ex_pw_constantylr = 0;

    int tcon1[3], tcon2[10], tcon3[3];
    float aconx1[3], aconx2[10], aconx3[3];
    float acony1[3], acony2[10], acony3[3];

    if (ex_pw_rampz+ex_pw_constantz/2 > ex_pw_rampy+ex_pw_gygap/2)
    {
        ex_pw_constantylr = ex_pw_rampz + ex_pw_constantz/2 - (ex_pw_rampy + ex_pw_gygap/2);
        ex_pw_constanty  = _ex_pw_constanty.fixedflag ?      ((void)(ex_pw_constanty-2*ex_pw_constantylr), ex_pw_constanty) : ex_pw_constanty-2*ex_pw_constantylr;
    }

    /* generate corner points */
    tcon1[0]=0; tcon1[1]=ex_pw_rampy; tcon1[2]=ex_pw_constantylr;
    aconx1[0]=0; aconx1[1]=a_gyrf1; aconx1[2]=a_gyrf1;
    acony1[0]=0; acony1[1]=0; acony1[2]=0;

    tcon3[0]=ex_pw_constanty; tcon3[1]=ex_pw_constantylr; tcon3[2]=ex_pw_rampy;
    aconx3[0]=a_gyrf1; aconx3[1]=a_gyrf1; aconx3[2]=0;
    acony3[0]=0; acony3[1]=0; acony3[2]=0;

    tcon2[0]=ex_pw_constanty; aconx2[0]=a_gyrf1; acony2[0]=0;

    if (ex_pw_rampz+ex_pw_constantz/2 > ex_pw_rampy+ex_pw_gygap/2)
    {
        tcon2[1]=ex_pw_constantylr+(ex_pw_rampy+ex_pw_gygap/2)-(ex_pw_rampz+ex_pw_constantz/2);
        aconx2[1]=a_gyrf1; acony2[1]=0;

        if (ex_pw_constantz/2 > ex_pw_rampy+ex_pw_gygap/2)
        {
            tcon2[2]=ex_pw_rampz; aconx2[2]=a_gyrf1; acony2[2]=a_gzrf1;
            tcon2[3]=(ex_pw_constantz/2)-(ex_pw_rampy+ex_pw_gygap/2); aconx2[3]=a_gyrf1; acony2[3]=a_gzrf1;
            tcon2[4]=ex_pw_rampy; aconx2[4]=0; acony2[4]=ex_pw_constantz;
        }
        else
        {
            tcon2[2]=(ex_pw_rampz+ex_pw_constantz/2)-(ex_pw_rampy+ex_pw_gygap/2); aconx2[2]=a_gyrf1;
            acony2[2] = intercept_rfov(0,a_gzrf1, ex_pw_rampz, tcon2[2]);

            if (ex_pw_constantz/2 > ex_pw_gygap/2)
            {
                tcon2[3]=(ex_pw_rampy+ex_pw_gygap/2)-(ex_pw_constantz/2);
                aconx2[3]=intercept_rfov(a_gyrf1, 0, ex_pw_rampy,tcon2[3]);
                acony2[3]=a_gzrf1;
                tcon2[4]=ex_pw_constantz/2 - ex_pw_gygap/2; aconx2[4]=0; acony2[4]=a_gzrf1;
            }
            else
            {
                tcon2[3]=ex_pw_rampy;
                aconx2[3]=0;
                acony2[3]=intercept_rfov(0, a_gzrf1, ex_pw_rampz,tcon2[2]+tcon2[3]);
                tcon2[4]=(ex_pw_gygap/2)-(ex_pw_constantz/2); aconx2[4]=0; acony2[4]=a_gzrf1;
            }
        }
    }
    else
    {
        tcon2[1]=ex_pw_constantylr; aconx2[1]=a_gyrf1; acony2[1]=0;

        if (ex_pw_rampz+ex_pw_constantz/2 > ex_pw_gygap/2)
        {
            tcon2[2]=(ex_pw_rampy+ex_pw_gygap/2)-(ex_pw_rampz+ex_pw_constantz/2);
            aconx2[2]=intercept_rfov(a_gyrf1, 0, ex_pw_rampy, tcon2[2]);
            acony2[2]=0;

            if (ex_pw_constantz/2 > ex_pw_gygap/2)
            {
                tcon2[3]=ex_pw_rampz;
                aconx2[3]=intercept_rfov(a_gyrf1, 0, ex_pw_rampy, ex_pw_rampy+ex_pw_gygap/2-ex_pw_constantz/2);
                acony2[3]=a_gzrf1;
                tcon2[4]=ex_pw_constantz/2-ex_pw_gygap/2; aconx2[4]=0; acony2[4]=a_gzrf1;
            }
            else
            {
                tcon2[3]=(ex_pw_rampz+ex_pw_constantz/2)-(ex_pw_gygap/2);
                aconx2[3]=0;
                acony2[3]=intercept_rfov(0, a_gzrf1, ex_pw_rampz, tcon2[3]);
                tcon2[4]=ex_pw_gygap/2-ex_pw_constantz/2; aconx2[4]=0; acony2[4]=a_gzrf1;
            }
        }
        else
        {
            tcon2[2]=ex_pw_rampy; aconx2[2]=0; acony2[2]=0;
            tcon2[3]=(ex_pw_gygap/2)-(ex_pw_rampz+ex_pw_constantz/2); aconx2[3]=0; acony2[3]=0;
            tcon2[4]=ex_pw_rampz; aconx2[4]=0; acony2[4]=a_gzrf1;
        }
    }

    tcon2[5]=2*((ex_pw_constantylr+ex_pw_rampy+ex_pw_gygap/2)-tcon2[1]-tcon2[2]-tcon2[3]-tcon2[4]);

    for (i = 6; i < 10; i++)
    {
        tcon2[i]=tcon2[10-i];
    }

    for (i = 5; i < 10; i++)
    {
        aconx2[i]=-aconx2[9-i];
        acony2[i]=acony2[9-i];
    }

    /* calculate dbdtper with convolution dbdt model */
    {
        int etl_1, num_cornerpoints;
        int * tcon;
        float * aconx, * acony;
        float * dbdtper_x_data, * dbdtper_y_data, * dbdtper_data;
        int sign = 1;

        float us2s = 1.0e-6;
        float gcm2Tm = 1.0e-2;
        float cm2m = 1.0e-2;

        float dbdtdxyz;

        etl_1 = 4;
        num_cornerpoints = 3+10*(etl_1-1)+3;

        tcon = (int *)malloc(num_cornerpoints*sizeof(int));
        aconx = (float *)malloc(num_cornerpoints*sizeof(float));
        acony = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_x_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_y_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_data = (float *)malloc(num_cornerpoints*sizeof(float));

        tcon[0]=0;
        aconx[0]=0;
        acony[0]=0;

        for (i = 1; i < num_cornerpoints; i++)
        {
            if (i < 3)
            {
                tcon[i] = tcon[i-1]+tcon1[i];
                aconx[i] = aconx1[i];
                acony[i] = acony1[i];
            }
            else if (i >= num_cornerpoints - 3)
            {
                tcon[i] = tcon[i-1]+tcon3[i-(num_cornerpoints-3)];
                aconx[i] = aconx3[i-(num_cornerpoints-3)]*sign;
                acony[i] = acony3[i-(num_cornerpoints-3)];
            }
            else
            {
                tcon[i] = tcon[i-1]+tcon2[(i-3)%10];
                aconx[i] = aconx2[(i-3)%10]*sign;
                acony[i] = acony2[(i-3)%10];

                if (((i-3)%10) == 9) sign *= -1;
            }
        }

        if (rfov_dbdt_debug)
        {
            print_corner_point_rfov(num_cornerpoints, tcon, aconx, acony);
        }

        dbdtdxyz = FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);

        for (i = 0; i < num_cornerpoints; i++)
        {
            aconx[i] *= dbdtdxyz*cm2m*gcm2Tm;
            acony[i] *= dbdtdxyz*cm2m*gcm2Tm;
        }

        max_dbdtper=0.0;
        dbdtper_x_data[0] = dbdtper_y_data[0] = dbdtper_data[0] = 0.0;

        for (i = 1; i < num_cornerpoints; i++)
        {
            float the_dbdtper_x=0.0;
            float the_dbdtper_y=0.0;
            float the_dbdtper;

            for (j = 0; j < i; j++)
            {
                float dbdt_x, dbdt_y;

                if (tcon[j+1] == tcon[j]) continue;

                dbdt_x=(aconx[j+1]-aconx[j])/(tcon[j+1]-tcon[j])/us2s;
                dbdt_y=(acony[j+1]-acony[j])/(tcon[j+1]-tcon[j])/us2s;
                the_dbdtper_x=the_dbdtper_x+dbdt_x*cfrfact/cfrinf*
                    (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
                the_dbdtper_y=the_dbdtper_y+dbdt_y*cfrfact/cfrinf*
                    (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
            }

            the_dbdtper = sqrt(the_dbdtper_x*the_dbdtper_x+the_dbdtper_y*the_dbdtper_y);

            if (the_dbdtper > max_dbdtper) max_dbdtper=the_dbdtper;

            dbdtper_x_data[i] = the_dbdtper_x;
            dbdtper_y_data[i] = the_dbdtper_y;
            dbdtper_data[i] = the_dbdtper;
        }

        if (rfov_dbdt_debug)
        {
            print_dbdtper_rfov( max_dbdtper*100.0, num_cornerpoints, tcon,
                                dbdtper_x_data, dbdtper_y_data, dbdtper_data );
        }

        free(tcon);
        free(aconx);
        free(acony);
        free(dbdtper_x_data);
        free(dbdtper_y_data);
        free(dbdtper_data);
    }

    return max_dbdtper;
}

/* SVBranch HCSDM00155611 
   For Type I pulse
   the blips are played simultaneously 
   with the negative fast lobe; */
float calcdbdtper_rfov2(void)
{
    /* HCSDM00300336: PSD static code analysis violations in MULAN;
       below vectors are now initialized before use; */
    float acon_fast[500] = {0}; 
    float acon_slow[500] = {0};
    float tcon[500] = {0};
    float max_pns; 
    float p_pns;
    float p_pns_fast;
    float p_pns_slow;
    float tmp_dmax;
    int tmp_k;
    int tmp_j;
    int dur_pos;
    int dur_neg;

    /* Generate Corner-points */
    /* The unit of tcon: s;  the unit of acon: T */
    tmp_dmax = FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);  /* max effective distance */ 
    dur_pos = ex_pw_rampy_pos*2 + ex_pw_constanty_pos; /* duration of each pos lobe */
    dur_neg = ex_pw_rampy*2 + ex_pw_constanty;         /* duration of each neg lobe */   
    for(tmp_j=1; tmp_j<=ex_num_gylobe; tmp_j++)
    {    
        /* Corner-points amplitude */        
        if( (tmp_j%2) == 1 ) 
        {         
            /* Up-ramp begin of a pos lobe (4us is the time between each two lobes) */
            tcon[(tmp_j-1)*4]   = (float)( (tmp_j-1)/2 * dur_pos + (tmp_j-1)/2 * dur_neg + (tmp_j-1) * 4 ) * 0.000001;
            /* Plateau begin of a pos lobe */
            tcon[(tmp_j-1)*4+1] = (float)( tcon[(tmp_j-1)*4] + ex_pw_rampy_pos ) * 0.000001;
            /* Plateau end of a pos lobe */
            tcon[(tmp_j-1)*4+2] = (float)( tcon[(tmp_j-1)*4+1] + ex_pw_constanty_pos ) * 0.000001; 
            /* Down-ramp end of a pos lobe */            
            tcon[(tmp_j-1)*4+3] = (float)( tcon[(tmp_j-1)*4+2] + ex_pw_rampy_pos ) * 0.000001;
            /* Positive fast lobe */
            acon_fast[(tmp_j-1)*4]   = 0.0;
            acon_fast[(tmp_j-1)*4+1] = a_gys_pos*tmp_dmax*0.0001;
            acon_fast[(tmp_j-1)*4+2] = a_gys_pos*tmp_dmax*0.0001;
            acon_fast[(tmp_j-1)*4+3] = 0.0;
            /* Wait between blips */
            acon_slow[(tmp_j-1)*4]   = 0.0;
            acon_slow[(tmp_j-1)*4+1] = 0.0;
            acon_slow[(tmp_j-1)*4+2] = 0.0;  
            acon_slow[(tmp_j-1)*4+3] = 0.0;             
        }
        else 
        {        
            /* Up-ramp begin of a neg lobe (4us is the time between each two lobes) */
            tcon[(tmp_j-1)*4]   = (float)( tmp_j/2 * dur_pos + (tmp_j/2-1) * dur_neg + (tmp_j-1) * 4 ) * 0.000001;
            /* Plateau begin of a neg lobe */
            tcon[(tmp_j-1)*4+1] = (float)( tcon[(tmp_j-1)*4] + ex_pw_rampy ) * 0.000001;
            /* Plateau end of a neg lobe */
            tcon[(tmp_j-1)*4+2] = (float)( tcon[(tmp_j-1)*4+1] + ex_pw_constanty ) * 0.000001; 
            /* Down-ramp end of a neg lobe */            
            tcon[(tmp_j-1)*4+3] = (float)( tcon[(tmp_j-1)*4+2] + ex_pw_rampy ) * 0.000001;        
            /* Negative fast lobe */
            acon_fast[(tmp_j-1)*4]   = 0.0;
            acon_fast[(tmp_j-1)*4+1] = -a_gyrf1*tmp_dmax*0.0001;
            acon_fast[(tmp_j-1)*4+2] = -a_gyrf1*tmp_dmax*0.0001; 
            acon_fast[(tmp_j-1)*4+3] = 0.0;
            /* Blips */
            acon_slow[(tmp_j-1)*4]   = 0.0;
            acon_slow[(tmp_j-1)*4+1] = a_gzrf1*tmp_dmax*0.0001;
            acon_slow[(tmp_j-1)*4+2] = a_gzrf1*tmp_dmax*0.0001;  
            acon_slow[(tmp_j-1)*4+3] = 0.0;             
        }        
    }
    /* calculate PNS with Convolution Model*/
    max_pns = 0.0;
    for(tmp_k=1;tmp_k<ex_num_gylobe*4;tmp_k++)
    {     
        p_pns      = 0.0;
        p_pns_fast = 0.0;
        p_pns_slow = 0.0;
        for(tmp_j=0;tmp_j<tmp_k;tmp_j++)
        {        
            if(!floatsAlmostEqualEpsilons(tcon[tmp_j+1]-tcon[tmp_j], 0.0, 2))
            {
                /* Fast grad axis */
                p_pns_fast = p_pns_fast + (acon_fast[tmp_j+1]-acon_fast[tmp_j])/
                    (tcon[tmp_j+1]-tcon[tmp_j]) * 
                    ((float)cfrfact*0.000001)/ 
                    cfrinf *
                    (1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j+1]) - 
                     1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j])); /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by floatsAlmostEqualEpsilons comparison " */
                /* Slow grad axis */
                p_pns_slow = p_pns_slow + (acon_slow[tmp_j+1]-acon_slow[tmp_j])/
                    (tcon[tmp_j+1]-tcon[tmp_j]) * 
                    ((float)cfrfact*0.000001)/ 
                    cfrinf *
                    (1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j+1]) - 
                     1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j])); /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by floatsAlmostEqualEpsilons comparison " */
            }
        }        
        p_pns = sqrt( p_pns_fast*p_pns_fast + p_pns_slow*p_pns_slow );
        if(fabs(p_pns)>max_pns) max_pns=fabs(p_pns);
    }      
       
    return max_pns;
}

float intercept_rfov(float y1, float y2, int xl, int x)
{
    return (y2-y1)/xl*x+y1;
}

void print_corner_point_rfov(int nump, int * tcon, float * aconx, float * acony)
{
    FILE * fp;
    int i;

    if ((fp=fopen("rfov_dbdt_corner.log","w")) == NULL) return;

    fprintf(fp, "phase and slice waveform:\n");
    fprintf(fp, "dbdtinf %f dbdtfactor %d efflength %f\n", cfrinf, cfrfact,
            FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz));
    fprintf(fp, "all %d\n", nump);

    for (i = 0; i < nump; i++)
    {
        fprintf(fp, "%d %f %f 0.0\n", tcon[i], aconx[i], acony[i]);
    }

    fclose(fp);
}

void print_dbdtper_rfov(float the_dbdtper, int nump, int * tcon,
                        float * dbdtper_x, float * dbdtper_y, float * dbdtper_t)
{
    FILE * fp;
    int i;

    if ((fp=fopen("rfov_dbdt.log","w")) == NULL) return;

    fprintf(fp, "convolution model dbdtper waveform:\n");
    fprintf(fp, "dbdtper= %f\n", the_dbdtper);

    for (i = 0; i < nump; i++)
    {
        fprintf(fp, "%d %f %f %f\n", tcon[i], dbdtper_x[i], dbdtper_y[i], dbdtper_t[i]);
    }

    fclose(fp);
}

float get_fa_scaling_factor_rfov(float * max_fa, float act_fa, float nom_fa, float nom_max_b1)
{
    double max_b1_limit, cur_b1_limit, act_b1;
    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;
    INT i;

    if (act_fa <= 0.0 || nom_fa <= 0.0 || nom_max_b1 <= 0.0)
    {
        *max_fa = 180.0;
        return 1.0;
    }

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils);
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);

    /* handle cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);

        if (cur_b1_limit < max_b1_limit)
        {
            max_b1_limit = cur_b1_limit;
        }
    }

    max_b1_limit = max_b1_limit/100; /* uT to Gauss conversion */

    *max_fa = (float)floor(max_b1_limit*nom_fa/nom_max_b1);
    if(*max_fa > 180.0) *max_fa = 180.0;

    act_b1 = nom_max_b1*act_fa/nom_fa;

    if (act_b1 <= max_b1_limit)
    {
        return 1.0;
    }

    return (float)(max_b1_limit/act_b1);
}

/* SVBranch HCSDM00155611 For walk sat:
   Executed in calcPulseParams() in predownload();
   Scale the walk-sat rf with updated a_rfwk; */
void walk_sat_scaleRF(void)
{        
    ia_rfwk  = _ia_rfwk.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFWK_SLOT].amp)), ia_rfwk) : max_pg_iamp*(*rfpulse[RFWK_SLOT].amp);
}



/*************************************************/

STATUS Multiband_cvinit(void)
{
    if ( (PSD_ON == exist(opdiffuse)) || ( (exist(oppseq) == PSD_GE) && (PSD_ON == exist(opepi)) ) || ( (exist(oppseq) == PSD_GE) && (PSD_ON == exist(opsilent)) ) )
    {
        cvmax(opmb, PSD_ON);
    } else {
        opmb  = _opmb.fixedflag ?  ((void)(PSD_OFF), opmb) : PSD_OFF;
    }

    if(PSD_ON == exist(opmb))
    {
        mux_flag  = _mux_flag.fixedflag ?  ((void)(PSD_ON), mux_flag) : PSD_ON;
    }
    else
    {
        mux_flag  = _mux_flag.fixedflag ?  ((void)(PSD_OFF), mux_flag) : PSD_OFF;
    }

    if(mux_flag && (oparc)){
        arc_extCal  = _arc_extCal.fixedflag ?  ((void)(1), arc_extCal) : 1;
        arc_ph_intaccel  = _arc_ph_intaccel.fixedflag ?  ((void)(1), arc_ph_intaccel) : 1;
        asset_factor  = _asset_factor.fixedflag ?  ((void)(arc_ph_factor), asset_factor) : arc_ph_factor;
    }
    else{
        arc_extCal  = _arc_extCal.fixedflag ?  ((void)(0), arc_extCal) : 0;
        arc_ph_intaccel  = _arc_ph_intaccel.fixedflag ?  ((void)(0), arc_ph_intaccel) : 0;
        asset_factor  = _asset_factor.fixedflag ?  ((void)(exist(opaccel_ph_stride)), asset_factor) : exist(opaccel_ph_stride);
    }

    pw_rf1  = _pw_rf1.fixedflag ?  ((void)(5000), pw_rf1) : 5000;
    tbwp_rf1  = _tbwp_rf1.fixedflag ?  ((void)(1.0), tbwp_rf1) : 1.0;
    window_type_rf1  = _window_type_rf1.fixedflag ?  ((void)(2), window_type_rf1) : 2;
    gauss_width_rf1  = _gauss_width_rf1.fixedflag ?  ((void)(1.0), gauss_width_rf1) : 1.0;

    if( mux_flag && (cfaccel_ph_maxstride * cfaccel_sl_maxstride > 1) )
    {
        piaccelscrn = PSD_ON;
        cvmin(opaccel_mb_stride, 2);
        avminaccel_mb_stride = 2;
        pimb = PSD_ON;
        piaccel_mbedit = 0;

        if ( PSD_ON == exist(opdiffuse) ) 
        {
            if ( isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)
                 &&  ((cfrecvend - cfrecvst + 1) >= 32) )  
            {
                /* support up to factor of 3 acceleration for diffusion in research mode or if using >=32 channel coils */
                avmaxaccel_mb_stride = 3;
                piaccel_mbnub = 3;
                piaccel_mbval2 = 2;
                piaccel_mbval3 = 3;
                cvmax(opaccel_mb_stride, 3);
                cvdef(opaccel_mb_stride, 2);
            } else {
                /* only support factor of 2 acceleration in clinical mode for diffusion */
                avmaxaccel_mb_stride = 2;
                piaccel_mbnub = 2;
                piaccel_mbval2 = 2;
                cvmax(opaccel_mb_stride, 2);
                cvdef(opaccel_mb_stride, 2);
            }
        }

        if ( (exist(oppseq) == PSD_GE) )
        {
            if ( PSD_ON == opresearch )
            {
                /* support up to factor of 8 acceleration in research mode for fMRI with any coil */
                avmaxaccel_mb_stride = 8;
                piaccel_mbnub = 6;
                piaccel_mbval2 = 2;
                piaccel_mbval3 = 3;
                piaccel_mbval4 = 4;
                piaccel_mbval5 = 6;
                piaccel_mbval6 = 8;
                cvmax(opaccel_mb_stride, 8);
                cvdef(opaccel_mb_stride, 2);
            } else if ( (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)
                  &&  ((cfrecvend - cfrecvst + 1) >= 32)) )
            {
                /* support up to factor of 3 acceleration for fMRI if using >=32 channel coils */
                avmaxaccel_mb_stride = 3;
                piaccel_mbnub = 3;
                piaccel_mbval2 = 2;
                piaccel_mbval3 = 3;
                cvmax(opaccel_mb_stride, 3);
                cvdef(opaccel_mb_stride, 2);
            } else {
                /* only support factor of 2 acceleration in clinical mode for fMRI */
                avmaxaccel_mb_stride = 2;
                piaccel_mbnub = 2;
                piaccel_mbval2 = 2;
                cvmax(opaccel_mb_stride, 2);
                cvdef(opaccel_mb_stride, 2);
            }
        }
        
        if(existcv(opaccel_mb_stride))
        {
            /* If user specified value, display it */
            piaccel_mb_stride = opaccel_mb_stride;
        }
        else
        {
            /* Otherwise default to 2 */
            cvoverride(opaccel_mb_stride, 2, PSD_FIX_ON, PSD_EXIST_ON);
            piaccel_mb_stride = opaccel_mb_stride;
        }

        mux_slices_rf1  = _mux_slices_rf1.fixedflag ?  ((void)(exist(opaccel_mb_stride)), mux_slices_rf1) : exist(opaccel_mb_stride);
        mux_slices_rf2  = _mux_slices_rf2.fixedflag ?  ((void)(exist(opaccel_mb_stride)), mux_slices_rf2) : exist(opaccel_mb_stride);

        use_slice_fov_shift_blips  = _use_slice_fov_shift_blips.fixedflag ?  ((void)(1), use_slice_fov_shift_blips) : 1;

        mux_slice_shift_mm_rf1  = _mux_slice_shift_mm_rf1.fixedflag ?  ((void)((float)mux_slquant*(exist(opslthick)+exist(opslspace))), mux_slice_shift_mm_rf1) : (float)mux_slquant*(exist(opslthick)+exist(opslspace));
    }
    else
    {
        pimb = PSD_OFF;
        avmaxaccel_mb_stride = 1;
        avminaccel_mb_stride = 1;
        piaccel_mbedit = 1;
        piaccel_mbnub = 0;
        piaccel_mbval2 = 1;
        piaccel_mbval3 = 1;
        piaccel_mb_stride = 1;
        if(PSD_OFF == exist(opasset) && PSD_OFF == exist(oparc)){
            piaccelscrn = PSD_OFF;
        }
        use_slice_fov_shift_blips  = _use_slice_fov_shift_blips.fixedflag ?  ((void)(0), use_slice_fov_shift_blips) : 0;
        slice_fov_shift  = _slice_fov_shift.fixedflag ?  ((void)(1), slice_fov_shift) : 1;
        mux_slices_rf1  = _mux_slices_rf1.fixedflag ?  ((void)(1), mux_slices_rf1) : 1;
        mux_slices_rf2  = _mux_slices_rf2.fixedflag ?  ((void)(1), mux_slices_rf2) : 1;
        mux_slquant  = _mux_slquant.fixedflag ?  ((void)(exist(opslquant)), mux_slquant) : exist(opslquant);
    }

    return SUCCESS;
}

/**********************************************/
STATUS Multiband_cveval(int revert_rf1)
{
    char supfailfmt[] = "Support routine %s failed.";
    int mux_mode_rf1=1;

    mux_rf2_scale  = _mux_rf2_scale.fixedflag ?  ((void)((B0_30000==cffield)?1.12:1.0), mux_rf2_scale) : (B0_30000==cffield)?1.12:1.0; /* equivalent to TGenh = -10 */

    if (mux_flag)
    {
        Multiband_cvinit();
        /* multiband -- calculate mux'ed number of slices */
        /* round up */
        mux_slquant  = _mux_slquant.fixedflag ?   ((void)(CEIL_DIV(opslquant,mux_slices_rf1)), mux_slquant) : CEIL_DIV(opslquant,mux_slices_rf1);

#ifdef EPI2_FLAG 
        mux_slquant  = _mux_slquant.fixedflag ?  ((void)((mux_slquant%2)?mux_slquant:(mux_slquant+1)), mux_slquant) : (mux_slquant%2)?mux_slquant:(mux_slquant+1);
#endif

        if (mux_slices_rf1&1) {
           mux_phase_step  = _mux_phase_step.fixedflag ?  ((void)(0), mux_phase_step) : 0;
        } else {
           mux_phase_step  = _mux_phase_step.fixedflag ?  ((void)(-PI/mux_slices_rf1), mux_phase_step) : -PI/mux_slices_rf1;
        }

        if ( ((exist(oppseq) == PSD_SE && exist(opdiffuse) == PSD_ON)) || ((exist(oppseq) == PSD_GE) && PSD_ON == exist(opepi)) )
        {
            if ( (exist(oppseq) == PSD_SE) || (exist(opflip)>30) ) 
            {
                flip_rf1  = _flip_rf1.fixedflag ?  ((void)(90.0), flip_rf1) : 90.0;
            } else {
                flip_rf1  = _flip_rf1.fixedflag ?  ((void)(30.0), flip_rf1) : 30.0;
            }
            rftype  = _rftype.fixedflag ?  ((void)(PSD_OFF), rftype) : PSD_OFF;
            hrf1a  = _hrf1a.fixedflag ?  ((void)(pw_rf1/2), hrf1a) : pw_rf1/2;
            hrf1b  = _hrf1b.fixedflag ?  ((void)(pw_rf1/2), hrf1b) : pw_rf1/2;
            res_rf1  = _res_rf1.fixedflag ?     ((void)(pw_rf1/2), res_rf1) : pw_rf1/2;
            mux_slice_shift_mm_rf1  = _mux_slice_shift_mm_rf1.fixedflag ?  ((void)((float)mux_slquant*(exist(opslthick)+exist(opslspace))), mux_slice_shift_mm_rf1) : (float)mux_slquant*(exist(opslthick)+exist(opslspace));
            mux_slices_rf1  = _mux_slices_rf1.fixedflag ?  ((void)((INT)exist(opaccel_mb_stride)), mux_slices_rf1) : (INT)exist(opaccel_mb_stride);

            /* calculate the RF pulse to use */
            thk_rf1       = _thk_rf1.fixedflag ?  ((void)(exist(opslthick)), thk_rf1) : exist(opslthick);

            /* Full windowed sinc RF pulse */
            res_rf1       = _res_rf1.fixedflag ?   ((void)(pw_rf1/dwell_rf_rf1), res_rf1) : pw_rf1/dwell_rf_rf1;
            if (fabs(tbwp_rf1) > 0.45) {
                bw_rf1        = _bw_rf1.fixedflag ?       ((void)(4*1e6*tbwp_rf1/pw_rf1), bw_rf1) : 4*1e6*tbwp_rf1/pw_rf1;   /* Check this */
            } else {
                bw_rf1        = _bw_rf1.fixedflag ?     ((void)(2*1e6/pw_rf1), bw_rf1) : 2*1e6/pw_rf1; /* Mostly from window function...  Check this */
            }

            /* Implemented single spin echo SSGR for Multiband */
            if (revert_rf1)    mux_mode_rf1 = -1;
            else    mux_mode_rf1 = 1;

            if ( (res_rf1                != save_res_rf1) ||
                (!floatsAlmostEqualEpsilons(tbwp_rf1, save_tbwp_rf1, 2)) ||
                (window_type_rf1        != save_window_type_rf1) ||
                (!floatsAlmostEqualEpsilons(gauss_width_rf1, save_gauss_width_rf1, 2)) ||
                (!floatsAlmostEqualEpsilons(thk_rf1, save_thk_rf1, 2)) ||
                (!floatsAlmostEqualEpsilons(mux_slice_shift_mm_rf1, save_mux_slice_shift_mm_rf1, 2)) ||
                (mux_slices_rf1         != save_mux_slices_rf1) ||
                (mux_mode_rf1           != save_mux_mode_rf1) )

            {

                /* Generate the single slice waveform */
                winsinc(runtime_rf_waveform_rf1, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                        1, mux_slice_shift_mm_rf1, thk_rf1, 0, mux_mode_rf1);
                /* Load up indices 0 through 8 in waveforms a...i */
                winsinc(runtime_rf_waveform_rf1a, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                        mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 0, mux_mode_rf1);
                if (mux_slices_rf1>1) {
                    winsinc(runtime_rf_waveform_rf1b, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 1, mux_mode_rf1);
                }
                if (mux_slices_rf1>2) {
                    winsinc(runtime_rf_waveform_rf1c, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 2, mux_mode_rf1);
                }
                if (mux_slices_rf1>3) {
                    winsinc(runtime_rf_waveform_rf1d, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 3, mux_mode_rf1);
                }
                if (mux_slices_rf1>4) {
                    winsinc(runtime_rf_waveform_rf1e, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 4, mux_mode_rf1);
                }
                if (mux_slices_rf1>5) {
                    winsinc(runtime_rf_waveform_rf1f, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 5, mux_mode_rf1);
                }
                if (mux_slices_rf1>6) {
                    winsinc(runtime_rf_waveform_rf1g, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 6, mux_mode_rf1);
                }
                if (mux_slices_rf1>7) {
                    winsinc(runtime_rf_waveform_rf1h, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 7, mux_mode_rf1);
                }
                if (mux_slices_rf1>8) {
                    winsinc(runtime_rf_waveform_rf1i, res_rf1, tbwp_rf1, window_type_rf1, gauss_width_rf1,
                            mux_slices_rf1, mux_slice_shift_mm_rf1, thk_rf1, 8, mux_mode_rf1);
                }

                save_res_rf1                  = _save_res_rf1.fixedflag ?  ((void)(res_rf1), save_res_rf1) : res_rf1;
                save_tbwp_rf1                 = _save_tbwp_rf1.fixedflag ?  ((void)(tbwp_rf1), save_tbwp_rf1) : tbwp_rf1;
                save_window_type_rf1          = _save_window_type_rf1.fixedflag ?  ((void)(window_type_rf1), save_window_type_rf1) : window_type_rf1;
                save_gauss_width_rf1          = _save_gauss_width_rf1.fixedflag ?  ((void)(gauss_width_rf1), save_gauss_width_rf1) : gauss_width_rf1;
                save_mux_slices_rf1           = _save_mux_slices_rf1.fixedflag ?  ((void)(mux_slices_rf1), save_mux_slices_rf1) : mux_slices_rf1;
                save_mux_slice_shift_mm_rf1   = _save_mux_slice_shift_mm_rf1.fixedflag ?  ((void)(mux_slice_shift_mm_rf1), save_mux_slice_shift_mm_rf1) : mux_slice_shift_mm_rf1;
                save_thk_rf1                  = _save_thk_rf1.fixedflag ?  ((void)(thk_rf1), save_thk_rf1) : thk_rf1;
                save_mux_mode_rf1             = _save_mux_mode_rf1.fixedflag ?  ((void)(mux_mode_rf1), save_mux_mode_rf1) : mux_mode_rf1;

            }
            pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
            if (ampslice(_a_gzrf1.fixedflag ? (_temp27_a_gzrf1=a_gzrf1,&_temp27_a_gzrf1) : &a_gzrf1,   bw_rf1, (float)thk_rf1, (float)gscale_rf1,
                         (int)TYPDEF) == FAILURE) return FAILURE;
            if (optramp(_pw_gzrf1a.fixedflag ? (_temp28_pw_gzrf1a=pw_gzrf1a,&_temp28_pw_gzrf1a) : &pw_gzrf1a, a_gzrf1, loggrd.tz_xyz, loggrd.zrt, TYPDEF) == FAILURE) return FAILURE;
            pw_gzrf1d  = _pw_gzrf1d.fixedflag ?  ((void)(pw_gzrf1a), pw_gzrf1d) : pw_gzrf1a;

            /* copy to frequency modulation waveform */
            pw_thetarf1   = _pw_thetarf1.fixedflag ?  ((void)(pw_gzrf1), pw_thetarf1) : pw_gzrf1;

            /* fill in the rfpulse[] structure */
            setuprfpulse_mux(runtime_rf_waveform_rf1, _res_rf1.fixedflag ? (_temp29_res_rf1=res_rf1,&_temp29_res_rf1) : &res_rf1, _flip_rf1.fixedflag ? (_temp30_flip_rf1=flip_rf1,&_temp30_flip_rf1) : &flip_rf1, _pw_rf1.fixedflag ? (_temp31_pw_rf1=pw_rf1,&_temp31_pw_rf1) : &pw_rf1, bw_rf1, rfExIso,
                             GAM, RF1_SLOT, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, _a_rf1.fixedflag ? (_temp32_a_rf1=a_rf1,&_temp32_a_rf1) : &a_rf1);

            /* We will have to scale up the fields by the number of mux slices or mux_slices^2 */
            if (mux_slices_rf1 > 1) {
                rfpulse[RF1_SLOT].effwidth/= mux_slices_rf1;
                rfpulse[RF1_SLOT].area/= mux_slices_rf1;
                rfpulse[RF1_SLOT].max_b1 *= mux_slices_rf1;
                rfpulse[RF1_SLOT].max_rms_b1 *= sqrt((float)mux_slices_rf1);
                rfpulse[RF1_SLOT].max_int_b1_sq *= mux_slices_rf1;
            }
  
            if (exist(oppseq) == PSD_SE)
            {
                mux_slices_rf2  = _mux_slices_rf2.fixedflag ?  ((void)((INT)exist(opaccel_mb_stride)), mux_slices_rf2) : (INT)exist(opaccel_mb_stride);

                /*setup rf2 pulse*/
                switch (mux_slices_rf2) {
                    case 3: /* Three band VERSEd Spin Echo Pulse */
                        res_rf2       = _res_rf2.fixedflag ?  ((void)(PSD_VERSE_MB3_RF2_R), res_rf2) : PSD_VERSE_MB3_RF2_R;
                        pw_rf2        = _pw_rf2.fixedflag ?      ((void)(res_rf2*2), pw_rf2) : res_rf2*2;
                        res_gzrf2     = _res_gzrf2.fixedflag ?  ((void)(PSD_VERSE_MB3_GZRF2_R), res_gzrf2) : PSD_VERSE_MB3_GZRF2_R;
                        pw_gzrf2      = _pw_gzrf2.fixedflag ?      ((void)(res_gzrf2*4), pw_gzrf2) : res_gzrf2*4;
                        res_thetarf2  = _res_thetarf2.fixedflag ?  ((void)(res_gzrf2), res_thetarf2) : res_gzrf2;
                        pw_thetarf2   = _pw_thetarf2.fixedflag ?  ((void)(pw_gzrf2), pw_thetarf2) : pw_gzrf2;

                        setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp33_pw_rf2=pw_rf2,&_temp33_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp34_a_rf2=a_rf2,&_temp34_a_rf2) : &a_rf2, SAR_ABS_VERSE_MB3, SAR_EFF_VERSE_MB3,
                                SAR_AREA_VERSE_MB3, SAR_DTC_VERSE_MB3, SAR_MAXPW_VERSE_MB3, 1,
                                MAX_B1_VERSE_MB3, MAX_INT_B1_SQ_VERSE_MB3,
                                MAX_RMS_B1_VERSE_MB3, NOM_FA_VERSE_MB3*mux_rf2_scale, _flip_rf2.fixedflag ? (_temp35_flip_rf2=flip_rf2,&_temp35_flip_rf2) : &flip_rf2, NOM_PW_VERSE_MB3,
                                NOM_BW_VERSE_MB3, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                                PSD_VERSE_MB3_RF2_R, 1.0, _res_rf2.fixedflag ? (_temp36_res_rf2=res_rf2,&_temp36_res_rf2) : &res_rf2, 1, _wg_rf2.fixedflag ? (_temp37_wg_rf2=wg_rf2,&_temp37_wg_rf2) : &wg_rf2, 1, rfpulse);
                        if (debug_mux_rf)
                        {
                            printf("MB: mux_slices_rf2=%d, MAX_B1=%f, MAX_INT_B1_SQ=%f\n", mux_slices_rf2, (float)MAX_B1_VERSE_MB3, (float)MAX_INT_B1_SQ_VERSE_MB3);
                        }
                        verse_rf2  = _verse_rf2.fixedflag ?  ((void)(1), verse_rf2) : 1;
                        mux_min_verserf2_slthk  = _mux_min_verserf2_slthk.fixedflag ?  ((void)(VERSERF2_BASE_SLICE_THICK*MAX_HB3_VERSERF2_SR/(save_gmax/save_ramptime*1.0E4)), mux_min_verserf2_slthk) : VERSERF2_BASE_SLICE_THICK*MAX_HB3_VERSERF2_SR/(save_gmax/save_ramptime*1.0E4);
                        break;

                    case 2:
                        res_rf2       = _res_rf2.fixedflag ?  ((void)(PSD_VERSE_MB2_RF2_R), res_rf2) : PSD_VERSE_MB2_RF2_R;
                        pw_rf2        = _pw_rf2.fixedflag ?      ((void)(res_rf2*2), pw_rf2) : res_rf2*2;
                        res_gzrf2     = _res_gzrf2.fixedflag ?  ((void)(PSD_VERSE_MB2_GZRF2_R), res_gzrf2) : PSD_VERSE_MB2_GZRF2_R;
                        pw_gzrf2      = _pw_gzrf2.fixedflag ?      ((void)(res_gzrf2*4), pw_gzrf2) : res_gzrf2*4;
                        res_thetarf2  = _res_thetarf2.fixedflag ?  ((void)(res_gzrf2), res_thetarf2) : res_gzrf2;
                        pw_thetarf2   = _pw_thetarf2.fixedflag ?  ((void)(pw_gzrf2), pw_thetarf2) : pw_gzrf2;

                        setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp38_pw_rf2=pw_rf2,&_temp38_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp39_a_rf2=a_rf2,&_temp39_a_rf2) : &a_rf2, SAR_ABS_VERSE_MB2, SAR_EFF_VERSE_MB2,
                                SAR_AREA_VERSE_MB2, SAR_DTC_VERSE_MB2, SAR_MAXPW_VERSE_MB2, 1,
                                MAX_B1_VERSE_MB2, MAX_INT_B1_SQ_VERSE_MB2,
                                MAX_RMS_B1_VERSE_MB2, NOM_FA_VERSE_MB2*mux_rf2_scale, _flip_rf2.fixedflag ? (_temp40_flip_rf2=flip_rf2,&_temp40_flip_rf2) : &flip_rf2, NOM_PW_VERSE_MB2,
                                NOM_BW_VERSE_MB2, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                                PSD_VERSE_MB2_RF2_R, 1.0, _res_rf2.fixedflag ? (_temp41_res_rf2=res_rf2,&_temp41_res_rf2) : &res_rf2, 1, _wg_rf2.fixedflag ? (_temp42_wg_rf2=wg_rf2,&_temp42_wg_rf2) : &wg_rf2, 1, rfpulse);
                        if (debug_mux_rf)
                        {
                            printf("MB: mux_slices_rf2=%d, MAX_B1=%f, MAX_INT_B1_SQ=%f\n", mux_slices_rf2, (float)MAX_B1_VERSE_MB2, (float)MAX_INT_B1_SQ_VERSE_MB2);
                        }
                        verse_rf2  = _verse_rf2.fixedflag ?  ((void)(1), verse_rf2) : 1;
                        mux_min_verserf2_slthk  = _mux_min_verserf2_slthk.fixedflag ?  ((void)(VERSERF2_BASE_SLICE_THICK*MAX_HB2_VERSERF2_SR/(save_gmax/save_ramptime*1.0E4)), mux_min_verserf2_slthk) : VERSERF2_BASE_SLICE_THICK*MAX_HB2_VERSERF2_SR/(save_gmax/save_ramptime*1.0E4);
                        break;

                    default: /* Single band VERSEd Spin Echo Pulse */
                        res_rf2       = _res_rf2.fixedflag ?  ((void)(PSD_VERSE_MB1_RF2_R), res_rf2) : PSD_VERSE_MB1_RF2_R;
                        pw_rf2        = _pw_rf2.fixedflag ?      ((void)(res_rf2*2), pw_rf2) : res_rf2*2;
                        res_gzrf2     = _res_gzrf2.fixedflag ?  ((void)(0), res_gzrf2) : 0;
                        res_thetarf2  = _res_thetarf2.fixedflag ?  ((void)(0), res_thetarf2) : 0;
                        pw_gzrf2      = _pw_gzrf2.fixedflag ?  ((void)(pw_rf2), pw_gzrf2) : pw_rf2;

                        setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp43_pw_rf2=pw_rf2,&_temp43_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp44_a_rf2=a_rf2,&_temp44_a_rf2) : &a_rf2, SAR_ABS_VERSE_MB1, SAR_EFF_VERSE_MB1,
                                SAR_AREA_VERSE_MB1, SAR_DTC_VERSE_MB1, SAR_MAXPW_VERSE_MB1, 1,
                                MAX_B1_VERSE_MB1, MAX_INT_B1_SQ_VERSE_MB1,
                                MAX_RMS_B1_VERSE_MB1, NOM_FA_VERSE_MB1, _flip_rf2.fixedflag ? (_temp45_flip_rf2=flip_rf2,&_temp45_flip_rf2) : &flip_rf2, NOM_PW_VERSE_MB1,
                                NOM_BW_VERSE_MB1, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                                PSD_VERSE_MB1_RF2_R, 1.0, _res_rf2.fixedflag ? (_temp46_res_rf2=res_rf2,&_temp46_res_rf2) : &res_rf2, 1, _wg_rf2.fixedflag ? (_temp47_wg_rf2=wg_rf2,&_temp47_wg_rf2) : &wg_rf2, 1, rfpulse);
                        verse_rf2  = _verse_rf2.fixedflag ?  ((void)(0), verse_rf2) : 0; /* Generate a trapezoid slice gradient */
                        break;
                }

                /* We will have to scale up the fields by the number of mux slices or mux_slices^2 */
                if (mux_slices_rf2 > 1) {
                    rfpulse[RF2_SLOT].effwidth/= mux_slices_rf2;
                    rfpulse[RF2_SLOT].area/= mux_slices_rf2;
                    rfpulse[RF2_SLOT].max_b1 *= mux_slices_rf2;
                    rfpulse[RF2_SLOT].max_rms_b1 *= sqrt((float)mux_slices_rf2);
                    rfpulse[RF2_SLOT].max_int_b1_sq *= mux_slices_rf2;
                }

                mux_min_verserf2_slthk  = _mux_min_verserf2_slthk.fixedflag ?  ((void)(ceil(mux_min_verserf2_slthk*10.0)/10.0), mux_min_verserf2_slthk) : ceil(mux_min_verserf2_slthk*10.0)/10.0;

                gscale_rf2    = _gscale_rf2.fixedflag ?  ((void)(1.0), gscale_rf2) : 1.0;
                hrf2b        = _hrf2b.fixedflag ?     ((void)(rfpulse[RF2_SLOT].isodelay*pw_rf2/rfpulse[RF2_SLOT].nom_pw), hrf2b) : rfpulse[RF2_SLOT].isodelay*pw_rf2/rfpulse[RF2_SLOT].nom_pw;
                hrf2a        = _hrf2a.fixedflag ?    ((void)(pw_rf2-hrf2b), hrf2a) : pw_rf2-hrf2b;
                flip_rf2     = _flip_rf2.fixedflag ?  ((void)(180.0), flip_rf2) : 180.0;
                rfpulse[RF2_SLOT].exciter = _wg_rf2.fixedflag ? (_temp48_wg_rf2=wg_rf2,&_temp48_wg_rf2) : &wg_rf2;

                /* Now scale down flip angle if neccessary*/

                if (multiband_fa_scaling_flag && (PSD_XRMB_COIL == cfgcoiltype || PSD_XRMW_COIL == cfgcoiltype || isRioSystem()))
                {
                    float fa_scaling_factor, fa_scaling_factor_rf1, fa_scaling_factor_rf2;
                    fa_scaling_factor_rf1 = get_fa_scaling_factor_multiband(_max_multiband_rf1_fa.fixedflag ? (_temp49_max_multiband_rf1_fa=max_multiband_rf1_fa,&_temp49_max_multiband_rf1_fa) : &max_multiband_rf1_fa, flip_rf1,
                                                                            rfpulse[RF1_SLOT].nom_fa,
                                                                            rfpulse[RF1_SLOT].max_b1,
                                                                            1);
                    fa_scaling_factor_rf2 = get_fa_scaling_factor_multiband(_max_multiband_rf2_fa.fixedflag ? (_temp50_max_multiband_rf2_fa=max_multiband_rf2_fa,&_temp50_max_multiband_rf2_fa) : &max_multiband_rf2_fa, flip_rf2,
                                                                            rfpulse[RF2_SLOT].nom_fa,
                                                                            rfpulse[RF2_SLOT].max_b1,
                                                                            1);
                    fa_scaling_factor = (fa_scaling_factor_rf2 < fa_scaling_factor_rf1)? fa_scaling_factor_rf2:fa_scaling_factor_rf1;
                    if (debug_mux_rf)
                    {
                        printf("MB: fa_scaling_factor=%f, fa_scaling_factor_rf1=%f, fa_scaling_factor_rf2=%f\n", fa_scaling_factor, fa_scaling_factor_rf1, fa_scaling_factor_rf2);
                    }
                    flip_rf1  = _flip_rf1.fixedflag ?  ((void)(floor(flip_rf1*fa_scaling_factor)), flip_rf1) : floor(flip_rf1*fa_scaling_factor);
                    flip_rf2  = _flip_rf2.fixedflag ?  ((void)(floor(flip_rf2*fa_scaling_factor)), flip_rf2) : floor(flip_rf2*fa_scaling_factor);
                }

                a_rf1     = _a_rf1.fixedflag ?  ((void)(flip_rf1/180), a_rf1) : flip_rf1/180;
                a_rf2     = _a_rf2.fixedflag ?  ((void)(flip_rf2/180), a_rf2) : flip_rf2/180;
                if (debug_mux_rf)
                {
                    printf("MB: flip_rf1=%f, flip_rf2=%f, a_rf1=%f, a_rf2=%f\n", flip_rf1, flip_rf2, a_rf1, a_rf2);
                }
            }
        }
        else
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "Multiband_cveval" );
            return FAILURE;
        }

    }
    else
    {
        mux_slquant  = _mux_slquant.fixedflag ?  ((void)(exist(opslquant)), mux_slquant) : exist(opslquant);
        save_res_rf1                  = _save_res_rf1.fixedflag ?  ((void)(0), save_res_rf1) : 0;
        save_tbwp_rf1                 = _save_tbwp_rf1.fixedflag ?  ((void)(0.0), save_tbwp_rf1) : 0.0;
        save_window_type_rf1          = _save_window_type_rf1.fixedflag ?  ((void)(0), save_window_type_rf1) : 0;
        save_gauss_width_rf1          = _save_gauss_width_rf1.fixedflag ?  ((void)(0.0), save_gauss_width_rf1) : 0.0;
        save_mux_slices_rf1           = _save_mux_slices_rf1.fixedflag ?  ((void)(0), save_mux_slices_rf1) : 0;
        save_mux_slice_shift_mm_rf1   = _save_mux_slice_shift_mm_rf1.fixedflag ?  ((void)(0.0), save_mux_slice_shift_mm_rf1) : 0.0;
        save_thk_rf1                  = _save_thk_rf1.fixedflag ?  ((void)(0.0), save_thk_rf1) : 0.0;
        save_mux_mode_rf1             = _save_mux_mode_rf1.fixedflag ?  ((void)(0), save_mux_mode_rf1) : 0;
    }
    return SUCCESS;
}

void winsinc(int *rtrf, int points, float tbp, int wtype, float gwidth,
             int mux_slices, float mux_slice_shift_mm, float thk, int mux_index, int mux_mode) {
    float  x;
    float  window, rfenvelope, mux_modulation;
    int count,indz;

    if (debug_mux_rf)
    {
        printf("Windowed Sinc generation code arguments:\n");
        printf("                points = %d\n",points);
        printf("time bandwidth product = %g\n",tbp);
        printf("           window type = %d\n",wtype);
        printf("              mux_mode = %d\n",mux_mode);
        if (wtype == 5) {
            printf("        Gaussian Width = %d\n",points);
        }
    }


    if ( points ==1 ) { /* just a hard pulse */
        x = 0.0;
        rfenvelope = 1.0;
        window = 1.0;
        rtrf[0] = MAX_PG_WAMP;
        count = 0;
    } else {
        for  (count=0; count < points; count++) {
            x = 2.0*count/(points-1)-1.0;

            if (mux_slices & 1) { /* Odd number has a central slice */
                mux_modulation = 1;
            } else {/* Even number has no central slice */
                mux_modulation = 0;
            }
            /* Do pairs of mux_slices to maintain Hermitian conjugate symmetry */
            for (indz=0; indz<(mux_slices/2); indz++){
                mux_modulation += 2*cos(2.0*PI*tbp*x*mux_slice_shift_mm/thk* 2 * (1+indz-0.5*((mux_slices+1)&1))  
                                        + mux_mode * (2.0 * PI * mux_index * (indz+1-0.5*((mux_slices+1)&1)))/ mux_slices);
            }

            mux_modulation/= mux_slices;

            if (fabs(2.0*PI*tbp*x) > 1e-6) {
                rfenvelope = sin(2.0*PI*tbp* x)/ (2.0*PI*tbp*x);
            } else {
                rfenvelope = 1.0;
            }
            switch (wtype) {
                case 1: /* Hamming */
                    window = 0.54 + 0.46*cos(PI*x);
                    break;
                case 2: /* Hanning */
                    window = (1.0 + cos(PI*x))*0.5;
                    break;
                case 3: /* Blackman */
                    window = 0.42 + 0.5*cos(PI*x) + 0.08*cos(2*PI*x);
                    break;
                case 4: /* Bartlett */
                    if (x < 0.0) {
                        window = x + 1.0;
                    } else {
                        window = 1.0 - x;
                    }
                    break;
                case 5: /* Gauss */
                    window = exp(-(x*x)/(gwidth*gwidth));
                    break;
                default: /* No window on Sinc */
                    window = 1.0;
                    break;
            }
            rtrf[count] = 2*floor(MAX_PG_WAMP*rfenvelope*mux_modulation*window/2.0+0.5);
        }
    }

}


/* fill in the rfpulse[] structure */
void setuprfpulse_mux(int *rtwave, int *wfres, float *wfflip, int *wfpw, float wfbw, float iso,
            float gam, int rfslotnum,unsigned int wfactivity, float *ampl){

    float standard_pw = 1e-3;
    float standard_fa = 180.0; /* not used */
    float standard_B1; /* Gauss */

    float nRFenvelope;
    int indx;
    float amax          = 0.0;
    float area          = 0.0;
    float abswidth      = 0.0;
    float effwidth      = 0.0;
    float dtycyc        = 0.0;
    float max_pw        = 0.0;
    float max_b1        = 0.0;
    float max_int_b1_sq = 0.0;
    float max_rms_b1    = 0.0;

    mux_rf1_scale  = _mux_rf1_scale.fixedflag ?  ((void)((B0_30000==cffield)?1.12:1.0), mux_rf1_scale) : (B0_30000==cffield)?1.12:1.0; /* equivalent to TGenh = -10 */

    standard_B1 = standard_fa/360.0/(gam*standard_pw);

    for (indx=0; indx< *wfres; indx++) {
        nRFenvelope = (float) rtwave[indx]/ MAX_PG_WAMP;
        area += nRFenvelope;
        abswidth += fabs(nRFenvelope);
        effwidth += (nRFenvelope*nRFenvelope);
        if (fabs(nRFenvelope)> amax) amax = fabs(nRFenvelope);
    }

    if(!floatsAlmostEqualEpsilons(amax, 0.0, 2))
    {
        for (indx=0; indx< *wfres; indx++) {
            nRFenvelope = (float) rtwave[indx]/ MAX_PG_WAMP/ amax; /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by floatsAlmostEqualEpsilons comparison " */
            if (fabs(nRFenvelope) > 0.2236) dtycyc +=1;
        }
    }

    area/= (float)(*wfres);
    abswidth/= (float)(*wfres);
    effwidth/= (float)(*wfres);
    dtycyc/= (float)(*wfres);

    max_pw = 1.0; /* have not actually calculated this */
    if(!floatsAlmostEqualEpsilons(area, 0.0, 2))
    {
        max_b1 = *wfflip/360.0/(area*(*wfpw)*1e-6)/gam; /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by floatsAlmostEqualEpsilons comparison " */ /* Max B1 if waveform amplitude is MAX_PG_WAMP */
    }
    else
    {
        max_b1 = *wfflip/360.0/(2.0*FLT_EPSILON*(*wfpw)*1e-6)/gam;
    }
    max_int_b1_sq = max_b1 * max_b1 * effwidth * (*wfpw) * 1e-6/ standard_pw;
    max_rms_b1 = sqrt(max_int_b1_sq/((*wfpw)*1e-6)*standard_pw);

    rfpulse[rfslotnum].pw             =  wfpw;     /* this is a pointer */
    rfpulse[rfslotnum].amp            =  ampl;     /* rfscale will write to this pointer */
    rfpulse[rfslotnum].abswidth       =  abswidth;
    rfpulse[rfslotnum].effwidth       =  effwidth;
    rfpulse[rfslotnum].area           =  area;
    rfpulse[rfslotnum].dtycyc         =  dtycyc;
    rfpulse[rfslotnum].maxpw          =  max_pw;
    rfpulse[rfslotnum].max_b1         =  max_b1;
    rfpulse[rfslotnum].max_int_b1_sq  =  max_int_b1_sq;
    rfpulse[rfslotnum].max_rms_b1     =  max_rms_b1;
    rfpulse[rfslotnum].nom_fa         = *wfflip*mux_rf1_scale;   /* nom_fa and act_fa are equal */
    rfpulse[rfslotnum].act_fa         =  wfflip;   /* this is a pointer */
    rfpulse[rfslotnum].nom_pw         = *wfpw;
    rfpulse[rfslotnum].nom_bw         =  wfbw;
    rfpulse[rfslotnum].activity       =  wfactivity;
    rfpulse[rfslotnum].reference      =  0;
    rfpulse[rfslotnum].isodelay       =  iso;
    rfpulse[rfslotnum].scale          =  1.0;      /* I don't usually see this */
    rfpulse[rfslotnum].res            =  wfres;    /* this is a pointer */
    rfpulse[rfslotnum].extgradfile    =  0;
#ifdef EPI2_FLAG /*  Stretch pw_rf1 for EPI as needed for HyperBand */
    rfpulse[rfslotnum].extgradfile    =  1;        /* Don't allow pulse stretching */
#endif
    rfpulse[rfslotnum].apply_as_hadamard_factor  =  1;    /* Hadamard Factor to be applied */

    if (debug_mux_rf)
    {
        printf("STANDARD RF pulse\n");
        printf("standard_B1 = %g Gauss\n",standard_B1);
        printf("standard_pw = %g us\n",1e6*standard_pw);
        printf("standard_fa = %g degrees\n",standard_fa);
        printf("\n");
        printf("RF Pulse structure for RFSLOT=%d\n",rfslotnum);
        printf("*rfpulse[%d].pw            = %d\n", rfslotnum, *rfpulse[rfslotnum].pw );
        printf("*rfpulse[%d].amp           = %g\n", rfslotnum, *rfpulse[rfslotnum].amp );
        printf(" rfpulse[%d].abswidth      = %g\n", rfslotnum,  rfpulse[rfslotnum].abswidth );
        printf(" rfpulse[%d].effwidth      = %g\n", rfslotnum,  rfpulse[rfslotnum].effwidth );
        printf(" rfpulse[%d].area          = %g\n", rfslotnum,  rfpulse[rfslotnum].area );
        printf(" rfpulse[%d].dtycyc        = %g\n", rfslotnum,  rfpulse[rfslotnum].dtycyc );
        printf(" rfpulse[%d].num           = %d\n", rfslotnum,  rfpulse[rfslotnum].num );
        printf(" rfpulse[%d].maxpw         = %g\n", rfslotnum,  rfpulse[rfslotnum].maxpw );
        printf(" rfpulse[%d].max_b1        = %g\n", rfslotnum,  rfpulse[rfslotnum].max_b1 );
        printf(" rfpulse[%d].max_int_b1_sq = %g\n", rfslotnum,  rfpulse[rfslotnum].max_int_b1_sq );
        printf(" rfpulse[%d].max_rms_b1    = %g\n", rfslotnum,  rfpulse[rfslotnum].max_rms_b1 );
        printf(" rfpulse[%d].nom_fa        = %g\n", rfslotnum,  rfpulse[rfslotnum].nom_fa );
        printf("*rfpulse[%d].act_fa        = %g\n", rfslotnum, *rfpulse[rfslotnum].act_fa );
        printf(" rfpulse[%d].nom_pw        = %g\n", rfslotnum,  rfpulse[rfslotnum].nom_pw );
        printf(" rfpulse[%d].nom_bw        = %g\n", rfslotnum,  rfpulse[rfslotnum].nom_bw );
        printf(" rfpulse[%d].activity      = %d\n", rfslotnum,  rfpulse[rfslotnum].activity );
        printf(" rfpulse[%d].reference     = %d\n", rfslotnum,  rfpulse[rfslotnum].reference );
        printf(" rfpulse[%d].isodelay      = %d\n", rfslotnum,  rfpulse[rfslotnum].isodelay );
        printf(" rfpulse[%d].scale         = %g\n", rfslotnum,  rfpulse[rfslotnum].scale );
        printf("*rfpulse[%d].res           = %d\n", rfslotnum, *rfpulse[rfslotnum].res );
        printf(" rfpulse[%d].extgradfile   = %d\n", rfslotnum,  rfpulse[rfslotnum].extgradfile );
        printf(" rfpulse[%d].apply_as_hadamard_factor  = %d\n", rfslotnum,  rfpulse[rfslotnum].apply_as_hadamard_factor );
        fflush(stdout);
    }

}

float get_fa_scaling_factor_multiband(float * max_fa, float act_fa, float nom_fa, float nom_max_b1, int mux_factor)
{
    double max_b1_limit, cur_b1_limit, act_b1;
    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;
    INT i;

    if (act_fa <= 0.0 || nom_fa <= 0.0 || nom_max_b1 <= 0.0)
    {
        *max_fa = 180.0 * mux_factor;
        return 1.0;
    }

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils);
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);
    cur_b1_limit = 0.0;

    /* handle cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);

        if (cur_b1_limit < max_b1_limit)
        {
            max_b1_limit = cur_b1_limit;
        }
    }

    max_b1_limit = max_b1_limit/100; /* uT to Gauss conversion */

    *max_fa = (float)floor(max_b1_limit*nom_fa/nom_max_b1);
    if(*max_fa > 180.0 * mux_factor) *max_fa = 180.0*mux_factor;

    act_b1 = nom_max_b1*act_fa/nom_fa;

    if (debug_mux_rf)
    {
        printf("MB: cur_b1_limit = %lf, max_b1_limit = %lf, nom_max_b1 = %f, act_b1 = %lf, act_fa=%f, nom_fa=%f, max_fa=%f\n", cur_b1_limit, max_b1_limit, nom_max_b1, act_b1, act_fa, nom_fa, *max_fa);
    }

    if (act_b1 <= max_b1_limit)
    {
        return 1.0;
    }
    return (float)(max_b1_limit/act_b1);
}

/*************************************************/

/*softkey checks*/
int dwepi_status = PSD_OFF;
int flairepi_status = PSD_OFF;
int edwi_status = PSD_OFF;
int bodynav_status = PSD_OFF;
int focus_status = PSD_OFF;
int multiband_status = PSD_OFF;
int apx_status = PSD_OFF;
int syndwi_status = PSD_OFF;
int superG_key_status = PSD_OFF;
int distcorr_status = PSD_OFF;
int muse_status = PSD_OFF;
int maxtensor_status = PSD_OFF;

int save_newgeo;
/* needed for Inversion.e */
FILTER_INFO scan_filt;         /* parameters for xres=256 filter */
FILTER_INFO echo1_filt;         /* Used by epi.e */

/* Array to hold max B1 for each entry point. */
float maxB1[MAX_ENTRY_POINTS], maxB1Seq;
int   entry, pulse;           /* loop counters */

int   crusher_type;             /* Vrg or non vrg type define */
float crusher_scale[NECHO_MAX];  /* reserve space for crusher scale factors*/

int av_temp_int;                 /* temp placement for advisory panel return values */
float av_temp_float;             /* temp placement for advisory panel return values */

OPT_GRAD_INPUT gradin;     /* gradient input paramters */
OPT_GRAD_PARAMS gradout;   /* gradient output paramters for optimal grads */

/* HCSDM00361682 */
int avmaxslquant_hist[MAX_FOCUS_EVAL_WATCH] = {0,0,0,0};
int acqs_hist[MAX_FOCUS_EVAL_WATCH] = {0,0,0,0};
int tmin_hist[MAX_FOCUS_EVAL_WATCH] = {0,0,0,0};

static const char supfailfmt[] = "Support routine %s failed.";

int old_weighted_avg_grad = -1;
float old_avg_bval = -1.0;
int old_num_dirs = -1;
int old_opdifnumt2 = -1;
int old_dualspinecho_flag = -1;
int old_diff_order_flag = -1;
int old_opdfax3in1 = -1;

int cur_num_iters;
int xamp_iters[MAX_NUM_ITERS];
int yamp_iters[MAX_NUM_ITERS];
int zamp_iters[MAX_NUM_ITERS];

int ss_rf1_compatible = PSD_ON;
int opfat_on_UI = PSD_OFF;

/* MGD inlines */

/* Function Delcaration */
STATUS checkEpi2ImageOptions( void );

/* Function Body */
STATUS
checkEpi2ImageOptions( void )
{
    int cardcv;                   /* Cardiac Gating Flag */

    /* Sequence Type Check - SE and GRE Only */
    if ( (exist(oppseq) != 1) && (exist(oppseq) != 2) ) { /* lockout IR,SSFP,SPGR,TOF,PC,TOFSP,PCSP */
	epic_error( use_ermes, "The EPI option is not supported in this scan", EM_PSD_EPI_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* No 3D yet */
    if (exist(opimode) == PSD_3D) {
	epic_error( use_ermes, "EPI is not compatible with the 3D Image Mode.  Please select 2D", EM_PSD_EPI_VOLUME_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* No Spectro-EPI Yet */
    if (exist(opimode) == PSD_SPECTRO) {
	epic_error( use_ermes, "Spectroscopy prescription failed.", EM_PSD_SPECTRO_FAILURE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* No CINE EPI */
    if ((exist(opimode) == PSD_CINE) && existcv(opimode)) {
        epic_error( use_ermes, "Cine is not available with this PSD", EM_PSD_CINE_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    
    /* POMP is not supported with EPI */
    if ((exist(oppomp) == PSD_ON) && existcv(oppomp)) {
        epic_error( use_ermes, "The POMP option is not supported in this scan.", EM_PSD_POMP_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    
    /* Tailored RF is only for FSE-based scans */  
    if (exist(optlrdrf) == PSD_ON) {
	epic_error( use_ermes, "The Tailored RF option is not supported in this scan.", EM_PSD_TLRDRF_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* Resp. Comp Check */
    if (exist(opexor) == PSD_ON) {
	epic_error( use_ermes, "Respiratory Compensation and EPI and incompatible features.", EM_PSD_EPI_RESP_COMP_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* Driven Equilibrium Prep not Supported */
    if (exist(opdeprep) == PSD_ON) {
	epic_error( use_ermes, "The DE Prep Option is not available with this pulse sequence.", EM_PSD_OPDEPREP_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
    
    /* No Mag. Transfer */
    if (exist(opmt)==PSD_ON && existcv(opmt)==PSD_ON) {
        epic_error( use_ermes, "MT not Supported", EM_PSD_MT_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }    
    
    /* IR Prep is not used with epi2 */
    if ((exist(opirprep) == PSD_ON) && (irprep_support == PSD_OFF)) {
        epic_error( use_ermes, "The IR Prep Option is not available with this pulse sequence.", EM_PSD_OPIRPREP_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }
    
    /* Can't use a graphic ROI */
    if ((exist(opgrxroi) == PSD_ON) && existcv(opgrxroi)) {
        epic_error( use_ermes, "The Graphic ROI Option is not available with this sequence.", EM_PSD_OPGRXROI_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    /* YMSmr07221, YMSmr07315 */
    if (existcv(opptsize) && (exist(opptsize) > 2) && (edr_support == PSD_OFF)) {
        epic_error(use_ermes,"EDR is not supported in this PSD.",EM_PSD_EDR_INCOMPATIBLE,0);
        return FAILURE;
    }

    /* EPI and SSFSE are not compatible */
    if (exist(opepi)==PSD_ON && exist(opssfse)==PSD_ON){
	epic_error( use_ermes, "EPI is incompatible with the Single-Shot button. Please use # of Shots = 1 for SS-EPI.", EM_PSD_EPI_SSFSE_INCOMPATIBLE, EE_ARGS(0) );
	return FAILURE;
    }
       
    /* Lock out diffusion wuth other sequence types */
    if((opdiffuse==PSD_ON) && (oppseq!=PSD_SE)) {
	epic_error( use_ermes, "Spin Echo Must Be Selected With Diffusion", EM_PSD_EPI_SEDIFFUSE, EE_ARGS(0) );
	return FAILURE;
    } 
  
    if((opdiffuse==PSD_ON)&&(oppseq==PSD_GE)) {
        epic_error( use_ermes, "Gradient Echo Not Compatible With Diffusion", EM_PSD_EPI_GEDIFFUSE, EE_ARGS(0) );
        return FAILURE;
    } 

    if((opdiffuse==PSD_ON)&&(opfcomp==PSD_ON)) {
        epic_error( use_ermes, "Flow Comp Not Compatible With Diffusion", EM_PSD_EPI_FCOMPDIFFUSE, EE_ARGS(0) );
        return FAILURE;
    }

    /* Multiphase-Diffusion is not compatible */
    if ((opmph == PSD_ON) && (opdiffuse == PSD_ON)) {
        epic_error( use_ermes, "Multi Phase not supported with diffusion", EM_PSD_EPI_MULTIPHASEDIFFUSE, EE_ARGS(0) );
        return FAILURE;
    } 

    /* MRIge51451 - Square pixel is not compatible with EZDWI. PH */
    if ( (existcv(opsquare)) && (exist(opsquare) == PSD_ON) && (EZflag == PSD_ON) ) {
        epic_error( use_ermes, "The square pixel option is not supported.", EM_PSD_SQUARE_INCOMPATIBLE, 0 );
        return FAILURE;
    }

#ifdef UNDEF
    /* MRIge57060 - lock out IIC w/ Flair or DWI */
    if( (exist(opscic) == PSD_ON) && ( (exist(opdiffuse)==PSD_ON) || (exist(opflair)==PSD_ON)) ) {
        epic_error(use_ermes,"This prescription is not allowed", EM_PSD_INVALID_RX, 0);
        return FAILURE;
    }
#endif /* UNDEF */

    /* The FAST option is not supported */
    if(opfast==PSD_ON) {
        epic_error( use_ermes, "Fast Option Not Compatible With This Pulse Sequence", EM_PSD_FAST_NOT_SUPPORTED, EE_ARGS(0) );
        return FAILURE;
    } 

    /* MRIge53672 - Make Concat SAT and multiphase EPI incompatible */
    if ( (PSD_ON == mph_flag) && (PSD_ON == exist(opccsat)) ) {
        epic_error( use_ermes, "%s is incompatible with %s ", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Concat SAT", STRING_ARG, "multiphase EPI" );
        return FAILURE;
    }
    
    /* No rect. FOV */
    if (exist(oprect) == PSD_ON) {
	epic_error( use_ermes, "Rectangular FOV is not allowed with this scan.", EM_PSD_RECT_NOT_SUPPORTED, EE_ARGS(0) );
	return FAILURE; 
    }

    /* More than 1.0 of No Phase Wrap is not supported */
    if( (exist(opnpwfactor) > 1.0) && existcv(opnpwfactor) )                                   
    {
        epic_error(use_ermes, "%s is incompatible with %s ",
                   EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "More than 1.0 of No Phase Wrap",
                   STRING_ARG, "this pulse sequence");
        return FAILURE;
    }
 
    /* Caridac Gating Checks */
    cardcv = (exist(opcgate) && existcv(ophrate) && existcv(ophrep) 
              && existcv(opphases) && existcv(opcardseq) && existcv(optdel1)
              && existcv(oparr));
    
    /* MRIge65081 */
    if (exist(opcgate)) {

        if ((exist(opslquant) > avmaxslquant) && existcv(opslquant)) {
            epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxslquant );
            return ADVISORY_FAILURE;
        }
    }

    if (!exist(opcgate)) {
        if ((opautotr == 0) && (exist(optr) < avmintr) && existcv(optr) &&
            !((PSD_ON == exist(opinrangetr)) && ((PSD_OFF == existcv(opslquant)) || (PSD_AUTO_TR_MODE_ADVANCED_IN_RANGE_TR == piautotrmode)))) {
            epic_error( use_ermes, "The selected TR needs to be increased to %d ms for the current prescription.", EM_PSD_TR_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintr/1000) );
            return ADVISORY_FAILURE;
        }
        
        if ((opautotr == 0) && (exist(optr) > avmaxtr) && existcv(optr) &&
            !((PSD_ON == exist(opinrangetr)) && ((PSD_OFF == existcv(opslquant)) || (PSD_AUTO_TR_MODE_ADVANCED_IN_RANGE_TR == piautotrmode)))) {
            epic_error( use_ermes, "The selected TR needs to be decreased to %d ms for the current prescription.", EM_PSD_TR_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG,(avmaxtr/1000) );
            return ADVISORY_FAILURE;
        }
    } else {
   
        if ((piait < avmintseq) && (existcv(optdel1))) {
                epic_error( use_ermes, "The available imaging time is insufficient. Decrease the trigger window or the trigger delay.", EM_PSD_AIT_OUT_OF_RANGE, EE_ARGS(0) );
                return FAILURE;
        }
                
        if ((existcv(optdel1))&& ((exist(optdel1) < avmintdel1) || (exist(optdel1) > 1600000))) {
            epic_error( use_ermes, "The trigger delay must be between %d ms and 1600 ms for the current prescription.", EM_PSD_TD_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintdel1/1000) );
            return FAILURE;
        }
    }
    
    if (cardcv) {

        if (exist(opphases) > avmaxphases) {
            epic_error( use_ermes, "Maximum number of phases exceeded, reduce # of slices or phases", EM_PSD_MAXPHASE_EXCEEDED, EE_ARGS(1), INT_ARG, avmaxphases );
            return FAILURE;
        }

        if ((psd_tseq < avmintseq) && (existcv(opfov)) && (existcv(opcardseq))) {
            epic_error( use_ermes, "The inter-sequence delay must be increased to %d ms due to the FOV/ slice thickness selected.", EM_PSD_TSEQ_FOV_OUT_OF_RANGE, EE_ARGS(1), INT_ARG,(avmintseq/1000) );
            return FAILURE;
        }
        
        if ((psd_tseq < avmintseq) && (existcv(opcardseq))) {
            epic_error( use_ermes, "The inter-sequence delay must be increased to %d ms.", EM_PSD_TSEQ_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintseq/1000) );
            return FAILURE;
        }

        if (seq_type == TYPMPMP) {
            if((exist(opslquant) > 1) && (opphases != opslquant) && (opphases != 2*opslquant) && (opphases != 3* opslquant) )
            {
                epic_error( use_ermes, "The number of phases divided by locations must equal 1, 2, or 3.", EM_PSD_SLCPHA_INCOMPATIBLE, EE_ARGS(0) );
                return FAILURE;
            }
            
            if (exist(opphases)*exist(opslquant)*dwi_fphases > DATA_ACQ_MAX) {
                epic_error( use_ermes, "The number of locations * phases has exceeded %d.", EM_PSD_SLCPHA_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, DATA_ACQ_MAX );
                return FAILURE;
            }
        }
    }

    if ((exist(oprtcgate) == PSD_ON) || (navtrig_flag == PSD_ON))
    {
        if ((pirtait < avminrttseq) && (existcv(oprtarr)))  /* MRIge63264/MRIge63355 */
        {
            epic_error(use_ermes,
                       "The available imaging time is insufficient. Decrease the trigger window",
                        EM_PSD_AIT_OUT_OF_RANGE2,EE_ARGS(0));
            return FAILURE;
        }
    }    

    if (existcv(oprtarr) &&((exist(oprtarr) > MAX_RESP_WINDOW) || (exist(oprtarr) < MIN_RESP_WINDOW))) {
        epic_error(use_ermes, "The range for the trigger window is %d to %d",
                   EM_PSD_RESPTRIG_WINDOW_RANGE,EE_ARGS(2),INT_ARG,MIN_RESP_WINDOW, INT_ARG,MAX_RESP_WINDOW);
        return FAILURE;
    }

    if (existcv(oprtpoint)&&((exist(oprtpoint) > MAX_RESP_POINT) || (exist(oprtpoint) < MIN_RESP_POINT))) {
        epic_error(use_ermes, "The range for the trigger point is %d to %d",
                   EM_PSD_RESPTRIG_POINT_RANGE,EE_ARGS(2),INT_ARG,MIN_RESP_POINT,INT_ARG,MAX_RESP_POINT);
        return FAILURE;
    }

    if (existcv(oprtcardseq)&& (exist(oprtcardseq) == PSD_CARD_INTER_OTHER) && (exist(oprttseq) < avminrttseq)) {
        epic_error(use_ermes, "The inter-sequence delay must be increased to %dms",
                   EM_PSD_RESPTRIG_MIN_INTERSEQ,EE_ARGS(1),INT_ARG,(avminrttseq/1000));
        return FAILURE;

    }

    if (((exist(opcgate) == PSD_ON) && existcv(opcgate)) &&
        ((exist(oprtcgate) == PSD_ON) && existcv(oprtcgate))) {
        epic_error(use_ermes, "Respiratory triggering and gating are not compatible",
                   EM_PSD_GATING_RESPTRIG_INCOMPATIBLE,0);
        return FAILURE;
    }

    if ((exist(opileave) == PSD_ON) && (exist(oprtcgate) == PSD_ON)) {
        epic_error(use_ermes,
                   "The interleave option and respiratory triggering cannot be selected at the same time.",
                   EM_PSD_ILEAV_RESPTRIG_INCOMPATIBLE, EE_ARGS(0));
        return FAILURE;
    }

    if ((exist(opileave) == PSD_ON) && (navtrig_flag == PSD_ON)) {
        epic_error(use_ermes,"%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The interleave option", STRING_ARG, "Navigator");
        return FAILURE;
    }

    if((exist(opirmode) == PSD_ON) && (exist(oprtcgate) == PSD_ON)) {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Sequential", STRING_ARG, "Respiratory Triggering");
        return FAILURE; 
    }

    if((exist(opirmode) == PSD_ON) && (navtrig_flag == PSD_ON)) {
        epic_error(use_ermes,"%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Sequential", STRING_ARG, "Navigator");
        return FAILURE; 
    }

    if ( isValueSystem() || isK15TSystem() )
    {
        if ((exist(oprtcgate) == PSD_ON) &&
             existcv(oprtrate) && existcv(oprtrep) && existcv(oprtarr)) {
            if ((exist(opslquant) > avmaxslquant) && existcv(opslquant)) {
                epic_error(use_ermes,"Maximum slice quantity is %-d",
                           EM_PSD_SLQUANT_OUT_OF_RANGE,EE_ARGS(1),INT_ARG,avmaxslquant);
                return ADVISORY_FAILURE;
            }
        }

        if ((navtrig_flag == PSD_ON) &&
             existcv(oprtrate) && existcv(oprtrep) && existcv(oprtarr)) {
            if ((exist(opslquant) > avmaxslquant) && existcv(opslquant)) {
                epic_error(use_ermes,"Maximum slice quantity is %-d",
                           EM_PSD_SLQUANT_OUT_OF_RANGE,EE_ARGS(1),INT_ARG,avmaxslquant);
                return FAILURE;
            }
        }
    }

    if ((exist(opileave) == PSD_ON) && (exist(opcgate) == PSD_ON)) {
        epic_error(use_ermes,
                   "The interleave option and cardiac gating cannot be selected at the same time.",
                   EM_PSD_ILEAV_CGAT_INCOMPATIBLE, EE_ARGS(0));
        return FAILURE;
    }

    /* MRIhc07638/MRIhc07639 - Merge of fix from Value 1.5T for SPRs
    YMSmr06637/YMSmr06638 - Removed the check for the existence
    setting for the epi_flair flag */
    /* MRIge51503 - Gating is not compatible with DWI or flair. */
    /* MRIge57057 - Gating is available for DW-EPI in 84 */
    if ( (exist(opcgate) == PSD_ON) && (epi_flair == PSD_ON) )
    {
        epic_error( use_ermes, "Cardiac Gating is not supported by this pulse sequence.", EM_PSD_GATING_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    if ( (exist(oprtcgate) == PSD_ON) && (epi_flair == PSD_ON) )
    {
        epic_error( use_ermes, "Respiratory triggering is not supported by this pulse sequence.", EM_PSD_RESPTRIG_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    if ( (navtrig_flag == PSD_ON) && (epi_flair == PSD_ON) )
    {
        epic_error(use_ermes,"%s is incompatible with %s.",
                   EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Navigator", STRING_ARG, "FLAIR");
        return FAILURE;
    }

    /* YMSmr09726 */
    if( exist(opasset) && (val15_lock == PSD_ON) ){
        if(!strcmp( coilInfo[0].coilName, "GE_HDx 8NVARRAY_A")){
            epic_error( use_ermes, "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, 2,
                            STRING_ARG, "EPI ASSET",
                            STRING_ARG, "8NVARRAY_A");
            return FAILURE;
        } else if(!strcmp( coilInfo[0].coilName, "GE_HDx 8NVANGIO_A")){ 
            epic_error( use_ermes, "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, 2,
                            STRING_ARG, "EPI ASSET",
                            STRING_ARG, "8NVANGIO_A");
            return FAILURE;
        }
    }

    /* HCSDM00150820 */
    if (NON_SELECTIVE == exist(opexcitemode))
    {
        epic_error( use_ermes, "%s excitation is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Non-selective", STRING_ARG, "EPI" );
        return FAILURE;
    }

    /* Focus diffusion not compatible with ASSET */
    if (rfov_flag && (exist(opasset) > PSD_OFF))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Focus", STRING_ARG, "ASSET" );
        return FAILURE;
    }

    /* Focus diffusion not compatible with FLAIR */
    if (rfov_flag && (exist(opflair) == PSD_ON))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Focus", STRING_ARG, "FLAIR" );
        return FAILURE;
    }

    /* Focus diffusion not compatible with gradient moment nulling */
    if (rfov_flag && (exist(opfcomp) ==  PSD_ON))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Focus", STRING_ARG, "Flow Compensation" );
        return FAILURE;
    }

    return SUCCESS;

}   /* end checkEpi2ImageOptions() */

STATUS epiCalFileCVInit(void);
STATUS epiCalFileCVCheck(void);

STATUS epiCalFileCVInit(void) {

    FILE *fp;
    const char *infile1="b0_dither.cal";
    const char *infile2="delay.dat";
    const char *infile3="delay.esp";
    const char *infile4="b0vectors.dat";

    const char *path="/usr/g/caldir/";
    char basefile1[80], basefile2[80], basefile3[80], basefile4[80];
 
    /* Check for the existence of the epi calibration files */
    strcpy(basefile1, path);
    strcat(basefile1, infile1);
    strcpy(basefile2, path);
    strcat(basefile2, infile2);
    strcpy(basefile3, path);
    strcat(basefile3, infile3);
    strcpy(basefile4, path);
    strcat(basefile4, infile4);
    
    /* Determine which coil is being used */
    switch(getTxCoilType()) {
        case TX_COIL_LOCAL:
            strcat(basefile1, ".head");
            strcat(basefile3, "h.xyz");
            strcat(basefile4, ".head");
            break;
        case TX_COIL_BODY:
        default:
            strcat(basefile1, ".body");
            strcat(basefile3, "b.xyz");
            strcat(basefile4, ".body");
            break;
    }
    

    /* Open the b0_dither.cal file */
    if ((fp=fopen(basefile1, "r")) ==NULL) {
        nob0dither = _nob0dither.fixedflag ? ((void)(1), nob0dither) : 1;
    } else {
        fclose(fp);
    }

    /* Open the delay.dat file */
    if ((fp=fopen(basefile2, "r")) ==NULL) {
        nodelay = _nodelay.fixedflag ? ((void)(1), nodelay) : 1;
    } else {
        fclose(fp);
    }

    /* Open the delay.esp.xyz file */
    if ((fp=fopen(basefile3, "r")) ==NULL) {
        nodelayesp = _nodelayesp.fixedflag ? ((void)(1), nodelayesp) : 1;
    } else {
        fclose(fp);
    }

    /* Open the b0vectors.dat file */
    if ((fp=fopen(basefile4, "r")) ==NULL) {
        nob0dither_interpo = _nob0dither_interpo.fixedflag ? ((void)(1), nob0dither_interpo) : 1;
    } else {
        fclose(fp);
    }

    return SUCCESS;
    
} /* end epiCalFileCheck */

 
STATUS epiCalFileCVCheck (void) {

    char calfiles[2560];
    char bccalfiles[2560];       
    char bcfile[80], bcfile2[80];
    const char *bcpath="/usr/g/caldir/";
    int recvnum;		
    FILE *fpbc;

    if (PSDDVMR == psd_board_type)
    {
        /* DVMR does not require B0 dither.  Do not warn user if
         * calibration files are not present */
        nob0dither  = _nob0dither.fixedflag ?  ((void)(0), nob0dither) : 0;
        nob0dither_interpo  = _nob0dither_interpo.fixedflag ?  ((void)(0), nob0dither_interpo) : 0;
        if (30000 == cffield)
	{
	    nodelayesp  = _nodelayesp.fixedflag ?  ((void)(0), nodelayesp) : 0;
	}
    }

    /* epi cal files */
    if (((nodelay==1) || (nob0dither==1 && b0dither_new==0) ||
         (nodelayesp==1) || (nob0dither_interpo==1 && b0dither_new==1)
        ) && (exist(opepi)==PSD_ON) ) {
        strcpy(calfiles, "/usr/g/caldir/");
        if (nodelay==1)
            strcat(calfiles, " delay.dat");
        if (nob0dither==1 && b0dither_new==0) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " b0_dither.cal.head");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " b0_dither.cal.body");
                    break;
            }
        }
        if (nodelayesp==1) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " delay.esph.xyz");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " delay.espb.xyz");
                    break;
            }
        }
        if (nob0dither_interpo==1 && b0dither_new==1) {
            /* strcat filename based on which coil is being used */
            switch(getTxCoilType()) {
                case TX_COIL_LOCAL:
                    strcat(calfiles, " b0vectors.dat.head");
                    break;
                case TX_COIL_BODY:
                default:
                    strcat(calfiles, " b0vectors.dat.body");
                    break;
            }
        }

#ifndef SIM
        epic_warning( "The following files were not found: %s. "
                      "Using default values.", calfiles );
#endif

        nob0dither  = _nob0dither.fixedflag ?  ((void)(0), nob0dither) : 0;
        nodelay  = _nodelay.fixedflag ?  ((void)(0), nodelay) : 0;
        nodelayesp  = _nodelayesp.fixedflag ?  ((void)(0), nodelayesp) : 0;
        nob0dither_interpo  = _nob0dither_interpo.fixedflag ?  ((void)(0), nob0dither_interpo) : 0;  
        _nob0dither.fixedflag = 1;
        _nodelay.fixedflag = 1;
        _nodelayesp.fixedflag = 1;
        _nob0dither_interpo.fixedflag = 1;
    }

    strcpy(bccalfiles, "/usr/g/caldir/");

    nobcfile  = _nobcfile.fixedflag ?  ((void)(0), nobcfile) : 0;
    for( recvnum = (cfrecvst + 1); recvnum < (cfrecvend + 2); recvnum++ ) {
        sprintf(bcfile,"%sbcrvs%d.dat", bcpath, recvnum);
        if ((fpbc=fopen(bcfile, "r")) ==NULL) {
            nobcfile  = _nobcfile.fixedflag ?    ((void)(nobcfile+1), nobcfile) : nobcfile+1;
            sprintf(bcfile2,"bcrvs%d.dat ", recvnum);
            strcat(bccalfiles, bcfile2);  
        } else {
            fclose(fpbc);
        }
    }        
    number_of_bc_files  = _number_of_bc_files.fixedflag ?        ((void)(cfrecvend-cfrecvst-nobcfile+1), number_of_bc_files) : cfrecvend-cfrecvst-nobcfile+1;
    if(activeReceivers !=  (cfrecvend - cfrecvst + 1)) {
        activeReceivers  = _activeReceivers.fixedflag ?       ((void)((cfrecvend-cfrecvst+1)), activeReceivers) : (cfrecvend-cfrecvst+1); 
        flagWarning  = _flagWarning.fixedflag ?  ((void)(TRUE), flagWarning) : TRUE;
    }


    if ( (cfrecvend - cfrecvst + 1 > number_of_bc_files) && (exist(opepi)==PSD_ON) ) {
    
#ifndef SIM
 
        if((flagWarning == TRUE) && (value_system_flag == NON_VALUE_SYSTEM) && (PSDDVMR != psd_board_type)) {
            epic_warning( "The following files were not found: %s. "
                          "Please have Field Service run bandpass cals.", bccalfiles );
            flagWarning  = _flagWarning.fixedflag ?  ((void)(FALSE), flagWarning) : FALSE;  /* only display error once */
        }

#endif

    }
  
    return SUCCESS;

}

/* MGD: needed for filter changes */
#include "rfsspsummary.h"

/* Structure definitions for prescan filters*/
FILTER_INFO echo1as_filt;
FILTER_INFO echo1mps1_filt;
FILTER_INFO echo1ftg_filt;
FILTER_INFO echo1xtg_filt;
FILTER_INFO echo1cfl;
FILTER_INFO echo1cfh;
FILTER_INFO echo1rcvn;
FILTER_INFO echo1rs_filt;
FILTER_INFO echo1dtg_filt;
FILTER_INFO echo1cal_filt;
FILTER_INFO echo1coil_filt;

/* defines for pimrsaps CVs from op_prescan.h */
#ifndef PSC_MAX_CONTROL_ARRAY
#define PSC_MAX_CONTROL_ARRAY 15
#endif

#define COILLOG_LOG_MAXSIZE 262144 /* quarter-Meg */

int* pimrs[PSC_MAX_CONTROL_ARRAY];

/* YMSmr09211 04/26/2006 YI */
SCAN_INFO rcvnscan_info[1];
SCAN_INFO cfh_info[MAX_PSC_VQUANT];
SCAN_INFO ps1scan_info[PRESCAN_ROT_MAX];
SCAN_INFO rsscan_info[RFSHIM_SLQ];
SCAN_INFO maptgscan_info[MAPTG_SLQ];




#define DBDTMODELRECT 0
#define DBDTMODELCONV 1
#define DBDT_STEPSIZE 2
#define DBDT_MAXNUMSTEPS 25
#define DBDT_ETL 2 /* 2 is sufficient for calculating dbdtper using convolution model */
#define XAXIS 0x0001
#define YAXIS 0x0002
#define ZAXIS 0x0004
#define MAXNUMESPRANGE 5
#define MAXCHAR 150

int dbdtper_count = 0;
int total_gradopt_count = 0;
int each_gradopt_count = 0;

int no_esprangefile = 0;
int esp_crc_check_passed = 0;

int numesprange_x = 0;
int esprange_x[MAXNUMESPRANGE][2];
float espamp_x[MAXNUMESPRANGE];
int numesprange_y = 0;
int esprange_y[MAXNUMESPRANGE][2];
float espamp_y[MAXNUMESPRANGE];
int numesprange_z = 0;
int esprange_z[MAXNUMESPRANGE][2];
float espamp_z[MAXNUMESPRANGE];

int epigradopt_debug_old = -1;
int reopt_flag = PSD_ON;
int dbdt_model_old = -1;
float cfdbdtper_old = -1;
int esprange_check_old = -1;
int espamp_check_old = -1;
int espopt_old = -1;
int espincway_old = -1;
int opmph_old = -1;
int rampopt_old = -1;
int max_dbdtper_hb_zblips_old = -1;
long rsprot_old[9] = {0,0,0,0,0,0,0,0,0};
OPT_GRAD_INPUT gradin_old = {-1, -1};


/* For enabling more than 1024 im/ser -Venkat */
int enable_1024 = 0; 
int max_slice_limit = DATA_ACQ_MAX;

#include <psdiopt.h>
int sequence_iopts[] = {
    PSD_IOPT_ARC,
    PSD_IOPT_CARD_GATE,
    PSD_IOPT_FLOW_COMP,
    PSD_IOPT_SEQUENTIAL,
    PSD_IOPT_MPH,
    PSD_IOPT_SQR_PIX,
    PSD_IOPT_ASSET,
    PSD_IOPT_DYNPL,
    PSD_IOPT_MILDNOTE,
    PSD_IOPT_IR_PREP,
    PSD_IOPT_RESP_TRIG,
    PSD_IOPT_NAV,
    PSD_IOPT_EDR,
    PSD_IOPT_MULTIBAND,
    PSD_IOPT_CLASSIC
};

typedef enum feature_bits {
    DWI_E,
    FLAIR_E
} feature_bit_e;

#define DWI (long)(1 << DWI_E)
#define FLAIR (long)(1 << FLAIR_E)

long feature_flag = 0;

void
psd_init_iopts( void )
{
    int numopts = sizeof(sequence_iopts)/ sizeof(int);

    psd_init_iopt_activity();

    activate_iopt_list( numopts, sequence_iopts );
    enable_iopt_list( numopts, sequence_iopts );

    set_incompatible( PSD_IOPT_CARD_GATE, PSD_IOPT_MPH );
    set_incompatible( PSD_IOPT_CARD_GATE, PSD_IOPT_DYNPL );
    set_incompatible( PSD_IOPT_MPH, PSD_IOPT_DYNPL );
    set_incompatible( PSD_IOPT_CARD_GATE, PSD_IOPT_RESP_TRIG );
    set_incompatible( PSD_IOPT_SEQUENTIAL, PSD_IOPT_RESP_TRIG );
    set_incompatible( PSD_IOPT_DYNPL, PSD_IOPT_RESP_TRIG );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_CARD_GATE );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_DYNPL );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_MPH );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_RESP_TRIG );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_SEQUENTIAL );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_MILDNOTE );
    set_incompatible( PSD_IOPT_ASSET, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_IR_PREP, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_CARD_GATE, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_RESP_TRIG, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_NAV, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_FLOW_COMP, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_SQR_PIX, PSD_IOPT_MULTIBAND );
    set_incompatible( PSD_IOPT_SEQUENTIAL, PSD_IOPT_MULTIBAND );
    return;
}

STATUS
cvsetfeatures( void )
{
    feature_flag = 0;

    if( (exist(opdiffuse) == PSD_ON) && existcv(opdiffuse) )
    {
        feature_flag |= DWI;
    }

    if( (exist(opflair) == PSD_ON) && existcv(opflair) )
    {
        feature_flag |= FLAIR;
    }

    return SUCCESS;
}

STATUS
cvfeatureiopts( void )
{
    psd_init_iopts();

    if( feature_flag & DWI )
    {
        set_disallowed_option( PSD_IOPT_FLOW_COMP );

        if(tensor_flag == PSD_ON)
        {
            set_disallowed_option( PSD_IOPT_DYNPL );
            set_disallowed_option( PSD_IOPT_RESP_TRIG );
            set_disallowed_option( PSD_IOPT_IR_PREP );
            set_disallowed_option( PSD_IOPT_NAV );
        }

        /* HCSDM00150820 */
        if(rfov_flag)
        {
            set_disallowed_option( PSD_IOPT_ASSET );
            set_disallowed_option( PSD_IOPT_MULTIBAND );
        }

        /* HCSDM00445759 */
        if(opmuse)
        {
            set_required_disabled_option( PSD_IOPT_ASSET );
            set_disallowed_option( PSD_IOPT_MULTIBAND );
            set_disallowed_option( PSD_IOPT_IR_PREP);
        }

        if(exist(opmb))
        {
            set_required_disabled_option( PSD_IOPT_ARC );
            set_required_disabled_option( PSD_IOPT_CLASSIC ); /* always use this to help on FatSat for Multiband*/
        }
        else
        {
            set_disallowed_option( PSD_IOPT_ARC );
            enable_ioption( PSD_IOPT_CLASSIC );
        }

        if(rfov_flag && (!dualspinecho_flag) && (!is_iopt_selected(PSD_IOPT_MULTIBAND)))
        {
            set_disallowed_option( PSD_IOPT_CLASSIC );
        }

        deactivate_ioption( PSD_IOPT_MPH );
        if(!value_system_flag){
            deactivate_ioption( PSD_IOPT_DYNPL );
        }

        if(aspir_flag)
        {
            set_disallowed_option( PSD_IOPT_IR_PREP );
        }
    }

    if( feature_flag & FLAIR )
    {
        set_disallowed_option( PSD_IOPT_SEQUENTIAL );
        if((!value_system_flag) || (isStarterSystem())){
            set_disallowed_option( PSD_IOPT_ASSET );
        }
        /* MRIhc07638 / MRIhc07639 */
        set_disallowed_option( PSD_IOPT_CARD_GATE );
        set_disallowed_option( PSD_IOPT_IR_PREP );
        set_disallowed_option( PSD_IOPT_RESP_TRIG );
        set_disallowed_option( PSD_IOPT_NAV );
        deactivate_ioption( PSD_IOPT_ARC );
        deactivate_ioption( PSD_IOPT_MULTIBAND );
        deactivate_ioption( PSD_IOPT_CLASSIC );
    }

    if(checkOptionKey( SOK_MPHVAR )){
        deactivate_ioption( PSD_IOPT_DYNPL );
    }

    if(checkOptionKey( SOK_BODYNAV )){
        deactivate_ioption( PSD_IOPT_NAV );
    }

    if(!mild_note_support){
        deactivate_ioption( PSD_IOPT_MILDNOTE );
    }

    if((irprep_support == PSD_OFF) || !(feature_flag & DWI))
    {
        deactivate_ioption( PSD_IOPT_IR_PREP );
    }

    if(!(feature_flag & DWI))
    {
        deactivate_ioption( PSD_IOPT_RESP_TRIG ); 
        deactivate_ioption( PSD_IOPT_NAV );
    }

    if( (val15_lock == PSD_ON) &&  
        (!strcmp( coilInfo[0].coilName, "GE_HDx 8NVARRAY_A") ||
         !strcmp( coilInfo[0].coilName, "GE_HDx 8NVANGIO_A"))) 
    {
        disable_ioption( PSD_IOPT_ASSET );
    }

    if(edr_support == PSD_OFF)
    {
        deactivate_ioption( PSD_IOPT_EDR );
    }

    if(checkOptionKey( SOK_HYPERBAND ))
    {
        deactivate_ioption( PSD_IOPT_MULTIBAND );
    }

    if(B0_15000 >= cffield)
    {
        deactivate_ioption( PSD_IOPT_CLASSIC );
    }

    return SUCCESS;
}

STATUS
cvevaliopts( void )
{
    return SUCCESS;
}


#include <stdlib.h>

#include "epic_usercv.h"
#include "physics.h"
#include "psdIF.h"

/* for psddebugcode2 */
#define PSDDEBUG_SCAN 1
#define PSDDEBUG_IPG  2
#define PSDDEBUG_RTIA 4
#define PSDDEBUG_GSPEC 8

int Is3DGWAllowed(int maxSliceGap2ThickPercent)
{
    if ( ( (PSD_2D == exist(opimode)) || (PSD_CINE == exist(opimode)) ) && 
           ( (exist(opslspace) > (float)maxSliceGap2ThickPercent/100*exist(opslthick)+__FLT_EPSILON__) ||
             (0 == exist(opcoax)) || (exist(opnumgroups) > 1) ) )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


/***SVBranch: HCSDM00259119  eco mpg ***/

/* cvinit */
STATUS eco_mpg_cvinit(void)
{
    if(isValueSystem())
    {
        eco_mpg_support  = _eco_mpg_support.fixedflag ?  ((void)(PSD_ON), eco_mpg_support) : PSD_ON;
    }
    else
    {
        eco_mpg_support  = _eco_mpg_support.fixedflag ?  ((void)(PSD_OFF), eco_mpg_support) : PSD_OFF;
    }

    return SUCCESS;
} /* end of eco_mpg_cvinit() */

/* cveval */
STATUS eco_mpg_cveval(void)
{
    /* turn on below features for ECO-MPG:
       MPG shape opt,
       Left diff shift for DSE,
       DSE MPG opt; */
    if (PSD_ON == eco_mpg_flag)
    {
        mpg_opt_flag  = _mpg_opt_flag.fixedflag ?  ((void)(PSD_ON), mpg_opt_flag) : PSD_ON;
        dse_enh_flag  = _dse_enh_flag.fixedflag ?  ((void)(PSD_ON), dse_enh_flag) : PSD_ON;
        dse_opt_flag  = _dse_opt_flag.fixedflag ?  ((void)(PSD_ON), dse_opt_flag) : PSD_ON;
    }
    else
    {
        mpg_opt_flag  = _mpg_opt_flag.fixedflag ?  ((void)(PSD_OFF), mpg_opt_flag) : PSD_OFF;
        dse_enh_flag  = _dse_enh_flag.fixedflag ?  ((void)(PSD_OFF), dse_enh_flag) : PSD_OFF;
        dse_opt_flag  = _dse_opt_flag.fixedflag ?  ((void)(PSD_OFF), dse_opt_flag) : PSD_OFF;    
    }

    /* For MPG shape opt:
       1. Use new coil-power algorithm
          (in XFD_model.c);
       2. Use new b-value calc algorithm with 
          arbitrary grad shape (in calcbval.c) */
    if ((PSD_ON == mpg_opt_flag))
    {
        CompositeRMS_method  = _CompositeRMS_method.fixedflag ?  ((void)(PSD_ON), CompositeRMS_method) : PSD_ON;
        bval_arbitrary_flag    = _bval_arbitrary_flag.fixedflag ?  ((void)(PSD_ON), bval_arbitrary_flag) : PSD_ON;
    }
    else
    {
        CompositeRMS_method  = _CompositeRMS_method.fixedflag ?  ((void)(PSD_OFF), CompositeRMS_method) : PSD_OFF;
        bval_arbitrary_flag    = _bval_arbitrary_flag.fixedflag ?  ((void)(PSD_OFF), bval_arbitrary_flag) : PSD_OFF;
    }  
    
    return SUCCESS;
} /* end of eco_mpg_cveval() */

/* This function optimizes the MPG shape
   such that the plateaus of the MPG pairs
   are furhter separated, and long ramps
   are used between the MPG pairs; 
   
   Inputs:
     avail_time: Total duration of diffusion module;
                 This should be kept because we don't
                 want to increase TE;
     time_180:   refocusing RF time;
     t1:         duration of 1st diff in DSE;
     tv1:        1st refocusing RF total duration and 
                 the margin time between excitation and 1st refocusing;       
     t2:         total duration of the 2nd and 3rd diff in DSE;
     tv2:        2nd refocusing RF total duration;
     t3:         duration of 4th diff in DSE;
     maxG:       upper limit of diffusion gradient;
     SR:         max slew rate of diffusion gradient;
     b_target:   targeted b-value;
     axis_flag:  0 = X, 1 = Y, 2 = Z; */
STATUS mpg_opt_gen(int   avail_time, 
                   int   time_180, 
                   int   t1, 
                   int   tv1, 
                   int   t2, 
                   int   tv2, 
                   int   t3, 
                   float maxG, 
                   float SR, 
                   float b_target, 
                   int   axis_flag)
{
    int   Gnum = 0;
    int   num = 0;
    int   i = 0;
    int   j = 0;
    float tstep = 24.0; /* us, search step */   
    float b_curr = 0.0;
    float G[20];
    float t[20];  

    /* HCSDM00300336: PSD static code analysis violations in MULAN;
       avoid zero b_curr in the calculations below; */
    if (b_target <= 0)
    {
        epic_error(use_ermes, "mpg_opt_gen() in eco_mpg.e failed, b_target should be larger than 0", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," mpg_opt_gen()");
        return FAILURE;
    }    

    if(PSD_OFF == dualspinecho_flag)
    { 
     /* The grad amp values and time points, indexed
        from 0 to 7, correspond to:
        
        start of 1st diff;
        start of 1st diff plateau;
        end   of 1st diff plateau;
        end   of 1st diff;
        start of 2nd diff;
        start of 2nd diff plateau, negated due to 180;
        end   of 2nd diff plateau, negated due to 180;
        end   of 2nd diff; 
        
     */
    
        G[0] = 0;     
        G[1] = maxG;  
        G[2] = maxG;  
        G[3] = 0;     
        G[4] = 0;     
        G[5] = -maxG; 
        G[6] = -maxG;  
        G[7] = 0;     

        t[0] = 0;
        t[1] = maxG/SR;
        t[2] = maxG/SR+tstep;
        t[3] = (avail_time-time_180)/ 2.0;
        t[4] = avail_time -t[3];
        t[7] = avail_time;
        t[6] = avail_time - maxG/SR;
        t[5] = t[6]-tstep;

        num = (t[3] - maxG/SR - t[1])/tstep;
        Gnum = 8;
    }  
    else
    {
    
     /* The grad amp values and time points, indexed
        from 0 to 14, correspond to:
        
        start of 1st diff;
        start of 1st diff plateau;
        end   of 1st diff plateau;
        end   of 1st diff;
        start of 2nd diff;
        start of 2nd diff plateau, negated due to 180;
        end   of 2nd diff plateau, negated due to 180;
        end   of 2nd diff (also, start of 3rd diff); 
        start of 3rd diff plateau, negated due to 180;
        end   of 3rd diff plateau, negated due to 180;
        end   of 3rd diff;    
        start of 4th diff;
        start of 4th diff plateau;
        end   of 4th diff plateau;
        end   of 4th diff;        
        
     */    
    
        G[0]  = 0;
        G[1]  = maxG;
        G[2]  = maxG;
        G[3]  = 0;
        G[4]  = 0;
        G[5]  = maxG;
        G[6]  = maxG;
        G[7]  = 0;
        G[8]  = -maxG;
        G[9]  = -maxG;
        G[10] = 0;
        G[11] = 0;
        G[12] = -maxG;
        G[13] = -maxG;
        G[14] = 0;

        t[0]  = 0;
        t[1]  = (maxG/SR);
        t[2]  = t1-maxG/SR;
        t[3]  = t1;
        t[4]  = t1+tv1;
        t[5]  = t[4]+maxG/SR;
        t[6]  = t1+tv1+t2/2-maxG/SR;
        t[7]  = t[6]+maxG/SR;
        t[8]  = t[7]+maxG/SR;
        t[10] = t1+tv1+t2;
        t[9]  = t[10]-maxG/SR;
        t[11] = t1+tv1+t2+tv2;
        t[12] = t[11]+maxG/SR;
        t[14] = t1+tv1+t2+tv2+t3;
        t[13] = t[14]-maxG/SR;

        Gnum = 15;
        num = (t[6]-tstep-t[5])/tstep;
    } 

    for(i=0; i<Gnum; i++)
    {
        t[i] = t[i]/1.0e6;    /* change us to s */
    }

    /* The algorithm below is, start from a pair of triangular-shaped
       diffusion gradient, search for a proper plateau to meet the
       b-value requirement;
    */
    for(j=1; j<num; j++)
    {
        if(PSD_OFF == dualspinecho_flag)
        {
            t[2] = (maxG/SR + tstep*j)/ 1.0e6;
            t[5] = (avail_time - maxG/SR - tstep*j)/ 1.0e6;
        }
        else
        {
            t[6]=t[5]+tstep*j/1.0e6;
            t[8]=t[9]-tstep*j/1.0e6;
        }

        b_curr = eco_mpg_calcbval(G, t, Gnum);

        if((b_curr > b_target) && (PSD_OFF == dualspinecho_flag))
        {
            switch(axis_flag)
            {
                case 0:   /* X axis */
                    pw_gxdla  = _pw_gxdla.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdla) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdl   = _pw_gxdl.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdld  = _pw_gxdld.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdld) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdra  = _pw_gxdra.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdra) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr   = _pw_gxdr.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdrd  = _pw_gxdrd.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdrd) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    incdifx  = _incdifx.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdifx) : sqrt(b_target/b_curr)*maxG;
                    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(incdifx), a_gxdl) : incdifx;
                    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(incdifx), a_gxdr) : incdifx;
                    break;
                case 1:   /* Y axis */
                    pw_gydla  = _pw_gydla.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydla) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydl   = _pw_gydl.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydld  = _pw_gydld.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydld) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydra  = _pw_gydra.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydra) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr   = _pw_gydr.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydrd  = _pw_gydrd.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydrd) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    incdify  = _incdify.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdify) : sqrt(b_target/b_curr)*maxG;
                    a_gydl  = _a_gydl.fixedflag ?  ((void)(incdify), a_gydl) : incdify;
                    a_gydr  = _a_gydr.fixedflag ?  ((void)(incdify), a_gydr) : incdify;
                    break;
                case 2:    /* Z axis */
                    pw_gzdla  = _pw_gzdla.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdla) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdl   = _pw_gzdl.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdld  = _pw_gzdld.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdld) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdra  = _pw_gzdra.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdra) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr   = _pw_gzdr.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdrd  = _pw_gzdrd.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdrd) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    incdifz  = _incdifz.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdifz) : sqrt(b_target/b_curr)*maxG;
                    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(incdifz), a_gzdl) : incdifz;
                    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(incdifz), a_gzdr) : incdifz;
                    break;
                default:
                    epic_error(use_ermes, "mpg_opt_gen() in eco_mpg.e failed, unknown axis index", 
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," mpg_opt_gen()");
                    return FAILURE;
                    break;
            }
            break;
        }
        if((b_curr > b_target) && (PSD_ON == dualspinecho_flag))
        {
            switch(axis_flag)
            {
                case 0:   /* X axis */
                    pw_gxdl1a  = _pw_gxdl1a.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl1a) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdl1   = _pw_gxdl1.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl1) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdl1d  = _pw_gxdl1d.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl1d) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr1a  = _pw_gxdr1a.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr1a) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr1   = _pw_gxdr1.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr1) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr1d  = _pw_gxdr1d.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr1d) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;

                    pw_gxdl2a  = _pw_gxdl2a.fixedflag ?       ((void)(((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl2a) : ((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdl2   = _pw_gxdl2.fixedflag ?       ((void)(((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl2) : ((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdl2d  = _pw_gxdl2d.fixedflag ?       ((void)(((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdl2d) : ((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr2a  = _pw_gxdr2a.fixedflag ?       ((void)(((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr2a) : ((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr2   = _pw_gxdr2.fixedflag ?       ((void)(((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr2) : ((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gxdr2d  = _pw_gxdr2d.fixedflag ?       ((void)(((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gxdr2d) : ((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    
                    /* avoid ridiculous values */
                    if (pw_gxdl1 < GRAD_UPDATE_TIME) pw_gxdl1  = _pw_gxdl1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxdl1) : GRAD_UPDATE_TIME;
                    if (pw_gxdr1 < GRAD_UPDATE_TIME) pw_gxdr1  = _pw_gxdr1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxdr1) : GRAD_UPDATE_TIME;
                    if (pw_gxdl2 < GRAD_UPDATE_TIME) pw_gxdl2  = _pw_gxdl2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxdl2) : GRAD_UPDATE_TIME;
                    if (pw_gxdr2 < GRAD_UPDATE_TIME) pw_gxdr2  = _pw_gxdr2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxdr2) : GRAD_UPDATE_TIME;                   
                    
                    incdifx  = _incdifx.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdifx) : sqrt(b_target/b_curr)*maxG;
                    a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(incdifx), a_gxdl1) : incdifx;
                    a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-incdifx), a_gxdr1) : -incdifx;
                    a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(incdifx), a_gxdl2) : incdifx;
                    a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-incdifx), a_gxdr2) : -incdifx;
                    break;
                case 1:   /* Y axis */
                    pw_gydl1a  = _pw_gydl1a.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl1a) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydl1   = _pw_gydl1.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl1) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydl1d  = _pw_gydl1d.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl1d) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr1a  = _pw_gydr1a.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr1a) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr1   = _pw_gydr1.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr1) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr1d  = _pw_gydr1d.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr1d) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;

                    pw_gydl2a  = _pw_gydl2a.fixedflag ?       ((void)(((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl2a) : ((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydl2   = _pw_gydl2.fixedflag ?       ((void)(((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl2) : ((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydl2d  = _pw_gydl2d.fixedflag ?       ((void)(((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydl2d) : ((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr2a  = _pw_gydr2a.fixedflag ?       ((void)(((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr2a) : ((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr2   = _pw_gydr2.fixedflag ?       ((void)(((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr2) : ((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gydr2d  = _pw_gydr2d.fixedflag ?       ((void)(((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gydr2d) : ((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;   

                    /* avoid ridiculous values */
                    if (pw_gydl1 < GRAD_UPDATE_TIME) pw_gydl1  = _pw_gydl1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gydl1) : GRAD_UPDATE_TIME;
                    if (pw_gydr1 < GRAD_UPDATE_TIME) pw_gydr1  = _pw_gydr1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gydr1) : GRAD_UPDATE_TIME;
                    if (pw_gydl2 < GRAD_UPDATE_TIME) pw_gydl2  = _pw_gydl2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gydl2) : GRAD_UPDATE_TIME;
                    if (pw_gydr2 < GRAD_UPDATE_TIME) pw_gydr2  = _pw_gydr2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gydr2) : GRAD_UPDATE_TIME;
                    
                    incdify  = _incdify.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdify) : sqrt(b_target/b_curr)*maxG;
                    a_gydl1  = _a_gydl1.fixedflag ?  ((void)(incdify), a_gydl1) : incdify;
                    a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-incdify), a_gydr1) : -incdify;
                    a_gydl2  = _a_gydl2.fixedflag ?  ((void)(incdify), a_gydl2) : incdify;
                    a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-incdify), a_gydr2) : -incdify;
                    break;
                case 2:    /* Z axis */
                    pw_gzdl1a  = _pw_gzdl1a.fixedflag ?       ((void)(((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl1a) : ((int)(((t[1]-t[0])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdl1   = _pw_gzdl1.fixedflag ?       ((void)(((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl1) : ((int)(((t[2]-t[1])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdl1d  = _pw_gzdl1d.fixedflag ?       ((void)(((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl1d) : ((int)(((t[3]-t[2])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr1a  = _pw_gzdr1a.fixedflag ?       ((void)(((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr1a) : ((int)(((t[5]-t[4])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr1   = _pw_gzdr1.fixedflag ?       ((void)(((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr1) : ((int)(((t[6]-t[5])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr1d  = _pw_gzdr1d.fixedflag ?       ((void)(((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr1d) : ((int)(((t[7]-t[6])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;

                    pw_gzdl2a  = _pw_gzdl2a.fixedflag ?       ((void)(((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl2a) : ((int)(((t[8]-t[7])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdl2   = _pw_gzdl2.fixedflag ?       ((void)(((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl2) : ((int)(((t[9]-t[8])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdl2d  = _pw_gzdl2d.fixedflag ?       ((void)(((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdl2d) : ((int)(((t[10]-t[9])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr2a  = _pw_gzdr2a.fixedflag ?       ((void)(((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr2a) : ((int)(((t[12]-t[11])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr2   = _pw_gzdr2.fixedflag ?       ((void)(((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr2) : ((int)(((t[13]-t[12])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;
                    pw_gzdr2d  = _pw_gzdr2d.fixedflag ?       ((void)(((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME), pw_gzdr2d) : ((int)(((t[14]-t[13])*1.0e6+2.0)/GRAD_UPDATE_TIME))*GRAD_UPDATE_TIME;    

                    /* avoid ridiculous values */
                    if (pw_gzdl1 < GRAD_UPDATE_TIME) pw_gzdl1  = _pw_gzdl1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzdl1) : GRAD_UPDATE_TIME;
                    if (pw_gzdr1 < GRAD_UPDATE_TIME) pw_gzdr1  = _pw_gzdr1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzdr1) : GRAD_UPDATE_TIME;
                    if (pw_gzdl2 < GRAD_UPDATE_TIME) pw_gzdl2  = _pw_gzdl2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzdl2) : GRAD_UPDATE_TIME;
                    if (pw_gzdr2 < GRAD_UPDATE_TIME) pw_gzdr2  = _pw_gzdr2.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzdr2) : GRAD_UPDATE_TIME;
                    
                    incdifz  = _incdifz.fixedflag ?    ((void)(sqrt(b_target/b_curr)*maxG), incdifz) : sqrt(b_target/b_curr)*maxG;
                    a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(incdifz), a_gzdl1) : incdifz;
                    a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-incdifz), a_gzdr1) : -incdifz;
                    a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(incdifz), a_gzdl2) : incdifz;
                    a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-incdifz), a_gzdr2) : -incdifz;
                    break;
                default:
                    epic_error(use_ermes, "mpg_opt_gen() in eco_mpg.e failed, unknown axis index", 
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," mpg_opt_gen()");
                    return FAILURE;
                    break;                    
            }
            break;
        }
        /* b_curr < b_target should not happen. If it happens,does not change anything */ 
    }
    
    return SUCCESS;
} /* end of mpg_opt_gen() */

/* this function performs mpg_opt_gen() for
   each axis 
   
   Inputs:
     tmp_axis_flag:  axis index, 0=X, 1=Y, 2=Z;
     tmp_Delta_time: time between central 2 diff;
     tmp_MaxAmp:     max grad amp to use for diff;
     tmp_bvaltemp:   targeted b value; */
STATUS mpg_opt_timing(int tmp_axis_flag,
                      int tmp_Delta_time,
                      float tmp_MaxAmp,
                      float tmp_bvaltemp)
{
    /* Params below correspond to the required params
       in function mpg_opt_gen(); */
    int tmp_avail_time = 0;
    int tmp_time_180   = 0;
    int tmp_t1         = 0;
    int tmp_tv1        = 0;
    int tmp_t2         = 0;
    int tmp_tv2        = 0;
    int tmp_t3         = 0;
    float tmp_maxG     = 0.0;
    float tmp_SR       = 0.0;
    float tmp_target_b = 0.0;   
    
    switch(tmp_axis_flag)
    {
        case 0: /* X axis */
            tmp_avail_time = pw_gxdla + pw_gxdl + pw_gxdld + 
                             tmp_Delta_time + 
                             pw_gxdra + pw_gxdr + pw_gxdrd;    
            tmp_time_180   = tmp_Delta_time;
            tmp_t1         = pw_gxdl1a + pw_gxdl1 + pw_gxdl1d;
            if (rfov_flag)
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso + pw_gyex1_tot - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;                
            }
            else
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;
            }
            tmp_t2         = pw_gxdr1a + pw_gxdr1 + pw_gxdr1d + 
                             pw_gxdl2a + pw_gxdl2 + pw_gxdl2d;
            tmp_tv2        = pw_gzrf2rightl1a + pw_gzrf2rightl1 + pw_gzrf2rightl1d + 
                             pw_gzrf2right + 
                             pw_gzrf2rightr1a + pw_gzrf2rightr1 + pw_gzrf2rightr1d - 
                             mpg_opt_margin;
            tmp_t3         = pw_gxdr2a + pw_gxdr2 + pw_gxdr2d;
            tmp_maxG       = tmp_MaxAmp/ mpg_opt_derate;
            tmp_SR         = tmp_maxG/ (float)pw_gxdla;
            tmp_target_b   = tmp_bvaltemp;
            break;
        case 1: /* Y axis */
            tmp_avail_time = pw_gydla + pw_gydl + pw_gydld + 
                             tmp_Delta_time + 
                             pw_gydra + pw_gydr + pw_gydrd;    
            tmp_time_180   = tmp_Delta_time;
            tmp_t1         = pw_gydl1a + pw_gydl1 + pw_gydl1d;
            if (rfov_flag)
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso + pw_gyex1_tot - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;            
            }
            else
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;
            }
            tmp_t2         = pw_gydr1a + pw_gydr1 + pw_gydr1d + 
                             pw_gydl2a + pw_gydl2 + pw_gydl2d;
            tmp_tv2        = pw_gzrf2rightl1a + pw_gzrf2rightl1 + pw_gzrf2rightl1d + 
                             pw_gzrf2right + 
                             pw_gzrf2rightr1a + pw_gzrf2rightr1 + pw_gzrf2rightr1d - 
                             mpg_opt_margin;
            tmp_t3         = pw_gydr2a + pw_gydr2 + pw_gydr2d;
            tmp_maxG       = tmp_MaxAmp/ mpg_opt_derate;
            tmp_SR         = tmp_maxG/ (float)pw_gydla;
            tmp_target_b   = tmp_bvaltemp;
            break; 
        case 2: /* Z axis */
            tmp_avail_time = pw_gzdla + pw_gzdl + pw_gzdld + 
                             tmp_Delta_time + 
                             pw_gzdra + pw_gzdr + pw_gzdrd;    
            tmp_time_180   = tmp_Delta_time;
            tmp_t1         = pw_gzdl1a + pw_gzdl1 + pw_gzdl1d;
            if (rfov_flag)
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso + pw_gyex1_tot - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;
            }
            else
            {
                tmp_tv1        = pw_gzrf2leftl1a + pw_gzrf2leftl1 + pw_gzrf2leftl1d +
                                 pw_gzrf2left +
                                 pw_gzrf2leftr1a + pw_gzrf2leftr1 + pw_gzrf2leftr1d + 
                                 fabs(rfExIso - tdaqhxa - pw_gx1a - pw_gx1 - pw_gx1d) -
                                 mpg_opt_margin;            
            }
            tmp_t2         = pw_gzdr1a + pw_gzdr1 + pw_gzdr1d + 
                             pw_gzdl2a + pw_gzdl2 + pw_gzdl2d;
            tmp_tv2        = pw_gzrf2rightl1a + pw_gzrf2rightl1 + pw_gzrf2rightl1d + 
                             pw_gzrf2right + 
                             pw_gzrf2rightr1a + pw_gzrf2rightr1 + pw_gzrf2rightr1d - 
                             mpg_opt_margin;
            tmp_t3         = pw_gzdr2a + pw_gzdr2 + pw_gzdr2d;
            tmp_maxG       = tmp_MaxAmp/ mpg_opt_derate;
            tmp_SR         = tmp_maxG/ (float)pw_gzdla;
            tmp_target_b   = tmp_bvaltemp;
            break;
        default:
            epic_error(use_ermes, "mpg_opt_timing() in eco_mpg.e failed, unknown axis index", 
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," mpg_opt_timing()");
            return FAILURE;
            break;            
    }  
    
    if ( FAILURE == mpg_opt_gen(tmp_avail_time, 
                                tmp_time_180, 
                                tmp_t1, 
                                tmp_tv1, 
                                tmp_t2, 
                                tmp_tv2, 
                                tmp_t3, 
                                tmp_maxG, 
                                tmp_SR, 
                                tmp_target_b, 
                                tmp_axis_flag) )
        return FAILURE;
    
    return SUCCESS;
} /* end of mpg_opt_timing() */ 

/* This function optimizes the diffusion
   gradient plateau duration for DSE case;
   Inputs:
      b_target:    in rad*s/mm2, target b-value;
      pw_d1_guess: in us, initial guess of the 
                   first diff-grad plateau duration;
      pw_ramp:     in us, ramp time of each diff-grad;
      pw_delta:    in us, delay between the central two
                   diffusion gradients;      
      gmax:        in Gauss/cm, diff-grad amp;
   Outputs:
      pw_d1:       in us, duration of 1st/4th diff-grad plateau;
      pw_d2:       in us, duration of 2nd/3rd diff-grad plateau;
*/   
STATUS dse_opt_timing(float b_target, 
                      int   pw_d1_guess, 
                      int   pw_ramp,
                      int   pw_delta,                      
                      float gmax)                      
{          
    /* Initialize */
    int   cnt = 0;
    int   find_max = PSD_ON;
    int   cnt_limit = 100;
    float b_error = 1000000.0;
    float b_curr = 0.0;
    float pw_delay = 0.0; /* end of 4th diff to TE */
    float pw_shift = 0.0;
    float pw_max = 0.0;
    float pw_min = 0.0;
    float t[20];
    float G[20];
    float b_tol_abs = 0.0;
    int   i = 0;   
    if (pw_delta < 1e-6)
    {
        pw_delta = GRAD_UPDATE_TIME;
    }
    b_curr = b_target;
    pw_delay = (float)(tdaqhxa + pw_gx1a + pw_gx1 + pw_gx1d);
    pw_d1  = _pw_d1.fixedflag ?  ((void)((float)pw_d1_guess), pw_d1) : (float)pw_d1_guess;
    pw_d2  = _pw_d2.fixedflag ?      ((void)(pw_d1+pw_delay-(float)pw_delta/2.0), pw_d2) : pw_d1+pw_delay-(float)pw_delta/2.0;
    if (dse_enh_flag)
    {
        pw_shift = pw_delay - (float)rfExIso;
        if (rfov_flag)
        {
            pw_shift = pw_delay - (float)rfExIso - pw_gyex1_tot;
        }
    }
    else
    {
        pw_shift = 0.0;
    }
    pw_max = (float)pw_d1_guess;
    
    /* Search for proper diffusion plateau */
    b_tol_abs = b_tol * b_target;
    while ( (b_error>b_tol_abs) && (cnt<cnt_limit) && (pw_max-pw_min>4.0) )
    {
        /* Recalc 1st/4th diff plateau */
        if (b_curr < b_target)
        {
            if (PSD_ON == find_max)
            {
                /* Search for initial max */
                pw_max = 2 * pw_max;
                pw_d1  = _pw_d1.fixedflag ?  ((void)(pw_max), pw_d1) : pw_max;
            }
            else
            {
                /* Update current min */
                pw_min = pw_d1;
                /* Update pw_d1 */
                pw_d1  = _pw_d1.fixedflag ?  ((void)((pw_max+pw_min)/2), pw_d1) : (pw_max+pw_min)/2;
            }
        }
        else if (b_curr > b_target)
        {
            /* Terminate search for initial max */
            find_max = PSD_OFF;
            /* Update current max */
            pw_max = pw_d1;
            /* Update pw_d1 */
            pw_d1  = _pw_d1.fixedflag ?  ((void)((pw_max+pw_min)/2), pw_d1) : (pw_max+pw_min)/2; 
        }
        
        /* Recalc 2nd/3rd diff plateau, based
           on the fact that a Spin Echo is
           required; */
        pw_d2  = _pw_d2.fixedflag ?      ((void)(pw_d1+pw_delay-(float)pw_delta/2.0), pw_d2) : pw_d1+pw_delay-(float)pw_delta/2.0;
        
        /* Generate time line */
        t[0]  = 0.0;
        t[1]  = t[0]  + (float)pw_ramp;
        t[2]  = t[1]  + pw_d1;
        t[3]  = t[2]  + (float)pw_ramp;
        t[4]  = t[3]  + pw_shift + (float)(pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot);
        t[5]  = t[4]  + (float)pw_ramp;
        t[6]  = t[5]  + pw_d2;
        t[7]  = t[6]  + (float)pw_ramp;
        t[8]  = t[7]  + (float)pw_delta;
        t[9]  = t[8]  + (float)pw_ramp;
        t[10] = t[9]  + pw_d2;
        t[11] = t[10] + (float)pw_ramp;
        t[12] = t[11] + (float)(pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot);
        t[13] = t[12] + (float)pw_ramp;
        t[14] = t[13] + pw_d1;
        t[15] = t[14] + (float)pw_ramp;   

        /* Generate grad wave */
        G[0]  = 0.0;
        G[1]  = gmax;
        G[2]  = gmax;
        G[3]  = 0.0;
        G[4]  = 0.0;
        G[5]  = gmax; /* flipped after 180 */
        G[6]  = gmax; /* flipped after 180 */
        G[7]  = 0.0;
        G[8]  = 0.0;
        G[9]  = -gmax; /* flipped after 180 */
        G[10] = -gmax; /* flipped after 180 */       
        G[11] = 0.0;
        G[12] = 0.0;
        G[13] = -gmax; 
        G[14] = -gmax;
        G[15] = 0.0;
        int Gnum = 16;

        /* us to s */
        for(i=0; i<Gnum; i++)
        {
            t[i] = t[i]/1.0e6;
        }        
        
        /* Calc current b-value */
        b_curr = eco_mpg_calcbval(G, t, Gnum);
        
        /* Calc current error in b */
        b_error = fabs(b_curr - b_target);  
        /* Ensure a b_curr >= b_target, so that
           some margin is left for verify_bvalue() */
        if (b_curr < b_target) b_error = b_tol_abs + 1.0;        
        
        /* Increment */
        cnt = cnt + 1;         
        
    } /* end While */  

    /* In case of no converge */
    if (cnt >= cnt_limit)
    {
        epic_error(use_ermes,"Search for diffusion duration failed",
                   EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"dse_opt_timing()");
        return FAILURE;        
    }
        
    return SUCCESS;    
        
} /* end dse_opt_timing() */

/* calculate b-value given the corner-points;
   Inputs:
       g: vector of grad amp, in Gauss/cm;
       t: vector of time pts, in s;
       n: number of valid pts in the vector; */
float eco_mpg_calcbval(float *g, float *t, int n)
{
    float A = 0.0; /* area */
    float B = 0.0; /* calced b-value */
    float C = 0.0; /* a tmp variable */
    float a = 0.0; /* slope */
    float b = 0.0; /* intercept */
    int   i = 0;
    
    for(i=0; i<n; i++)
    {
        if(0 == i)
        {
            A = 0;
            B = 0;
        }
        else
        {
            a = (g[i] - g[i-1])/ (t[i] - t[i-1]); 
            b = g[i-1]-a*t[i-1]; 
            C = A - 0.5*a*t[i-1]*t[i-1]-b*t[i-1];

            B = B + (
                        ( 
                            (1/20.0)*a*a*t[i]*t[i]*t[i]*t[i]*t[i] + 
                            (1/4.0)*a*b*t[i]*t[i]*t[i]*t[i] +
                            (1/3.0)*b*b*t[i]*t[i]*t[i] + 
                            (1/3.0)*a*C*t[i]*t[i]*t[i] + 
                            b*C*t[i]*t[i] +
                            C*C*t[i] 
                        ) -
                        (  
                            (1/20.0)*a*a*t[i-1]*t[i-1]*t[i-1]*t[i-1]*t[i-1] +
                            (1/4.0)*a*b*t[i-1]*t[i-1]*t[i-1]*t[i-1] +
                            (1/3.0)*b*b*t[i-1]*t[i-1]*t[i-1] +
                            (1/3.0)*a*C*t[i-1]*t[i-1]*t[i-1] +
                            b*C*t[i-1]*t[i-1] +
                            C*C*t[i-1]                                                                
                        ) 
                    ) * 
                    (TWOPI_GAMMA * TWOPI_GAMMA/ 100.0);  
            A = A + ( (g[i] + g[i-1])/ 2 ) * (t[i]-t[i-1]);
        }            
    }
    
    return B;
}
  
/*** end of host ***/


/***********************/
/*** Inline Contents ***/
/***********************/
/*********************/

/* load up psd header */
abstract("Spin or gradient recalled echo planar imaging sequence (rev113)");
psdname("EPI2");

/* HOEC: Functions to read HOEC compensation configuration in manual mode */

/* in manual mode, which bases are included in PSD/recon
   are set in hoecCorrTerms.txt and loaded into this array */
int ext_corr_term[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES] = {{0}};

/* in manual mode, depending on the config file, some terms may not be
   designed to be compensated, in which case alpha_scale would be 0 */
float alpha_scale[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES][HOEC_MAX_NUM_TERMS] = {{{0}}};

/* Note: Z gradients are not corrected. */
/* HCSDM00195152: This should be moved to HoecIpgexport to correct Z gradients */
float dwi_hoec_gcor_XonZ[HOEC_MAX_ILEAVE][HOEC_MAX_SLQUANT][HOEC_MAX_ETL] = {{{0}}};
float dwi_hoec_gcor_YonZ[HOEC_MAX_ILEAVE][HOEC_MAX_SLQUANT][HOEC_MAX_ETL] = {{{0}}};
float dwi_hoec_gcor_ZonZ[HOEC_MAX_ILEAVE][HOEC_MAX_SLQUANT][HOEC_MAX_ETL] = {{{0}}};

/* Function to read HOEC compensation configuration in manual mode */
STATUS ReadHoecCorrTerms(void)
{
    FILE *fp;
    FILE *debug_file_ptr;
    char tempStr[257];
    int i,j;
 
    /* Intiialization */
    for (i=0;i<HOEC_TOTAL_NUM_AXES;i++)
    {
        for (j=0;j<HOEC_MAX_NUM_BASES;j++)
        {
            ext_corr_term[i][j] = 0;  /* basis correction option in manual mode */
        }
    }

    if ((fp = fopen(HOEC_CORRTERMS_FILE, "r")) == NULL)
    {
        return FAILURE;
    }
 
    /* Read correction flag for bases in case manual mode is selected (hoecc_psd_flag=2) */
    /* basis correction option: 0 = no correction, 1 = psd, 2 = recon */
    for (i=0;i<HOEC_TOTAL_NUM_AXES;i++)
    {
        for (j=0;j<HOEC_MAX_NUM_BASES;j++)
        {
            do
            {
                if (fgets (tempStr, 256, fp) == NULL) return failureClose(fp);
            } while(isCommentOrBlankLine(tempStr));

            if (sscanf(tempStr, "%d %*s", &(ext_corr_term[i][j])) < 1) return failureClose(fp);

            if (j<hoec_cal_info.total_bases_per_axis)
            {
                if (ext_corr_term[i][j] < 0 || ext_corr_term[i][j] > 2)
                    return failureClose(fp);
            }
        }
    }

    fclose(fp);

    /* In debug mode, write all the variables into a file */
    if (hoecc_debug == PSD_ON)
    {
        debug_file_ptr = fopen(HOEC_DEBUG_FILE, "a");
        if (debug_file_ptr != NULL)
        {
            fprintf(debug_file_ptr, "\nCorrection Terms - Manual Mode\n");
            fprintf(debug_file_ptr, "Donor Base Flag(0-off, 1-PSD, 2-Recon\n");
            
            for (i=0;i<HOEC_TOTAL_NUM_AXES;i++)
            {
                for (j=0;j<HOEC_MAX_NUM_BASES;j++)
                {
                    fprintf(debug_file_ptr, "%d %2d %d\n", i, j, ext_corr_term[i][j]);
                }
            }
            fclose(debug_file_ptr);
        }
        else
        {        	
            printf("Failed to open %s.\n", HOEC_DEBUG_FILE);
        }            
    }

    return SUCCESS;
}

/* Supporting function to handle file reading failure */
STATUS failureClose(FILE * fp)
{
    if(fp != NULL) fclose(fp);
    return FAILURE;
}

/* Supporting function to determine if current line is blank */
int isCommentOrBlankLine(char * str)
{
    int i;

    i = -1;
    while(isspace(str[++i]));
    if(( i == (int)strlen(str)) || (str[i] == '#')) return 1;
    return 0;
}

/* Determine if HOEC is supported or not */

/* parab() for b_fact calculation */
/* BJM: all this is is the result of the indefinite integral */
/* of b(t) = integral of (k(t)k(t))dt from x to t where....  */
/*         k(t) = (2pi*gamma)(g*t+c) (assumes g(t) = g)      */
/* Thus, parab = (2pi*gamma)^2*integral(g^2t^2 + 2gtc +c^2) evaluated */
/* over some interval x -> x'. c is the initial condition for each    */ 
/* time interval.... */
#ifdef __STDC__
FLOAT parab( FLOAT amp, FLOAT time, FLOAT offset )
#else /* !__STDC__ */
    FLOAT parab(amp,time,offset)
    FLOAT amp; 
    FLOAT time;
    FLOAT offset;
#endif /* __STDC__ */
{
    FLOAT tmp;

    tmp = pow(amp, 2.0) * pow(time, 3.0)/ 3.0;
    tmp += amp * pow(time, 2.0) * offset;
    tmp += time * pow(offset, 2.0);

    return tmp;
}


/* ****************************************
   MYSCAN
   myscan sets up the scan_info table for a hypothetical scan.
   It is controlled by the cv opslquant, and opslthick, and opfov. 
   ************************************** */
void
myscan( void )
{
    int i,j;
    int num_slice;
    float z_delta;		/* change in z_loc between slices */
    float r_delta;		/* change in r_loc between slices */
    double alpha, beta, gamma; /* rotation angles about x, y, z respectively */
    
    num_slice = exist(opslquant);
    
    r_delta = exist(opfov)/num_slice;
    z_delta = exist(opslthick)+exist(opslspace);
    
    scan_info[0].optloc = 0.5*z_delta*(num_slice-1);
    scan_info[0].oprloc = myrloc;

    for (i=1;i<9;i++)
        scan_info[0].oprot[i]=0.0;
    
    switch (exist(opplane)) {
    case PSD_AXIAL:
        scan_info[0].oprot[0] = 1.0;
        scan_info[0].oprot[4] = 1.0;
        scan_info[0].oprot[8] = 1.0;
        break;
    case PSD_SAG:
        scan_info[0].oprot[2] = 1.0;
        scan_info[0].oprot[4] = 1.0;
        scan_info[0].oprot[6] = 1.0;
        break;
    case PSD_COR:
        scan_info[0].oprot[1] = 1.0;
        scan_info[0].oprot[5] = 1.0;
        scan_info[0].oprot[6] = 1.0;
        break;
    case PSD_OBL:
        alpha = PI/4.0;  /* rotation about x (applied first) */
        beta = PI/8.0;   /* rotation about y (applied 2nd) */
        gamma = PI/4.0;  /* rotation about z (applied 3rd) */
        scan_info[0].oprot[0] = cos(gamma)*cos(beta);
        scan_info[0].oprot[1] = cos(gamma)*sin(beta)*sin(alpha) -
                                       sin(gamma)*cos(alpha);
        scan_info[0].oprot[2] = cos(gamma)*sin(beta)*cos(alpha) +
                                       sin(gamma)*sin(alpha);
        scan_info[0].oprot[3] = sin(gamma)*cos(beta);
        scan_info[0].oprot[4] = sin(gamma)*sin(beta)*sin(alpha) +
                                       cos(gamma)*cos(alpha);
        scan_info[0].oprot[5] = sin(gamma)*sin(beta)*cos(alpha) -
                                       cos(gamma)*sin(alpha);
        scan_info[0].oprot[6] = -sin(beta);
        scan_info[0].oprot[7] = cos(beta)*sin(alpha);
        scan_info[0].oprot[8] = cos(beta)*cos(alpha);
        break;
    }
  
    for(i=1;i<num_slice;i++) {
        scan_info[i].optloc = scan_info[i-1].optloc - z_delta;
        scan_info[i].oprloc = i*r_delta;
        for(j=0;j<9;j++)
            scan_info[i].oprot[j] = scan_info[0].oprot[j];
    }
    
    return;
    
}

/*
 * Override coil acceleration capabilties
 */
void epi_asset_override(void)
{
    if(existcv(opasset) && (1 == exist(opassetscan)))
    {
        /* To replicate legacy behavior, allow ASSET R=2 even if the coil
         * doesn't support it. */
         cfaccel_ph_maxstride = FMax(2, 2.0, cfaccel_ph_maxstride);
    }

    return;
}

/*
 * Setup parallel imaging UI to only show integer step sizes
 */
void epi_asset_set_dropdown(void)
{
    if(existcv(opasset) && (1 == exist(opassetscan)))
    {
        if(muse_flag)
        {
            float temp_maxaccel = 1.0;

            temp_maxaccel = floor(avmaxaccel_ph_stride/exist(opnshots)*4.0)*0.25;
            piaccel_phval2 = 1.0;
            piaccel_phval3 = FMin(2, avmaxaccel_ph_stride/2.0, temp_maxaccel);
            if(piaccel_phval3 > piaccel_phval2)
            {
                piaccel_phnub = 3;
            }
            else
            {
                piaccel_phnub = 2;
            } 
        }
        else
        {
            if(avmaxaccel_ph_stride > 2.0)
            {
                piaccel_phnub = 4;
                piaccel_phval2 = 1.0;
                piaccel_phval3 = 2.0;
                piaccel_phval4 = avmaxaccel_ph_stride;
            }
            else
            {
                piaccel_phnub = 3;
                piaccel_phval2 = 1.0;
                piaccel_phval3 = 2.0;
            }
        }

        piaccel_ph_step = 1.0;
    }

    return;
}

/*
 * Setup ARC parallel imaging UI to only show integer step sizes
 */
void epi_arc_set_dropdown(void)
{
    if( existcv(oparc) && (exist(oparc)) && (PSD_ON == mux_flag) )
    {
        /*Multiband only supports up to factor of 2 in-plane acceleration*/
        if(avmaxaccel_ph_stride >= 2.0)
        {
            piaccel_phedit = 0; /* do not allow user manually input acceleration factor */
            if  (avmaxaccel_ph_stride >2.0)
            {
                piaccel_phnub = 4;
                piaccel_phval2 = 1.0;
                piaccel_phval3 = 2.0;
                piaccel_phval4 = avmaxaccel_ph_stride;
            }
            else
            {
                piaccel_phnub = 3;
                piaccel_phval2 = 1.0;
                piaccel_phval3 = 2.0;
            }
            piaccel_ph_step = 1.0;
        }
        else
        {
            piaccel_phnub = 0;
            avmaxaccel_ph_stride = 1.0;
        }
    }

    return;
}

/*
 * Only allow integer acceleration factors
 */
STATUS epi_arc_override(void)
{
    if(existcv(oparc) && (exist(oparc)))
    {
        if (!floatIsInteger(exist(opaccel_ph_stride)))
        {
            cvoverride(opaccel_ph_stride, (int)ceil(exist(opaccel_ph_stride)), PSD_FIX_ON, PSD_EXIST_ON);
            epic_error( use_ermes, "Only integer acceleration factor allows for ARC EPI. The integer value of %d should be used.",
                        EM_PSD_INT_ACCEL, EE_ARGS(1),
                        INT_ARG, (int)(ceil(opaccel_ph_stride)) );
            return ADVISORY_FAILURE;
        }
        if(cfaccel_ph_maxstride < 2.0)
        {
            cvoverride(opaccel_ph_stride, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
        }
    }

    return SUCCESS;
}

/****************************************************************************/
/*  CVINIT                                                                  */
/****************************************************************************/
STATUS
cvinit( void )
{
    int status_flag = SUCCESS;

    cvmax(vrgfsamp, PSD_ON);
    cvdef(esp, 0);
    esp  = _esp.fixedflag ?  ((void)(0), esp) : 0;

    if ((PSDDVMR == psd_board_type) && (value_system_flag == NON_VALUE_SYSTEM))
    {
        /* B0 dither calibration is removed for DVMR hardware */
        ditheron  = _ditheron.fixedflag ?  ((void)(0), ditheron) : 0;
    }
    else
    {
        ditheron  = _ditheron.fixedflag ?  ((void)(1), ditheron) : 1;
    }

    OpenDelayFile(delay_buffer);
    if (ditheron)
    {
        OpenDitherFile(txCoilInfo[getTxIndex(coilInfo[0])].txCoilType,
                       dither_buffer);
        OpenDitherInterpoFile(txCoilInfo[getTxIndex(coilInfo[0])].txCoilType,
                              ccinx, cciny, ccinz, esp_in, fesp_in, &g0,
                              &num_elements, &file_exist);
    }

    /* RAK: MRIge55889 - removed GRAD_UPDATE_TIME being used during the */
    /*                   initialization of CVs.                         */ 
    pwmin_gap      = _pwmin_gap.fixedflag ?  ((void)(2*GRAD_UPDATE_TIME), pwmin_gap) : 2*GRAD_UPDATE_TIME;
    td0            = _td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0) : GRAD_UPDATE_TIME;
    hrdwr_period  = _hrdwr_period.fixedflag ?  ((void)(GRAD_UPDATE_TIME), hrdwr_period) : GRAD_UPDATE_TIME;

    /* update to include external gradient waveforms for QTI granty edit 9/28/17 */
    wg_gxdl  = _wg_gxdl.fixedflag ?  ((void)(XGRAD), wg_gxdl) : XGRAD;
    wg_gxdr  = _wg_gxdr.fixedflag ?  ((void)(XGRAD), wg_gxdr) : XGRAD;
    wg_gydl  = _wg_gydl.fixedflag ?  ((void)(YGRAD), wg_gydl) : YGRAD;
    wg_gydr  = _wg_gydr.fixedflag ?  ((void)(YGRAD), wg_gydr) : YGRAD;
    wg_gzdl  = _wg_gzdl.fixedflag ?  ((void)(ZGRAD), wg_gzdl) : ZGRAD;
    wg_gzdr  = _wg_gzdr.fixedflag ?  ((void)(ZGRAD), wg_gzdr) : ZGRAD; 
	/* granty end */

    /* SXZ::MRIge72411: init the optimization arr */
    taratio_arr[0] = 0.7; 
    taratio_arr[1] = 0.65; 
    taratio_arr[2] = 0.5;
    totarea_arr[0] = 1127.4; /* fov=20; xres=96 */
    totarea_arr[1] = 1503.2; /* fov=20; xres=128 */
    totarea_arr[2] = 2254.8; /* fov=20; xres=192 */

    if ( !strncasecmp("epi2spec",get_psd_name(),8) ) {
        epi2spec_mode  = _epi2spec_mode.fixedflag ?  ((void)(PSD_ON), epi2spec_mode) : PSD_ON;
    } else {
        epi2spec_mode  = _epi2spec_mode.fixedflag ?  ((void)(PSD_OFF), epi2spec_mode) : PSD_OFF;
    }

    epi_asset_override();
    epi_arc_override();

/* AssetCVInit  inlined from Asset.e */
/* This section enables asset scanning only. */
/* Currently, calibration scans are performed */
/* with an fgre sequence. If there is aA need to */
/* enable calibration scans in other sequences, then */
/* the AsseCalCVInit section (below) should be inlined instead */
{
    cvmax(opassetscan, 1);

    /* New flags, originally used in efgre3d , being expanded */
    assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;

    /* Pick up default step size computed from avmaxaccel_ph_stride
     * and avmaxaccel_sl_stride
     * */

    avmaxaccel_sl_stride = 1.0;
    avmaxaccel_ph_stride = 1.0;
    piaccel_sl_stride = 1.0;
    piaccel_ph_stride = 1.0;

    assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_sl_maxstride > 1.0) && 
        (ASSET_SUPPORT_SLICE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support slice ASSET */

        /* Enable slice ASSET (host no longer sets slices ASSET) */
        cvoverride(opasset, ASSET_SCAN_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_ON), assetsl_flag) : PSD_ON;
        avmaxaccel_sl_stride = cfaccel_sl_maxstride;

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride, avmaxaccel_sl_stride);
        }

        if (exist(opaccel_sl_stride) > 1.0) {
            assetsl_factor  = _assetsl_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_sl_stride))), assetsl_factor) : FMin(2,1.0,1.0/exist(opaccel_sl_stride));
        } else {
            assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        }
    }

    asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_ph_maxstride > 1.0) && 
        (ASSET_SUPPORT_PHASE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support phase ASSET */

        /* Reset to phase ASSET (host no longer sets slice ASSET ) */
        cvoverride(opasset, ASSET_SCAN_PHASE, PSD_FIX_ON, PSD_EXIST_ON);

        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_ON), assetph_flag) : PSD_ON;
        avmaxaccel_ph_stride = cfaccel_ph_maxstride;

        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride, avmaxaccel_ph_stride);
        }

        if (exist(opaccel_ph_stride) > 1.0) {
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_ph_stride))), asset_factor) : FMin(2,1.0,1.0/exist(opaccel_ph_stride));
        } else {
            asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        }
    }

    /* Set asset_factor */
    /* MRIge92386 */
    if( existcv(opasset) && exist(opassetscan) == PSD_ON )
    {
        float temp_maxaccel_ph;
        float temp_maxaccel_sl;
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);
        int cardiac_scan = (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                            && (!strcmp(attribute_codeMeaning, "Heart") || !strcmp(attribute_codeMeaning, "Aorta")
                                || !strcmp(attribute_codeMeaning, "Aortic arch")));

        piaccelscrn = PSD_ON;

        /* Set up the PI pulldown */
        if(PSD_ON == cardiac_scan)  /* pulldown to show max factor up to 3 for cardiac scans */
        {
            temp_maxaccel_ph = FMin(2, 3.0, avmaxaccel_ph_stride);
            temp_maxaccel_sl = FMin(2, 3.0, avmaxaccel_sl_stride);
        }
        else
        {
            temp_maxaccel_ph = avmaxaccel_ph_stride;
            temp_maxaccel_sl = avmaxaccel_sl_stride;
        }

        setAccelPulldown (temp_maxaccel_ph, temp_maxaccel_sl, 
                          &piaccel_phval2, &piaccel_phval3,
                          &piaccel_phval4, &piaccel_phval5,
                          &piaccel_phval6, &piaccel_phnub,
                          &piaccel_phedit, &piaccel_slval2,
                          &piaccel_slval3, &piaccel_slval4,
                          &piaccel_slval5, &piaccel_slval6,
                          &piaccel_slnub, &piaccel_sledit,
                          &piaccel_ph_step, &piaccel_sl_step);

        cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;
    } 
    else
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
        if(PSD_OFF == exist(oparc))
        {
            piaccel_slnub = 0.0;
            piaccel_phnub = 0.0;
            piaccelscrn = PSD_OFF;
        }        
        /* set opcalrequired value in loadrheader.e */
        override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_OFF), override_opcalrequired) : PSD_OFF;
    }
}

/* AssetCVInit  inlined from Asset.e */
    if(mux_flag)
    {
/* ARCInit inlined from ARC.e*/

ARCKey  = _ARCKey.fixedflag ?    ((void)(!checkOptionKey(SOK_ARC)), ARCKey) : !checkOptionKey(SOK_ARC);

if( !ARCKey && arc_flag ) 
{
    epic_error( use_ermes, "%s is not available without the option key.",
                EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG,"ARC" );
    return FAILURE;
}

/* MRIhc46119 - Changes for Parallel Imaging UI */

if (PSD_ON == exist(oparc))
{
    cvmax( arc_flag, PSD_ON );
    cvoverride(arc_flag, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
    init_arc_variables ();

    /* set up arc_ph_acs_min based on user selected accel factor */
    if(exist(opaccel_ph_stride) > 3.0 && existcv(opaccel_ph_stride))
    {
        arc_ph_acs_min  = _arc_ph_acs_min.fixedflag ?  ((void)((int)(4.0*opaccel_ph_stride)), arc_ph_acs_min) : (int)(4.0*opaccel_ph_stride);
    }
    else
    {
        arc_ph_acs_min  = _arc_ph_acs_min.fixedflag ?  ((void)(12), arc_ph_acs_min) : 12;
    }
    /* set up arc_sl_acs_min based on user selected accel factor */
    if(exist(opaccel_sl_stride) > 3.0 && existcv(opaccel_sl_stride))
    {
        arc_sl_acs_min  = _arc_sl_acs_min.fixedflag ?  ((void)((int)(4.0*opaccel_sl_stride)), arc_sl_acs_min) : (int)(4.0*opaccel_sl_stride);
    }
    else
    {
        arc_sl_acs_min  = _arc_sl_acs_min.fixedflag ?  ((void)(12), arc_sl_acs_min) : 12;
    }
}
else
{
    reset_accel_variables ();
}

/* Initialize ARC variables so that we can use it commonly, 
 * Works for both Asset and ARC, MRIhc46119 Changes for PI-UI
 * */



/* ARCInit inlined from ARC.e*/
    }
    epi_asset_set_dropdown();
    epi_arc_set_dropdown();

    /* MRIhc19114 */
    if ( (fract_ky == PSD_FRACT_KY) && (intleaves == 1) ) {
        rup_factor  = _rup_factor.fixedflag ?  ((void)(4.0), rup_factor) : 4.0;
    } else {
        rup_factor  = _rup_factor.fixedflag ?  ((void)(2.0), rup_factor) : 2.0;
    }

    if ( (existcv(opasset) && (exist(opasset) == ASSET_SCAN_PHASE)) || (existcv(oparc) && (exist(oparc))) ) {
        int temp_nframes;

        if(arc_extCal && oparc){
            asset_factor  = _asset_factor.fixedflag ?  ((void)(arc_ph_factor), asset_factor) : arc_ph_factor;
        }
        if (num_overscan > 0) {
            temp_nframes = (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop - ky_offset);
            asset_factor  = _asset_factor.fixedflag ?      ((void)(FMin(2,1.0,floorf((temp_nframes+ky_offset)*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5)), asset_factor) : FMin(2,1.0,floorf((temp_nframes+ky_offset)*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5);
        } else {
            temp_nframes = (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,floorf(temp_nframes*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5)), asset_factor) : FMin(2,1.0,floorf(temp_nframes*1.0e5/((float)exist(opyres)*fn*nop))/1.0e5);
        }
    } else {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        arc_ph_factor  = _arc_ph_factor.fixedflag ?  ((void)(1.0), arc_ph_factor) : 1.0;
    }

    /* BJM - gating */
    cvmax(ophrep, 10);
    ophrep  = _ophrep.fixedflag ?  ((void)(10), ophrep) : 10;
    cvdef(ophrep, 10);
    cvmin(ophrep, 1);
    pihrepnub = 2;
    
    opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_OFF), opautorbw) : PSD_OFF;

#ifdef ERMES_DEBUG
    
    use_ermes  = _use_ermes.fixedflag ?  ((void)(0), use_ermes) : 0;
    
#else /* !ERMES_DEBUG */
    use_ermes  = _use_ermes.fixedflag ?  ((void)(1), use_ermes) : 1;
#endif /* ERMES_DEBUG */
    /* MRIge52416 - ezdwi can't be run on SR120 and SR150, lock it out. PH */
    if ( strncasecmp("ezdwi",get_psd_name(),5) == 0 ) {
        if ( ((cfsrmode == PSD_SR50) && (isStarterSystem())) || (cfsrmode == PSD_SR100) || (cfsrmode == PSD_SR120) || (cfsrmode == PSD_SR150) ) {
            epic_error( use_ermes, "EZDWI is not compatible with SR50(Starter System),SR100, SR120 or SR150", EM_PSD_EZDWI_INCOMPATIBLE, EE_ARGS(0) ); 
            return FAILURE;
        } else {
            EZflag  = _EZflag.fixedflag ?  ((void)(PSD_ON), EZflag) : PSD_ON;
        }
    } else {
        EZflag  = _EZflag.fixedflag ?  ((void)(PSD_OFF), EZflag) : PSD_OFF;
    }

#ifdef PSD_HW
    if ( (checkOptionKey( SOK_DWEPI ) == KEY_PRESENT)
         || (checkOptionKey( SOK_DWEPIEZ ) == KEY_PRESENT) )
    {   /* any problem reading option key? */
        dwepi_status = PSD_ON;     /* no-then flag key as present */
    }
    else
    {
        dwepi_status = PSD_OFF;    /* yes-then flag key as absent */
    }
    
    if ( (checkOptionKey( SOK_FLAIREPI ) == KEY_PRESENT)
         || (checkOptionKey( SOK_DWEPIEZ ) == KEY_PRESENT) )
    {   /* any problem reading option key? */
        flairepi_status = PSD_ON;  /* no-then flag key as present */
    } 
    else
    {
        flairepi_status = PSD_OFF; /* yes-then flag key as absent */
    } 

    if (checkOptionKey( SOK_EDWI ) == KEY_PRESENT)
    {   /* any problem reading option key? */
        edwi_status = PSD_ON;      /* no-then flag key as present */
    }
    else
    {
        edwi_status = PSD_OFF;     /* yes-then flag key as absent */
    }

    if (checkOptionKey( SOK_BODYNAV ) == KEY_PRESENT)
    {
        bodynav_status = PSD_ON;   /* no-then flag key as present */
    }
    else
    {
        bodynav_status = PSD_OFF;  /* yes-then flag key as absent */
    }

    if (checkOptionKey( SOK_FOCUS ) == KEY_PRESENT)
    {
        focus_status = PSD_ON;
    }
    else
    {
        focus_status = PSD_OFF;
    }

    if ( checkOptionKey( SOK_SYNDWI ) == KEY_PRESENT )
    {
        syndwi_status = PSD_ON;
    }
    else
    {
        syndwi_status = PSD_OFF;
    }

    if (checkOptionKey( SOK_APX ) == KEY_PRESENT)
    {
        apx_status = PSD_ON;
    }
    else
    {
        apx_status = PSD_OFF;
    }

    if (checkOptionKey( SOK_HYPERBAND ) == KEY_PRESENT)
    {
        multiband_status = PSD_ON;
    }
    else
    {
        multiband_status = PSD_OFF;
    }
    
    if (checkOptionKey( SOK_DISTCORR ) == KEY_PRESENT)
    {
        distcorr_status = PSD_ON;
    }
    else
    {
        distcorr_status = PSD_OFF;
    }

    if (checkOptionKey( SOK_SUPERG ) == KEY_PRESENT)
    {
        superG_key_status = PSD_ON;
    }
    else
    {
        superG_key_status = PSD_OFF;
    }
    if (checkOptionKey( SOK_MUSE ) == KEY_PRESENT) 
    {
        muse_status = PSD_ON;
    }
    else
    {
        muse_status = PSD_OFF;
    }
    if (checkOptionKey( SOK_MAXTENSOR ) == KEY_PRESENT) 
    {
        maxtensor_status = PSD_ON;
    }
    else
    {
        maxtensor_status = PSD_OFF;
    }

#else
    dwepi_status = PSD_ON;
    flairepi_status = PSD_ON;
    edwi_status = PSD_ON;
    bodynav_status = PSD_ON;
    focus_status = PSD_ON;
    syndwi_status = PSD_ON;
    apx_status = PSD_ON;
    multiband_status = PSD_ON;
    distcorr_status  = PSD_ON;
    superG_key_status = PSD_ON;
    muse_status = PSD_ON;
    maxtensor_status = PSD_ON;
#endif

    /***********************************************************************/
    /*	Init some flair  variables					*/
    /************************************************************************/
    cvmax(opepi, PSD_ON);  /* enable epi flag selection */
    cvdef(opepi, PSD_ON);

    cvmax(opdiffuse,PSD_ON);
    cvmax(opflair, PSD_ON);

    cvmin(opexcitemode, SELECTIVE);
    cvmax(opexcitemode, FOCUS);
    cvdef(opexcitemode, SELECTIVE);
    pidefexcitemode = SELECTIVE;

    SetCyclingCVs();

    /***SVBranch: HCSDM00259119  eco mpg ***/
    if (FAILURE == eco_mpg_cvinit())
    {
        epic_error(use_ermes, "ECO-MPG cvinit Failed",
                   EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG, "eco_mpg_cvinit()");
        return FAILURE;
    }
    /**********************/

    if( (PSD_ON == focus_status) && 
        existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) &&
        (PSD_OFF == exist(opflair)) && (PSD_OFF == exist(opasset)) &&
        (opnumgroups <= 1) && (strcmp(get_psd_name(), "epi2alt")) && (mux_flag == PSD_OFF) && (muse_flag == PSD_OFF))
    {
        /* Allow RFOV Focus DWI */
        piexcitemodenub = 1 + 4; /* 1:Selective + 4:Focus */
    }
    else
    {
        piexcitemodenub = 1;     /* Selective only */
    }

    /* MRIhc56268: Dual Spin Echo */
    if( existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) &&
        existcv(opdualspinecho) && (PSD_ON == exist(opdualspinecho)) )
    {
        dualspinecho_flag  = _dualspinecho_flag.fixedflag ?  ((void)(1), dualspinecho_flag) : 1;
    }
    else
    {
        dualspinecho_flag  = _dualspinecho_flag.fixedflag ?  ((void)(0), dualspinecho_flag) : 0;
    }

    if((PSD_ON == exist(opdiffuse)) && (PSD_OFF == rfov_flag))
    {
        pioverlap  = _pioverlap.fixedflag ?  ((void)(PSD_ON), pioverlap) : PSD_ON;
    }
    else
    {
        pioverlap  = _pioverlap.fixedflag ?  ((void)(PSD_OFF), pioverlap) : PSD_OFF;
    }

    if(exist(opdiffuse) == PSD_ON)
    {
        irprep_support  = _irprep_support.fixedflag ?  ((void)(PSD_ON), irprep_support) : PSD_ON;
        edr_support  = _edr_support.fixedflag ?  ((void)(PSD_ON), edr_support) : PSD_ON;
    }
    else
    {
        irprep_support  = _irprep_support.fixedflag ?  ((void)(PSD_OFF), irprep_support) : PSD_OFF;
        edr_support  = _edr_support.fixedflag ?  ((void)(PSD_OFF), edr_support) : PSD_OFF;
    }

    if (DATA_ACQ_TYPE_FLOAT == dacq_data_type)  /* if data type is float(32bits), edr need to be turned on for 32bits data */
    {
        edr_support  = _edr_support.fixedflag ?  ((void)(PSD_ON), edr_support) : PSD_ON;
    }

    /* MRIge65081 */
    if(opcgate==PSD_ON)
        setexist(opcgate,PSD_ON); 
    else
        setexist(opcgate,PSD_OFF); 

    
    /*JAH: MRIge59726 -- added existcv(opuser6) to prevent nuisance failures
      when switching between DW and FLAIR */
    /* irprep_support */
    if ( (exist(opdiffuse) == PSD_ON) && existcv(opuser6) && !exist(opirprep))
    {
        setexist(opflair,PSD_ON);
        _opflair.fixedflag = 0;
        opflair  = _opflair.fixedflag ?  ((void)((int)opuser6), opflair) : (int)opuser6;     /* MRIge56912 - TAA */
        _opflair.fixedflag = 1;
        setexist(opuser6,(opflair == 1)); /*MRIge59726 -- I don't exist when
                                            you don't see me.*/
    }
    
        
    /* MRIge52235 - use opflair instead of opuser6. */ 
    epi_flair  = _epi_flair.fixedflag ?  ((void)(exist(opflair)), epi_flair) : exist(opflair);
    flair_flag  = _flair_flag.fixedflag ?  ((void)(exist(opflair)), flair_flag) : exist(opflair);

    if(irprep_support == PSD_OFF){
        ir_on  = _ir_on.fixedflag ?  ((void)(exist(opflair)), ir_on) : exist(opflair);
        irprep_flag  = _irprep_flag.fixedflag ?  ((void)(PSD_OFF), irprep_flag) : PSD_OFF;
    } else {
        ir_on  = _ir_on.fixedflag ?    ((void)(exist(opflair)|exist(opirprep)), ir_on) : exist(opflair)|exist(opirprep); 
        irprep_flag  = _irprep_flag.fixedflag ?  ((void)(exist(opirprep)), irprep_flag) : exist(opirprep); 
    }

    if ( !strncmp(get_psd_name(), "epi2_stircl",11) )
    {
        /* non-interleaved STIR */
        t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
        ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
    }
    else
    {
        if (irprep_flag)
        {
            if ((exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON) ||
                (navtrig_flag == PSD_ON) || (exist(opirmode) == PSD_ON) ||
                (rfov_flag == PSD_ON))
            {
                t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
                ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
            }
            else
            {
                /* T1flair STIR and Auto TI support only 3T at this time. */
                /* Need evaluation for 1.5T to make them compatible.      */
                if (B0_30000 == cffield)
                {
                    t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_ON), t1flair_flag) : PSD_ON;
                    ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
                }
                else
                {
                    /* Non 3T cases */
                    t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
                    ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
                }
            }
        }
        else
        {
            t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
            ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
        }
    }

    if ((t1flair_flag == PSD_ON) && (ir_prep_manual_tr_mode == PSD_ON))
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2), STRING_ARG, "T1flair mode",STRING_ARG, "Manual TR mode");
        return FAILURE;
    }

    if(epi_flair == PSD_ON)
    {
        false_acqs = _false_acqs.fixedflag ? ((void)(2), false_acqs) : 2;	/* Force false_acqs=2  */
        cvdef(opslquant,4);
    }

    /* flag for cross term correction */
    dwicntrl = _dwicntrl.fixedflag ? ((void)(0), dwicntrl) : 0;
    
    /* Initialize B0 field for maxwell compensation */
    B0_field = _B0_field.fixedflag ? ((void)(cffield), B0_field) : cffield;

    { /* Start of code inlined from vmx.e SysParmInit */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            cvdef(opfov, FOV_MAX_VMX);
            cvmax(opfov, FOV_MAX_VMX);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_VMX), opfov) : FOV_MAX_VMX;
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        else
        {
            cvdef(opfov, cfsystemmaxfov);
            cvmax(opfov, cfsystemmaxfov);
            opfov  = _opfov.fixedflag ?  ((void)(cfsystemmaxfov), opfov) : cfsystemmaxfov;

            cvdef(asfov, cfsystemmaxfov);
            cvmax(asfov, cfsystemmaxfov);
            asfov  = _asfov.fixedflag ?  ((void)(cfsystemmaxfov), asfov) : cfsystemmaxfov;
           
            cvdef(tgfov, cfsystemmaxfov);
            cvmax(tgfov, cfsystemmaxfov);
            tgfov  = _tgfov.fixedflag ?  ((void)(cfsystemmaxfov), tgfov) : cfsystemmaxfov;
            
            cvmax(opmonfov, cfsystemmaxfov);
            
            cvmax(rhscanfov, cfsystemmaxfov * FOV_MAX_SCALE);

            cvmax(rhdispfov, cfsystemmaxfov * FOV_MAX_SCALE);
        }
        if(cffield == 2000)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            cvdef(opfov, FOV_MAX_PROFILE);
            cvmax(opfov, FOV_MAX_PROFILE);
            opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_PROFILE), opfov) : FOV_MAX_PROFILE;
            avmaxfov = FOV_MAX_PROFILE;
        }
        if(cffield <= 2000)
        {
            _opcfsel.fixedflag = 0;
            opcfsel  = _opcfsel.fixedflag ?  ((void)(PSD_CFPK), opcfsel) : PSD_CFPK;
            _opcfsel.existflag = 1;
            _opcfsel.fixedflag = 1;
        }
        if(cffield == 2000)
        {
            /* Maximum integrated (B1)^2 per pulse (uT^2sec) */
            txCoilInfo[getTxIndex(coilInfo[0])].maxB1Squared = 8.0; 
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode  = _psddebugcode.fixedflag ?  ((void)(value), psddebugcode) : value;
            }
        }
        {
            char *envvar; envvar = (char *)getenv("PSDDEBUGCODE2");
            if(envvar)
            {
                int value = (int)strtol(envvar, (char **)NULL, 10);
                psddebugcode2  = _psddebugcode2.fixedflag ?  ((void)(value), psddebugcode2) : value;
            }
        }

#ifdef VMX_VERSION_MFO
        debug_scan  = _debug_scan.fixedflag ?    /*PSDDEBUG_SCAN*/((void)((int)((psddebugcode2&1)!=0)), debug_scan) : (int)((psddebugcode2&1)!=0);
        debug  = _debug.fixedflag ?    /*PSDDEBUG_IPG*/((void)((int)((psddebugcode2&2)!=0)), debug) : (int)((psddebugcode2&2)!=0);
#endif
        debug_grad_spec  = _debug_grad_spec.fixedflag ?    /*PSDDEBUG_GSPEC*/((void)((int)((psddebugcode2&8)!=0)), debug_grad_spec) : (int)((psddebugcode2&8)!=0);
        if(cffield <= 3500)pisupnub = 0;

        switch (cfsrmode)
        {
            case PSD_SR50:
                if((PSD_BRM2_COIL == cfgcoiltype) && (5551 == cfgradamp))
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                }
                else
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_HDE), value_system_flag) : VALUE_SYSTEM_HDE;
                }
                break;
            case PSD_SR100:
                if(cffield == 15000 && PSD_VRMW_COIL != cfgcoiltype)
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(VALUE_SYSTEM_SVEM), value_system_flag) : VALUE_SYSTEM_SVEM;
                }
                else
                {
                    value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
                }
                break;
            default:
                value_system_flag  = _value_system_flag.fixedflag ?  ((void)(NON_VALUE_SYSTEM), value_system_flag) : NON_VALUE_SYSTEM;
        }

        if( VALUE_SYSTEM_HDE == value_system_flag )
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_ON), val15_lock) : PSD_ON;
        }
        else
        {
            val15_lock  = _val15_lock.fixedflag ?  ((void)(PSD_OFF), val15_lock) : PSD_OFF;
        }

       /* SVBranch HCSDM00357453 Mild Note */
        if (PSD_OFF == cfnumartlevels)
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_OFF), mild_note_support) : PSD_OFF;
        }
        else
        {
            mild_note_support  = _mild_note_support.fixedflag ?  ((void)(PSD_ON), mild_note_support) : PSD_ON;
        }
        pinumartlevels  = _pinumartlevels.fixedflag ?  ((void)(cfnumartlevels), pinumartlevels) : cfnumartlevels; /* This parameter will be used by host to manage ART UI */

        if(isRioSystem())
        {
           sphericalGradient  = _sphericalGradient.fixedflag ?  ((void)(PSD_ON), sphericalGradient) : PSD_ON;
        } 
        else
        {  
           sphericalGradient  = _sphericalGradient.fixedflag ?  ((void)(PSD_OFF), sphericalGradient) : PSD_OFF;
        }  
        
        /* Update default values based on the system configuration */
        configSystem();

        /* SVBranch HCSDM00107762 */
        if( isValueSystem() )
        {
             cfcoilswitchmethod   = _cfcoilswitchmethod.fixedflag ?  ((void)(COIL_SWITCH_RSP_SETHUBINDEXIMM), cfcoilswitchmethod) : COIL_SWITCH_RSP_SETHUBINDEXIMM;
        }

        /* Set flags for scan volume shift */
        set_vol_shift_cvs();

    } /* End of code inlined from vmx.e SysParmInit */

    {
        psd_relative_excited_volume_freq  = _psd_relative_excited_volume_freq.fixedflag ?  ((void)(_psd_relative_excited_volume_freq.defval), psd_relative_excited_volume_freq) : _psd_relative_excited_volume_freq.defval;
        psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(_psd_relative_excited_volume_phase.defval), psd_relative_excited_volume_phase) : _psd_relative_excited_volume_phase.defval;
        psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(_psd_relative_excited_volume_slice.defval), psd_relative_excited_volume_slice) : _psd_relative_excited_volume_slice.defval;

        psd_relative_encoded_volume_freq  = _psd_relative_encoded_volume_freq.fixedflag ?  ((void)(_psd_relative_encoded_volume_freq.defval), psd_relative_encoded_volume_freq) : _psd_relative_encoded_volume_freq.defval;
        psd_relative_encoded_volume_phase  = _psd_relative_encoded_volume_phase.fixedflag ?  ((void)(_psd_relative_encoded_volume_phase.defval), psd_relative_encoded_volume_phase) : _psd_relative_encoded_volume_phase.defval;
        psd_relative_encoded_volume_slice  = _psd_relative_encoded_volume_slice.fixedflag ?  ((void)(_psd_relative_encoded_volume_slice.defval), psd_relative_encoded_volume_slice) : _psd_relative_encoded_volume_slice.defval;
    }


    /* default opslquant to 4 slices for the benefit of flair */
    cvdef(opslquant,4);


    cvmod(rhpcspacial, 0, DATA_ACQ_MAX, 1,
          "temporal index of ref scan slice (0=all slices).",0," ");
    cvmod(rhref, 0, 5, 2, "Ref Alg. 0=old, 1=new, 2=N-N sub, 5=integrated",0," ");
    cvmod(opirmode, 0, 1, 0, "Sequential (1) or interleaved (0) mode.",0," ");
    opirmode  = _opirmode.fixedflag ?  ((void)(0), opirmode) : 0;
  
    scan_offset  = _scan_offset.fixedflag ?  ((void)(0), scan_offset) : 0;
    postsat  = _postsat.fixedflag ?  ((void)(PSD_OFF), postsat) : PSD_OFF;
    
    /*
     * Set the gradient calc mode here for selecting the right gradsafety
     * calc technique.
     * NOTE: The gradHeatMethod CV is used in minseq() to decide whether to call
     *       minseqseg() (gradHeatMethod = TRUE -> Linear Segment Method) or
     *       minseqgrad() (gradHeatMethod = FALSE -> Traditional Method).
     */
    gradHeatMethod  = _gradHeatMethod.fixedflag ?  ((void)(PSD_ON), gradHeatMethod) : PSD_ON;

    /* YMSmr07133 */
    if( value_system_flag == VALUE_SYSTEM_HDE ){
        gradDriverMethod  = _gradDriverMethod.fixedflag ?  ((void)(PSD_ON), gradDriverMethod) : PSD_ON;
    }

    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
/* *********************************************************** 
*  Set default values of gradHeatMethod =1, gradCoilMethod =3 and
*  gradHeatFile=0 - Start of Code inlined from AutoAdjustTR.e 
***************************************************************/
#ifdef PGEN_UTIL
      pititle = _pititle.fixedflag ? ((void)(1), pititle) : 1;
      piuset|= use18;
      opuser18  = _opuser18.fixedflag ?  ((void)(1), opuser18) : 1; 
      cvmod (opuser18,0,1,1,"Value of gradHeatMethod: ", 1, "gradHeatMethod");
      cvdesc(pititle, "gradHeatMethod");
     
      gradHeatMethod  = _gradHeatMethod.fixedflag ?   ((void)((int)exist(opuser18)), gradHeatMethod) : (int)exist(opuser18);
      
      cvdesc(pititle,"gradCoilMethod");
      piuset |=use19;
      opuser19  = _opuser19.fixedflag ?  ((void)(3), opuser19) : 3;
      cvmod (opuser19,0,5,3,"Value of gradCoilMethod: ", 3, "gradCoilMethod");
      gradCoilMethod  = _gradCoilMethod.fixedflag ?   ((void)((int)exist(opuser19)), gradCoilMethod) : (int)exist(opuser19);
	
      cvdesc(pititle,"gradHeatFile");
      piuset |= use21;
      opuser21 = _opuser21.fixedflag ? ((void)(0), opuser21) : 0;
      cvmod (opuser21,0,2,0,"Value of gradHeatFile: ", 0, "gradHeatFile");
      gradHeatFile  = _gradHeatFile.fixedflag ?   ((void)((int)exist(opuser21)), gradHeatFile) : (int)exist(opuser21);
      /* MRIhc17231 */	
/*      printf("\ng.HeatMethod= %d,g.CoilMethod=%d,g.HeatFile=%d\n",(int)exist(opuser18),(int)exist(opuser19),(int)exist(opuser21));
      fflush(stdout);
*/ 
#endif
/* End of code inlined from AutoAdjustTR.e */

    if( (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) && ( (PSD_ON == tensor_flag) || (PSD_ON == mux_flag) || (PSD_ON == muse_flag) ) )
    {
        cvmax(optracq, 1);
    }
    else
    {
        cvmax(optracq,1000);
    }


    /* initialize configurable variables */
    EpicConf();

    opautodifnext2  = _opautodifnext2.fixedflag ?  ((void)(1), opautodifnext2) : 1;
    opautonumbvals  = _opautonumbvals.fixedflag ?  ((void)(1), opautonumbvals) : 1;

    opautoti  = _opautoti.fixedflag ?  ((void)(PSD_OFF), opautoti) : PSD_OFF;

    /* ZZ, activate ASPIR through SPECIAL fat sat option */
    if( PSD_ON == exist(opdiffuse) )
    {
        if (exist(opirprep))
        {
            pichemsatopt = 0;
        }
        else
        {
            pichemsatopt = 2;
        }
    }
    else {
        pichemsatopt = 0;
    }

    /* set max nex limit */
    max_difnex_limit  = _max_difnex_limit.fixedflag ?  ((void)(MAX_DIFF_NEX), max_difnex_limit) : MAX_DIFF_NEX;
    if(!value_system_flag && (PSD_ON == exist(opdiffuse)) && (PSD_ON == edwi_status))
    {
        max_difnex_limit  = _max_difnex_limit.fixedflag ?  ((void)(MAX_DIFF_NEX_64), max_difnex_limit) : MAX_DIFF_NEX_64;
    }

    if ( FAILURE == DTI_Init() ) {
        return FAILURE;
    } 

    cvmax(rhreps, 512); /* YMSmr06649 */

    /* Enable > 1024 im/ser only for DTI and Multiphase scans
     * and NOT for DW-Epi since host/recon don't support it
     * -Venkat
     */
    /* MRIhc46718: set enable_1024 ON and increase max_slice_limit to 50,000 for DWI */
    if (PSD_ON == opdiffuse)
    {
        enable_1024 = PSD_ON;
        max_slice_limit = MAX_SLICES_DTI;
        /* Update to number of diffusion directions for Clinical and Research Modes */
        avmaxpasses  = _avmaxpasses.fixedflag ?             ((void)((((PSD_ON==exist(opresearch))&&(rhtensor_file_number>0))?MAX_DIRECTIONS:act_numdir_clinical)+MAX_T2), avmaxpasses) : (((PSD_ON==exist(opresearch))&&(rhtensor_file_number>0))?MAX_DIRECTIONS:act_numdir_clinical)+MAX_T2; 
    }
    else if (PSD_ON == exist(opmph))
    {
        enable_1024 = PSD_ON;
        max_slice_limit = RHF_MAX_IMAGES_MULTIPHASE;
        avmaxpasses  = _avmaxpasses.fixedflag ?  ((void)(PHASES_MAX), avmaxpasses) : PHASES_MAX; 
    }
    else
    {
        enable_1024 = PSD_OFF;
        max_slice_limit = DATA_ACQ_MAX * SLICE_FACTOR;
        avmaxpasses  = _avmaxpasses.fixedflag ?  ((void)(PHASES_MAX), avmaxpasses) : PHASES_MAX; 
    }

    cvmod(rhnslices, 0, max_slice_limit, 1, "opslquant*optphases*opfphases.", 0, " ");


    /* Silent Mode  05/19/2005 YI */
    /* Save configurable variables after conversion by setupConfig() */
    if(set_grad_spec(CONFIG_SAVE,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }

    if( !strncmp(get_psd_name(), "epi2gspec",9) )
    {
        mkgspec_epi2_flag  = _mkgspec_epi2_flag.fixedflag ?  ((void)(PSD_ON), mkgspec_epi2_flag) : PSD_ON;
    }
    else if( !strncmp(get_psd_name(), "gregspec3ax",11) )
    {
        mkgspec_flag  = _mkgspec_flag.fixedflag ?  ((void)(MK_SPEC_MODE_GRAD_3AXES), mkgspec_flag) : MK_SPEC_MODE_GRAD_3AXES;
    }
    else
    {
        mkgspec_flag  = _mkgspec_flag.fixedflag ?  ((void)(MK_SPEC_MODE_OFF), mkgspec_flag) : MK_SPEC_MODE_OFF;
        mkgspec_epi2_flag  = _mkgspec_epi2_flag.fixedflag ?  ((void)(PSD_OFF), mkgspec_epi2_flag) : PSD_OFF;
    }


    if(PSD_ON == mkgspec_epi2_flag)
    {
        piuset |= use22;
        opuser22  = _opuser22.fixedflag ?  ((void)(3.0), opuser22) : 3.0;
        cvmod(opuser22, 0.0, 3.0, 3.0, "MK Gradient Spec Control (0=Off, 1=Gmax, 2=SR, 3=Gmax&SR)",0," ");

        if (existcv(opuser22) && 
            ((exist(opuser22) > 3) || (exist(opuser22) < 0) || (!floatIsInteger(exist(opuser22)))))
        {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser22.descr );
            return FAILURE;
        }

        mkgspec_flag  = _mkgspec_flag.fixedflag ?  ((void)((int)opuser22), mkgspec_flag) : (int)opuser22;
    }
    else
    {
        piuset &= ~use22;
        cvmod( opuser22, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 22", 0, "" );
        cvoverride(opuser22, _opuser22.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        mkgspec_flag  = _mkgspec_flag.fixedflag ?  ((void)(PSD_OFF), mkgspec_flag) : PSD_OFF;
    }

    if( (mkgspec_flag) && (PSD_VRMW_COIL == cfgcoiltype) && (5550 == cfgradamp) ) /* VRMW & SSSD only */
    {
        if(MK_SPEC_MODE_GMAX == mkgspec_flag)
        {
            mkgspec_z_gmax_flag  = _mkgspec_z_gmax_flag.fixedflag ?  ((void)(PSD_ON), mkgspec_z_gmax_flag) : PSD_ON;
            glimit_z  = _glimit_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_GMAX), glimit_z) : MK_SPEC_SSSD_VRMW_GMAX;
            mkgspec_z_sr_flag  = _mkgspec_z_sr_flag.fixedflag ?  ((void)(PSD_OFF), mkgspec_z_sr_flag) : PSD_OFF;
            srate_z  = _srate_z.fixedflag ?  ((void)(save_srate), srate_z) : save_srate;
        }
        else if(MK_SPEC_MODE_SR == mkgspec_flag)
        {
            mkgspec_z_gmax_flag  = _mkgspec_z_gmax_flag.fixedflag ?  ((void)(PSD_ON), mkgspec_z_gmax_flag) : PSD_ON;
            glimit_z  = _glimit_z.fixedflag ?  ((void)(GLIMIT_FOR_MK_SPEC_SSSD_VRMW_SR), glimit_z) : GLIMIT_FOR_MK_SPEC_SSSD_VRMW_SR;
            mkgspec_z_sr_flag  = _mkgspec_z_sr_flag.fixedflag ?  ((void)(MK_SPEC_SR_CHANGE), mkgspec_z_sr_flag) : MK_SPEC_SR_CHANGE;
            srate_z  = _srate_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_SR), srate_z) : MK_SPEC_SSSD_VRMW_SR;
        }
        else if(MK_SPEC_MODE_GMAX_SR == mkgspec_flag)
        {
            mkgspec_z_gmax_flag  = _mkgspec_z_gmax_flag.fixedflag ?  ((void)(PSD_ON), mkgspec_z_gmax_flag) : PSD_ON;
            glimit_z  = _glimit_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_GMAX), glimit_z) : MK_SPEC_SSSD_VRMW_GMAX;
            mkgspec_z_sr_flag  = _mkgspec_z_sr_flag.fixedflag ?  ((void)(MK_SPEC_SR_CHANGE), mkgspec_z_sr_flag) : MK_SPEC_SR_CHANGE;
            srate_z  = _srate_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_SR), srate_z) : MK_SPEC_SSSD_VRMW_SR;
        }
        else if(MK_SPEC_MODE_GRAD_3AXES == mkgspec_flag)
        {
            mkgspec_z_gmax_flag  = _mkgspec_z_gmax_flag.fixedflag ?  ((void)(PSD_ON), mkgspec_z_gmax_flag) : PSD_ON;
            glimit_z  = _glimit_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_GMAX), glimit_z) : MK_SPEC_SSSD_VRMW_GMAX;
            mkgspec_z_sr_flag  = _mkgspec_z_sr_flag.fixedflag ?    ((void)(MK_SPEC_SR_CHANGE+MK_SPEC_DBDT_LIMIT_OFF), mkgspec_z_sr_flag) : MK_SPEC_SR_CHANGE+MK_SPEC_DBDT_LIMIT_OFF;
            srate_z  = _srate_z.fixedflag ?  ((void)(MK_SPEC_SSSD_VRMW_SR), srate_z) : MK_SPEC_SSSD_VRMW_SR;
        }
    }
    else
    {
        mkgspec_z_gmax_flag  = _mkgspec_z_gmax_flag.fixedflag ?  ((void)(PSD_OFF), mkgspec_z_gmax_flag) : PSD_OFF;
        glimit_z  = _glimit_z.fixedflag ?  ((void)(save_gmax), glimit_z) : save_gmax;;
        mkgspec_z_sr_flag  = _mkgspec_z_sr_flag.fixedflag ?  ((void)(PSD_OFF), mkgspec_z_sr_flag) : PSD_OFF;
        srate_z  = _srate_z.fixedflag ?  ((void)(save_srate), srate_z) : save_srate;
    }


    if (PSD_XRMW_COIL == cfgcoiltype)
    {
        config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP321SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP321SR120;
    }

    if( (mkgspec_x_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_y_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_z_sr_flag & MK_SPEC_SR_CHANGE) || 
         mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
    {
        config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_SKIP), config_update_mode) : CONFIG_UPDATE_TYPE_SKIP;
    }

    if( mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
    {
        different_mpg_amp_flag  = _different_mpg_amp_flag.fixedflag ?  ((void)(PSD_ON), different_mpg_amp_flag) : PSD_ON;
    }
    else
    {
        different_mpg_amp_flag  = _different_mpg_amp_flag.fixedflag ?  ((void)(PSD_OFF), different_mpg_amp_flag) : PSD_OFF;
    }

    /* Obl 3in1 opt */
    {
        int i;
        orth_info[0].optloc = 0.0;
        orth_info[0].oprloc = 0.0;
        orth_info[0].opphasoff = 0.0;

        for (i=0; i<9; i++)
        {
            orth_info[0].oprot[i]=0.0;
        }

        orth_info[0].oprot[0] = 1.0;
        orth_info[0].oprot[4] = 1.0;
        orth_info[0].oprot[8] = 1.0;
    }

    inittargets(&loggrd, &phygrd);
    inittargets(&epiloggrd, &epiphygrd);
    inittargets(&orthloggrd, &orthphygrd); /* Obl 3in1 opt */

    /* Get gradient spec for silent mode */
    getSilentSpec(exist(opsilent), _grad_spec_ctrl.fixedflag ? (_temp51_grad_spec_ctrl=grad_spec_ctrl,&_temp51_grad_spec_ctrl) : &grad_spec_ctrl, _glimit.fixedflag ? (_temp52_glimit=glimit,&_temp52_glimit) : &glimit, _srate.fixedflag ? (_temp53_srate=srate,&_temp53_srate) : &srate);

    /* MRIhc56520: for EPI with ART on 750w. */
    if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_XRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(XRMW_3T_EPI_ART_SR), srate) : XRMW_3T_EPI_ART_SR;
    }
    else if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_VRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(VRMW_3T_EPI_ART_SR), srate) : VRMW_3T_EPI_ART_SR;
    }

    if ((cffield == B0_15000) && (cfgcoiltype == PSD_VRMW_COIL))
    {
        k15_system_flag  = _k15_system_flag.fixedflag ?  ((void)(PSD_ON), k15_system_flag) : PSD_ON;        
    }
    else 
    {
        k15_system_flag  = _k15_system_flag.fixedflag ?  ((void)(PSD_OFF), k15_system_flag) : PSD_OFF;
    }

    if( PSD_OFF == exist(opsilent) )
    {
        if( (mkgspec_x_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_y_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_z_sr_flag & MK_SPEC_SR_CHANGE) )
        {
            grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(SRATE_CHANGE), grad_spec_ctrl) : grad_spec_ctrl|SRATE_CHANGE;
            srate  = _srate.fixedflag ?  ((void)(save_srate), srate) : save_srate;
        }
        if( mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
        {
            grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(GMAX_CHANGE), grad_spec_ctrl) : grad_spec_ctrl|GMAX_CHANGE;
            glimit  = _glimit.fixedflag ?  ((void)(save_gmax), glimit) : save_gmax;
        }
    }


    /* Update configurable variables */
    if(set_grad_spec(grad_spec_ctrl,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }

    /* Skip setupConfig() if grad_spec_ctrl is turned on */
    if(grad_spec_change_flag) {
        if(grad_spec_ctrl)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_SKIP), config_update_mode) : CONFIG_UPDATE_TYPE_SKIP;
        else {
            /* MRIhc56453 supported XRMW coil case  Apr 18,2011 YI */
            if (PSD_XRMW_COIL == cfgcoiltype) config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP321SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP321SR120;
            else if(tensor_flag)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_TENSOR), config_update_mode) : CONFIG_UPDATE_TYPE_TENSOR;
            else           config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_ACGD_PLUS), config_update_mode) : CONFIG_UPDATE_TYPE_ACGD_PLUS;
        }
        inittargets(&loggrd, &phygrd);
        inittargets(&epiloggrd, &epiphygrd);
        inittargets(&orthloggrd, &orthphygrd); /* Obl 3in1 opt */
    }
    /* End Silent Mode */

    epiphygrd.xrt = cfrmp2xfs;
    epiphygrd.yrt = cfrmp2yfs;
    epiphygrd.zrt = cfrmp2zfs;
    epiphygrd.xft = cffall2x0;
    epiphygrd.yft = cffall2y0;
    epiphygrd.zft = cffall2z0;
    epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt = IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs);
    epiloggrd.xft = epiloggrd.yft = epiloggrd.zft = IMax(3,cffall2x0,cffall2y0,cffall2z0);

    /* MRIhc18005 */

    /* always set initnewgeo=1 since cvinit (including inittargets) is called on transition
       to scan ops page in 5.5 */
    initnewgeo  = _initnewgeo.fixedflag ?  ((void)(PSD_ON), initnewgeo) : PSD_ON;
   
    /* save this for next call since oblopt set this to zero upon return */
    save_newgeo = initnewgeo;

    if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                        exist(opplane), exist(opcoax), obl_method,
                        obl_debug, _initnewgeo.fixedflag ? (_temp54_initnewgeo=initnewgeo,&_temp54_initnewgeo) : &initnewgeo, cfsrmode)==FAILURE) { 
        /* maybe rot matrices not set */
        epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cvinit()" );
        return FAILURE;
 
    }

    /* Obl 3in1 opt */
    initnewgeo  = _initnewgeo.fixedflag ?  ((void)(save_newgeo), initnewgeo) : save_newgeo;
    if (obloptimize_epi(&orthloggrd, &orthphygrd, orth_info, 1,
                        PSD_AXIAL, 1, obl_method,
                        obl_debug, _initnewgeo.fixedflag ? (_temp55_initnewgeo=initnewgeo,&_temp55_initnewgeo) : &initnewgeo, cfsrmode)==FAILURE) {
        epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cvinit()" );
        return FAILURE;
    }

    /* BJM: MRIge47073 derate non readout waveforms */
    dbdtderate(&loggrd, dbdt_debug);
    dbdtderate(&orthloggrd, dbdt_debug); /* Obl 3in1 opt */
 
    initnewgeo  = _initnewgeo.fixedflag ?  ((void)(save_newgeo), initnewgeo) : save_newgeo;
    if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                        exist(opplane), exist(opcoax), obl_method,
                        obl_debug, _initnewgeo.fixedflag ? (_temp56_initnewgeo=initnewgeo,&_temp56_initnewgeo) : &initnewgeo, cfsrmode)==FAILURE) { 
        /* maybe rot matrices not set */
        epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cvinit()" );
        return FAILURE;

    }    

    cvmod(pw_wgxdl, 0, 1000000, 4, "Diffgrad end to RF2 start delay,us.",0," ");
    cvmod(pw_wgxdr, 0, 1000000, 4, "RF2 end to diffgrad start delay,us.",0," ");
  
    if (use_myscan==1) myscan();

    /* spsp FL90mc or GR30l for excitation, and se1b4 for 
       refocussing */
    cyc_rf1  = _cyc_rf1.fixedflag ?  ((void)(1), cyc_rf1) : 1;
    cyc_rf2  = _cyc_rf2.fixedflag ?  ((void)(1), cyc_rf2) : 1;
  
    if(exist(opdiffuse) == PSD_ON)
        sp_sattype  = _sp_sattype.fixedflag ?  ((void)(2), sp_sattype) : 2;
    else
        sp_sattype  = _sp_sattype.fixedflag ?  ((void)(0), sp_sattype) : 0;

    switch( sp_sattype )
    {
        case 1:
        case 2:
            vrgsat  = _vrgsat.fixedflag ?  ((void)(3), vrgsat) : 3;
            satgap_opt_flag  = _satgap_opt_flag.fixedflag ?  ((void)(PSD_OFF), satgap_opt_flag) : PSD_OFF;
            break;
        default:
            vrgsat  = _vrgsat.fixedflag ?  ((void)(2), vrgsat) : 2;
            satgap_opt_flag  = _satgap_opt_flag.fixedflag ?  ((void)(PSD_ON), satgap_opt_flag) : PSD_ON;
            break;
    }
    
    if (SpSatInit(vrgsat) == FAILURE) return FAILURE;

    if (PSD_ON == exist(opdiffuse))
    {
        piuset |= use5;
        opuser5  = _opuser5.fixedflag ?  ((void)(1.0), opuser5) : 1.0;
        cvmod(opuser5, 0.0, 1.0, 1.0, "Recon Type (0=Zero Filling, 1=Homodyne)",0," ");

        if (existcv(opuser5) && ((exist(opuser5) > 1) || (exist(opuser5) < 0) || (!floatIsInteger(exist(opuser5)))))
        {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser5.descr );
            return FAILURE;
        }


	/* granty edit added user cv to specify which IDE diffusion filename to play out */
        piuset |= use12;
        cvmod(opuser12,60,120,60, "specifies IDE encoding waveform length",0," ");
        opuser12  = _opuser12.fixedflag ?  ((void)(_opuser12.defval), opuser12) : _opuser12.defval;
        if (!floatIsInteger(exist(opuser12)))
        {
              /* Check user-defined opuser12 is an integer */
              epic_error( use_ermes, "User CV 12 is out of range (has to be an a rounded float)", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, _opuser12.descr);
              return FAILURE;
        }

	/* granty edit added user cv to specify which IDE diffusion filename to play out */
        piuset |= use2;
        cvmod(opuser2,0,150,0, "specifies ECC time constant x (ms)",0," ");
        opuser2  = _opuser2.fixedflag ?  ((void)(_opuser2.defval), opuser2) : _opuser2.defval;
        if (!floatIsInteger(exist(opuser2)))
        {
              /* Check user-defined opuser2 is an integer */
              epic_error( use_ermes, "User CV 30 is out of range (has to be an a rounded float)", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, _opuser2.descr);
              return FAILURE;
        }

	/* granty edit added user cv to specify which IDE diffusion filename to play out */
        piuset |= use3;
        cvmod(opuser3,0,150,0, "specifies ECC time constant y (ms)",150," ");
        opuser3  = _opuser3.fixedflag ?  ((void)(_opuser3.defval), opuser3) : _opuser3.defval;
	opuser3  = _opuser3.fixedflag ?  ((void)(150), opuser3) : 150;
        if (!floatIsInteger(exist(opuser3)))
        {
              /* Check user-defined opuser3 is an integer */
              epic_error( use_ermes, "User CV 3 is out of range (has to be an a rounded float)", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, _opuser3.descr);
              return FAILURE;
        }

	/* granty edit added user cv to specify which IDE diffusion filename to play out */
        piuset |= use4;
        cvmod(opuser4,0,150,0, "specifies ECC time constant z (ms)",0," ");
        opuser4  = _opuser4.fixedflag ?  ((void)(_opuser4.defval), opuser4) : _opuser4.defval;
        if (!floatIsInteger(exist(opuser4)))
        {
              /* Check user-defined opuser4 is an integer */
              epic_error( use_ermes, "User CV 32 is out of range (has to be an a rounded float)", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, _opuser4.descr);
              return FAILURE;
        }

	/* granty edit added user cv to specify which phase encode polarity */
        piuset |= use13;
        cvmod(opuser13,0,1,0, "flip phase encode?",0," ");
        opuser13  = _opuser13.fixedflag ?  ((void)(_opuser13.defval), opuser13) : _opuser13.defval;
	pepolar  = _pepolar.fixedflag ?  ((void)(opuser13), pepolar) : opuser13;

        /* HCSDM00398133 HCSDM00419770 */
        /* Moved setting CV8 to setUserCVs() */

        if (tensor_flag)
        {
            /* Add user CV for tensor filename. Research can use >99. */
            if ((PSD_ON == exist(opresearch)) && (isRioSystem() || isDVSystem()))
            {
                piuset |= use11;
                cvmod(opuser11,0,TENSOR_FILE_RSRCH_MAX,0, "Tensor filename = tensor[n].dat (research use >99)",0," ");
                opuser11  = _opuser11.fixedflag ?  ((void)(_opuser11.defval), opuser11) : _opuser11.defval;
                if (!floatIsInteger(exist(opuser11)))
                {
                    /* Check user-defined opuser11 is an integer */
                    epic_error( use_ermes, "User CV 11 is out of range (has to be an a rounded float)", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG, _opuser11.descr);
                    return FAILURE;
                }
                rhtensor_file_number  = _rhtensor_file_number.fixedflag ?  ((void)(opuser11), rhtensor_file_number) : opuser11;
            }
            else
            {
                piuset &= ~use11;
                cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
                cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                rhtensor_file_number  = _rhtensor_file_number.fixedflag ?  ((void)(0), rhtensor_file_number) : 0;
            }
        }
        else
        {
            piuset &= ~use11;
            cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
            cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            rhtensor_file_number  = _rhtensor_file_number.fixedflag ?  ((void)(0), rhtensor_file_number) : 0;
        }

        if(!isRioSystem())
        {
            piuset |= use17;
            opuser17  = _opuser17.fixedflag ?  ((void)(1.0), opuser17) : 1.0;
            cvmod(opuser17, 0.0, 1.0, 1.0, "Integrated Reference Scan (1=on, 0=off)", 0 ," ");
            cvoverride(refless_option, (int)opuser17, PSD_FIX_OFF, PSD_EXIST_ON);

            if (existcv(opuser17) && ((exist(opuser17) > 1) || (exist(opuser17) < 0) || (!floatIsInteger(exist(opuser17)))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser17.descr );
                return FAILURE;
            }
        }
        else
        {
            refless_option  = _refless_option.fixedflag ?  ((void)(1), refless_option) : 1;
        }

        /* HCSDM00398133 HCSDM00419770 */
        /* Moved setting CV18 to setUserCVs() */
        {
            int rtnval;
            rtnval = setUserCVs();
            if(rtnval != SUCCESS)
            {
                return rtnval;
            }
        }

        piuset |= use9;
        opuser9  = _opuser9.fixedflag ?  ((void)(0.0), opuser9) : 0.0;
        cvmod(opuser9, 0.0, 2.0, 0.0, "Shim Volume Mode (0=Default, 1=Breast)", 0, " ");

        if ((exist(opuser9) > 0.51) || (exist(opuser9) < 0.49))
        {
            if (existcv(opuser9) && ((exist(opuser9) > 2) || (exist(opuser9) < 0) || (!floatIsInteger(exist(opuser9)))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser9.descr );
                return FAILURE;
            }

            /* Method 0: Slice Mode CFH + localized Shim */
            /* Method 1: Shim volume Mode CFH + localized shim, on 3T
             * use STEAM instead of PRESS */

            global_shim_method  = _global_shim_method.fixedflag ?  ((void)(PSD_OFF), global_shim_method) : PSD_OFF;

            if ((1 <= (int)exist(opuser9)) && (int)(oppscvquant))
            {
                if (B0_30000 == cffield)
                {
                    cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_ON), cfh_steam_flag) : PSD_ON;
                }
                else
                {
                    cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_OFF), cfh_steam_flag) : PSD_OFF;
                }
                presscfh_override  = _presscfh_override.fixedflag ?  ((void)(3), presscfh_override) : 3; /* shim volume mode CFH */
            }
            else
            {
                cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_OFF), cfh_steam_flag) : PSD_OFF;
                presscfh_override  = _presscfh_override.fixedflag ?  ((void)(PSD_OFF), presscfh_override) : PSD_OFF; /* set to default: slice mode CFH */
            }
        }
        else
        {
            /* Method 2: opuser9 = 0.5 -- Shim volume Mode CFH + Global Shim */
            global_shim_method  = _global_shim_method.fixedflag ?  ((void)(PSD_ON), global_shim_method) : PSD_ON;
            if ((int)(oppscvquant))
            {
                cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_ON), cfh_steam_flag) : PSD_ON;
                presscfh_override  = _presscfh_override.fixedflag ?  ((void)(3), presscfh_override) : 3;
            }
            else
            {
                cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_OFF), cfh_steam_flag) : PSD_OFF;
                presscfh_override  = _presscfh_override.fixedflag ?  ((void)(PSD_OFF), presscfh_override) : PSD_OFF;
            }
        }

        if ( mux_flag && use_slice_fov_shift_blips )
        {
            slice_fov_shift  = _slice_fov_shift.fixedflag ?  ((void)(exist(opaccel_mb_stride)*(INT)ceil(exist(opaccel_ph_stride))), slice_fov_shift) : exist(opaccel_mb_stride)*(INT)ceil(exist(opaccel_ph_stride));
        }
        else
        {
            slice_fov_shift  = _slice_fov_shift.fixedflag ?  ((void)(1), slice_fov_shift) : 1;
        }

        /* SVBranch: HCSDM00339822 */
        if((!isValueSystem()) 
           && (!isRioSystem()) && (!isDVSystem()) && (!(isKizunaSystem()&&(B0_30000==cffield))))
        {
            piuset |= use16;
            opuser16  = _opuser16.fixedflag ?  ((void)(0.0), opuser16) : 0.0;
            cvmod(opuser16, 0.0, 1.0, 0.0, "Legacy Phase Correction (1=on, 0=off)",0," ");

            if (existcv(opuser16) && ((exist(opuser16) > 1) || (exist(opuser16) < 0) || (!floatIsInteger(exist(opuser16)))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser16.descr );
                return FAILURE;
            }

            if ((int)exist(opuser16) == 0)
            {
                pc_enh  = _pc_enh.fixedflag ?  ((void)(PSD_ON), pc_enh) : PSD_ON;
            }
            else
            {
                pc_enh  = _pc_enh.fixedflag ?  ((void)(PSD_OFF), pc_enh) : PSD_OFF;
            }
            hopc_flag  = _hopc_flag.fixedflag ?  ((void)(PSD_OFF), hopc_flag) : PSD_OFF;
        }
        else if(isRioSystem() || isDVSystem() || (isKizunaSystem()&&(B0_30000==cffield)))
        {
            pc_enh  = _pc_enh.fixedflag ?  ((void)(PSD_ON), pc_enh) : PSD_ON;
            if((!isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD)) && opanatomy)
            {
                hopc_flag  = _hopc_flag.fixedflag ?  ((void)(PSD_ON), hopc_flag) : PSD_ON;
            }
            else
            {
                hopc_flag  = _hopc_flag.fixedflag ?  ((void)(PSD_OFF), hopc_flag) : PSD_OFF;
            }
        }
        else
        {
            pc_enh  = _pc_enh.fixedflag ?  ((void)(PSD_OFF), pc_enh) : PSD_OFF;
            hopc_flag  = _hopc_flag.fixedflag ?  ((void)(PSD_OFF), hopc_flag) : PSD_OFF;
        } 

        /***SVBranch: HCSDM00259122 -  For FOCUS Type I pulse ***/
        if (FAILURE == type1_control())
        {
            return FAILURE;
        }

        /* HCSDM00272549: type1 pulse control CV is set invisible to non-FOCUS case; */
        /* HCSDM00522509: Starter use the walk-saturation as default, and make CV21 invisible */
        if ( (PSD_ON == type1_support) && (rfov_flag) && (!isStarterSystem()) )
        {
            piuset |= use21;
            opuser21  = _opuser21.fixedflag ?  ((void)(1), opuser21) : 1;
            cvmod(opuser21, 0, 1, 1, "Homogeneity: 1 = ON, 0 = OFF", 0, " ");

            if (existcv(opuser21) && ((exist(opuser21) > 1) || (exist(opuser21) < 0) || (!floatIsInteger(exist(opuser21)))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser21.descr );
                return FAILURE;
            }
            if ((int)exist(opuser21) == 1)
            {
                homogeneity_flag  = _homogeneity_flag.fixedflag ?  ((void)(PSD_ON), homogeneity_flag) : PSD_ON;
            }
            else
            {
                homogeneity_flag  = _homogeneity_flag.fixedflag ?  ((void)(PSD_OFF), homogeneity_flag) : PSD_OFF;
            }
        }
        else
        {
            piuset &= ~use21;
            cvmod( opuser21, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 21", 0, ""  );
            cvoverride(opuser21, _opuser21.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            homogeneity_flag  = _homogeneity_flag.fixedflag ?  ((void)(PSD_OFF), homogeneity_flag) : PSD_OFF;
            if(isStarterSystem())
            {
                homogeneity_flag  = _homogeneity_flag.fixedflag ?  ((void)(PSD_ON), homogeneity_flag) : PSD_ON;
            }
        }

        /* HCSDM00272549: eco-MPG control CV is set invisible to non-diffusion case; */
        if ( (PSD_ON == eco_mpg_support) && (PSD_ON == exist(opdiffuse)) && existcv(opdiffuse) )
        {
            piuset |= use1;
            opuser1   = _opuser1.fixedflag ?  ((void)(1), opuser1) : 1;
            cvmod(opuser1, 0, 1, 1, "ECO-MPG (0=OFF, 1=ON)", 0, "");

            if (existcv(opuser1) && ((exist(opuser1) > 1) || (exist(opuser1) < 0) || (!floatIsInteger(exist(opuser1)))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser1.descr );
                return FAILURE;
            }
            /* turn on ECO-MPG */
            if ( PSD_ON == (int)exist(opuser1) )
            {
                eco_mpg_flag  = _eco_mpg_flag.fixedflag ?  ((void)(PSD_ON), eco_mpg_flag) : PSD_ON;
            }
            else
            {
                eco_mpg_flag  = _eco_mpg_flag.fixedflag ?  ((void)(PSD_OFF), eco_mpg_flag) : PSD_OFF;
            }
        }
        else
        {
            piuset &= ~use1;
            cvmod( opuser1, -MAXFLOAT, MAXFLOAT, 1.0, "User CV variable 1", 0, "" );
            cvoverride(opuser1, _opuser1.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            eco_mpg_flag  = _eco_mpg_flag.fixedflag ?  ((void)(PSD_OFF), eco_mpg_flag) : PSD_OFF;
        }
    }
    else
    {
        piuset &= ~use5;
        piuset &= ~use9;
        piuset &= ~use11;
        piuset &= ~use16;
        piuset &= ~use17;
        cvmod( opuser5, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 5", 0, "" );
        cvoverride(opuser5, _opuser5.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmod( opuser9, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 9", 0, "" );
        cvoverride(opuser9, _opuser9.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmod( opuser11, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 11", 0, "" );
        cvoverride(opuser11, _opuser11.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmod( opuser16, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 16", 0, "" );
        cvoverride(opuser16, _opuser16.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmod( opuser17, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 17", 0, "" );
        cvoverride(opuser17, _opuser17.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        global_shim_method  = _global_shim_method.fixedflag ?  ((void)(PSD_OFF), global_shim_method) : PSD_OFF;
        presscfh_override  = _presscfh_override.fixedflag ?  ((void)(PSD_OFF), presscfh_override) : PSD_OFF;
        cfh_steam_flag  = _cfh_steam_flag.fixedflag ?  ((void)(PSD_OFF), cfh_steam_flag) : PSD_OFF;
        cvoverride(refless_option, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
        pc_enh  = _pc_enh.fixedflag ?  ((void)(PSD_OFF), pc_enh) : PSD_OFF;
        hopc_flag  = _hopc_flag.fixedflag ?  ((void)(PSD_OFF), hopc_flag) : PSD_OFF;
    }

    /* we add ref_in_scan_flag because potentially more refless options can be added
       and multiple ones would correspond to ref in scan */
    ref_in_scan_flag  = _ref_in_scan_flag.fixedflag ?  ((void)(refless_option), ref_in_scan_flag) : refless_option;

    { /* Start of code inlined from ChemSat.e ChemSatInit */
        cyc_rfcssat  = _cyc_rfcssat.fixedflag ?  ((void)(1), cyc_rfcssat) : 1;
        alpha_rfcssat  = _alpha_rfcssat.fixedflag ?  ((void)(0.46), alpha_rfcssat) : 0.46;
	
        /* SVBranch HCSDM00091804: Duo Chemical Saturation */
	if (PSD_ON == duo_cs_flag)
	{
		n_cspulses  = _n_cspulses.fixedflag ?  ((void)(2), n_cspulses) : 2;
	}else
	{
		n_cspulses  = _n_cspulses.fixedflag ?  ((void)(1), n_cspulses) : 1;
	}


        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
            rfupa = csat_rfupa;
        }
        /* end vmx */

        if (B0_30000 == cffield)
        {
            cs_dda_flip  = _cs_dda_flip.fixedflag ?  ((void)(75), cs_dda_flip) : 75;
        }
        else
        {
            cs_dda_flip  = _cs_dda_flip.fixedflag ?  ((void)(90), cs_dda_flip) : 90;
        }
    } /* End of code inlined from ChemSat.e ChemSatInit */

    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        pipscshimtgnub = PSD_ON;
        if(PSD_SPECTRO == exist(opimode))
        {
            pipscshimtgnub = PSD_OFF;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));

        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if( (cffield == B0_30000) && 
            (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_SPINE) && strstr(attribute_codeMeaning, "Lumbar spine")) &&
            (PSD_OFF == local_tg) )
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }
        else
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
        RScvinit();
        DTGcvinit();
        AutoCoilcvinit();
        ExtCalcvinit();
    } /* End of code inlined from Prescan.e PScvinit */

/* MuseCVInit  inlined from Muse.e */
/* Determine if Muse feature is supported. Currently it is supported in Rio and DV systems*/
{
    if (isRioSystem() || isDVSystem() || (isKizunaSystem() && (B0_30000 == cffield)))
    {
        muse_support  = _muse_support.fixedflag ?  ((void)(PSD_ON), muse_support) : PSD_ON;
    }
    else
    {
        muse_support  = _muse_support.fixedflag ?  ((void)(PSD_OFF), muse_support) : PSD_OFF;
    }

    if (PSD_ON == muse_support && PSD_ON == exist(opdiffuse))
    {
        cvmax(opmuse, PSD_ON);
    }

    if(PSD_ON == muse_support && PSD_ON == exist(opmuse))
    {
        muse_flag  = _muse_flag.fixedflag ?  ((void)(PSD_ON), muse_flag) : PSD_ON;
    }
    else
    {
        muse_flag  = _muse_flag.fixedflag ?  ((void)(PSD_OFF), muse_flag) : PSD_OFF;
    }

    if (muse_flag==PSD_ON)
    {		
        piaccel_ph_stride = 1;
    }
}

      
#include "cvinit.in"

    pw_sspshift  = _pw_sspshift.fixedflag ?  ((void)(400), pw_sspshift) : 400;   /* pulse with of spring for sspwait */
    a_rfcssat  = _a_rfcssat.fixedflag ?  ((void)(.50), a_rfcssat) : .50;
    
    gscale_rf2  = _gscale_rf2.fixedflag ?  ((void)(0.9), gscale_rf2) : 0.9;

    /* ****************************************************
       Advisory Panel 
       
       If piadvise is 1, the advisory panel is supported.
       pimax and pimin are bitmaps that describe which
       advisory panel routines are supported by the psd.
       Scan Rx will activate cardiac gating advisory panel
       values if gating is chosen from the gating screen onward.
       Scan Rx will display the minte2 and maxte2 values 
       if 2 echos are chosen.
       
       Constants for the bitmaps are defined in epic.h
       *********************************************** */
    piadvise = 1; /* Advisory Panel Supported */
    
    /* bit mask for minimum adv. panel values.
     * Scan Rx will remove TE2 entry automatically if 
     * 1 or 4 echos selected. */
    piadvmin = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) +	(1<<PSD_ADVFOV);
    piadvmax = (1<<PSD_ADVECHO) +
        (1<<PSD_ADVTE) + (1<<PSD_ADVTR) +	(1<<PSD_ADVFOV);
  
    /* bit mask for cardiac adv. panel values */
    piadvcard = (1<<PSD_ADVISEQDELAY)
        + (1<<PSD_ADVMAXPHASES) + (1<<PSD_ADVEFFTR) + (1<<PSD_ADVMAXSCANLOCS)
        + (1<<PSD_ADVAVAILIMGTIME);
  
    /* bit mask for scan time adv. panel values */
    piadvtime = (1<<PSD_ADVMINTSCAN) + (1<<PSD_ADVMAXLOCSPERACQ) +
        (1<<PSD_ADVMINACQS) + (1<<PSD_ADVMAXYRES);
  
    /* THE FOLLOWING CODE HAS BEEN REORGANIZED TO FOLLOW */
    /* THE LX INTERFACE LAYOUT - Search on UI to view each section*/
    cvdef(opplane, PSD_AXIAL);
    opplane  = _opplane.fixedflag ?  ((void)(PSD_AXIAL), opplane) : PSD_AXIAL;

    /***** ECHO UI Button Control *******/
    /* Epi2 -> Single echo Only */
    piechnub  = 0;
    opnecho  = _opnecho.fixedflag ?  ((void)(1), opnecho) : 1;
    avminnecho =1;
    avmaxnecho =1;
    
    cvmax(opetl, MAXINT);

	if (muse_flag == PSD_OFF){
            cvdef(opnshots, 1);
            cvmin(opnshots, 1);
            opnshots  = _opnshots.fixedflag ?  ((void)(1), opnshots) : 1;
	}

    /**** Number of SHOTS ******/
    if ((opdiffuse == PSD_ON) || (tensor_flag == PSD_ON)){
        if (muse_flag) {
/* MuseCVInitNumberOfShots inlined from Muse.e */
{
	int i;

	/*set this to maximum number in cvinit & update it with coil related values in cveval(). 
	This is essential such that the parameters in the saved protocol will not be overwritten*/
    max_nshots  = _max_nshots.fixedflag ?  ((void)(MUSE_MAX_NSHOTS), max_nshots) : MUSE_MAX_NSHOTS;  
    min_nshots  = _min_nshots.fixedflag ?  ((void)(MUSE_MIN_NSHOTS), min_nshots) : MUSE_MIN_NSHOTS;

    cvdef(opnshots, min_nshots);
    cvmin(opnshots, min_nshots);
    cvmax(opnshots, max_nshots);

    opnshots  = _opnshots.fixedflag ?  ((void)(min_nshots), opnshots) : min_nshots;

	pishotnub = 1;
	for (i = 1; i < max_nshots; i++)
	{
		pishotnub += 1<<i;
	}

	if ( pishotnub >=63 )
		pishotnub = 63; /* maximum is 6 values */

	pishotval2 = 2;
	pishotval3 = 3;
	pishotval4 = 4;
	pishotval5 = 5;
	pishotval6 = max_nshots;
}   

        }
        else 
        {	
            min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
            max_nshots  = _max_nshots.fixedflag ?  ((void)(1), max_nshots) : 1;
            pishotnub = 2;
            pishotval2 = 1;
        }
    }
    else {
        pishotnub = 63;   /* display "other" + 5 shot buttons (bitmask) */
        pishotval2 = 1;
        pishotval3 = 2;
        pishotval4 = 4;
        pishotval5 = 8;
        pishotval6 = 16;
    }

    /***** TE UI Button Control *********/
    /* te button bitmask:
       1       2          4       8 16 32
       other, automin, autominfull, x, x, x */
    /*  For diffusion MIN TE only */
    if( (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON) ) {
        pite1nub = 63;
        cvdef(opautote,PSD_MINTE);
    } else {
        pite1nub = 63;
    }
    pite1val2 = PSD_MINIMUMTE;    /* 2nd button is autominte */
    pite1val3 = PSD_MINFULLTE;    /* 3rd button is autominte full */
    pitetype = PSD_LABEL_TE_EFF;  /* label te buttons as
                                     "Effective Echo Time" */
    /* Displayed TE Values */
    if (exist(oppseq) == PSD_SE) {

        if ((exist(opdiffuse) == PSD_ON) || (tensor_flag == PSD_ON))
        {
            int min_te1val = (int)ceilf((float)avminte/10000)*10000;

            if (avmintefull > min_te1val + 20000)
            {
                pite1val3 = min_te1val;
                pite1val4 = min_te1val + 10000;
                pite1val5 = min_te1val + 20000;
                pite1val6 = PSD_MINFULLTE;
            }
            else if (avmintefull > min_te1val + 10000)
            {
                pite1val3 = min_te1val;
                pite1val4 = min_te1val + 5000;
                pite1val5 = min_te1val + 10000;
                pite1val6 = PSD_MINFULLTE;
            }
            else
            {
                pite1val3 = PSD_MINFULLTE;
                pite1val4 = min_te1val;
                pite1val5 = min_te1val + 10000;
                pite1val6 = min_te1val + 20000;
            }
        }
        else
        {
            pite1val4 = 20000;
            pite1val5 = 60000;
            pite1val6 = 100000;
        }

        /* No flip angle on UI for SE */
        pifanub = 0;
        acq_type  = _acq_type.fixedflag ?  ((void)(TYPSPIN), acq_type) : TYPSPIN;
    } else {
        pite1val4 = 20000;
        pite1val5 = 30000;
        pite1val6 = 40000;

        /* GRE: flip angle buttons */
        pifanub = 6;
        pifaval2 = 10;
        pifaval3 = 20;
        pifaval4 = 30;
        pifaval5 = 60;
        pifaval6 = 90;
        acq_type  = _acq_type.fixedflag ?  ((void)(TYPGRAD), acq_type) : TYPGRAD;
    }

  
    /* Reasonable TE Defaults */
    cvdef(opte, 175000);
    opte  = _opte.fixedflag ?  ((void)(175000), opte) : 175000;
    
    /* UI Fields TR & TI (FLAIR) */
    if (epi_flair == PSD_ON) {
        
        pitinub = 2;
        pitrnub = 2;
        
        if(cffield==B0_15000) {
            pitival2 = 2200000;
            pitrval2 = 10000000;
        } else if (cffield==B0_10000) {
            pitival2 = 2000000;
            pitrval2 = 8000000;
        } else if(cffield==B0_5000) {
            pitival2 = 1800000; 
            pitrval2 = 6800000;
        }
        else if (cffield == B0_40000) {
            pitival2 = 2200000;
            pitrval2 = 10000000;
            DEBUG_4_0(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000) {
            pitival2 = 2200000;
            pitrval2 = 10000000;
            DEBUG_3_0(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000) {
            pitival2 = 1800000; 
            pitrval2 = 6800000;
            DEBUG_0_7(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_2000) {
            SDL_PrintFStrengthWarning(SD_PSD_EPI2,cffield,__FILE__,__LINE__);
        }
        else {
            SDL_PrintFStrengthWarning(SD_PSD_EPI2,cffield,__FILE__,__LINE__);
        }

        opautoti  = _opautoti.fixedflag ?  ((void)(PSD_OFF), opautoti) : PSD_OFF;

        avminti=FLAIR_MIN_TI;
        avmaxti=FLAIR_MAX_TI;
        avmintr=FLAIR_MIN_TR;
        
        cvmin(opti,FLAIR_MIN_TI);
        cvmax(opti,FLAIR_MAX_TI);
        cvmin(optr,FLAIR_MIN_TR);
        
        cvdef(opti,1500000);
    } else {

        /* TR field */
        pitrnub=6;
        pitrval2 = 2000000;
        pitrval3 = 4000000;
        pitrval4 = 6000000;
        pitrval5 = 8000000;
        pitrval6 = 10000000;
 
        avmintr=TR_MIN;
        cvmin(optr,TR_MIN);
        cvmin(opti,TI_MIN);

        /* irprep_support */
        if(irprep_flag == PSD_ON)
        {
            /* Activate advisory panel checks for TI */
            piadvmin = (piadvmin | (1<<PSD_ADVTI));
            piadvmax = (piadvmax | (1<<PSD_ADVTI));

            pitinub = 5;

            if(cffield == B0_15000)
            {
                pitival2 = 160000;
                pitival3 = 170000;
                pitival4 = 180000;
                pitival5 = 190000;
            }
            else
            {
                pitival2 = 220000;
                pitival3 = 230000;
                pitival4 = 240000;
                pitival5 = 250000;
            }

            if ((PSD_ON == t1flair_flag) || (PSD_ON == ir_prep_manual_tr_mode))
            {
                /* turn on Auto TI for t1flair interleaved STIR */
                piautoti = PSD_ON;
            }
            else
            {
                piautoti = PSD_OFF;
            }

            avmaxti = EPI_STIR_TI_MAX;
            cvmax(opti,EPI_STIR_TI_MAX);
        }
        else if(PSD_ON == exist(opspecir))
        {
            init_ASPIR_TI();
        }
        else
        {
          /* turn off TI field, flair = 0 */
          pitinub=0;
          piautoti = PSD_OFF;
          avmaxti = TI_MAX;
          cvmax(opti,TI_MAX);
        }
    }

    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
pitracqnub = 0;
pitracqval2 = 0;
pitracqval3 = 0;
pitracqval4 = 0;
pitracqval5 = 0;
pitracqval6 = 0;
tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(pitrval3), tr_acq_val3) : pitrval3;
tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
piautotrmode = PSD_AUTO_TR_MODE_IN_RANGE_TR;


    if((exist(opflair) == PSD_ON) || ((PSD_ON == aspir_flag) && (PSD_ON == exist(opautoti))))
    {
        piautotrmode = PSD_AUTO_TR_MODE_MANUAL_TR;
    }

    /* Set min/maxTR for In-Range TR */
    if(PSD_ON == irprep_flag)
    {
        piinrangetrmin = 2500000;
    }
    else
    {
        piinrangetrmin = 2000000;
    }

    piinrangetrmax = TR_MAX_EPI2;
 
    /* Use a large default value for tr */
    cvmax(optr,TR_MAX_EPI2);
    cvdef(optr, 10000000);

    /* RBW UI Choices */
    pircb2nub = 0;    /* turn off 2nd echo rbw buttons */
     
    /* MGD: +/- 250 Digital */
    cvdef(oprbw, 62.5);
    oprbw  = _oprbw.fixedflag ?  ((void)(62.5), oprbw) : 62.5;
   
    pidefrbw = 62.5;
    pircbnub = 5;
    pircbval2 = 250.0;
    pircbval3 = 166.6;
    pircbval4 = 125.0;
    pircbval5 = 62.5;
    
    /* FOV UI Buttons */
    pifovnub = 6;
    pifovval2 = 240;
    pifovval3 = 260;
    pifovval4 = 280;
    pifovval5 = 320;
    pifovval6 = 360;

    /* Xres & Yres UI Options */
    if (muse_flag==PSD_OFF)
    {
        oprect  = _oprect.fixedflag ?  ((void)(0), oprect) : 0;
        cvmin(opxres, 64);
        cvmax(opxres, 256);
        cvdef(opxres, 64);
        opxres  = _opxres.fixedflag ?  ((void)(64), opxres) : 64;

        cvmin(opyres,32);
        cvmax(opyres,256);
        cvdef(opyres, 64);
        opyres  = _opyres.fixedflag ?  ((void)(64), opyres) : 64;
  
        pixresnub = 15; /* bitmask */
        pixresval2 = 64;
        pixresval3 = 128;
        pixresval4 = 256;

        piyresnub = 63;
        piyresval2 = 32;
        piyresval3 = 64;
        piyresval4 = 128;
        piyresval5 = 192;
        piyresval6 = 256;             /* MRIge52734 - lockout 512 yres. */
    }
    else
    {
/* MuseCVInitXYResUIOptions inlined from Muse.e */
{
    cvmax(opxres, 512);
    cvdef(opxres, 256);
    opxres  = _opxres.fixedflag ?  ((void)(192), opxres) : 192;

    cvmax(opyres,512);
    cvdef(opyres, 256);
    opyres  = _opyres.fixedflag ?  ((void)(192), opyres) : 192;

    pixresnub = 63; /* bitmask */
    pixresval2 = 128;
    pixresval3 = 192;
    pixresval4 = 256;
    pixresval5 = 384;
    pixresval6 = 512;

    piyresnub = 63;
    piyresval2 = 128;
    piyresval3 = 192;
    piyresval4 = 256;
    piyresval5 = 384;
    piyresval6 = 512;
}

    }
      
    /* The following are the restrictions for SR20 systems */
    if (( cfsrmode == PSD_SR20 ) || ( cfsrmode == PSD_SR25 ))   /* HOUP */
    {
        pifovnub = 2;
        pifovval2 = 360;
        avminfov = 360;
        avmaxfov = 360;
        
        pistnub = 4;
        pistval2 = 5;
        pistval3 = 7;
        pistval4 = 10;
        avminslthick = 5;
        
        pixresnub = 7;
        pixresval2 = 96;
        pixresval3 = 128;
        cvmin(opxres,96);
        cvmax(opxres,128);
        cvdef(opxres,128);
        opxres = _opxres.fixedflag ? ((void)(128), opxres) : 128;
        
        piyresnub = 2;
        piyresval2 = 128;
        cvmin(opyres,128);
        cvmax(opyres,128);
        cvdef(opyres, 128);
        opyres  = _opyres.fixedflag ?  ((void)(128), opyres) : 128;
    }
    
    /* Ramp Sampled DW & Flair at SR50 & SR77 protocol limits */
    if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON) )
    {
        pifovnub = 6;
        pifovval2 = 240;
        pifovval3 = 280;
        pifovval4 = 320;
        pifovval5 = 360;
        pifovval6 = 400;
        avminfov = 240;
        if(cfsrmode == PSD_SR77)
        {
            avmaxfov = 600;
        }
        else
        {
            avmaxfov = 400;    
        }

        if ( cfsrmode == PSD_SR50 ) {
            pixresnub = 63;
            pixresval2 = 96;
            pixresval3 = 128;
            pixresval4 = 160;
            pixresval5 = 192;
            pixresval6 = 256;
            cvmin(opxres,96);
            cvmax(opxres,256);
            cvdef(opxres,128);
            opxres = _opxres.fixedflag ? ((void)(128), opxres) : 128;
        }
        else
        {
            pixresnub = 63;
            pixresval2 = 128;
            pixresval3 = 160;
            pixresval4 = 192;
            pixresval5 = 224;
            pixresval6 = 256;
            cvmin(opxres,128);
            cvmax(opxres,256);
            cvdef(opxres,128);
            opxres = _opxres.fixedflag ? ((void)(128), opxres) : 128;
        }
        
        piyresnub = 15;
        piyresval2 = 128;
        piyresval3 = 192;
        piyresval4 = 256;
        cvmin(opyres,128);
        cvmax(opyres,256);           /* MRIge52734 - max yres = 256 */
        cvdef(opyres, 128);
        opyres  = _opyres.fixedflag ?  ((void)(128), opyres) : 128;
    }
    

    /* MRIge51174 - Check typein EZDWI, PH */
    if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (EZflag == PSD_ON) )
    {  
        pifovnub = 2;
        pifovval2 = 360;
        avminfov = 360;
        avmaxfov = 360;

        pistnub = 4;
        pistval2 = 5;
        pistval3 = 7;
        pistval4 = 10;
        avminslthick = 5;

        if ( cfsrmode == PSD_SR50 )
        {
            pixresnub = 7;
            pixresval2 = 96;
            pixresval3 = 128;
            cvmin(opxres,96);
            cvmax(opxres,128);
            cvdef(opxres,128);
            opxres = _opxres.fixedflag ? ((void)(128), opxres) : 128;
        }
        else
        {
            pixresnub = 3;
            pixresval2 = 128;
            cvmin(opxres,128);
            cvmax(opxres,128);
            cvdef(opxres,128);
            opxres = _opxres.fixedflag ? ((void)(128), opxres) : 128;
        }

        piyresnub = 2;
        piyresval2 = 128;
        cvmin(opyres,128);
        cvmax(opyres,128);
        cvdef(opyres, 128);
        opyres  = _opyres.fixedflag ?  ((void)(128), opyres) : 128;
    }
    
    if ((cfsrmode == PSD_SR20) || (cfsrmode == PSD_SR25)) {
        cvdef(opslthick, 10.0); 
        opslthick  = _opslthick.fixedflag ?  ((void)(5.0), opslthick) : 5.0; 
    }
    else
    {
        cvdef(opslthick, 10.0);
        opslthick  = _opslthick.fixedflag ?  ((void)(10.0), opslthick) : 10.0;
    }

    if (PSD_SR200 == cfsrmode) 
    { 
        if (ss_rf1 == PSD_ON)
        {
            pistnub = 6; 
            pistval2 = 4; 
            pistval3 = 5; 
            pistval4 = 6; 
            pistval5 = 7; 
            pistval6 = 10; 
        }
        else
        {
            pistnub = 6; 
            pistval2 = 2; 
            pistval3 = 3; 
            pistval4 = 4; 
            pistval5 = 7; 
            pistval6 = 10; 
        }
    }

    cvmax(rhfrsize, 8192);
    cvmax(rhdaxres, 8192);
    
    if (rfov_flag)
    {
        cvmin(opfov, FMax(2, (float)FOV_MIN, (float)(MIN_RFOV/exist(opphasefov))));      /*HCSDM00388767*/
    }
    else
    {
        cvmin(opfov, FOV_MIN);
    }

    cvmax(opfov, FOV_MAX_EPI2);
    cvdef(opfov, FOV_MAX_EPI2);
    opfov  = _opfov.fixedflag ?  ((void)(FOV_MAX_EPI2), opfov) : FOV_MAX_EPI2;

    /* RTG */
    if(exist(opcgate)==PSD_ON || exist(oprtcgate)==PSD_ON || navtrig_flag==PSD_ON || rfov_flag==PSD_ON || mux_flag == PSD_ON)
    {
        piisil = 0;
    } else {
        piisil = 1;
    }
    
    /* multi-phase CVs */
    cvmax(opmph,1);
    cvdef(opmph,0); /* default to MPH off */
    cvdef(opacqo,0);  /* default to interleaved */
    cvdef(opfphases, PHASES_MIN);
    cvmin(opsldelay, -MAXINT); /* YMSmr07177 */
    cvmax(opsldelay,  MAXINT); /* YMSmr07177 */
    cvdef(opsldelay, 1  );
    opsldelay  = _opsldelay.fixedflag ?    ((void)(1), opsldelay) : 1;
    opautosldelay  = _opautosldelay.fixedflag ?  ((void)(1), opautosldelay) : 1;

    /* init epigradopt output structure to point to appropriate CVs */
    gradout.agxw = _a_gxw.fixedflag ? (_temp57_a_gxw=a_gxw,&_temp57_a_gxw) : &a_gxw;
    gradout.pwgxw = _pw_gxw.fixedflag ? (_temp58_pw_gxw=pw_gxw,&_temp58_pw_gxw) : &pw_gxw;
    gradout.pwgxwa = _pw_gxwad.fixedflag ? (_temp59_pw_gxwad=pw_gxwad,&_temp59_pw_gxwad) : &pw_gxwad;
    gradout.agyb = _a_gyb.fixedflag ? (_temp60_a_gyb=a_gyb,&_temp60_a_gyb) : &a_gyb;
    gradout.pwgyb = _pw_gyb.fixedflag ? (_temp61_pw_gyb=pw_gyb,&_temp61_pw_gyb) : &pw_gyb;
    gradout.pwgyba = _pw_gyba.fixedflag ? (_temp62_pw_gyba=pw_gyba,&_temp62_pw_gyba) : &pw_gyba;
    gradout.agzb = _a_gzb.fixedflag ? (_temp63_a_gzb=a_gzb,&_temp63_a_gzb) : &a_gzb;
    gradout.pwgzb = _pw_gzb.fixedflag ? (_temp64_pw_gzb=pw_gzb,&_temp64_pw_gzb) : &pw_gzb;
    gradout.pwgzba = _pw_gzba.fixedflag ? (_temp65_pw_gzba=pw_gzba,&_temp65_pw_gzba) : &pw_gzba;
    gradout.frsize = _temprhfrsize.fixedflag ? (_temp66_temprhfrsize=temprhfrsize,&_temp66_temprhfrsize) : &temprhfrsize;
    gradout.pwsamp = _samp_period.fixedflag ? (_temp67_samp_period=samp_period,&_temp67_samp_period) : &samp_period;
    gradout.pwxgap = _pw_gxgap.fixedflag ? (_temp68_pw_gxgap=pw_gxgap,&_temp68_pw_gxgap) : &pw_gxgap;
    
    /* Turn off EP_TRAIN macro elements we don't want */
    pw_gxcla  = _pw_gxcla.fixedflag ?  ((void)(0), pw_gxcla) : 0;
    pw_gxcl  = _pw_gxcl.fixedflag ?  ((void)(0), pw_gxcl) : 0;
    pw_gxcld  = _pw_gxcld.fixedflag ?  ((void)(0), pw_gxcld) : 0;
    a_gxcl  = _a_gxcl.fixedflag ?  ((void)(0), a_gxcl) : 0;
    pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(0), pw_gxwl) : 0;
    pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(0), pw_gxwr) : 0;
    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    pw_gxcra  = _pw_gxcra.fixedflag ?  ((void)(0), pw_gxcra) : 0;
    pw_gxcr  = _pw_gxcr.fixedflag ?  ((void)(0), pw_gxcr) : 0;
    pw_gxcrd  = _pw_gxcrd.fixedflag ?  ((void)(0), pw_gxcrd) : 0;
    a_gxcr  = _a_gxcr.fixedflag ?  ((void)(.0), a_gxcr) : .0;
  
    /* Enable only the prescan autoshim button and default on, 
     * always keep phase correction on and grey it out */
    pipscoptnub = 1;
    pipscdef = 3;
    _opphcor.fixedflag = PSD_OFF;
    opphcor  = _opphcor.fixedflag ?  ((void)(PSD_ON), opphcor) : PSD_ON;
    cvdef(opphcor, PSD_ON);
    _opphcor.fixedflag = PSD_ON;
    _opphcor.existflag = PSD_ON;
  
    /* OPUSER CV PAGE control */       
    /* Turn on page */      
    pititle  = _pititle.fixedflag ?  ((void)(1), pititle) : 1;
    cvdesc(pititle, "EPI II Feature Controls:");

    /* Only 30 characters per CV are displayed on user CV screen, thats it!
       "123456789012345678901234567890" */

    /* Show ramp Sampling Option */
    piuset |= use0;
    opuser0  = _opuser0.fixedflag ?  ((void)(1.0), opuser0) : 1.0;
    cvmod(opuser0, 0.0, 1.0, 1.0, "Ramp Sampling (1=on, 0=off)",0," ");

    /* MRIge59852: opuser0 range check */
    /* MRIge71092 */
    if( existcv(opuser0) && ((exist(opuser0) > 1) || (exist(opuser0) < 0) || (!floatIsInteger(exist(opuser0))))) 
    {
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser0.descr );
        return FAILURE;
    }

    /* HCSDM00398133 HCSDM00419770 */
    /* Moved setting CV6 to setUserCVs() */

    /* t1flair_stir */
    if ( ( status_flag = T1flairInit() ) != SUCCESS )
    {
        return status_flag;
    }

    /************************************************************************/
    /*	Init some diffusion  variables					*/
    /************************************************************************/
    pidifrecnub=1;

    if(exist(opdiffuse)==PSD_ON) {
        pidifpage=1; 	/* turn on diffusion page */
    } else {
        pidifpage=0;
    }
    
    num_dif = _num_dif.fixedflag ? ((void)(0), num_dif) : 0;
    acqmode = _acqmode.fixedflag ? ((void)(0), acqmode) : 0;	/* default acmode to 0 */
    
    /************************************************************************/
    
    /* Needed for blipcorr() */ 
    cvxfull  = _cvxfull.fixedflag ?  ((void)(cfxfull), cvxfull) : cfxfull;
    cvyfull  = _cvyfull.fixedflag ?  ((void)(cfyfull), cvyfull) : cfyfull;
    cvzfull  = _cvzfull.fixedflag ?  ((void)(cfzfull), cvzfull) : cfzfull;
    

    /* Phase of refocussing pulse shifted by pi/2 relative to alpha pulse
       to compensate for B1 impefections. pi/2 is 0.25 of a cycle. */
    rf1_phase  = _rf1_phase.fixedflag ?  ((void)(0.25), rf1_phase) : 0.25;
    rf2_phase  = _rf2_phase.fixedflag ?  ((void)(0.0), rf2_phase) : 0.0;

    if (FAILURE == Monitor_Cvinit(rfpulse))
    {
        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_Cvinit");
        return FAILURE;
    }

    if (FAILURE == Multiband_cvinit())
    {
        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Multiband_cvinit");
        return FAILURE;
    }

    /* Check for Cal files */
    status_flag = epiCalFileCVInit(); 
    if(status_flag != SUCCESS) return status_flag;

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_ON), opautorbw) : PSD_ON;
    }


    if((!isRioSystem()) && (exist(opdiffuse) == PSD_ON) && (exist(opdfaxall) > PSD_OFF) && (edwi_status == PSD_ON))
    {
       /* Show gradopt_diffall Option */
       piuset |= use7;
       opuser7  = _opuser7.fixedflag ?  ((void)(0.0), opuser7) : 0.0;
       cvmod(opuser7, 0.0, 1.0, 0.0, "Gradient Optimization for Diffusion ALL (1=on, 0=off)",0," ");

       if( existcv(opuser7) && ((exist(opuser7) > 1) || (exist(opuser7) < 0) || (!floatIsInteger(exist(opuser7))))) 
       {
            epic_error( use_ermes, "%s must be set to either 0 or 1.", EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, _opuser7.descr );
            return FAILURE;
       }
       if( floatsAlmostEqualEpsilons(exist(opuser7), 1.0, 2) && (opsavedf != 1))
       {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Recon All Images", STRING_ARG, "Gradient Optimization" );
            return FAILURE;
       }
       gradopt_diffall  = _gradopt_diffall.fixedflag ?  ((void)((int)exist(opuser7)), gradopt_diffall) : (int)exist(opuser7);
    }
    else
    {
       piuset &= ~use7;
       cvoverride(opuser7, 0.0, PSD_FIX_ON, PSD_EXIST_ON);
       gradopt_diffall  = _gradopt_diffall.fixedflag ?  ((void)(PSD_OFF), gradopt_diffall) : PSD_OFF;
    }

    if( (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL || cfgcoiltype == PSD_VRMW_COIL || isRioSystem())  ||
        (opweight > 150 && cffield >= B0_30000 && getTxCoilType() == TX_COIL_BODY &&
         cfgcoiltype == PSD_TRM_COIL) )
    {
       if (ss_rf1 == PSD_ON)
       {
           ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), ss_fa_scaling_flag) : PSD_ON;
       }
       else
       {
           ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ss_fa_scaling_flag) : PSD_OFF;
       }

       if (ir_on == PSD_ON && opweight > 150 && cffield >= B0_30000 &&
           getTxCoilType() == TX_COIL_BODY && cfgcoiltype == PSD_TRM_COIL)
       {
           ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), ir_fa_scaling_flag) : PSD_ON;
       }
       else
       {
           ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ir_fa_scaling_flag) : PSD_OFF;
       }
    }
    else
    {
        ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ss_fa_scaling_flag) : PSD_OFF;
        ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ir_fa_scaling_flag) : PSD_OFF;
    }

    /* enable Fixed RG feature */
    rgfeature_enable  = _rgfeature_enable.fixedflag ?  ((void)(PSD_ON), rgfeature_enable) : PSD_ON;
 
    /* Reversed Phase Encoding polarity is applied for the following conditions
     * 1) using type-in PSD: epi2alt no matter it is regular DWI or Multiband DWI
     * 2) for Multiband DWI, reversed PE polarity is always used unless it is a type-in PSD: epi2altoff */
/*
    if( (!strcmp(get_psd_name(), "epi2alt")) || ((PSD_ON == mux_flag) && strcmp(get_psd_name(), "epi2altoff")) )
    {
        pepolar = PSD_ON;
    }
    else
    {
        pepolar = PSD_OFF;
    }
*/

/* granty edit user controlled phase encode polarity for easier protocol setup */
    if(PSD_ON == mux_flag)
    {
	if( floatsAlmostEqualEpsilons(PSD_ON, opuser13, 2)){
		pepolar  = _pepolar.fixedflag ?  ((void)(PSD_OFF), pepolar) : PSD_OFF;
	} else {
		pepolar  = _pepolar.fixedflag ?  ((void)(PSD_ON), pepolar) : PSD_ON;
	}
    } else {
	pepolar  = _pepolar.fixedflag ?  ((void)(opuser13), pepolar) : opuser13;
    }
    
    /* HCSDM00453434 reset rhdistcorr_ctrl so that cvcheck later is effective. */
    rhdistcorr_ctrl  = _rhdistcorr_ctrl.fixedflag ?  ((void)(0), rhdistcorr_ctrl) : 0;

    if (PSD_ON == exist(opdiffuse))
    {
        if ((PSD_ON == distcorr_status) && /* option key and HW check */
            (PSD_OFF == rfov_flag) && ((asset_factor/(float)(opnshots))<=0.5)) /* PSD options check */
        {
            pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(2), pidistcorrnub) : 2; /* Controls show/hide */
        }
        else
        {
            pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(0), pidistcorrnub) : 0; /* Controls show/hide */
        }
    }
    else
    {
        pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(0), pidistcorrnub) : 0;
    }

    /* turn on opcalrequired CV for ASSET, Multiband and MUSE scan */
    if ( (existcv(opasset) && (PSD_ON == exist(opassetscan))) || (existcv(opmb) && (PSD_ON == exist(opmb)) && (cfaccel_ph_maxstride*cfaccel_sl_maxstride > 1)) || muse_flag ) 
    {
        cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;
    }
    else
    {
        /* set opcalrequired value in loadrheader.e */
        override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_OFF), override_opcalrequired) : PSD_OFF;
    }

    if(existcv(opblim) && (PSD_ON == exist(opblim)))
    {
        if(mux_flag)
        {
            ssgr_flag  = _ssgr_flag.fixedflag ?  ((void)(PSD_OFF), ssgr_flag) : PSD_OFF;
            ssgr_mux  = _ssgr_mux.fixedflag ?  ((void)(PSD_ON), ssgr_mux) : PSD_ON;
        }
        else
        {
            ssgr_flag  = _ssgr_flag.fixedflag ?  ((void)(PSD_ON), ssgr_flag) : PSD_ON;
            ssgr_mux  = _ssgr_mux.fixedflag ?  ((void)(PSD_OFF), ssgr_mux) : PSD_OFF;
        }
    }
    else
    {
        ssgr_flag  = _ssgr_flag.fixedflag ?  ((void)(PSD_OFF), ssgr_flag) : PSD_OFF;
        ssgr_mux  = _ssgr_mux.fixedflag ?  ((void)(PSD_OFF), ssgr_mux) : PSD_OFF;
    }

    if (rfov_flag && (cffield >= B0_30000) &&
        (isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_NECK) ||
         isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_SPINE)))
    {
        focus_B0_robust_mode  = _focus_B0_robust_mode.fixedflag ?  ((void)(PSD_ON), focus_B0_robust_mode) : PSD_ON;
    }
    else
    {
        focus_B0_robust_mode  = _focus_B0_robust_mode.fixedflag ?  ((void)(PSD_OFF), focus_B0_robust_mode) : PSD_OFF;
    }

    /* Set flags for scan volume scale */
    set_vol_scale_cvs(cfgcoiltype,
                      VOL_SCALE_FREQ_DIR_ALLOWED | VOL_SCALE_PHASE_DIR_ALLOWED,
                      VOL_SCALE_CONSTRAINT_NONE,
                      _vol_scale_type.fixedflag ? (_temp69_vol_scale_type=vol_scale_type,&_temp69_vol_scale_type) : &vol_scale_type,
                      _vol_scale_constraint_type.fixedflag ? (_temp70_vol_scale_constraint_type=vol_scale_constraint_type,&_temp70_vol_scale_constraint_type) : &vol_scale_constraint_type);

    return SUCCESS;
    
}   /* end cvinit() */

#ifdef __STDC__ 
STATUS DTI_Init( void )
#else /* !__STDC__ */
STATUS DTI_Init() 
#endif /* __STDC__ */
{   
   gCoilType = cfgcoiltype;

   /* Make sure DTI+ is OFF */
    cvmax(dti_plus_flag,PSD_OFF);

    if( exist(optensor) > 0 )
    {
        tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_ON), tensor_flag) : PSD_ON;    
#ifdef PSD_HW
        /* Option key check */
        if ( checkOptionKey( SOK_TENSOR ) != KEY_PRESENT )
            tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_OFF), tensor_flag) : PSD_OFF;
#endif
    }
    else
        tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_OFF), tensor_flag) : PSD_OFF;

    pidualspinechonub = 1;
    cvdef(opdualspinecho, PSD_OFF);

    /* ACGD_PLUS is the default mode and inittargets:setupConfig
       will check to see if it is really ACGD Plus compatible */
    config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_ACGD_PLUS), config_update_mode) : CONFIG_UPDATE_TYPE_ACGD_PLUS;

    /* TENSOR UI related initializations */    
    if (tensor_flag == PSD_ON) {

        if( existcv(opepi) && (PSD_ON == exist(opepi)) &&
            existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) && 
            existcv(optensor) ) {

            config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_TENSOR), config_update_mode) : CONFIG_UPDATE_TYPE_TENSOR;
        }

        /* Remove interleave slice spacing */
        piisil = PSD_OFF;

        cvdef(opuser0, PSD_ON); 

        if (!vrgf_bwctrl)
        {
            pircbnub = 0;
        }

        pidiffproctype = 1;

        /* MRIge71899 (AC) - remove DTI+ if non-CRM & ACGD system */
        /*MRIge92832 - add HFD 8916 to this*/ 
        /*MRIhc05807 add HFD-S 8917 to this*/
                                               
        if( ((8915 <= cfgradamp && 8925 > cfgradamp) && (PSD_CRM_COIL == gCoilType)) || ((8915 < cfgradamp || 8925 > cfgradamp) && (PSD_TRM_COIL == gCoilType) && (TRM_ZOOM_COIL == opgradmode) ) ) {
            piuset |= use10; /* opuser for gradient switching for tensor ALP */
            cvmod(opuser10, 0.0, 1.0, 0.0, "DTI+ (1=on, 0=off)",0," ");
            opuser10  = _opuser10.fixedflag ?  ((void)(_opuser10.defval), opuser10) : _opuser10.defval;
            cvmax(dti_plus_flag,PSD_ON);
        } else {
           
            piuset &= ~use10;
            cvmod( opuser10, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 10", 0, "" );
            cvoverride(opuser10, _opuser10.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        }

        /* screen for diffusion directions */
        pidifnumdirsnub = 15;       
        pidifnumdirsval2 = MIN_DTI_DIRECTIONS;
        pidifnumdirsval3 = 15;
        pidifnumdirsval4 = 25;

        /* screen for number of T2 images */
        opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(0), opautodifnumt2) : 0;
        pidifnumt2nub = 15;    
        pidifnumt2val2 = 1;
        pidifnumt2val3 = 2;
        pidifnumt2val4 = 3;

        pibvalstab = 1; /* show bvalue table */
        pidifnextab = 1; /* show NEX table */
        avmindifnextab = 1;
        avmaxdifnextab = max_difnex_limit;

        pinumbnub = 0;  /* number of b value allowed only 1 */
        avminnumbvals = 1;
        avmaxnumbvals = 1;
        cvoverride(opnumbvals, 1, PSD_FIX_ON, PSD_EXIST_ON);

        pidifnext2nub = 0;   /* NEX for T2 disabled */
        avmindifnext2 = difnextab[0];
        avmaxdifnext2 = difnextab[0];
        cvoverride(opdifnext2, difnextab[0], PSD_FIX_ON, PSD_EXIST_ON);

        pinexnub = 0; /* disable opnex */

        if (PSD_ON == maxtensor_status)
        {
            cvoverride(act_numdir_clinical, MAX_DTI_CLINICAL, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            cvoverride(act_numdir_clinical, MAX_DTI_LEGACY, PSD_FIX_ON, PSD_EXIST_ON);
        }

    } else {

        /* turn interleave slice spacing field back on */
        piisil = PSD_ON;

        piuset &= ~use10;
        cvmod( opuser10, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 10", 0, "" );
        cvoverride(opuser10, _opuser10.defval, PSD_FIX_OFF, PSD_EXIST_OFF);


        if(exist(opdiffuse) == PSD_ON)
        {
            if(edwi_status == PSD_ON)
            {
                /* screen for number of T2 images */
                opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(0), opautodifnumt2) : 0;
                pidifnumt2nub = 7;    
                pidifnumt2val2 = 0;   
                pidifnumt2val3 = 1;  

                pibvalstab = 1;  /* show bvalue table */
                pidifnextab = 1; /* show NEX table */
                avmindifnextab = 1;
                avmaxdifnextab = max_difnex_limit;

                pinumbnub = 63;
                pinumbval2 = 1;
                pinumbval3 = 5;
                pinumbval4 = 10;
                pinumbval5 = 20;
                pinumbval6 = 40;
                avminnumbvals = 1;
                avmaxnumbvals = MAX_NUM_BVALS_PSD;

                if(exist(opdifnumt2) == 1)
                {
                    /* T2 image acquisition on.  Enable NEX for T2 control */
                    pidifnext2nub = 63;
                    if(exist(opdifnext2) < 1.0)
                    {
                        cvoverride(opdifnext2, 1.0, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    avmindifnext2 = 1;
                    avmaxdifnext2 = max_difnex_limit;
                }
                else if(exist(opdifnumt2) == 0)
                {
                    /* T2 image acquisition off.  Disable NEX for T2 control */
                    cvoverride(opdifnext2, 0.0, PSD_FIX_ON, PSD_EXIST_ON);
                    pidifnext2nub = 0;
                    avmindifnext2 = 0;
                    avmaxdifnext2 = 0;
                }
                pidifnext2val2 = 1;
                pidifnext2val3 = 2;
                pidifnext2val4 = 4;
                pidifnext2val5 = 8;
                pidifnext2val6 = 16;
            }
            else
            {
                /* No eDWI support */
                avmindifnextab = 1;
                avmaxdifnextab = max_difnex_limit;

                /* Always acquire single T2 image */
                opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(1), opautodifnumt2) : 1;
                pidifnumt2nub = 0;
                cvoverride(opdifnumt2, 1, PSD_FIX_ON, PSD_EXIST_ON);

                /* Use name NEX for T2 and DW images */ 
                pidifnext2nub = 0;
                cvoverride(opdifnext2, difnextab[0], PSD_FIX_ON, PSD_EXIST_ON);

                /* Only supports 1 b-value */
                pinumbnub = 0;
                cvoverride(opnumbvals, 1, PSD_FIX_ON, PSD_EXIST_ON);

            }

            pinexnub = 0; /* disable opnex */

        }

    }
    dti_plus_flag  = _dti_plus_flag.fixedflag ?  ((void)((int)exist(opuser10)), dti_plus_flag) : (int)exist(opuser10);

    update_opmintedif();

    return SUCCESS;
} /* end DTI_Init */

/* granty function for reading in length of custom gradient files */
STATUS read_grad_res(float wave_number, int* res_gd1, int* res_gd2){
	char fname[80],junk[80];
	FILE *fid;

#ifndef PSD_HW
	    sprintf(fname,"wave%d.dat",(int)wave_number);
#else
	    sprintf(fname,"/usr/g/research/daiep/qti/WAVES/wave%d.dat",(int)wave_number);
#endif 

	fid = fopen(fname,"r");
	if (fid==NULL) {
    		fprintf(stderr, "Error opening grad pulse file:  %s!!\n",fname);
    		fflush (stderr);
    		return FAILURE;
	}
	/* length of first diffusion encoding waveform */
	fscanf(fid,"%d %s",res_gd1,junk);
	/* length of second diffusion encoding waveform */
	fscanf(fid,"%d %s",res_gd2,junk);
	fclose(fid);
	return SUCCESS;
}


float sat_info[6][9];
float abswidth_sat, effwidth_sat; /* Abs width and Eff Width for Sat pulses */

/* Routine to initialize RF pulse structures */
void
sp_init_rf( INT *pw_ptr,
            FLOAT *amp_ptr,
            FLOAT *flip_ptr,
            INT type,
            RF_PULSE *rfstruct )
{
    switch (type)
    {
    case SINC_SAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = SAR_ABS_SINC1;
        rfstruct->effwidth = SAR_PSINC1;
        rfstruct->area     = SAR_ASINC1;
        rfstruct->dtycyc   = SAR_DTYCYC_SINC1;
        rfstruct->maxpw    = SAR_MAXPW_SINC1;
        rfstruct->num      = 0;
        rfstruct->max_b1 = 0.073;
        rfstruct->max_int_b1_sq = 0.00345;
        rfstruct->max_rms_b1 = 0.0328;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 3200 ;
        rfstruct->nom_bw = 1250.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = TRUE;
        rfstruct->apply_as_hadamard_factor = 1;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(REAL_RF), sat_pulse_type) : REAL_RF;
        break;
 
    case SLR_SAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = SAR_ABS_SLR;
        rfstruct->effwidth = SAR_PSLR;
        rfstruct->area     = SAR_ASLR;
        rfstruct->dtycyc   = SAR_DTYCYC_SLR;
        rfstruct->maxpw    = SAR_MAXPW_SLR;
        rfstruct->max_b1 = MAX_B1_DBLSATL0;
        rfstruct->max_int_b1_sq = MAX_INT_B1_SQ_DBLSATL0;
        rfstruct->max_rms_b1 = MAX_RMS_B1_DBLSATL0;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 4000 ;
        rfstruct->nom_bw = 1562.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = TRUE;
        rfstruct->num      = 0;
        rfstruct->apply_as_hadamard_factor = 1;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(REAL_RF), sat_pulse_type) : REAL_RF;
        break;

    case SLR_CSAT:
        *amp_ptr = 1.0;
        rfstruct->pw = pw_ptr;
        rfstruct->amp = amp_ptr;
        rfstruct->abswidth = 0.3472;
        rfstruct->effwidth = 0.2506;
        rfstruct->area     = 0.3472;
        rfstruct->dtycyc   = 0.9960;
        rfstruct->maxpw    = 0.9960;
        rfstruct->max_b1 = 0.105;
        rfstruct->max_int_b1_sq = 0.00179175;
        rfstruct->max_rms_b1 = 0.0211646;
        rfstruct->nom_fa = 90.0;
        rfstruct->act_fa = flip_ptr;
        rfstruct->nom_pw = 4000 ;
        rfstruct->nom_bw = 3000.0;
        rfstruct->activity = PSD_PULSE_OFF;
        rfstruct->reference = FALSE;
        rfstruct->num      = 0;
        rfstruct->apply_as_hadamard_factor = 1;
        sat_pulse_type  = _sat_pulse_type.fixedflag ?  ((void)(COMPLEX_RF), sat_pulse_type) : COMPLEX_RF;
        break;

    default:
        break;
    }
    
    abswidth_sat = rfstruct->abswidth; 
    effwidth_sat = rfstruct->effwidth;
    
    return;
}

STATUS
SpSatInit( INT sat_type )
{
#ifdef ERMES_DEBUG
    use_ermes  = _use_ermes.fixedflag ?  ((void)(0), use_ermes) : 0;
#else /* !ERMES_DEBUG */
    use_ermes  = _use_ermes.fixedflag ?  ((void)(1), use_ermes) : 1;
#endif /* ERMES_DEBUG */

    /* vmx 3/13/95 YI */
    if( cfpwrmontyp == PMTYP_VMX ) 
    {
        spsat_sys_type  = _spsat_sys_type.fixedflag ?  ((void)(1), spsat_sys_type) : 1;
        rfupa = spsat_rfupa;
    }
    /* end vmx */

    /* Note that pw_isisat & pw_rotdelay must be multiples of 4. Otherwise
       gradients do not occur on 4us boundaries that are required. */
    pw_isisat  = _pw_isisat.fixedflag ?    ((void)(RUP_GRD(200)), pw_isisat) : RUP_GRD(200); /*MRIge61221, SK */

    /* Calculate delay of rotation matrix relative to total SSP delay */
    isi_satdelay  = _isi_satdelay.fixedflag ?    ((void)(RDN_GRD(pw_isisat-psd_grd_wait)), isi_satdelay) : RDN_GRD(pw_isisat-psd_grd_wait);
    isi_extra  = _isi_extra.fixedflag ?    ((void)(32), isi_extra) : 32;     /* Make sure 32us after rot. update before
                             next gradient attack */

    rot_delay  = _rot_delay.fixedflag ?  ((void)(RUP_GRD(psd_grd_wait)), rot_delay) : RUP_GRD(psd_grd_wait); /* Make sure that rotation is done after
                                          gradient delay has been delayed in
                                          WARP */
    pw_rotupdate  = _pw_rotupdate.fixedflag ?    ((void)(RUP_GRD(12)), pw_rotupdate) : RUP_GRD(12); /* MRIge61221 , SK */

    /* MRIge77195 Changed default SAT thickness to 40mm */
    satthickx1  = _satthickx1.fixedflag ?  ((void)(40), satthickx1) : 40;  /* Default SAT thickness */
    satthickx2  = _satthickx2.fixedflag ?  ((void)(40), satthickx2) : 40;
    satthicky1  = _satthicky1.fixedflag ?  ((void)(40), satthicky1) : 40;
    satthicky2  = _satthicky2.fixedflag ?  ((void)(40), satthicky2) : 40;
    satthickz1  = _satthickz1.fixedflag ?  ((void)(40), satthickz1) : 40;
    satthickz2  = _satthickz2.fixedflag ?  ((void)(40), satthickz2) : 40;

    exsatthick1  = _exsatthick1.fixedflag ?  ((void)(80), exsatthick1) : 80; /* Explicit SAT thickness */
    exsatthick2  = _exsatthick2.fixedflag ?  ((void)(80), exsatthick2) : 80;
    exsatthick3  = _exsatthick3.fixedflag ?  ((void)(80), exsatthick3) : 80;
    exsatthick4  = _exsatthick4.fixedflag ?  ((void)(80), exsatthick4) : 80;
    exsatthick5  = _exsatthick5.fixedflag ?  ((void)(80), exsatthick5) : 80;
    exsatthick6  = _exsatthick6.fixedflag ?  ((void)(80), exsatthick6) : 80;
 
    gsat_scale  = _gsat_scale.fixedflag ?  ((void)(1), gsat_scale) : 1;

    flip_rfsx1  = _flip_rfsx1.fixedflag ?  ((void)(90.0), flip_rfsx1) : 90.0; /* Default SAT flip angles */
    flip_rfsx2  = _flip_rfsx2.fixedflag ?  ((void)(90.0), flip_rfsx2) : 90.0;
    flip_rfsy1  = _flip_rfsy1.fixedflag ?  ((void)(90.0), flip_rfsy1) : 90.0;
    flip_rfsy2  = _flip_rfsy2.fixedflag ?  ((void)(90.0), flip_rfsy2) : 90.0;
    flip_rfsz1  = _flip_rfsz1.fixedflag ?  ((void)(90.0), flip_rfsz1) : 90.0;
    flip_rfsz2  = _flip_rfsz2.fixedflag ?  ((void)(90.0), flip_rfsz2) : 90.0;

    flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(90.0), flip_rfse1) : 90.0; /* Explicit SAT slip angles */
    flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(90.0), flip_rfse2) : 90.0;
    flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(90.0), flip_rfse3) : 90.0;
    flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(90.0), flip_rfse4) : 90.0;
    flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(90.0), flip_rfse5) : 90.0;
    flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(90.0), flip_rfse6) : 90.0;
  
    if (opfluorotrigger)
    {
        flip_rfsx1  = _flip_rfsx1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsx1) : rtia3d_sat_flip; /* Default SAT flip angles */
        flip_rfsx2  = _flip_rfsx2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsx2) : rtia3d_sat_flip;
        flip_rfsy1  = _flip_rfsy1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsy1) : rtia3d_sat_flip;
        flip_rfsy2  = _flip_rfsy2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsy2) : rtia3d_sat_flip;
        flip_rfsz1  = _flip_rfsz1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsz1) : rtia3d_sat_flip;
        flip_rfsz2  = _flip_rfsz2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfsz2) : rtia3d_sat_flip;

        flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse1) : rtia3d_sat_flip; /* Explicit SAT slip angles */
        flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse2) : rtia3d_sat_flip;
        flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse3) : rtia3d_sat_flip;
        flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse4) : rtia3d_sat_flip;
        flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse5) : rtia3d_sat_flip;
        flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(rtia3d_sat_flip), flip_rfse6) : rtia3d_sat_flip;
    }
 
    /* Initialize resolutions for rf pulse & 
       RF pulse structure in grad_rf_data.h */
    switch (sat_type)
    {
    case SINC_SAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx1) : RES_NVRGSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx2) : RES_NVRGSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy1) : RES_NVRGSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy2) : RES_NVRGSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz1) : RES_NVRGSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz2) : RES_NVRGSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse1) : RES_NVRGSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse2) : RES_NVRGSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse3) : RES_NVRGSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse4) : RES_NVRGSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse5) : RES_NVRGSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse6) : RES_NVRGSAT;

        pw_rfs  = _pw_rfs.fixedflag ?   ((void)(3200), pw_rfs) : 3200;
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(RUP_RF((int)ceilf(lp_stretch*pw_rfs))), pw_rfs) : RUP_RF((int)ceilf(lp_stretch*pw_rfs));
        }

        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(1), cyc_rfs) : 1;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp71_pw_rfsx1=pw_rfsx1,&_temp71_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp72_a_rfsx1=a_rfsx1,&_temp72_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp73_flip_rfsx1=flip_rfsx1,&_temp73_flip_rfsx1) : &flip_rfsx1, SINC_SAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp74_pw_rfsx2=pw_rfsx2,&_temp74_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp75_a_rfsx2=a_rfsx2,&_temp75_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp76_flip_rfsx2=flip_rfsx2,&_temp76_flip_rfsx2) : &flip_rfsx2, SINC_SAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp77_pw_rfsy1=pw_rfsy1,&_temp77_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp78_a_rfsy1=a_rfsy1,&_temp78_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp79_flip_rfsy1=flip_rfsy1,&_temp79_flip_rfsy1) : &flip_rfsy1, SINC_SAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp80_pw_rfsy2=pw_rfsy2,&_temp80_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp81_a_rfsy2=a_rfsy2,&_temp81_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp82_flip_rfsy2=flip_rfsy2,&_temp82_flip_rfsy2) : &flip_rfsy2, SINC_SAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp83_pw_rfsz1=pw_rfsz1,&_temp83_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp84_a_rfsz1=a_rfsz1,&_temp84_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp85_flip_rfsz1=flip_rfsz1,&_temp85_flip_rfsz1) : &flip_rfsz1, SINC_SAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp86_pw_rfsz2=pw_rfsz2,&_temp86_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp87_a_rfsz2=a_rfsz2,&_temp87_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp88_flip_rfsz2=flip_rfsz2,&_temp88_flip_rfsz2) : &flip_rfsz2, SINC_SAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp89_pw_rfse1=pw_rfse1,&_temp89_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp90_a_rfse1=a_rfse1,&_temp90_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp91_flip_rfse1=flip_rfse1,&_temp91_flip_rfse1) : &flip_rfse1, SINC_SAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp92_pw_rfse2=pw_rfse2,&_temp92_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp93_a_rfse2=a_rfse2,&_temp93_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp94_flip_rfse2=flip_rfse2,&_temp94_flip_rfse2) : &flip_rfse2, SINC_SAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp95_pw_rfse3=pw_rfse3,&_temp95_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp96_a_rfse3=a_rfse3,&_temp96_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp97_flip_rfse3=flip_rfse3,&_temp97_flip_rfse3) : &flip_rfse3, SINC_SAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp98_pw_rfse4=pw_rfse4,&_temp98_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp99_a_rfse4=a_rfse4,&_temp99_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp100_flip_rfse4=flip_rfse4,&_temp100_flip_rfse4) : &flip_rfse4, SINC_SAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp101_pw_rfse5=pw_rfse5,&_temp101_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp102_a_rfse5=a_rfse5,&_temp102_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp103_flip_rfse5=flip_rfse5,&_temp103_flip_rfse5) : &flip_rfse5, SINC_SAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp104_pw_rfse6=pw_rfse6,&_temp104_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp105_a_rfse6=a_rfse6,&_temp105_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp106_flip_rfse6=flip_rfse6,&_temp106_flip_rfse6) : &flip_rfse6, SINC_SAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    case SLR_SAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;

        pw_rfs = _pw_rfs.fixedflag ?   ((void)(4000), pw_rfs) : 4000;
        if (opfluorotrigger) 
        {
            if (cffield > B0_15000)
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(6400), pw_rfs) : 6400;
            }
            else
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(1000), pw_rfs) : 1000;
            }
        }
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(RUP_RF((int)ceilf(lp_stretch*pw_rfs))), pw_rfs) : RUP_RF((int)ceilf(lp_stretch*pw_rfs));
        }
        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(1.21), cyc_rfs) : 1.21;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp107_pw_rfsx1=pw_rfsx1,&_temp107_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp108_a_rfsx1=a_rfsx1,&_temp108_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp109_flip_rfsx1=flip_rfsx1,&_temp109_flip_rfsx1) : &flip_rfsx1, SLR_SAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp110_pw_rfsx2=pw_rfsx2,&_temp110_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp111_a_rfsx2=a_rfsx2,&_temp111_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp112_flip_rfsx2=flip_rfsx2,&_temp112_flip_rfsx2) : &flip_rfsx2, SLR_SAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp113_pw_rfsy1=pw_rfsy1,&_temp113_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp114_a_rfsy1=a_rfsy1,&_temp114_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp115_flip_rfsy1=flip_rfsy1,&_temp115_flip_rfsy1) : &flip_rfsy1, SLR_SAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp116_pw_rfsy2=pw_rfsy2,&_temp116_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp117_a_rfsy2=a_rfsy2,&_temp117_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp118_flip_rfsy2=flip_rfsy2,&_temp118_flip_rfsy2) : &flip_rfsy2, SLR_SAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp119_pw_rfsz1=pw_rfsz1,&_temp119_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp120_a_rfsz1=a_rfsz1,&_temp120_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp121_flip_rfsz1=flip_rfsz1,&_temp121_flip_rfsz1) : &flip_rfsz1, SLR_SAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp122_pw_rfsz2=pw_rfsz2,&_temp122_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp123_a_rfsz2=a_rfsz2,&_temp123_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp124_flip_rfsz2=flip_rfsz2,&_temp124_flip_rfsz2) : &flip_rfsz2, SLR_SAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp125_pw_rfse1=pw_rfse1,&_temp125_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp126_a_rfse1=a_rfse1,&_temp126_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp127_flip_rfse1=flip_rfse1,&_temp127_flip_rfse1) : &flip_rfse1, SLR_SAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp128_pw_rfse2=pw_rfse2,&_temp128_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp129_a_rfse2=a_rfse2,&_temp129_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp130_flip_rfse2=flip_rfse2,&_temp130_flip_rfse2) : &flip_rfse2, SLR_SAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp131_pw_rfse3=pw_rfse3,&_temp131_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp132_a_rfse3=a_rfse3,&_temp132_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp133_flip_rfse3=flip_rfse3,&_temp133_flip_rfse3) : &flip_rfse3, SLR_SAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp134_pw_rfse4=pw_rfse4,&_temp134_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp135_a_rfse4=a_rfse4,&_temp135_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp136_flip_rfse4=flip_rfse4,&_temp136_flip_rfse4) : &flip_rfse4, SLR_SAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp137_pw_rfse5=pw_rfse5,&_temp137_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp138_a_rfse5=a_rfse5,&_temp138_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp139_flip_rfse5=flip_rfse5,&_temp139_flip_rfse5) : &flip_rfse5, SLR_SAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp140_pw_rfse6=pw_rfse6,&_temp140_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp141_a_rfse6=a_rfse6,&_temp141_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp142_flip_rfse6=flip_rfse6,&_temp142_flip_rfse6) : &flip_rfse6, SLR_SAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    case SLR_CSAT:
        res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx1) : RES_SLRCSAT;
        res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx2) : RES_SLRCSAT;
        res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy1) : RES_SLRCSAT;
        res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy2) : RES_SLRCSAT;
        res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz1) : RES_SLRCSAT;
        res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz2) : RES_SLRCSAT;
        res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse1) : RES_SLRCSAT;
        res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse2) : RES_SLRCSAT;
        res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse3) : RES_SLRCSAT;
        res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse4) : RES_SLRCSAT;
        res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse5) : RES_SLRCSAT;
        res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse6) : RES_SLRCSAT;

        pw_rfs = _pw_rfs.fixedflag ?   ((void)(4000), pw_rfs) : 4000;
        if (opfluorotrigger)
        {
            if (cffield > B0_15000)
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(6400), pw_rfs) : 6400;
            }
            else
            {
               pw_rfs  = _pw_rfs.fixedflag ?   ((void)(1000), pw_rfs) : 1000;
            }
        }
        if(lp_mode ==1)
        {
            pw_rfs = _pw_rfs.fixedflag ? ((void)(RUP_RF((int)ceilf(lp_stretch*pw_rfs))), pw_rfs) : RUP_RF((int)ceilf(lp_stretch*pw_rfs));
        }
        cyc_rfs  = _cyc_rfs.fixedflag ?  ((void)(3.0), cyc_rfs) : 3.0;

        sp_init_rf(_pw_rfsx1.fixedflag ? (_temp143_pw_rfsx1=pw_rfsx1,&_temp143_pw_rfsx1) : &pw_rfsx1, _a_rfsx1.fixedflag ? (_temp144_a_rfsx1=a_rfsx1,&_temp144_a_rfsx1) : &a_rfsx1, _flip_rfsx1.fixedflag ? (_temp145_flip_rfsx1=flip_rfsx1,&_temp145_flip_rfsx1) : &flip_rfsx1, SLR_CSAT,
                   &rfpulse[RFSX1_SLOT]);
        sp_init_rf(_pw_rfsx2.fixedflag ? (_temp146_pw_rfsx2=pw_rfsx2,&_temp146_pw_rfsx2) : &pw_rfsx2, _a_rfsx2.fixedflag ? (_temp147_a_rfsx2=a_rfsx2,&_temp147_a_rfsx2) : &a_rfsx2, _flip_rfsx2.fixedflag ? (_temp148_flip_rfsx2=flip_rfsx2,&_temp148_flip_rfsx2) : &flip_rfsx2, SLR_CSAT,
                   &rfpulse[RFSX2_SLOT]);
        sp_init_rf(_pw_rfsy1.fixedflag ? (_temp149_pw_rfsy1=pw_rfsy1,&_temp149_pw_rfsy1) : &pw_rfsy1, _a_rfsy1.fixedflag ? (_temp150_a_rfsy1=a_rfsy1,&_temp150_a_rfsy1) : &a_rfsy1, _flip_rfsy1.fixedflag ? (_temp151_flip_rfsy1=flip_rfsy1,&_temp151_flip_rfsy1) : &flip_rfsy1, SLR_CSAT,
                   &rfpulse[RFSY1_SLOT]);
        sp_init_rf(_pw_rfsy2.fixedflag ? (_temp152_pw_rfsy2=pw_rfsy2,&_temp152_pw_rfsy2) : &pw_rfsy2, _a_rfsy2.fixedflag ? (_temp153_a_rfsy2=a_rfsy2,&_temp153_a_rfsy2) : &a_rfsy2, _flip_rfsy2.fixedflag ? (_temp154_flip_rfsy2=flip_rfsy2,&_temp154_flip_rfsy2) : &flip_rfsy2, SLR_CSAT,
                   &rfpulse[RFSY2_SLOT]);
        sp_init_rf(_pw_rfsz1.fixedflag ? (_temp155_pw_rfsz1=pw_rfsz1,&_temp155_pw_rfsz1) : &pw_rfsz1, _a_rfsz1.fixedflag ? (_temp156_a_rfsz1=a_rfsz1,&_temp156_a_rfsz1) : &a_rfsz1, _flip_rfsz1.fixedflag ? (_temp157_flip_rfsz1=flip_rfsz1,&_temp157_flip_rfsz1) : &flip_rfsz1, SLR_CSAT,
                   &rfpulse[RFSZ1_SLOT]);
        sp_init_rf(_pw_rfsz2.fixedflag ? (_temp158_pw_rfsz2=pw_rfsz2,&_temp158_pw_rfsz2) : &pw_rfsz2, _a_rfsz2.fixedflag ? (_temp159_a_rfsz2=a_rfsz2,&_temp159_a_rfsz2) : &a_rfsz2, _flip_rfsz2.fixedflag ? (_temp160_flip_rfsz2=flip_rfsz2,&_temp160_flip_rfsz2) : &flip_rfsz2, SLR_CSAT,
                   &rfpulse[RFSZ2_SLOT]);
        sp_init_rf(_pw_rfse1.fixedflag ? (_temp161_pw_rfse1=pw_rfse1,&_temp161_pw_rfse1) : &pw_rfse1, _a_rfse1.fixedflag ? (_temp162_a_rfse1=a_rfse1,&_temp162_a_rfse1) : &a_rfse1, _flip_rfse1.fixedflag ? (_temp163_flip_rfse1=flip_rfse1,&_temp163_flip_rfse1) : &flip_rfse1, SLR_CSAT,
                   &rfpulse[RFSE1_SLOT]);
        sp_init_rf(_pw_rfse2.fixedflag ? (_temp164_pw_rfse2=pw_rfse2,&_temp164_pw_rfse2) : &pw_rfse2, _a_rfse2.fixedflag ? (_temp165_a_rfse2=a_rfse2,&_temp165_a_rfse2) : &a_rfse2, _flip_rfse2.fixedflag ? (_temp166_flip_rfse2=flip_rfse2,&_temp166_flip_rfse2) : &flip_rfse2, SLR_CSAT,
                   &rfpulse[RFSE2_SLOT]);
        sp_init_rf(_pw_rfse3.fixedflag ? (_temp167_pw_rfse3=pw_rfse3,&_temp167_pw_rfse3) : &pw_rfse3, _a_rfse3.fixedflag ? (_temp168_a_rfse3=a_rfse3,&_temp168_a_rfse3) : &a_rfse3, _flip_rfse3.fixedflag ? (_temp169_flip_rfse3=flip_rfse3,&_temp169_flip_rfse3) : &flip_rfse3, SLR_CSAT,
                   &rfpulse[RFSE3_SLOT]);
        sp_init_rf(_pw_rfse4.fixedflag ? (_temp170_pw_rfse4=pw_rfse4,&_temp170_pw_rfse4) : &pw_rfse4, _a_rfse4.fixedflag ? (_temp171_a_rfse4=a_rfse4,&_temp171_a_rfse4) : &a_rfse4, _flip_rfse4.fixedflag ? (_temp172_flip_rfse4=flip_rfse4,&_temp172_flip_rfse4) : &flip_rfse4, SLR_CSAT,
                   &rfpulse[RFSE4_SLOT]);
        sp_init_rf(_pw_rfse5.fixedflag ? (_temp173_pw_rfse5=pw_rfse5,&_temp173_pw_rfse5) : &pw_rfse5, _a_rfse5.fixedflag ? (_temp174_a_rfse5=a_rfse5,&_temp174_a_rfse5) : &a_rfse5, _flip_rfse5.fixedflag ? (_temp175_flip_rfse5=flip_rfse5,&_temp175_flip_rfse5) : &flip_rfse5, SLR_CSAT,
                   &rfpulse[RFSE5_SLOT]);
        sp_init_rf(_pw_rfse6.fixedflag ? (_temp176_pw_rfse6=pw_rfse6,&_temp176_pw_rfse6) : &pw_rfse6, _a_rfse6.fixedflag ? (_temp177_a_rfse6=a_rfse6,&_temp177_a_rfse6) : &a_rfse6, _flip_rfse6.fixedflag ? (_temp178_flip_rfse6=flip_rfse6,&_temp178_flip_rfse6) : &flip_rfse6, SLR_CSAT,
                   &rfpulse[RFSE6_SLOT]);
        break;

    default:
        break;
    }

    pw_rfsx1  = _pw_rfsx1.fixedflag ?  ((void)(pw_rfs), pw_rfsx1) : pw_rfs;  /* RF pulse width for default SAT */
    pw_rfsx2  = _pw_rfsx2.fixedflag ?  ((void)(pw_rfs), pw_rfsx2) : pw_rfs;
    pw_rfsy1  = _pw_rfsy1.fixedflag ?  ((void)(pw_rfs), pw_rfsy1) : pw_rfs;
    pw_rfsy2  = _pw_rfsy2.fixedflag ?  ((void)(pw_rfs), pw_rfsy2) : pw_rfs;
    pw_rfsz1  = _pw_rfsz1.fixedflag ?  ((void)(pw_rfs), pw_rfsz1) : pw_rfs;
    pw_rfsz2  = _pw_rfsz2.fixedflag ?  ((void)(pw_rfs), pw_rfsz2) : pw_rfs;

    pw_rfse1  = _pw_rfse1.fixedflag ?  ((void)(pw_rfs), pw_rfse1) : pw_rfs;  /* RF pulse width for explicit SAT */
    pw_rfse2  = _pw_rfse2.fixedflag ?  ((void)(pw_rfs), pw_rfse2) : pw_rfs;
    pw_rfse3  = _pw_rfse3.fixedflag ?  ((void)(pw_rfs), pw_rfse3) : pw_rfs;
    pw_rfse4  = _pw_rfse4.fixedflag ?  ((void)(pw_rfs), pw_rfse4) : pw_rfs;
    pw_rfse5  = _pw_rfse5.fixedflag ?  ((void)(pw_rfs), pw_rfse5) : pw_rfs;
    pw_rfse6  = _pw_rfse6.fixedflag ?  ((void)(pw_rfs), pw_rfse6) : pw_rfs;

    /* Init satloggrd structure.  Do it here to get ramp times */
    if( FAILURE == sp_init_satloggrd(&satloggrd) ) {
        return FAILURE;
    }
    pw_satrampx  = _pw_satrampx.fixedflag ?  ((void)(satloggrd.xrt), pw_satrampx) : satloggrd.xrt;
    pw_satrampy  = _pw_satrampy.fixedflag ?  ((void)(satloggrd.yrt), pw_satrampy) : satloggrd.yrt;
    pw_satrampz  = _pw_satrampz.fixedflag ?  ((void)(satloggrd.zrt), pw_satrampz) : satloggrd.zrt;

    pw_gxrfsx1  = _pw_gxrfsx1.fixedflag ?  ((void)(pw_rfsx1), pw_gxrfsx1) : pw_rfsx1;   /* Default SAT gradient width */
    pw_gxrfsx2  = _pw_gxrfsx2.fixedflag ?  ((void)(pw_rfsx2), pw_gxrfsx2) : pw_rfsx2;
    pw_gyrfsy1  = _pw_gyrfsy1.fixedflag ?  ((void)(pw_rfsy1), pw_gyrfsy1) : pw_rfsy1;
    pw_gyrfsy2  = _pw_gyrfsy2.fixedflag ?  ((void)(pw_rfsy2), pw_gyrfsy2) : pw_rfsy2;
    pw_gzrfsz1  = _pw_gzrfsz1.fixedflag ?  ((void)(pw_rfsz1), pw_gzrfsz1) : pw_rfsz1;
    pw_gzrfsz2  = _pw_gzrfsz2.fixedflag ?  ((void)(pw_rfsz2), pw_gzrfsz2) : pw_rfsz2;

    pw_gzrfse1a  = _pw_gzrfse1a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse1a) : pw_satrampz;  /* Explicit SAt gradient ramp widths */
    pw_gzrfse2a  = _pw_gzrfse2a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse2a) : pw_satrampz;
    pw_gzrfse3a  = _pw_gzrfse3a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse3a) : pw_satrampz;
    pw_gzrfse4a  = _pw_gzrfse4a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse4a) : pw_satrampz;
    pw_gzrfse5a  = _pw_gzrfse5a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse5a) : pw_satrampz;
    pw_gzrfse6a  = _pw_gzrfse6a.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse6a) : pw_satrampz;
    pw_gzrfse1d  = _pw_gzrfse1d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse1d) : pw_satrampz;
    pw_gzrfse2d  = _pw_gzrfse2d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse2d) : pw_satrampz;
    pw_gzrfse3d  = _pw_gzrfse3d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse3d) : pw_satrampz;
    pw_gzrfse4d  = _pw_gzrfse4d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse4d) : pw_satrampz;
    pw_gzrfse5d  = _pw_gzrfse5d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse5d) : pw_satrampz;
    pw_gzrfse6d  = _pw_gzrfse6d.fixedflag ?  ((void)(pw_satrampz), pw_gzrfse6d) : pw_satrampz;

    pw_gzrfse1  = _pw_gzrfse1.fixedflag ?  ((void)(pw_rfse1), pw_gzrfse1) : pw_rfse1;    /* Explicit Sat gradient width */
    pw_gzrfse2  = _pw_gzrfse2.fixedflag ?  ((void)(pw_rfse2), pw_gzrfse2) : pw_rfse2;
    pw_gzrfse3  = _pw_gzrfse3.fixedflag ?  ((void)(pw_rfse3), pw_gzrfse3) : pw_rfse3;
    pw_gzrfse4  = _pw_gzrfse4.fixedflag ?  ((void)(pw_rfse4), pw_gzrfse4) : pw_rfse4;
    pw_gzrfse5  = _pw_gzrfse5.fixedflag ?  ((void)(pw_rfse5), pw_gzrfse5) : pw_rfse5;
    pw_gzrfse6  = _pw_gzrfse6.fixedflag ?  ((void)(pw_rfse6), pw_gzrfse6) : pw_rfse6;
  
#ifdef SPSATXKILLER
    gradx[GXKSE1_SLOT].attack = _pw_gxkse1a.fixedflag ? (_temp179_pw_gxkse1a=pw_gxkse1a,&_temp179_pw_gxkse1a) : &pw_gxkse1a;
    gradx[GXKSE2_SLOT].attack = _pw_gxkse2a.fixedflag ? (_temp180_pw_gxkse2a=pw_gxkse2a,&_temp180_pw_gxkse2a) : &pw_gxkse2a;
    gradx[GXKSE3_SLOT].attack = _pw_gxkse3a.fixedflag ? (_temp181_pw_gxkse3a=pw_gxkse3a,&_temp181_pw_gxkse3a) : &pw_gxkse3a;
    gradx[GXKSE4_SLOT].attack = _pw_gxkse4a.fixedflag ? (_temp182_pw_gxkse4a=pw_gxkse4a,&_temp182_pw_gxkse4a) : &pw_gxkse4a;
    gradx[GXKSE5_SLOT].attack = _pw_gxkse5a.fixedflag ? (_temp183_pw_gxkse5a=pw_gxkse5a,&_temp183_pw_gxkse5a) : &pw_gxkse5a;
    gradx[GXKSE6_SLOT].attack = _pw_gxkse6a.fixedflag ? (_temp184_pw_gxkse6a=pw_gxkse6a,&_temp184_pw_gxkse6a) : &pw_gxkse6a;
    gradx[GXKSX1_SLOT].attack = _pw_gxksx1a.fixedflag ? (_temp185_pw_gxksx1a=pw_gxksx1a,&_temp185_pw_gxksx1a) : &pw_gxksx1a;
    gradx[GXKSX2_SLOT].attack = _pw_gxksx2a.fixedflag ? (_temp186_pw_gxksx2a=pw_gxksx2a,&_temp186_pw_gxksx2a) : &pw_gxksx2a;
    gradx[GXKSY1_SLOT].attack = _pw_gxksy1a.fixedflag ? (_temp187_pw_gxksy1a=pw_gxksy1a,&_temp187_pw_gxksy1a) : &pw_gxksy1a;
    gradx[GXKSY2_SLOT].attack = _pw_gxksy2a.fixedflag ? (_temp188_pw_gxksy2a=pw_gxksy2a,&_temp188_pw_gxksy2a) : &pw_gxksy2a;
    gradx[GXKSZ1_SLOT].attack = _pw_gxksz1a.fixedflag ? (_temp189_pw_gxksz1a=pw_gxksz1a,&_temp189_pw_gxksz1a) : &pw_gxksz1a;
    gradx[GXKSZ2_SLOT].attack = _pw_gxksz2a.fixedflag ? (_temp190_pw_gxksz2a=pw_gxksz2a,&_temp190_pw_gxksz2a) : &pw_gxksz2a;

    gradx[GXKSE1_SLOT].decay = _pw_gxkse1d.fixedflag ? (_temp191_pw_gxkse1d=pw_gxkse1d,&_temp191_pw_gxkse1d) : &pw_gxkse1d;
    gradx[GXKSE2_SLOT].decay = _pw_gxkse2d.fixedflag ? (_temp192_pw_gxkse2d=pw_gxkse2d,&_temp192_pw_gxkse2d) : &pw_gxkse2d;
    gradx[GXKSE3_SLOT].decay = _pw_gxkse3d.fixedflag ? (_temp193_pw_gxkse3d=pw_gxkse3d,&_temp193_pw_gxkse3d) : &pw_gxkse3d;
    gradx[GXKSE4_SLOT].decay = _pw_gxkse4d.fixedflag ? (_temp194_pw_gxkse4d=pw_gxkse4d,&_temp194_pw_gxkse4d) : &pw_gxkse4d;
    gradx[GXKSE5_SLOT].decay = _pw_gxkse5d.fixedflag ? (_temp195_pw_gxkse5d=pw_gxkse5d,&_temp195_pw_gxkse5d) : &pw_gxkse5d;
    gradx[GXKSE6_SLOT].decay = _pw_gxkse6d.fixedflag ? (_temp196_pw_gxkse6d=pw_gxkse6d,&_temp196_pw_gxkse6d) : &pw_gxkse6d;
    gradx[GXKSX1_SLOT].decay = _pw_gxksx1d.fixedflag ? (_temp197_pw_gxksx1d=pw_gxksx1d,&_temp197_pw_gxksx1d) : &pw_gxksx1d;
    gradx[GXKSX2_SLOT].decay = _pw_gxksx2d.fixedflag ? (_temp198_pw_gxksx2d=pw_gxksx2d,&_temp198_pw_gxksx2d) : &pw_gxksx2d;
    gradx[GXKSY1_SLOT].decay = _pw_gxksy1d.fixedflag ? (_temp199_pw_gxksy1d=pw_gxksy1d,&_temp199_pw_gxksy1d) : &pw_gxksy1d;
    gradx[GXKSY2_SLOT].decay = _pw_gxksy2d.fixedflag ? (_temp200_pw_gxksy2d=pw_gxksy2d,&_temp200_pw_gxksy2d) : &pw_gxksy2d;
    gradx[GXKSZ1_SLOT].decay = _pw_gxksz1d.fixedflag ? (_temp201_pw_gxksz1d=pw_gxksz1d,&_temp201_pw_gxksz1d) : &pw_gxksz1d;
    gradx[GXKSZ2_SLOT].decay = _pw_gxksz2d.fixedflag ? (_temp202_pw_gxksz2d=pw_gxksz2d,&_temp202_pw_gxksz2d) : &pw_gxksz2d;

    gradx[GXKSE1_SLOT].pw = _pw_gxkse1.fixedflag ? (_temp203_pw_gxkse1=pw_gxkse1,&_temp203_pw_gxkse1) : &pw_gxkse1;
    gradx[GXKSE2_SLOT].pw = _pw_gxkse2.fixedflag ? (_temp204_pw_gxkse2=pw_gxkse2,&_temp204_pw_gxkse2) : &pw_gxkse2;
    gradx[GXKSE3_SLOT].pw = _pw_gxkse3.fixedflag ? (_temp205_pw_gxkse3=pw_gxkse3,&_temp205_pw_gxkse3) : &pw_gxkse3;
    gradx[GXKSE4_SLOT].pw = _pw_gxkse4.fixedflag ? (_temp206_pw_gxkse4=pw_gxkse4,&_temp206_pw_gxkse4) : &pw_gxkse4;
    gradx[GXKSE5_SLOT].pw = _pw_gxkse5.fixedflag ? (_temp207_pw_gxkse5=pw_gxkse5,&_temp207_pw_gxkse5) : &pw_gxkse5;
    gradx[GXKSE6_SLOT].pw = _pw_gxkse6.fixedflag ? (_temp208_pw_gxkse6=pw_gxkse6,&_temp208_pw_gxkse6) : &pw_gxkse6;
    gradx[GXKSX1_SLOT].pw = _pw_gxksx1.fixedflag ? (_temp209_pw_gxksx1=pw_gxksx1,&_temp209_pw_gxksx1) : &pw_gxksx1;
    gradx[GXKSX2_SLOT].pw = _pw_gxksx2.fixedflag ? (_temp210_pw_gxksx2=pw_gxksx2,&_temp210_pw_gxksx2) : &pw_gxksx2;
    gradx[GXKSY1_SLOT].pw = _pw_gxksy1.fixedflag ? (_temp211_pw_gxksy1=pw_gxksy1,&_temp211_pw_gxksy1) : &pw_gxksy1;
    gradx[GXKSY2_SLOT].pw = _pw_gxksy2.fixedflag ? (_temp212_pw_gxksy2=pw_gxksy2,&_temp212_pw_gxksy2) : &pw_gxksy2;
    gradx[GXKSZ1_SLOT].pw = _pw_gxksz1.fixedflag ? (_temp213_pw_gxksz1=pw_gxksz1,&_temp213_pw_gxksz1) : &pw_gxksz1;
    gradx[GXKSZ2_SLOT].pw = _pw_gxksz2.fixedflag ? (_temp214_pw_gxksz2=pw_gxksz2,&_temp214_pw_gxksz2) : &pw_gxksz2;

    gradx[GXKSE1_SLOT].amp = _a_gxkse1.fixedflag ? (_temp215_a_gxkse1=a_gxkse1,&_temp215_a_gxkse1) : &a_gxkse1;
    gradx[GXKSE2_SLOT].amp = _a_gxkse2.fixedflag ? (_temp216_a_gxkse2=a_gxkse2,&_temp216_a_gxkse2) : &a_gxkse2;
    gradx[GXKSE3_SLOT].amp = _a_gxkse3.fixedflag ? (_temp217_a_gxkse3=a_gxkse3,&_temp217_a_gxkse3) : &a_gxkse3;
    gradx[GXKSE4_SLOT].amp = _a_gxkse4.fixedflag ? (_temp218_a_gxkse4=a_gxkse4,&_temp218_a_gxkse4) : &a_gxkse4;
    gradx[GXKSE5_SLOT].amp = _a_gxkse5.fixedflag ? (_temp219_a_gxkse5=a_gxkse5,&_temp219_a_gxkse5) : &a_gxkse5;
    gradx[GXKSE6_SLOT].amp = _a_gxkse6.fixedflag ? (_temp220_a_gxkse6=a_gxkse6,&_temp220_a_gxkse6) : &a_gxkse6;
    gradx[GXKSX1_SLOT].amp = _a_gxksx1.fixedflag ? (_temp221_a_gxksx1=a_gxksx1,&_temp221_a_gxksx1) : &a_gxksx1;
    gradx[GXKSX2_SLOT].amp = _a_gxksx2.fixedflag ? (_temp222_a_gxksx2=a_gxksx2,&_temp222_a_gxksx2) : &a_gxksx2;
    gradx[GXKSY1_SLOT].amp = _a_gxksy1.fixedflag ? (_temp223_a_gxksy1=a_gxksy1,&_temp223_a_gxksy1) : &a_gxksy1;
    gradx[GXKSY2_SLOT].amp = _a_gxksy2.fixedflag ? (_temp224_a_gxksy2=a_gxksy2,&_temp224_a_gxksy2) : &a_gxksy2;
    gradx[GXKSZ1_SLOT].amp = _a_gxksz1.fixedflag ? (_temp225_a_gxksz1=a_gxksz1,&_temp225_a_gxksz1) : &a_gxksz1;
    gradx[GXKSZ2_SLOT].amp = _a_gxksz2.fixedflag ? (_temp226_a_gxksz2=a_gxksz2,&_temp226_a_gxksz2) : &a_gxksz2;
#endif

    return SUCCESS;
}

/***********************************************************************/


STATUS
SpSatCheck( void )
{

    if (exist(opccsat)==PSD_ON) 
    {
        if (exist(opileave) == PSD_ON) 
        {
            epic_error(use_ermes, "Can not perform Concat Sat with interleaving",
                       EM_PSD_CATSAT_INTLEAVE,0);
            return(FAILURE);
        }
    }
    return(SUCCESS);
}

/*************************************************************************/
STATUS ssInit(void) 
{
    INT ss_type = 0;
    off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;

    /* RF1 initialization */
    if (ss_rf1 == PSD_ON)  /* initialize spsp pulses for current field strength and SR17 */
    {
        /* Spatial-Spectral pulses use external gradient files. Do not scale pulse */
        switch ((int ) cffield) {
            case B0_40000:

            case B0_30000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(268), pw_ss_rampz) : 268;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_PW), pw_rf1) : PSD_ss3026838_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_R), res_rf1) : PSD_ss3026838_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss3026838_RF1_LEFT), hrf1a) : PSD_ss3026838_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss3026838_RF1_RIGHT), hrf1b) : PSD_ss3026838_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026838_RF1_NUML), num_rf1lobe) : PSD_ss3026838_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026838_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026838_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp227_pw_rf1=pw_rf1,&_temp227_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp228_a_rf1=a_rf1,&_temp228_a_rf1) : &a_rf1, SAR_ABS_ss3026838,
                             SAR_Pss3026838, SAR_ARss3026838, SAR_DTCss3026838,
                             SAR_MAXPWss3026838, 1, MAX_B1_ss3026838, 
                             MAX_INT_B1_SQ_ss3026838, MAX_RMS_B1_ss3026838, 90.0, 
                             _flip_rf1.fixedflag ? (_temp229_flip_rf1=flip_rf1,&_temp229_flip_rf1) : &flip_rf1, (float)PSD_ss3026838_RF1_PW, NOM_BW_ss3026838,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp230_res_rf1=res_rf1,&_temp230_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp231_wg_rf1=wg_rf1,&_temp231_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "ss3026838.rho");
                sprintf(ssgzfile, "ss3026838.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026838), whichss) : 3026838;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026838), nbw_ssrf) : NOM_BW_ss3026838;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;     
                break;       /* end YH, YZ */

            case B0_7000:
                /* FEC (nMR) : Put same values as 0.5T, MUST FIX THIS !!!! */
                /*    MUST GENERATE EXTERNAL WAVEFORM FILE FOR 0.7T */
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss0560010_RF1_LEFT), hrf1a) : PSD_ss0560010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss0560010_RF1_RIGHT), hrf1b) : PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp232_pw_rf1=pw_rf1,&_temp232_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp233_a_rf1=a_rf1,&_temp233_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010,
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0,
                             _flip_rf1.fixedflag ? (_temp234_flip_rf1=flip_rf1,&_temp234_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp235_res_rf1=res_rf1,&_temp235_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp236_wg_rf1=wg_rf1,&_temp236_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                break;

            case B0_5000:

            case B0_3500:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss0560010_RF1_LEFT), hrf1a) : PSD_ss0560010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss0560010_RF1_RIGHT), hrf1b) : PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp237_pw_rf1=pw_rf1,&_temp237_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp238_a_rf1=a_rf1,&_temp238_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010, 
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp239_flip_rf1=flip_rf1,&_temp239_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp240_res_rf1=res_rf1,&_temp240_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp241_wg_rf1=wg_rf1,&_temp241_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                break;

            case B0_10000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_PW), pw_rf1) : PSD_ss1060010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_R), res_rf1) : PSD_ss1060010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1060010_RF1_LEFT), hrf1a) : PSD_ss1060010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1060010_RF1_RIGHT), hrf1b) : PSD_ss1060010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1060010_RF1_NUML), num_rf1lobe) : PSD_ss1060010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1060010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1060010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp242_pw_rf1=pw_rf1,&_temp242_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp243_a_rf1=a_rf1,&_temp243_a_rf1) : &a_rf1, SAR_ABS_ss1060010,
                             SAR_Pss1060010, SAR_ARss1060010, SAR_DTCss1060010,
                             SAR_MAXPWss1060010, 1, MAX_B1_ss1060010,
                             MAX_INT_B1_SQ_ss1060010, MAX_RMS_B1_ss1060010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp244_flip_rf1=flip_rf1,&_temp244_flip_rf1) : &flip_rf1, (float)PSD_ss1060010_RF1_PW, NOM_BW_ss1060010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp245_res_rf1=res_rf1,&_temp245_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp246_wg_rf1=wg_rf1,&_temp246_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1060010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1060010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1060010), whichss) : 1060010;
                break;

            case B0_15000:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_PW), pw_rf1) : PSD_ss1560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_R), res_rf1) : PSD_ss1560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1560010_RF1_LEFT), hrf1a) : PSD_ss1560010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1560010_RF1_RIGHT), hrf1b) : PSD_ss1560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1560010_RF1_NUML), num_rf1lobe) : PSD_ss1560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp247_pw_rf1=pw_rf1,&_temp247_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp248_a_rf1=a_rf1,&_temp248_a_rf1) : &a_rf1, SAR_ABS_ss1560010,
                             SAR_Pss1560010, SAR_ARss1560010, SAR_DTCss1560010,
                             SAR_MAXPWss1560010, 1, MAX_B1_ss1560010, 
                             MAX_INT_B1_SQ_ss1560010, MAX_RMS_B1_ss1560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp249_flip_rf1=flip_rf1,&_temp249_flip_rf1) : &flip_rf1, (float)PSD_ss1560010_RF1_PW, NOM_BW_ss1560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp250_res_rf1=res_rf1,&_temp250_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp251_wg_rf1=wg_rf1,&_temp251_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1560010), whichss) : 1560010;
                break;

            default: /* not a defined field strength */
                SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
                break; 
                /* NOTREACHED */
        } /* end switch cffield */

        /* BJM: MRIge58917 - moved this out of ssEval1 */
        if (((ss_override!=560010)  && (ss_override!=1060010) && 
             (ss_override!=10110022) && (ss_override!=1028822) &&
             (ss_override!=1560010) && (ss_override!=15110022) &&
             (ss_override!=1528822) && (ss_override!=1544022) &&
             (ss_override!=1534433) && (ss_override!=3018027) && 
             (ss_override!=3026838) && (ss_override!=3026033) &&
             (ss_override!=30276221) && (ss_override!=30276222) && 
             (ss_override!=15048233) && (ss_override!=15048234) &&
             (ss_override!=15048235) && (ss_override!=30104233) &&
             (ss_override!=30104234) && (ss_override!=30104235) &&             
             (ss_override!=30248501) && (ss_override!=30248502) &&
             (ss_override!=30260334) && (ss_override!=3027633) &&
             (ss_override != 1) && (ss_override != 2))
             || (existcv(ss_override)==PSD_OFF) ) {
            /* choose pulse based on field strength and slew rate mode */
            switch ((int) cffield) {
                case B0_40000:

                case B0_30000:

                    /* HD new 30276221 Type I spsp pulse (default pulse for WHOLE mode) */
                    if((exist(opgradmode) == 1))
                        ss_type = 30276221;  

                    /* YH,YZ  Keep 3026033 spsp pulse for BRM/CRM and Zoom Modes */
                    else
                    {
                        switch(breast_spsp_flag)
                        {
                            case 0:
                            default:
                                ss_type = 30260334;  /* new ss pulse to replace 3026838 */
                                break;
                            case 1:
                                if(cfgcoiltype == PSD_XRMW_COIL || cfgcoiltype == PSD_VRMW_COIL)
                                    ss_type = 3027633;
                                else
                                    ss_type = 30248501;
                                break;
                            case 2:
                                ss_type = 30248502;
                                break;
                        }
                    }
                    
                    break;      

                case B0_7000:
                    /* FEC (nMR) : Put same values as 0.5T, MUST FIX THIS!! */
                    /*    MUST GENERATE EXTERNAL WAVEFORM FILE FOR 0.7T */
                    switch (cfsrmode) {
                        case PSD_SR17:
                            ss_type = 1060010;
                            break;
                        case PSD_SR20:
                        case PSD_SR25:
                            ss_type = 10110022;
                            break;
                        case PSD_SR77:
                        case PSD_SR100:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1028822;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_5000:
                case B0_3500:
                    switch (cfsrmode) {
                        case PSD_SR17:
                        case PSD_SR25:  /* MFO 03/14/00 YI */
                            ss_type = 560010;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_10000:
                    switch (cfsrmode) {
                        case PSD_SR17:
                            ss_type = 1060010;
                            break;
                        case PSD_SR20:
                        case PSD_SR50:
                            ss_type = 10110022;
                            break;
                        case PSD_SR77:
                        case PSD_SR100:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1028822;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);
                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                case B0_15000:
                    switch (cfsrmode) {
                        case PSD_SR17:
                        case PSD_SR25:
                            ss_type = 1560010;
                            break;
                        case PSD_SR20:
                        case PSD_SR50:
                            if((VALUE_SYSTEM_HDE == value_system_flag) || (isStarterSystem() && opslthick > 3.005))
                            {
                                ss_type = 1544022; 
                            } 
                            else if(isStarterSystem() && opslthick <= 3.005)
                            {
                                ss_type = 15496248;
                            }                           
                            else 
                            {
                                ss_type = 15110022;
                            }
                            break;
                        case PSD_SR77:
                        case PSD_SR120:
                        case PSD_SR150:
                        case PSD_SR200:
                        case PSD_SR230:
                            ss_type = 1528822;
                            break;
                        case PSD_SR100:
                            ss_type = 1534433;
                            break;
                        default:
                            epic_error(0, "Slew Rate %d not found", 0, EE_ARGS(1),
                                       INT_ARG, cfsrmode);

                            return FAILURE;
                            /* NOTREACHED */
                    }
                    break;
                default:
                    SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,
                                              __FILE__,__LINE__);
                    break;
            } /* end switch cffield */

        } /* end if ss_override!=... */ 
        else {  /* use override the auto selection */
            ss_type = ss_override;
        } 
        /* set up pulses based on what pulse was chosen */
        switch (ss_type) {
            case 1:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1_RF1_PW), pw_rf1) : PSD_ss1_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1_RF1_R), res_rf1) : PSD_ss1_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1_RF1_LEFT), hrf1a) : PSD_ss1_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1_RF1_RIGHT), hrf1b) : PSD_ss1_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1_RF1_NUML), num_rf1lobe) : PSD_ss1_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss1_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp252_pw_rf1=pw_rf1,&_temp252_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp253_a_rf1=a_rf1,&_temp253_a_rf1) : &a_rf1, SAR_ABS_ss1,
                             SAR_Pss1, SAR_ARss1, SAR_DTCss1,
                             SAR_MAXPWss1, 1, MAX_B1_ss1, 
                             MAX_INT_B1_SQ_ss1, MAX_RMS_B1_ss1, 45.0, 
                             _flip_rf1.fixedflag ? (_temp254_flip_rf1=flip_rf1,&_temp254_flip_rf1) : &flip_rf1, (float)PSD_ss1_RF1_PW, NOM_BW_ss1,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp255_res_rf1=res_rf1,&_temp255_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp256_wg_rf1=wg_rf1,&_temp256_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ssrfx3.rho");
                sprintf(ssgzfile, "/usr/g/bin/ssrfx3.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1), whichss) : 1;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1), nbw_ssrf) : NOM_BW_ss1;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 2:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss2_RF1_PW), pw_rf1) : PSD_ss2_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss2_RF1_R), res_rf1) : PSD_ss2_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss2_RF1_LEFT), hrf1a) : PSD_ss2_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss2_RF1_RIGHT), hrf1b) : PSD_ss2_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss2_RF1_NUML), num_rf1lobe) : PSD_ss2_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss2_RF1_HlPW), pw_gzrf1lobe) : PSD_ss2_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp257_pw_rf1=pw_rf1,&_temp257_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp258_a_rf1=a_rf1,&_temp258_a_rf1) : &a_rf1, SAR_ABS_ss2,
                             SAR_Pss2, SAR_ARss2, SAR_DTCss2,
                             SAR_MAXPWss2, 1, MAX_B1_ss2, 
                             MAX_INT_B1_SQ_ss2, MAX_RMS_B1_ss2, 45.0, 
                             _flip_rf1.fixedflag ? (_temp259_flip_rf1=flip_rf1,&_temp259_flip_rf1) : &flip_rf1, (float)PSD_ss2_RF1_PW, NOM_BW_ss2,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp260_res_rf1=res_rf1,&_temp260_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp261_wg_rf1=wg_rf1,&_temp261_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ssrf6.rho");
                sprintf(ssgzfile, "/usr/g/bin/ssrf6.gz");
                whichss  = _whichss.fixedflag ?  ((void)(2), whichss) : 2;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss2), nbw_ssrf) : NOM_BW_ss2;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30260334:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(252), pw_ss_rampz) : 252;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30260334_RF1_PW), pw_rf1) : PSD_ss30260334_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30260334_RF1_R), res_rf1) : PSD_ss30260334_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30260334_RF1_LEFT), hrf1a) : PSD_ss30260334_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30260334_RF1_RIGHT), hrf1b) : PSD_ss30260334_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30260334_RF1_NUML), num_rf1lobe) : PSD_ss30260334_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30260334_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30260334_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp262_pw_rf1=pw_rf1,&_temp262_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp263_a_rf1=a_rf1,&_temp263_a_rf1) : &a_rf1, SAR_ABS_ss30260334,
                             SAR_Pss30260334, SAR_ARss30260334, SAR_DTCss30260334,
                             SAR_MAXPWss30260334, 1, MAX_B1_ss30260334, 
                             MAX_INT_B1_SQ_ss30260334, MAX_RMS_B1_ss30260334, 90.0, 
                             _flip_rf1.fixedflag ? (_temp264_flip_rf1=flip_rf1,&_temp264_flip_rf1) : &flip_rf1, (float)PSD_ss30260334_RF1_PW, NOM_BW_ss30260334,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp265_res_rf1=res_rf1,&_temp265_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp266_wg_rf1=wg_rf1,&_temp266_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30260334.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30260334.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30260334), whichss) : 30260334;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30260334), nbw_ssrf) : NOM_BW_ss30260334;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30248501:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(116), pw_ss_rampz) : 116;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30248501_RF1_PW), pw_rf1) : PSD_ss30248501_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30248501_RF1_R), res_rf1) : PSD_ss30248501_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30248501_RF1_LEFT), hrf1a) : PSD_ss30248501_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30248501_RF1_RIGHT), hrf1b) : PSD_ss30248501_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30248501_RF1_NUML), num_rf1lobe) : PSD_ss30248501_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30248501_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30248501_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp267_pw_rf1=pw_rf1,&_temp267_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp268_a_rf1=a_rf1,&_temp268_a_rf1) : &a_rf1, SAR_ABS_ss30248501,
                             SAR_Pss30248501, SAR_ARss30248501, SAR_DTCss30248501,
                             SAR_MAXPWss30248501, 1, MAX_B1_ss30248501,
                             MAX_INT_B1_SQ_ss30248501,
                             MAX_RMS_B1_ss30248501, 90.0,
                             _flip_rf1.fixedflag ? (_temp269_flip_rf1=flip_rf1,&_temp269_flip_rf1) : &flip_rf1, (float)PSD_ss30248501_RF1_PW, NOM_BW_ss30248501,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp270_res_rf1=res_rf1,&_temp270_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp271_wg_rf1=wg_rf1,&_temp271_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30248501.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30248501.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30248501), whichss) : 30248501;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30248501), nbw_ssrf) : NOM_BW_ss30248501;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30248502:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(116), pw_ss_rampz) : 116;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30248502_RF1_PW), pw_rf1) : PSD_ss30248502_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30248502_RF1_R), res_rf1) : PSD_ss30248502_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30248502_RF1_LEFT), hrf1a) : PSD_ss30248502_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30248502_RF1_RIGHT), hrf1b) : PSD_ss30248502_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30248502_RF1_NUML), num_rf1lobe) : PSD_ss30248502_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30248502_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30248502_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp272_pw_rf1=pw_rf1,&_temp272_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp273_a_rf1=a_rf1,&_temp273_a_rf1) : &a_rf1, SAR_ABS_ss30248502,
                             SAR_Pss30248502, SAR_ARss30248502, SAR_DTCss30248502,
                             SAR_MAXPWss30248502, 1, MAX_B1_ss30248502, 
                             MAX_INT_B1_SQ_ss30248502, 
                             MAX_RMS_B1_ss30248502, 90.0, 
                             _flip_rf1.fixedflag ? (_temp274_flip_rf1=flip_rf1,&_temp274_flip_rf1) : &flip_rf1, (float)PSD_ss30248502_RF1_PW, NOM_BW_ss30248502,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp275_res_rf1=res_rf1,&_temp275_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp276_wg_rf1=wg_rf1,&_temp276_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss30248502.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss30248502.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30248502), whichss) : 30248502;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30248502), nbw_ssrf) : NOM_BW_ss30248502;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 3027633:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(188), pw_ss_rampz) : 188;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3027633_RF1_PW), pw_rf1) : PSD_ss3027633_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3027633_RF1_R), res_rf1) : PSD_ss3027633_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss3027633_RF1_LEFT), hrf1a) : PSD_ss3027633_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss3027633_RF1_RIGHT), hrf1b) : PSD_ss3027633_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3027633_RF1_NUML), num_rf1lobe) : PSD_ss3027633_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss3027633_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3027633_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp277_pw_rf1=pw_rf1,&_temp277_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp278_a_rf1=a_rf1,&_temp278_a_rf1) : &a_rf1, SAR_ABS_ss3027633,
                             SAR_Pss3027633, SAR_ARss3027633, SAR_DTCss3027633,
                             SAR_MAXPWss3027633, 1, MAX_B1_ss3027633,
                             MAX_INT_B1_SQ_ss3027633,
                             MAX_RMS_B1_ss3027633, 90.0,
                             _flip_rf1.fixedflag ? (_temp279_flip_rf1=flip_rf1,&_temp279_flip_rf1) : &flip_rf1, (float)PSD_ss3027633_RF1_PW, NOM_BW_ss3027633,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp280_res_rf1=res_rf1,&_temp280_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp281_wg_rf1=wg_rf1,&_temp281_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3027633.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3027633.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3027633), whichss) : 3027633;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3027633), nbw_ssrf) : NOM_BW_ss3027633;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

                /* HD new spsp typeI 9nrf pulse (Default for WHOLE mode) */
            case 30276221:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(276), pw_ss_rampz) : 276;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30276221_RF1_PW), pw_rf1) : PSD_ss30276221_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30276221_RF1_R), res_rf1) : PSD_ss30276221_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30276221_RF1_LEFT), hrf1a) : PSD_ss30276221_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30276221_RF1_RIGHT), hrf1b) : PSD_ss30276221_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30276221_RF1_NUML), num_rf1lobe) : PSD_ss30276221_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30276221_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30276221_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp282_pw_rf1=pw_rf1,&_temp282_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp283_a_rf1=a_rf1,&_temp283_a_rf1) : &a_rf1, SAR_ABS_ss30276221,
                             SAR_Pss30276221,SAR_ARss30276221,SAR_DTCss30276221,
                             SAR_MAXPWss30276221, 1, MAX_B1_ss30276221, 
                             MAX_INT_B1_SQ_ss30276221, MAX_RMS_B1_ss30276221, 90.0, 
                             _flip_rf1.fixedflag ? (_temp284_flip_rf1=flip_rf1,&_temp284_flip_rf1) : &flip_rf1, (float)PSD_ss30276221_RF1_PW, NOM_BW_ss30276221,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp285_res_rf1=res_rf1,&_temp285_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp286_wg_rf1=wg_rf1,&_temp286_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/spsp_30276221.rho");
                sprintf(ssgzfile, "/usr/g/bin/spsp_30276221.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30276221), whichss) : 30276221;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30276221), nbw_ssrf) : NOM_BW_ss30276221;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

                /* HD new spsp typeII 7nrf pulse for WHOLE mode */
            case 30276222:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(276), pw_ss_rampz) : 276;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30276222_RF1_PW), pw_rf1) : PSD_ss30276222_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30276222_RF1_R), res_rf1) : PSD_ss30276222_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30276222_RF1_LEFT), hrf1a) : PSD_ss30276222_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30276222_RF1_RIGHT), hrf1b) : PSD_ss30276222_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30276222_RF1_NUML), num_rf1lobe) : PSD_ss30276222_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ?  ((void)(PSD_ss30276222_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30276222_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp287_pw_rf1=pw_rf1,&_temp287_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp288_a_rf1=a_rf1,&_temp288_a_rf1) : &a_rf1, SAR_ABS_ss30276222,
                             SAR_Pss30276222,SAR_ARss30276222,SAR_DTCss30276222,
                             SAR_MAXPWss30276222, 1, MAX_B1_ss30276222, 
                             MAX_INT_B1_SQ_ss30276222, MAX_RMS_B1_ss30276222, 90.0, 
                             _flip_rf1.fixedflag ? (_temp289_flip_rf1=flip_rf1,&_temp289_flip_rf1) : &flip_rf1, (float)PSD_ss30276222_RF1_PW, NOM_BW_ss30276222,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp290_res_rf1=res_rf1,&_temp290_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp291_wg_rf1=wg_rf1,&_temp291_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/spsp_30276222.rho");
                sprintf(ssgzfile, "/usr/g/bin/spsp_30276222.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30276222), whichss) : 30276222;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30276222), nbw_ssrf) : NOM_BW_ss30276222;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 560010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_PW), pw_rf1) : PSD_ss0560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss0560010_RF1_R), res_rf1) : PSD_ss0560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss0560010_RF1_LEFT), hrf1a) : PSD_ss0560010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss0560010_RF1_RIGHT), hrf1b) : PSD_ss0560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss0560010_RF1_NUML), num_rf1lobe) : PSD_ss0560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss0560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss0560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp292_pw_rf1=pw_rf1,&_temp292_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp293_a_rf1=a_rf1,&_temp293_a_rf1) : &a_rf1, SAR_ABS_ss0560010,
                             SAR_Pss0560010, SAR_ARss0560010, SAR_DTCss0560010,
                             SAR_MAXPWss0560010, 1, MAX_B1_ss0560010,
                             MAX_INT_B1_SQ_ss0560010, MAX_RMS_B1_ss0560010, 90.0,  
                             _flip_rf1.fixedflag ? (_temp294_flip_rf1=flip_rf1,&_temp294_flip_rf1) : &flip_rf1, (float)PSD_ss0560010_RF1_PW, NOM_BW_ss0560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp295_res_rf1=res_rf1,&_temp295_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp296_wg_rf1=wg_rf1,&_temp296_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss0560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss0560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(560010), whichss) : 560010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss0560010), nbw_ssrf) : NOM_BW_ss0560010;
                break;

            case 1060010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_PW), pw_rf1) : PSD_ss1060010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1060010_RF1_R), res_rf1) : PSD_ss1060010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1060010_RF1_LEFT), hrf1a) : PSD_ss1060010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1060010_RF1_RIGHT), hrf1b) : PSD_ss1060010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1060010_RF1_NUML), num_rf1lobe) : PSD_ss1060010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1060010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1060010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp297_pw_rf1=pw_rf1,&_temp297_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp298_a_rf1=a_rf1,&_temp298_a_rf1) : &a_rf1, SAR_ABS_ss1060010,
                             SAR_Pss1060010, SAR_ARss1060010, SAR_DTCss1060010,
                             SAR_MAXPWss1060010, 1, MAX_B1_ss1060010,
                             MAX_INT_B1_SQ_ss1060010, MAX_RMS_B1_ss1060010, 90.0,  
                             _flip_rf1.fixedflag ? (_temp299_flip_rf1=flip_rf1,&_temp299_flip_rf1) : &flip_rf1, (float)PSD_ss1060010_RF1_PW, NOM_BW_ss1060010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp300_res_rf1=res_rf1,&_temp300_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp301_wg_rf1=wg_rf1,&_temp301_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1060010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1060010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1060010), whichss) : 1060010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1060010), nbw_ssrf) : NOM_BW_ss1060010;
                break;

            case 10110022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(1100), pw_ss_rampz) : 1100;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss10110022_RF1_PW), pw_rf1) : PSD_ss10110022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss10110022_RF1_R), res_rf1) : PSD_ss10110022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss10110022_RF1_LEFT), hrf1a) : PSD_ss10110022_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss10110022_RF1_RIGHT), hrf1b) : PSD_ss10110022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss10110022_RF1_NUML), num_rf1lobe) : PSD_ss10110022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss10110022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss10110022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp302_pw_rf1=pw_rf1,&_temp302_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp303_a_rf1=a_rf1,&_temp303_a_rf1) : &a_rf1, SAR_ABS_ss10110022,
                             SAR_Pss10110022, SAR_ARss10110022, 
                             SAR_DTCss10110022, SAR_MAXPWss10110022, 1, 
                             MAX_B1_ss10110022, MAX_INT_B1_SQ_ss10110022, 
                             MAX_RMS_B1_ss10110022, 90.0, _flip_rf1.fixedflag ? (_temp304_flip_rf1=flip_rf1,&_temp304_flip_rf1) : &flip_rf1,
                             (float)PSD_ss10110022_RF1_PW, NOM_BW_ss10110022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp305_res_rf1=res_rf1,&_temp305_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp306_wg_rf1=wg_rf1,&_temp306_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss10110022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss10110022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(10110022), whichss) : 10110022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss10110022), nbw_ssrf) : NOM_BW_ss10110022;
                break;

            case 1028822:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1028822_RF1_PW), pw_rf1) : PSD_ss1028822_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1028822_RF1_R), res_rf1) : PSD_ss1028822_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1028822_RF1_LEFT), hrf1a) : PSD_ss1028822_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1028822_RF1_RIGHT), hrf1b) : PSD_ss1028822_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1028822_RF1_NUML), num_rf1lobe) : PSD_ss1028822_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1028822_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1028822_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp307_pw_rf1=pw_rf1,&_temp307_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp308_a_rf1=a_rf1,&_temp308_a_rf1) : &a_rf1, SAR_ABS_ss1028822,
                             SAR_Pss1028822, SAR_ARss1028822, SAR_DTCss1028822,
                             SAR_MAXPWss1028822, 1, MAX_B1_ss1028822,
                             MAX_INT_B1_SQ_ss1028822, MAX_RMS_B1_ss1028822, 90.0,  
                             _flip_rf1.fixedflag ? (_temp309_flip_rf1=flip_rf1,&_temp309_flip_rf1) : &flip_rf1, (float)PSD_ss1028822_RF1_PW, NOM_BW_ss1028822,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp310_res_rf1=res_rf1,&_temp310_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp311_wg_rf1=wg_rf1,&_temp311_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1028822.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1028822.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1028822), whichss) : 1028822;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1028822), nbw_ssrf) : NOM_BW_ss1028822;
                off90minor  = _off90minor.fixedflag ?  ((void)(-25), off90minor) : -25;
                break;

            case 1534433: /* New designed pulse for SV EM and DM. wxc */
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(344), pw_ss_rampz) : 344;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1534433_RF1_PW), pw_rf1) : PSD_ss1534433_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1534433_RF1_R), res_rf1) : PSD_ss1534433_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1534433_RF1_LEFT), hrf1a) : PSD_ss1534433_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1534433_RF1_RIGHT), hrf1b) : PSD_ss1534433_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1534433_RF1_NUML), num_rf1lobe) : PSD_ss1534433_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1534433_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1534433_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp312_pw_rf1=pw_rf1,&_temp312_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp313_a_rf1=a_rf1,&_temp313_a_rf1) : &a_rf1, SAR_ABS_ss1534433,
                             SAR_Pss1534433, SAR_ARss1534433, SAR_DTCss1534433,
                             SAR_MAXPWss1534433, 1, MAX_B1_ss1534433,
                             MAX_INT_B1_SQ_ss1534433, MAX_RMS_B1_ss1534433, 90.0,
                             _flip_rf1.fixedflag ? (_temp314_flip_rf1=flip_rf1,&_temp314_flip_rf1) : &flip_rf1, (float)PSD_ss1534433_RF1_PW, NOM_BW_ss1534433,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp315_res_rf1=res_rf1,&_temp315_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp316_wg_rf1=wg_rf1,&_temp316_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1534433.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1534433.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1534433), whichss) : 1534433;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1534433), nbw_ssrf) : NOM_BW_ss1534433;
                break;
 
            case 15496248: /* New designed pulse for Starter. ZT */
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(496), pw_ss_rampz) : 496;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15496248_RF1_PW), pw_rf1) : PSD_ss15496248_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15496248_RF1_R), res_rf1) : PSD_ss15496248_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss15496248_RF1_LEFT), hrf1a) : PSD_ss15496248_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss15496248_RF1_RIGHT), hrf1b) : PSD_ss15496248_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15496248_RF1_NUML), num_rf1lobe) : PSD_ss15496248_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15496248_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15496248_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp317_pw_rf1=pw_rf1,&_temp317_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp318_a_rf1=a_rf1,&_temp318_a_rf1) : &a_rf1, SAR_ABS_ss15496248,
                             SAR_Pss15496248, SAR_ARss15496248, SAR_DTCss15496248,
                             SAR_MAXPWss15496248, 1, MAX_B1_ss15496248,
                             MAX_INT_B1_SQ_ss15496248, MAX_RMS_B1_ss15496248, 90.0,
                             _flip_rf1.fixedflag ? (_temp319_flip_rf1=flip_rf1,&_temp319_flip_rf1) : &flip_rf1, (float)PSD_ss15496248_RF1_PW, NOM_BW_ss15496248,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp320_res_rf1=res_rf1,&_temp320_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp321_wg_rf1=wg_rf1,&_temp321_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss15496248.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss15496248.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15496248), whichss) : 15496248;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15496248), nbw_ssrf) : NOM_BW_ss15496248;
                break;

            case 1560010:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(600), pw_ss_rampz) : 600;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_PW), pw_rf1) : PSD_ss1560010_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1560010_RF1_R), res_rf1) : PSD_ss1560010_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1560010_RF1_LEFT), hrf1a) : PSD_ss1560010_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1560010_RF1_RIGHT), hrf1b) : PSD_ss1560010_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1560010_RF1_NUML), num_rf1lobe) : PSD_ss1560010_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1560010_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1560010_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp322_pw_rf1=pw_rf1,&_temp322_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp323_a_rf1=a_rf1,&_temp323_a_rf1) : &a_rf1, SAR_ABS_ss1560010,
                             SAR_Pss1560010, SAR_ARss1560010, SAR_DTCss1560010,
                             SAR_MAXPWss1560010, 1, MAX_B1_ss1560010,
                             MAX_INT_B1_SQ_ss1560010, MAX_RMS_B1_ss1560010, 90.0, 
                             _flip_rf1.fixedflag ? (_temp324_flip_rf1=flip_rf1,&_temp324_flip_rf1) : &flip_rf1, (float)PSD_ss1560010_RF1_PW, NOM_BW_ss1560010,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp325_res_rf1=res_rf1,&_temp325_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp326_wg_rf1=wg_rf1,&_temp326_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1560010.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1560010.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1560010), whichss) : 1560010;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1560010), nbw_ssrf) : NOM_BW_ss1560010;
                break;

            case 15110022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(1100), pw_ss_rampz) : 1100;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15110022_RF1_PW), pw_rf1) : PSD_ss15110022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15110022_RF1_R), res_rf1) : PSD_ss15110022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss15110022_RF1_LEFT), hrf1a) : PSD_ss15110022_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss15110022_RF1_RIGHT), hrf1b) : PSD_ss15110022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15110022_RF1_NUML), num_rf1lobe) : PSD_ss15110022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15110022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15110022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp327_pw_rf1=pw_rf1,&_temp327_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp328_a_rf1=a_rf1,&_temp328_a_rf1) : &a_rf1, SAR_ABS_ss15110022,
                             SAR_Pss15110022, SAR_ARss15110022, SAR_DTCss15110022,
                             SAR_MAXPWss15110022, 1, MAX_B1_ss15110022,
                             MAX_INT_B1_SQ_ss15110022, MAX_RMS_B1_ss15110022, 90.0,  
                             _flip_rf1.fixedflag ? (_temp329_flip_rf1=flip_rf1,&_temp329_flip_rf1) : &flip_rf1, (float)PSD_ss15110022_RF1_PW, NOM_BW_ss15110022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp330_res_rf1=res_rf1,&_temp330_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp331_wg_rf1=wg_rf1,&_temp331_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss15110022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss15110022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15110022), whichss) : 15110022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15110022), nbw_ssrf) : NOM_BW_ss15110022;
                break;

            case 1528822:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(288), pw_ss_rampz) : 288;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1528822_RF1_PW), pw_rf1) : PSD_ss1528822_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1528822_RF1_R), res_rf1) : PSD_ss1528822_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1528822_RF1_LEFT), hrf1a) : PSD_ss1528822_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1528822_RF1_RIGHT), hrf1b) : PSD_ss1528822_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1528822_RF1_NUML), num_rf1lobe) : PSD_ss1528822_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1528822_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1528822_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp332_pw_rf1=pw_rf1,&_temp332_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp333_a_rf1=a_rf1,&_temp333_a_rf1) : &a_rf1, SAR_ABS_ss1528822,
                             SAR_Pss1528822, SAR_ARss1528822, SAR_DTCss1528822,
                             SAR_MAXPWss1528822, 1, MAX_B1_ss1528822, 
                             MAX_INT_B1_SQ_ss1528822, MAX_RMS_B1_ss1528822, 90.0, 
                             _flip_rf1.fixedflag ? (_temp334_flip_rf1=flip_rf1,&_temp334_flip_rf1) : &flip_rf1, (float)PSD_ss1528822_RF1_PW, NOM_BW_ss1528822,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp335_res_rf1=res_rf1,&_temp335_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp336_wg_rf1=wg_rf1,&_temp336_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1528822.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1528822.gz");
                sprintf(hgzssfn, "/usr/g/bin/hss1528822.grd");
                whichss  = _whichss.fixedflag ?  ((void)(1528822), whichss) : 1528822;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1528822), nbw_ssrf) : NOM_BW_ss1528822;
                off90minor  = _off90minor.fixedflag ?  ((void)(-45), off90minor) : -45;
                break;

            case 1544022:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(440), pw_ss_rampz) : 440;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss1544022_RF1_PW), pw_rf1) : PSD_ss1544022_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss1544022_RF1_R), res_rf1) : PSD_ss1544022_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss1544022_RF1_LEFT), hrf1a) : PSD_ss1544022_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss1544022_RF1_RIGHT), hrf1b) : PSD_ss1544022_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss1544022_RF1_NUML), num_rf1lobe) : PSD_ss1544022_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss1544022_RF1_HlPW), pw_gzrf1lobe) : PSD_ss1544022_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp337_pw_rf1=pw_rf1,&_temp337_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp338_a_rf1=a_rf1,&_temp338_a_rf1) : &a_rf1, SAR_ABS_ss1544022,
                             SAR_Pss1544022, SAR_ARss1544022, SAR_DTCss1544022,
                             SAR_MAXPWss1544022, 1, MAX_B1_ss1544022,
                             MAX_INT_B1_SQ_ss1544022, MAX_RMS_B1_ss1544022, 90.0,
                             _flip_rf1.fixedflag ? (_temp339_flip_rf1=flip_rf1,&_temp339_flip_rf1) : &flip_rf1, (float)PSD_ss1544022_RF1_PW, NOM_BW_ss1544022,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp340_res_rf1=res_rf1,&_temp340_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp341_wg_rf1=wg_rf1,&_temp341_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss1544022.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss1544022.gz");
                whichss  = _whichss.fixedflag ?  ((void)(1544022), whichss) : 1544022;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss1544022), nbw_ssrf) : NOM_BW_ss1544022;
                break;

            case 3026838:  /*YH,YZ*/
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(268), pw_ss_rampz) : 268;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_PW), pw_rf1) : PSD_ss3026838_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026838_RF1_R), res_rf1) : PSD_ss3026838_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss3026838_RF1_LEFT), hrf1a) : PSD_ss3026838_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss3026838_RF1_RIGHT), hrf1b) : PSD_ss3026838_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026838_RF1_NUML), num_rf1lobe) : PSD_ss3026838_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026838_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026838_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp342_pw_rf1=pw_rf1,&_temp342_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp343_a_rf1=a_rf1,&_temp343_a_rf1) : &a_rf1, SAR_ABS_ss3026838,
                             SAR_Pss3026838, SAR_ARss3026838, SAR_DTCss3026838,
                             SAR_MAXPWss3026838, 1, MAX_B1_ss3026838, 
                             MAX_INT_B1_SQ_ss3026838, MAX_RMS_B1_ss3026838, 90.0, 
                             _flip_rf1.fixedflag ? (_temp344_flip_rf1=flip_rf1,&_temp344_flip_rf1) : &flip_rf1, (float)PSD_ss3026838_RF1_PW, NOM_BW_ss3026838,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp345_res_rf1=res_rf1,&_temp345_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp346_wg_rf1=wg_rf1,&_temp346_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3026838.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3026838.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026838), whichss) : 3026838;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026838), nbw_ssrf) : NOM_BW_ss3026838;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;  /*end YH,YZ*/

                /* cxl04 19991201 add 3018027 pulse */

            case 3026033:  /*YH,YZ*/
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(260), pw_ss_rampz) : 260;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3026033_RF1_PW), pw_rf1) : PSD_ss3026033_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3026033_RF1_R), res_rf1) : PSD_ss3026033_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                if(exist(opflip) > 60)
                { 
                    hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss3026033_RF1_LEFT), hrf1a) : PSD_ss3026033_RF1_LEFT;
                    hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss3026033_RF1_RIGHT), hrf1b) : PSD_ss3026033_RF1_RIGHT;
                }
                else if ((30 < opflip) && (opflip <=60))
                {
                    hrf1a  = _hrf1a.fixedflag ?  ((void)(4820), hrf1a) : 4820; 
                    hrf1b  = _hrf1b.fixedflag ?  ((void)(4900), hrf1b) : 4900;
                }
                else
                {
                    hrf1a  = _hrf1a.fixedflag ?  ((void)(4910), hrf1a) : 4910;
                    hrf1b  = _hrf1b.fixedflag ?  ((void)(4810), hrf1b) : 4810;
                }
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3026033_RF1_NUML), num_rf1lobe) : PSD_ss3026033_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3026033_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3026033_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp347_pw_rf1=pw_rf1,&_temp347_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp348_a_rf1=a_rf1,&_temp348_a_rf1) : &a_rf1, SAR_ABS_ss3026033,
                             SAR_Pss3026033, SAR_ARss3026033, SAR_DTCss3026033,
                             SAR_MAXPWss3026033, 1, MAX_B1_ss3026033, 
                             MAX_INT_B1_SQ_ss3026033, MAX_RMS_B1_ss3026033, 90.0, 
                             _flip_rf1.fixedflag ? (_temp349_flip_rf1=flip_rf1,&_temp349_flip_rf1) : &flip_rf1, (float)PSD_ss3026033_RF1_PW, NOM_BW_ss3026033,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp350_res_rf1=res_rf1,&_temp350_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp351_wg_rf1=wg_rf1,&_temp351_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "ss3026033.rho");
                sprintf(ssgzfile, "ss3026033.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3026033), whichss) : 3026033;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3026033), nbw_ssrf) : NOM_BW_ss3026033;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;  /*end YZ */

            case 3018027:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(180), pw_ss_rampz) : 180;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss3018027_RF1_PW), pw_rf1) : PSD_ss3018027_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss3018027_RF1_R), res_rf1) : PSD_ss3018027_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss3018027_RF1_LEFT), hrf1a) : PSD_ss3018027_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss3018027_RF1_RIGHT), hrf1b) : PSD_ss3018027_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss3018027_RF1_NUML), num_rf1lobe) : PSD_ss3018027_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss3018027_RF1_HlPW), pw_gzrf1lobe) : PSD_ss3018027_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp352_pw_rf1=pw_rf1,&_temp352_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp353_a_rf1=a_rf1,&_temp353_a_rf1) : &a_rf1, SAR_ABS_ss3018027,
                             SAR_Pss3018027, SAR_ARss3018027, SAR_DTCss3018027,
                             SAR_MAXPWss3018027, 1, MAX_B1_ss3018027, 
                             MAX_INT_B1_SQ_ss3018027, MAX_RMS_B1_ss3018027, 90.0, 
                             _flip_rf1.fixedflag ? (_temp354_flip_rf1=flip_rf1,&_temp354_flip_rf1) : &flip_rf1, (float)PSD_ss3018027_RF1_PW, NOM_BW_ss3018027,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp355_res_rf1=res_rf1,&_temp355_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp356_wg_rf1=wg_rf1,&_temp356_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "/usr/g/bin/ss3018027.rho");
                sprintf(ssgzfile, "/usr/g/bin/ss3018027.gz");
                whichss  = _whichss.fixedflag ?  ((void)(3018027), whichss) : 3018027;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss3018027), nbw_ssrf) : NOM_BW_ss3018027;
                off90minor  = _off90minor.fixedflag ?  ((void)(-45), off90minor) : -45;
                break;

            case 15048233:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048233_RF1_PW), pw_rf1) : PSD_ss15048233_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048233_RF1_R), res_rf1) : PSD_ss15048233_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss15048233_RF1_LEFT), hrf1a) : PSD_ss15048233_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss15048233_RF1_RIGHT), hrf1b) : PSD_ss15048233_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048233_RF1_NUML), num_rf1lobe) : PSD_ss15048233_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048233_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048233_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp357_pw_rf1=pw_rf1,&_temp357_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp358_a_rf1=a_rf1,&_temp358_a_rf1) : &a_rf1, SAR_ABS_ss15048233,
                             SAR_Pss15048233, SAR_ARss15048233, SAR_DTCss15048233,
                             SAR_MAXPWss15048233, 1, MAX_B1_ss15048233,
                             MAX_INT_B1_SQ_ss15048233, MAX_RMS_B1_ss15048233, 90.0,
                             _flip_rf1.fixedflag ? (_temp359_flip_rf1=flip_rf1,&_temp359_flip_rf1) : &flip_rf1, (float)PSD_ss15048233_RF1_PW, NOM_BW_ss15048233,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp360_res_rf1=res_rf1,&_temp360_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp361_wg_rf1=wg_rf1,&_temp361_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp15048233.rho");
                sprintf(ssgzfile, "spsp15048233.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048233), whichss) : 15048233;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048233), nbw_ssrf) : NOM_BW_ss15048233;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 15048234:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048234_RF1_PW), pw_rf1) : PSD_ss15048234_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048234_RF1_R), res_rf1) : PSD_ss15048234_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss15048234_RF1_LEFT), hrf1a) : PSD_ss15048234_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss15048234_RF1_RIGHT), hrf1b) : PSD_ss15048234_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048234_RF1_NUML), num_rf1lobe) : PSD_ss15048234_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048234_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048234_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp362_pw_rf1=pw_rf1,&_temp362_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp363_a_rf1=a_rf1,&_temp363_a_rf1) : &a_rf1, SAR_ABS_ss15048234,
                             SAR_Pss15048234, SAR_ARss15048234, SAR_DTCss15048234,
                             SAR_MAXPWss15048234, 1, MAX_B1_ss15048234,
                             MAX_INT_B1_SQ_ss15048234, MAX_RMS_B1_ss15048234, 90.0,
                             _flip_rf1.fixedflag ? (_temp364_flip_rf1=flip_rf1,&_temp364_flip_rf1) : &flip_rf1, (float)PSD_ss15048234_RF1_PW, NOM_BW_ss15048234,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp365_res_rf1=res_rf1,&_temp365_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp366_wg_rf1=wg_rf1,&_temp366_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp15048234.rho");
                sprintf(ssgzfile, "spsp15048234.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048234), whichss) : 15048234;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048234), nbw_ssrf) : NOM_BW_ss15048234;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 15048235:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(48), pw_ss_rampz) : 48;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss15048235_RF1_PW), pw_rf1) : PSD_ss15048235_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss15048235_RF1_R), res_rf1) : PSD_ss15048235_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss15048235_RF1_LEFT), hrf1a) : PSD_ss15048235_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss15048235_RF1_RIGHT), hrf1b) : PSD_ss15048235_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss15048235_RF1_NUML), num_rf1lobe) : PSD_ss15048235_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss15048235_RF1_HlPW), pw_gzrf1lobe) : PSD_ss15048235_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp367_pw_rf1=pw_rf1,&_temp367_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp368_a_rf1=a_rf1,&_temp368_a_rf1) : &a_rf1, SAR_ABS_ss15048235,
                             SAR_Pss15048235, SAR_ARss15048235, SAR_DTCss15048235,
                             SAR_MAXPWss15048235, 1, MAX_B1_ss15048235,
                             MAX_INT_B1_SQ_ss15048235, MAX_RMS_B1_ss15048235, 90.0,
                             _flip_rf1.fixedflag ? (_temp369_flip_rf1=flip_rf1,&_temp369_flip_rf1) : &flip_rf1, (float)PSD_ss15048235_RF1_PW, NOM_BW_ss15048235,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp370_res_rf1=res_rf1,&_temp370_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp371_wg_rf1=wg_rf1,&_temp371_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp15048235.rho");
                sprintf(ssgzfile, "spsp15048235.gz");
                whichss  = _whichss.fixedflag ?  ((void)(15048235), whichss) : 15048235;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss15048235), nbw_ssrf) : NOM_BW_ss15048235;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104233:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104233_RF1_PW), pw_rf1) : PSD_ss30104233_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104233_RF1_R), res_rf1) : PSD_ss30104233_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30104233_RF1_LEFT), hrf1a) : PSD_ss30104233_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30104233_RF1_RIGHT), hrf1b) : PSD_ss30104233_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104233_RF1_NUML), num_rf1lobe) : PSD_ss30104233_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104233_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104233_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp372_pw_rf1=pw_rf1,&_temp372_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp373_a_rf1=a_rf1,&_temp373_a_rf1) : &a_rf1, SAR_ABS_ss30104233,
                             SAR_Pss30104233, SAR_ARss30104233, SAR_DTCss30104233,
                             SAR_MAXPWss30104233, 1, MAX_B1_ss30104233,
                             MAX_INT_B1_SQ_ss30104233, MAX_RMS_B1_ss30104233, 90.0,
                             _flip_rf1.fixedflag ? (_temp374_flip_rf1=flip_rf1,&_temp374_flip_rf1) : &flip_rf1, (float)PSD_ss30104233_RF1_PW, NOM_BW_ss30104233,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp375_res_rf1=res_rf1,&_temp375_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp376_wg_rf1=wg_rf1,&_temp376_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp30104233.rho");
                sprintf(ssgzfile, "spsp30104233.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104233), whichss) : 30104233;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104233), nbw_ssrf) : NOM_BW_ss30104233;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104234:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104234_RF1_PW), pw_rf1) : PSD_ss30104234_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104234_RF1_R), res_rf1) : PSD_ss30104234_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30104234_RF1_LEFT), hrf1a) : PSD_ss30104234_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30104234_RF1_RIGHT), hrf1b) : PSD_ss30104234_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104234_RF1_NUML), num_rf1lobe) : PSD_ss30104234_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104234_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104234_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp377_pw_rf1=pw_rf1,&_temp377_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp378_a_rf1=a_rf1,&_temp378_a_rf1) : &a_rf1, SAR_ABS_ss30104234,
                             SAR_Pss30104234, SAR_ARss30104234, SAR_DTCss30104234,
                             SAR_MAXPWss30104234, 1, MAX_B1_ss30104234,
                             MAX_INT_B1_SQ_ss30104234, MAX_RMS_B1_ss30104234, 90.0,
                             _flip_rf1.fixedflag ? (_temp379_flip_rf1=flip_rf1,&_temp379_flip_rf1) : &flip_rf1, (float)PSD_ss30104234_RF1_PW, NOM_BW_ss30104234,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp380_res_rf1=res_rf1,&_temp380_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp381_wg_rf1=wg_rf1,&_temp381_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp30104234.rho");
                sprintf(ssgzfile, "spsp30104234.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104234), whichss) : 30104234;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104234), nbw_ssrf) : NOM_BW_ss30104234;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;

            case 30104235:
                pw_ss_rampz  = _pw_ss_rampz.fixedflag ?  ((void)(104), pw_ss_rampz) : 104;
                pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_ss30104235_RF1_PW), pw_rf1) : PSD_ss30104235_RF1_PW;
                res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_ss30104235_RF1_R), res_rf1) : PSD_ss30104235_RF1_R;
                gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
                hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_ss30104235_RF1_LEFT), hrf1a) : PSD_ss30104235_RF1_LEFT;
                hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_ss30104235_RF1_RIGHT), hrf1b) : PSD_ss30104235_RF1_RIGHT;
                num_rf1lobe   = _num_rf1lobe.fixedflag ?  ((void)(PSD_ss30104235_RF1_NUML), num_rf1lobe) : PSD_ss30104235_RF1_NUML;
                pw_gzrf1lobe  = _pw_gzrf1lobe.fixedflag ? ((void)(PSD_ss30104235_RF1_HlPW), pw_gzrf1lobe) : PSD_ss30104235_RF1_HlPW;
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp382_pw_rf1=pw_rf1,&_temp382_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp383_a_rf1=a_rf1,&_temp383_a_rf1) : &a_rf1, SAR_ABS_ss30104235,
                             SAR_Pss30104235, SAR_ARss30104235, SAR_DTCss30104235,
                             SAR_MAXPWss30104235, 1, MAX_B1_ss30104235,
                             MAX_INT_B1_SQ_ss30104235, MAX_RMS_B1_ss30104235, 90.0,
                             _flip_rf1.fixedflag ? (_temp384_flip_rf1=flip_rf1,&_temp384_flip_rf1) : &flip_rf1, (float)PSD_ss30104235_RF1_PW, NOM_BW_ss30104235,
                             PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                             hrf1b, 1.0, _res_rf1.fixedflag ? (_temp385_res_rf1=res_rf1,&_temp385_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp386_wg_rf1=wg_rf1,&_temp386_wg_rf1) : &wg_rf1, 1, rfpulse);
                sprintf(ssrffile, "spsp30104235.rho");
                sprintf(ssgzfile, "spsp30104235.gz");
                whichss  = _whichss.fixedflag ?  ((void)(30104235), whichss) : 30104235;
                nbw_ssrf  = _nbw_ssrf.fixedflag ?  ((void)(NOM_BW_ss30104235), nbw_ssrf) : NOM_BW_ss30104235;
                off90minor  = _off90minor.fixedflag ?  ((void)(0), off90minor) : 0;
                break;                

            default:

                epic_error(0, "SS type %d not found", 0, EE_ARGS(1),
                           INT_ARG, ss_type);

                return FAILURE;
                /* NOTREACHED */
        } /* end switch ss_type */
    } /* end if ssrf1 */

    return(SUCCESS);
}

/******************************ssEval************************************/
/* 4/21/96 RJL: Init all new Advisory Cvs */

#include "InitAdvisories.h"

/*-------------------------------------------------------------------
 * PROCEDURE: InitAdvPnlCVs
 * INPUT: none
 * OUTPUT: none
 * RETURN: none
 * SYNOPSIS: This function sets the advisory panel minimum and maximum values
 *           for advisory panel cvs which are not set in cveval. This gives us
 *           the opportunity to start placing items into the 8.0 EPIC Advisory
 *           Panel popup as desired.
 *
 *           Example:
 *                 if (exist(opssfse)!=PSD_OFF && exist(opnex)!=0.5) {
 *                      avminnex = avmaxnex = 0.5;
 *                      return ADVISORY_FAILURE;
 *                 }
 *           The above will ensure that (Nex 0.5) appears in the popup as a valid choice.
 *
 *---------------------------------------------------------------------*/
void 
InitAdvPnlCVs( void )
{
 avmaxnecho = _opnecho.maxval;
 avmaxte = _opte.maxval;
 avmaxte2 = _opte2.maxval;
 avmaxti = _opti.maxval;
 avmaxtr = _optr.maxval;
 avmaxfov = _opfov.maxval;
 avmaxyres = _opyres.maxval;
 avmaxxres = _opxres.maxval;
 avmaxrbw = _oprbw.maxval; 
 avmaxrbw2 = _oprbw2.maxval;
 avmaxsldelay = _opsldelay.maxval;
 avmaxetl = _opetl.maxval;
 avmaxslicecnt = _opslicecnt.maxval;
 avmaxnshots = _opnshots.maxval;
 avmaxphasefov = _opphasefov.maxval;
 avmaxslthick = _opslthick.maxval;
 avmaxnex = _opnex.maxval;
 avmaxflip = _opflip.maxval;
 avminnecho = _opnecho.minval;
 avminte = _opte.minval;
 avminte2 = _opte2.minval;
 avminti = _opti.minval;
 avmintr = _optr.minval;
 avminfov = _opfov.minval;
 avmaxslquant = _opslquant.maxval;
 avminslquant = _opslquant.minval;
 avminrbw = _oprbw.minval; 
 avminrbw2 = _oprbw2.minval;
 avminsldelay  = _avminsldelay.fixedflag ?  ((void)(_opsldelay.minval), avminsldelay) : _opsldelay.minval;
 avminetl = _opetl.minval;
 avminyres = _opyres.minval;
 avminslicecnt = _opslicecnt.minval;
 avminxres = _opxres.minval;
 avminnshots = _opnshots.minval;
 avminphasefov = _opphasefov.minval;
 avminslthick = _opslthick.minval;
 avminnex = _opnex.minval;
 avminflip = _opflip.minval;
 avminslspace = _opslspace.minval;
 avmaxslspace = _opslspace.maxval;
 avminbspti = _opbspti.minval;
 avmaxbspti = _opbspti.maxval;
 avminvest = _opvest.minval;
 avmaxvest = _opvest.maxval;
 avminnpwfactor = _opnpwfactor.minval;
 avmaxnpwfactor = _opnpwfactor.maxval;

 return;
}

/* t1flair_stir */

/* epi_t1flair_stir */
STATUS T1flairInit( void )
{
    avminti_t1flair  = _avminti_t1flair.fixedflag ?  ((void)(T1FLAIR_MIN_TI), avminti_t1flair) : T1FLAIR_MIN_TI;
    avmaxti_t1flair  = _avmaxti_t1flair.fixedflag ?  ((void)(T1FLAIR_MAX_TI), avmaxti_t1flair) : T1FLAIR_MAX_TI;

    /*** T1flair Enabler ***/
    /* epi_t1flair_stir */
    /* Always use interleaved stir */

    cvmax( t1flair_flag, PSD_ON );

    cvdef( t1flair_flag, PSD_OFF );

    return SUCCESS;
}


#include "rfsspsummary.h"
#include "sar_display_api.h"

FILTER_INFO *echo1mon_filt, echo1mon_rtfilt;  /* real-time filter generation */

/* Flags set by soft key to enable the Smartprep features */
int sp_key_on;
/* FOR MERGE */
int gate_on = 0;
float gmax_cylr=0.0;
int   nom_pw_cylr=0; 

int auto_nav_track_key_on = 0; /* A flag for auto navigator tracker enabled by its option key */

float rootcyl;
int pw_estim;

STATUS Monitor_Cvinit(RF_PULSE Rfpulse[])
{
#ifdef SPIRAL

#ifdef PSD_HW
    FILE *fp;

    if (!(fp = fopen("/tmp/monloc.dat","r"))) 
    {
        fprintf(stderr, "Can't open /tmp/monloc.dat, please download a nav scan with a tracker first\n");
    } else {
        fscanf(fp, "%f\t%f\t%f\n",&(mymon_loc.optloc),&(mymon_loc.oprloc),
               &(mymon_loc.opphasoff));
        fscanf(fp, "%f\t%f\t%f\n",&(mymon_loc.optloc_shift),&(mymon_loc.oprloc_shift),
               &(mymon_loc.opphasoff_shift));
        fscanf(fp,"%f\t%f\t%f\n",&(mymon_loc.oprot[0]),&(mymon_loc.oprot[1]),
               &(mymon_loc.oprot[2]));
        fscanf(fp,"%f\t%f\t%f\n",&(mymon_loc.oprot[3]),&(mymon_loc.oprot[4]),
               &(mymon_loc.oprot[5]));
        fscanf(fp,"%f\t%f\t%f\n",&(mymon_loc.oprot[6]),&(mymon_loc.oprot[7]),
               &(mymon_loc.oprot[8]));
        fclose(fp);
    }
#endif /* PSD_HW */
    mon_loc = mymon_loc;

#endif /* SPIRAL */

    cvmax(opnav, 1);

    auto_nav_track_key_on = !checkOptionKey( SOK_AUTONAVTRK );

    if (PSD_OFF == navigator_flag)
        navigatorCYL_flag  = _navigatorCYL_flag.fixedflag ?  ((void)(0), navigatorCYL_flag) : 0;
    
    /* initialize pulse widths */
    pw_rf1mon  = _pw_rf1mon.fixedflag ?  ((void)(Rfpulse[RF1MON_SLOT].nom_pw), pw_rf1mon) : Rfpulse[RF1MON_SLOT].nom_pw;
    if (cffield >= B0_30000) {
        pw_rf2mon  = _pw_rf2mon.fixedflag ?  ((void)(4800), pw_rf2mon) : 4800;
        pw_rfmontipup  = _pw_rfmontipup.fixedflag ?  ((void)(4800), pw_rfmontipup) : 4800;
    } else {
        pw_rf2mon  = _pw_rf2mon.fixedflag ?  ((void)(Rfpulse[RF2MON_SLOT].nom_pw), pw_rf2mon) : Rfpulse[RF2MON_SLOT].nom_pw;
        pw_rfmontipup  = _pw_rfmontipup.fixedflag ?  ((void)(Rfpulse[RFMONTIPUP_SLOT].nom_pw), pw_rfmontipup) : Rfpulse[RFMONTIPUP_SLOT].nom_pw;
    }
    pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(Rfpulse[RFCYLR_SLOT].nom_pw), pw_rfcylr) : Rfpulse[RFCYLR_SLOT].nom_pw;
    pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(Rfpulse[RFCYLRTIPUP_SLOT].nom_pw), pw_rfcylrtipup) : Rfpulse[RFCYLRTIPUP_SLOT].nom_pw;
    
    /* initialize resolutions */
    res_rf1mon  = _res_rf1mon.fixedflag ?  ((void)(0), res_rf1mon) : 0; 
    res_rf2mon  = _res_rf2mon.fixedflag ?  ((void)(0), res_rf2mon) : 0;
    res_rfmontipup  = _res_rfmontipup.fixedflag ?  ((void)(0), res_rfmontipup) : 0;

    /* initialize flip angles */
    flip_rf1mon  = _flip_rf1mon.fixedflag ?  ((void)(90), flip_rf1mon) : 90;
    flip_rf2mon  = _flip_rf2mon.fixedflag ?  ((void)(180), flip_rf2mon) : 180;
    flip_rfmontipup  = _flip_rfmontipup.fixedflag ?  ((void)(180), flip_rfmontipup) : 180;

    /* MRIge75943, Set flip angle enough to get through for even the largest 
       patient weight with the body coil, SK */

    if (cffield == B0_30000)
    {
        flip_rf2mon  = _flip_rf2mon.fixedflag ?  ((void)(140), flip_rf2mon) : 140; 
        flip_rfmontipup  = _flip_rfmontipup.fixedflag ?  ((void)(140), flip_rfmontipup) : 140; 
    }

    /* initialize amplitudes */
    a_rf1mon  = _a_rf1mon.fixedflag ?  ((void)(0.5), a_rf1mon) : 0.5;
    a_rf2mon  = _a_rf2mon.fixedflag ?  ((void)(1.0), a_rf2mon) : 1.0;
    a_rfmontipup  = _a_rfmontipup.fixedflag ?  ((void)(1.0), a_rfmontipup) : 1.0;
    /* MRIhc07226: navCYL */ 
    a_rfcylr  = _a_rfcylr.fixedflag ?  ((void)(1.0), a_rfcylr) : 1.0;
    a_rfcylrtipup  = _a_rfcylrtipup.fixedflag ?  ((void)(1.0), a_rfcylrtipup) : 1.0;
    
    /* initialize sinc cycles */
    cyc_rf1mon  = _cyc_rf1mon.fixedflag ?  ((void)(1), cyc_rf1mon) : 1;
    cyc_rf2mon  = _cyc_rf2mon.fixedflag ?  ((void)(1), cyc_rf2mon) : 1;
    cyc_rfmontipup  = _cyc_rfmontipup.fixedflag ?  ((void)(1), cyc_rfmontipup) : 1;

    /* initialize gscale values */
    gscale_rf1mon  = _gscale_rf1mon.fixedflag ?  ((void)(1.0), gscale_rf1mon) : 1.0;
    gscale_rf2mon  = _gscale_rf2mon.fixedflag ?  ((void)(1.0), gscale_rf2mon) : 1.0;
    gscale_rfmontipup  = _gscale_rfmontipup.fixedflag ?  ((void)(1.0/nav_tipup_ratio), gscale_rfmontipup) : 1.0/nav_tipup_ratio;

    Rfpulse[RF1MON_SLOT].activity = PSD_PULSE_OFF;
    Rfpulse[RF2MON_SLOT].activity = PSD_PULSE_OFF;
    Rfpulse[RFMONTIPUP_SLOT].activity = PSD_PULSE_OFF;
    Rfpulse[RFCYLR_SLOT].activity = PSD_PULSE_OFF;
    Rfpulse[RFCYLRTIPUP_SLOT].activity = PSD_PULSE_OFF;

    max_avg_time  = _max_avg_time.fixedflag ?  ((void)(40000000), max_avg_time) : 40000000;
    numpts2pass  = _numpts2pass.fixedflag ?  ((void)(1), numpts2pass) : 1;

    inittargets(&monloggrd,&monphygrd);

    /* Initialize CVs for Monitor page */
    /* Show three pulldown values for Tracker length */
    /* and allow type-in values. */
    pimonfovnub = 4;
    /* Default Tracker length varies */
    if ((existcv(opnav)) && (exist(opnav)))
    {
        pimonfovval2 = 100.0;
        pimonfovval3 = 120.0;
        pimonfovval4 = 150.0;
        pidfmonfov = 120.0;

        /* Show three pulldown values for Tracker thickness */
        /* and allow type-in values. */
        pimonthicknub = 3;
        pimonthickval2 = 20.0;
        pimonthickval3 = 30.0;
        pidfmonthick = 20.0;   /* default Tracker thickness */
 
    } else {
        pimonfovval2 = 50.0;
        pimonfovval3 = 100.0;
        pimonfovval4 = 200.0;
        pidfmonfov = 200.0;
    
        /* Show three pulldown values for Tracker thickness */
        /* and allow type-in values. */
        pimonthicknub = 4;
        pimonthickval2 = 20.0;
        pimonthickval3 = 40.0;
        pimonthickval4 = 80.0;
        pidfmonthick = 20.0;   /* default Tracker thickness */
    }

    cerdtype  = _cerdtype.fixedflag ?  ((void)(cfcerdtype), cerdtype) : cfcerdtype;

    if(navigator_flag || smartprep_flag)
    {
        tracker_quant  = _tracker_quant.fixedflag ?  ((void)(1), tracker_quant) : 1;
    } else {
        tracker_quant  = _tracker_quant.fixedflag ?  ((void)(0), tracker_quant) : 0;
    }

    return SUCCESS;
}


STATUS
Monitor_CvevalInit(RF_PULSE Rfpulse[])
{
    int sp_on = 0;
    int ft_on = 0;
    /* FOR MERGE */
    gate_on = 0;

#ifdef NAV_EFGRE3D
#ifndef SPIRAL
    sp_key_on = (SmartPrepKey==Present);
#endif /* !SPIRAL */

    nav_irprep_flag  = _nav_irprep_flag.fixedflag ?  ((void)(irprep_flag), nav_irprep_flag) : irprep_flag;
    nav_tseq_irprep  = _nav_tseq_irprep.fixedflag ?  ((void)(tseq_irprep), nav_tseq_irprep) : tseq_irprep;
    nav_min_tseq_irprep  = _nav_min_tseq_irprep.fixedflag ?  ((void)(min_tseq_irprep), nav_min_tseq_irprep) : min_tseq_irprep;
#endif /* NAV_EFGRE3D */

    _navigator_flag.fixedflag = PSD_FIX_OFF;
    navigator_flag  = _navigator_flag.fixedflag ?  ((void)(exist(opnav)), navigator_flag) : exist(opnav);
    _navigator_flag.fixedflag = PSD_FIX_ON;

    opsmartprep  = _opsmartprep.fixedflag ?  ((void)(0), opsmartprep) : 0;
    cvmod( opsmartprep, 0, 1, 0, "Enable Smart Prep (0=OFF, 1=ON)", 0, "Smart Prep must be 0 or 1." );

    /* Fix for MRIge42402 */
    smartprep_flag  = _smartprep_flag.fixedflag ?    ((void)(exist(opsmartprep)&&sp_key_on), smartprep_flag) : exist(opsmartprep)&&sp_key_on;

    if(!navigator_flag) mon_tr  = _mon_tr.fixedflag ?  ((void)(20000), mon_tr) : 20000;

    if( smartprep_flag &&
        ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq)) ||      
         (PSD_GE == exist(oppseq)) || (PSD_SPGR == exist(oppseq))) )
    {
        sp_on = PSD_ON;
    }

    if( existcv(opfluorotrigger) && (PSD_ON == exist(opfluorotrigger)) )
    {
        ft_on = PSD_ON;
    }

    /* FOR MERGE */
    if ((exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON)) 
    {
        gate_on = 1;   
    }

#ifdef SPIRAL
    if( sp_on ) 
    {
        piuset |= use6 | use7;

        cvmod( opuser6, 10.0, 400.0, 40.0, "Max. monitor period (sec)", 0, "Max. monitor period out of range." );
        opuser6  = _opuser6.fixedflag ?  ((void)(_opuser6.defval), opuser6) : _opuser6.defval;

        cvmod( opuser7, 1.0, 100.0, 8.0, "Image acq. delay (sec)", 0, "Acq. delay out of range." );
        opuser7  = _opuser7.fixedflag ?  ((void)(_opuser7.defval), opuser7) : _opuser7.defval;
    } else {
        piuset &= ~use6;
        cvmod( opuser6, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  6", 0, "" );   
        cvoverride(opuser6, _opuser6.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        piuset &= ~use7;
        cvmod( opuser7, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  7", 0, "" );   
        cvoverride(opuser7, _opuser7.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    if( exist(opsmartprep) == 0 ) 
    {
        max_avg_time  = _max_avg_time.fixedflag ?  ((void)(20000000), max_avg_time) : 20000000;
    } else {
        max_avg_time  = _max_avg_time.fixedflag ?    ((void)(((int)(exist(opuser6)))*1000000), max_avg_time) : ((int)(exist(opuser6)))*1000000;
    }

    mon_trigger_delay  = _mon_trigger_delay.fixedflag ?    ((void)((int)(exist(opuser7))*1000000), mon_trigger_delay) : (int)(exist(opuser7))*1000000;
#else /* !SPIRAL */
#ifdef NAV_EFGRE3D
    cvmax(opt2prep,1);
    t2prep_flag = exist(opt2prep);

    if( sp_on ) 
    {
        piuset |= use2;
        cvmod( opuser2, 10.0, 400.0, 40.0, "Max. monitor period (sec)", 0, "Max. monitor period out of range." );
        opuser2  = _opuser2.fixedflag ?  ((void)(_opuser2.defval), opuser2) : _opuser2.defval;
    } else {
        piuset &= ~use2;
        cvmod( opuser2, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  2", 0, "" );   
        cvoverride(opuser2, _opuser2.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    if ( gate_on || (ssfp_flag && (ft_on==0)) || brava_flag || vibrant_flag ) 
    {
        piuset &= ~use4;
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  4", 0, "" );
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    } else {
        static int ft_or_sp_on = FALSE;

        /* Turn User CV ON and set field values */
        piuset |= use4;
        cvmod( opuser4, 0.0, 100.0, 0.0, "Image acq. delay (sec)", 0, "Acq. delay out of range." );

        /* Set flag to determine the default value */
        if( (PSD_ON == exist(opsmartprep)) ||
            (PSD_ON == exist(opfluorotrigger)) ) 
        {
            ft_or_sp_on = TRUE;
        }

        /* Set default value for Image Acquisition Delay */
        /* MRIge71573 - Make sure to override any previously prescribed
           value if the user turns FTMRA or SmartPrep OFF.  However, do
           this only the first time.  Otherwise, the user will not be able
           to prescribe a delay for any TOF protocols. */
        if( ft_or_sp_on && (PSD_OFF == exist(opsmartprep)) &&
            (PSD_OFF == exist(opfluorotrigger)) )
        {
            cvoverride(opuser4, _opuser4.defval, PSD_FIX_ON, PSD_EXIST_ON);
            ft_or_sp_on = FALSE;
        } else {
            opuser4  = _opuser4.fixedflag ?  ((void)(_opuser4.defval), opuser4) : _opuser4.defval;
        }
    }

    /* Scan delay only allowed for first station of meta-series */
    /* Scan delay disallowed for mask and venous acquisitions */
    if( ((exist(opmultistation) == PSD_ON) && (exist(opstation) > 1)) ||
        (exist(opmask) == PSD_ON) || (exist(opvenous) == PSD_ON) ) 
    {
        piuset &= ~use4;
        cvmod( opuser4, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable  4", 0, "" );   
        cvoverride(opuser4, _opuser4.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
    }

    if( exist(opsmartprep) == 0 ) 
    {
        max_avg_time  = _max_avg_time.fixedflag ?  ((void)(20000000), max_avg_time) : 20000000;
    } else {
        max_avg_time  = _max_avg_time.fixedflag ?    ((void)(((int)(exist(opuser2)))*1000000), max_avg_time) : ((int)(exist(opuser2)))*1000000;
    }

    mon_trigger_delay  = _mon_trigger_delay.fixedflag ?    ((void)((int)(exist(opuser4)*1000000)), mon_trigger_delay) : (int)(exist(opuser4)*1000000);
#endif /* NAV_EFGRE3D */
#endif /* SPIRAL */

    pititle  = _pititle.fixedflag ?    ((void)((piuset!=0)), pititle) : (piuset!=0);
    /* end of MRIge42402 */

    sigma1  = _sigma1.fixedflag ?  ((void)(3), sigma1) : 3;

    if( exist(opdose) > 20.0 ) 
    {
        sigma2  = _sigma2.fixedflag ?  ((void)(0.20), sigma2) : 0.20;
    } else {
        sigma2  = _sigma2.fixedflag ?  ((void)(0.15), sigma2) : 0.15;
    }

    if( (navigator_flag == PSD_ON) || (smartprep_flag == PSD_ON) ) 
    {
        pimonitor = 1;

        /* Display Auto Tracker UI only for BODY Navigator */
        if( (PSD_ON == auto_nav_track_key_on) && (PSD_ON == navigator_flag) && (PSD_ON != exist(opcgate)) )
        {
            piautonavtracker = PSD_ON;
        } else {
            piautonavtracker = PSD_OFF;
        }

    } else {
        pimonitor = 0;
        piautonavtracker = PSD_OFF;
    }

    num_baseline_pts  = _num_baseline_pts.fixedflag ?    ((void)(num_avg_bline+num_throwaways), num_baseline_pts) : num_avg_bline+num_throwaways;

    if (smartprep_flag) monrot_phi  = _monrot_phi.fixedflag ?  ((void)(0.0), monrot_phi) : 0.0;

    /* Turn ON activity flag for TIPUP rfs since they will be scaled in
     * efgre3d.e instead of Monitor.e. The flag has to be ON before
     * scalerfpulse function call.
     */
    if(exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
    {
        gradzmon[GZKMONTIPUP_SLOT].num = 1;
        if(navigatorCYL_flag)
        {
            Rfpulse[RFCYLRTIPUP_SLOT].activity = PSD_SCAN_ON;
            Rfpulse[RFCYLRTIPUP_SLOT].num = 1;
            gradymon[GYCYLRATIPUP_SLOT].num = 1;
            gradymon[GYCYLRTIPUP_SLOT].num = 1;
            gradzmon[GZCYLRATIPUP_SLOT].num = 1;
            gradzmon[GZCYLRTIPUP_SLOT].num = 1;
        } else {
            Rfpulse[RFMONTIPUP_SLOT].activity = PSD_SCAN_ON;
            Rfpulse[RFMONTIPUP_SLOT].num = 1;
            gradymon[GYMONTIPUP_SLOT].num = 1;
        }
    } else {
        Rfpulse[RFCYLRTIPUP_SLOT].activity = PSD_PULSE_OFF;
        Rfpulse[RFCYLRTIPUP_SLOT].num = 0;
        Rfpulse[RFMONTIPUP_SLOT].activity = PSD_PULSE_OFF;
        Rfpulse[RFMONTIPUP_SLOT].num = 0;
        gradymon[GYCYLRATIPUP_SLOT].num = 0;
        gradymon[GYCYLRTIPUP_SLOT].num = 0;
        gradzmon[GZCYLRATIPUP_SLOT].num = 0;
        gradzmon[GZCYLRTIPUP_SLOT].num = 0;
        gradymon[GYMONTIPUP_SLOT].num = 0;
        gradzmon[GZKMONTIPUP_SLOT].num = 0;
    }

    if(navigatorCYL_flag)
    {
        if (exist(opmonthick)<20.0)
        {
            cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_CONSTANT_DENSITY), cylr_rf_type) : CYLR_CONSTANT_DENSITY;
        }
        else if (PSD_XRMW_COIL == cfgcoiltype)
        {   /* XRMW */
            cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR145), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR145;
        }
        else if (PSD_VRMW_COIL == cfgcoiltype)
        {   /* VRMW */
            cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR107), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR107;
        }
        else if ((PSD_BRM2_COIL == cfgcoiltype) && (5551 == cfgradamp))
        {   /* Starter */
            cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR48), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR48;
        } 
        else
        {
            if(cfsrmode>190)
            {   /* XRM */
                cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR190), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR190;
            }
            else if (cfsrmode>145)
            {   /* TRM-Z */
                cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR145), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR145;
            }
            else if (cfsrmode>118)
            {   /* BRM/CRM */
                cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR118), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR118;
            }
            else
            {   /* TRM-W */              
                cylr_rf_type  = _cylr_rf_type.fixedflag ?  ((void)(CYLR_VARIABLE_DENSITY_SR75), cylr_rf_type) : CYLR_VARIABLE_DENSITY_SR75;
            }
        }

        if(CYLR_CONSTANT_DENSITY == cylr_rf_type)
        {   /* Legacy pluse with constant k-space density */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(GRAD_UPDATE_TIME*2400), pw_rfcylr) : GRAD_UPDATE_TIME*2400;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(2400), res_rfcylr) : 2400;
            Rfpulse[RFCYLR_SLOT].abswidth = 0.6308;
            Rfpulse[RFCYLR_SLOT].area     = 0.6308;
            Rfpulse[RFCYLR_SLOT].effwidth = 0.4704;
            Rfpulse[RFCYLR_SLOT].dtycyc   = 1.0;
            Rfpulse[RFCYLR_SLOT].maxpw    = 1.0;
            Rfpulse[RFCYLR_SLOT].max_b1   = 0.0166216;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = 0.000727778;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = 0.0114;
            Rfpulse[RFCYLR_SLOT].nom_pw   = pw_rfcylr;
            Rfpulse[RFCYLR_SLOT].nom_fa   = 90.0;
            nom_pw_cylr = pw_rfcylr;
            rootcyl = sqrt(10.0/exist(opmonthick));
            pw_estim = (int)(rootcyl*(float)pw_nomcyl*12.0/8.0);
        }
        else if(CYLR_VARIABLE_DENSITY_SR48 == cylr_rf_type)
        {   /* Starter */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR48), pw_rfcylr) : NOM_PW_CYL_SR48;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR48), res_rfcylr) : RES_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR48;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR48;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR48;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR48;
            gmax_cylr = MAX_G_CYL_SR48;
            nom_pw_cylr = NOM_PW_CYL_SR48;
        }
        else if(CYLR_VARIABLE_DENSITY_SR75 == cylr_rf_type)
        {   /* TRM-W */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR75), pw_rfcylr) : NOM_PW_CYL_SR75;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR75), res_rfcylr) : RES_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR75;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR75;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR75;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR75;
            gmax_cylr = MAX_G_CYL_SR75;
            nom_pw_cylr = NOM_PW_CYL_SR75;
        }
        else if(CYLR_VARIABLE_DENSITY_SR107 == cylr_rf_type)
        {   /* VRMW */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR107), pw_rfcylr) : NOM_PW_CYL_SR107;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR107), res_rfcylr) : RES_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR107;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR107;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR107;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR107;
            gmax_cylr = MAX_G_CYL_SR107;
            nom_pw_cylr = NOM_PW_CYL_SR107;
        }
        else if(CYLR_VARIABLE_DENSITY_SR118 == cylr_rf_type)
        {   /* BRM/CRM */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR118), pw_rfcylr) : NOM_PW_CYL_SR118;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR118), res_rfcylr) : RES_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR118;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR118;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR118;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR118;
            gmax_cylr = MAX_G_CYL_SR118;
            nom_pw_cylr = NOM_PW_CYL_SR118;
        }
        else if(CYLR_VARIABLE_DENSITY_SR145 == cylr_rf_type)
        {   /* XRMW, TRM-Z */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR145), pw_rfcylr) : NOM_PW_CYL_SR145;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR145), res_rfcylr) : RES_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR145;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR145;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR145;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR145;
            gmax_cylr = MAX_G_CYL_SR145;
            nom_pw_cylr = NOM_PW_CYL_SR145;
        }
        else if(CYLR_VARIABLE_DENSITY_SR190 == cylr_rf_type)
        {   /* XRM */
            pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR190), pw_rfcylr) : NOM_PW_CYL_SR190;
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR190), res_rfcylr) : RES_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR190;
            Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR190;
            Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR190;
            Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR190;
            gmax_cylr = MAX_G_CYL_SR190;
            nom_pw_cylr = NOM_PW_CYL_SR190;
        }
        else
        {
            epic_error(use_ermes,"%s: The type of cylindrical RF pulse is not valid (cylr_rf_type : %d)",
                       EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "Monitor_CvevalInit()", INT_ARG, cylr_rf_type );
            return FAILURE;
        }

        if(exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
        {
            if(CYLR_CONSTANT_DENSITY == cylr_rf_type)
            {   /* Legacy pluse with constant k-space density */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(GRAD_UPDATE_TIME*2400), pw_rfcylrtipup) : GRAD_UPDATE_TIME*2400;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(2400), res_rfcylrtipup) : 2400;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = 0.6308;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = 0.6308;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = 0.4704;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = 1.0;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = 1.0;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = 0.0166216;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = 0.000727778;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = 0.0114;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = pw_rfcylrtipup;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = 90.0;
            }
            else if(CYLR_VARIABLE_DENSITY_SR48 == cylr_rf_type)
            {   /* Starter */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(NOM_PW_CYL_SR48), pw_rfcylrtipup) : NOM_PW_CYL_SR48;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(RES_CYL_SR48), res_rfcylrtipup) : RES_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = SAR_ABS_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = SAR_ACYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = SAR_MAXPW_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = MAX_B1_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = NOM_PW_CYL_SR48;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR48;
            }
            else if(CYLR_VARIABLE_DENSITY_SR75 == cylr_rf_type)
            {   /* TRM-W */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(NOM_PW_CYL_SR75), pw_rfcylrtipup) : NOM_PW_CYL_SR75;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(RES_CYL_SR75), res_rfcylrtipup) : RES_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = SAR_ABS_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = SAR_ACYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = SAR_MAXPW_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = MAX_B1_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = NOM_PW_CYL_SR75;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR75;
            }
            else if(CYLR_VARIABLE_DENSITY_SR107==cylr_rf_type)
            {   /* VRMW */
                pw_rfcylr  = _pw_rfcylr.fixedflag ?  ((void)(NOM_PW_CYL_SR107), pw_rfcylr) : NOM_PW_CYL_SR107;
                res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(RES_CYL_SR107), res_rfcylr) : RES_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].abswidth = SAR_ABS_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].area     = SAR_ACYL_SR107;
                Rfpulse[RFCYLR_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR107;
                Rfpulse[RFCYLR_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].maxpw    = SAR_MAXPW_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].max_b1   = MAX_B1_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].nom_pw   = NOM_PW_CYL_SR107;
                Rfpulse[RFCYLR_SLOT].nom_fa   = NOM_FA_CYL_SR107;
                gmax_cylr = MAX_G_CYL_SR107;
                nom_pw_cylr = NOM_PW_CYL_SR107;
            }
            else if(CYLR_VARIABLE_DENSITY_SR118 == cylr_rf_type)
            {   /* BRM/CRM */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(NOM_PW_CYL_SR118), pw_rfcylrtipup) : NOM_PW_CYL_SR118;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(RES_CYL_SR118), res_rfcylrtipup) : RES_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = SAR_ABS_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = SAR_ACYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = SAR_MAXPW_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = MAX_B1_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = NOM_PW_CYL_SR118;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR118;
            }
            else if(CYLR_VARIABLE_DENSITY_SR145 == cylr_rf_type)
            {   /* XRMW,TRM-Z */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(NOM_PW_CYL_SR145), pw_rfcylrtipup) : NOM_PW_CYL_SR145;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(RES_CYL_SR145), res_rfcylrtipup) : RES_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = SAR_ABS_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = SAR_ACYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = SAR_MAXPW_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = MAX_B1_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = NOM_PW_CYL_SR145;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR145;
            }
            else if(CYLR_VARIABLE_DENSITY_SR190 == cylr_rf_type)
            {   /* XRM */
                pw_rfcylrtipup  = _pw_rfcylrtipup.fixedflag ?  ((void)(NOM_PW_CYL_SR190), pw_rfcylrtipup) : NOM_PW_CYL_SR190;
                res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(RES_CYL_SR190), res_rfcylrtipup) : RES_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].abswidth = SAR_ABS_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].area     = SAR_ACYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].effwidth = SAR_CYL_EFF_WIDTH_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].dtycyc   = SAR_DTYCYC_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].maxpw    = SAR_MAXPW_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].max_b1   = MAX_B1_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].max_rms_b1 = MAX_RMS_B1_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_pw   = NOM_PW_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR190;
                Rfpulse[RFCYLRTIPUP_SLOT].nom_fa   = NOM_FA_CYL_SR118;
            }
            else
            {
                epic_error(use_ermes,"%s: The type of cylindrical RF pulse is not valid (cylr_rf_type : %d)",
                           EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "Monitor_CvevalInit()", INT_ARG, cylr_rf_type);
                return FAILURE;
            }
        }
    }

    return SUCCESS;
}


STATUS
Monitor_Eval( RF_PULSE Rfpulse[], INT numPulses, FLOAT *average_sar, FLOAT *avecoil_sar, FLOAT *peak_sar_mon )
{
    /* Initialize monitor SAR to zero */
    *average_sar = 0.0;
    *avecoil_sar = 0.0;
    *peak_sar_mon = 0.0;

    if( smartprep_flag || navigator_flag ) 
    {
        if (!navigatorCYL_flag)
        {
            Rfpulse[RF1MON_SLOT].activity = PSD_SCAN_ON+PSD_TEST_ON;
            Rfpulse[RF2MON_SLOT].activity = PSD_SCAN_ON+PSD_TEST_ON;
            Rfpulse[RFCYLR_SLOT].activity = PSD_PULSE_OFF;
        } else {
            Rfpulse[RF1MON_SLOT].activity = PSD_PULSE_OFF;
            Rfpulse[RF2MON_SLOT].activity = PSD_PULSE_OFF;
            Rfpulse[RFCYLR_SLOT].activity = PSD_SCAN_ON+PSD_TEST_ON;

       }

        /* Calculate new targets everytime */
        monnewgeo  = _monnewgeo.fixedflag ?  ((void)(1), monnewgeo) : 1;
        if( obloptimize( &monloggrd, &monphygrd, 
                         &mon_loc,1,
                         PSD_OBL,1, monobl_method,
                         monobl_debug, _monnewgeo.fixedflag ? (_temp387_monnewgeo=monnewgeo,&_temp387_monnewgeo) : &monnewgeo,
                         cfsrmode ) == FAILURE ) 
        {
            epic_error(use_ermes,"%s failed.",EM_PSD_SMARTPREP_FAIL,EE_ARGS(1),
                       STRING_ARG,"obloptimize: Monitor_Eval");
            return FAILURE;
        }

        if( FAILURE == monitor_cveval( Rfpulse, numPulses, average_sar, avecoil_sar, peak_sar_mon ) )
        {
            epic_error(use_ermes, "%s failed",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG,
                       "monitor_cveval");
            return FAILURE;
        }

        if (get_fullecho)
        {
            numpts2pass  = _numpts2pass.fixedflag ?  ((void)(128), numpts2pass) : 128;
        } else {
            numpts2pass  = _numpts2pass.fixedflag ?  ((void)(1), numpts2pass) : 1;
        }

        if( monitor_test ) 
        {
            flip_rf1mon  = _flip_rf1mon.fixedflag ?  ((void)(140.0), flip_rf1mon) : 140.0;
            flip_rf2mon  = _flip_rf2mon.fixedflag ?  ((void)(120.0), flip_rf2mon) : 120.0;
            flip_rfmontipup  = _flip_rfmontipup.fixedflag ?  ((void)(180.0), flip_rfmontipup) : 180.0;
        } else {
            flip_rf1mon  = _flip_rf1mon.fixedflag ?  ((void)(90.0), flip_rf1mon) : 90.0;
            if (cffield == B0_30000)
            {
                flip_rf2mon  = _flip_rf2mon.fixedflag ?  ((void)(140.0), flip_rf2mon) : 140.0;  /*MRIge75943, SK */
                flip_rfmontipup  = _flip_rfmontipup.fixedflag ?  ((void)(140.0), flip_rfmontipup) : 140.0;
            }
            else
            {
            flip_rf2mon  = _flip_rf2mon.fixedflag ?  ((void)(180.0), flip_rf2mon) : 180.0;
            flip_rfmontipup  = _flip_rfmontipup.fixedflag ?  ((void)(180.0), flip_rfmontipup) : 180.0;
            }
        }
    }

    return SUCCESS;
}

#ifdef NAV_EFGRE3D
STATUS
Calc_Monitor_Acq_Delay(INT Act_tr)
{
    int temp_num_views;
    int use_tr;

    if( smartprep_flag || navigator_flag ) 
    {
        if( Act_tr == 0 ) 
        {
            use_tr = exist(optr);
        } else {
            use_tr = Act_tr;
        }

        delay_dda  = _delay_dda.fixedflag ?  ((void)(0), delay_dda) : 0;
        delay_quiet_dda  = _delay_quiet_dda.fixedflag ?  ((void)(0), delay_quiet_dda) : 0;

        min_delay_time  = _min_delay_time.fixedflag ?        ((void)(use_tr*(num_audibles*audible_loop+opslquant)), min_delay_time) : use_tr*(num_audibles*audible_loop+opslquant);

        if( smartprep_flag ) 
        {
            min_delay_sec  = _min_delay_sec.fixedflag ?      ((void)((float)(min_delay_time+999999)/1000000), min_delay_sec) : (float)(min_delay_time+999999)/1000000;

            /* Make sure minimum for opuser4 is displayed correctly */
            cvmin(opuser4, (int)(min_delay_sec));
            cvdef(opinittrigdelay, min_delay_sec); /* Auto Voice  04/12/2005 YI */ 
            
            /* Cannot allow adv. error because we would never be able to
               switch to Smartprep */ 
            if( exist(opuser4) < min_delay_sec ) {
                cvoverride(opuser4, (int)(min_delay_sec), PSD_FIX_ON, PSD_EXIST_ON);
                mon_trigger_delay  = _mon_trigger_delay.fixedflag ?    ((void)((int)(exist(opuser4)*1000000)), mon_trigger_delay) : (int)(exist(opuser4)*1000000);
            }
        }

        /* ATV - only play 1 sec disdacqs before actual 3D */
        temp_num_views = (int)(1000000/ use_tr);
        delay_quiet_time  = _delay_quiet_time.fixedflag ?    ((void)((int)(mon_trigger_delay-1000000)), delay_quiet_time) : (int)(mon_trigger_delay-1000000);
        delay_quiet_dda  = _delay_quiet_dda.fixedflag ?   ((void)((int)(delay_quiet_time/loopdelay2)), delay_quiet_dda) : (int)(delay_quiet_time/loopdelay2);
        /*MRIhc05287*/
        rtpend_quiet_dda  = _rtpend_quiet_dda.fixedflag ?   ((void)(ceil((float)(smartp_rtpend_wait)/100)), rtpend_quiet_dda) : ceil((float)(smartp_rtpend_wait)/100);
        if (delay_quiet_dda > (rtpend_quiet_dda+1) ) 
        {
            total_quiet_dda  = _total_quiet_dda.fixedflag ?  ((void)(delay_quiet_dda), total_quiet_dda) : delay_quiet_dda;
        } else {
            total_quiet_dda  = _total_quiet_dda.fixedflag ?    ((void)(rtpend_quiet_dda+1), total_quiet_dda) : rtpend_quiet_dda+1;
        }

        if( temp_num_views < 0 ) 
        {
            delay_dda  = _delay_dda.fixedflag ?  ((void)(0), delay_dda) : 0;
        } else {
            delay_dda  = _delay_dda.fixedflag ?  ((void)(temp_num_views), delay_dda) : temp_num_views;
        }
    } /* end (smartprep_flag || navigator_flag) */

    return SUCCESS;
}
#endif /* NAV_EFGRE3D */ 

STATUS
Monitor_setpulsenumoff( RF_PULSE  Rfpulse[] )
{
    if (navigator_flag || smartprep_flag)
    {
        if (navigatorCYL_flag)
        {
            Rfpulse[RFCYLR_SLOT].num = 0;
        } else {
            Rfpulse[RF1MON_SLOT].num = 0;
            Rfpulse[RF2MON_SLOT].num = 0;
        }
    }
    return SUCCESS;
}

STATUS Monitor_setpulsenumon( RF_PULSE Rfpulse[] )
{
    if (navigator_flag || smartprep_flag)
    {
        if(navigatorCYL_flag)
        {
            Rfpulse[RFCYLR_SLOT].num = 1;
        } else {
            Rfpulse[RF1MON_SLOT].num = 1;
            Rfpulse[RF2MON_SLOT].num = 1;
        }
    }
    return SUCCESS;
}

STATUS monitor_cveval( RF_PULSE Rfpulse[], INT numPulses, FLOAT *average_sar, FLOAT *avecoil_sar, FLOAT *peak_sar_mon)
{
    DOUBLE area_pulse;
    DOUBLE area_gxwmon;
    DOUBLE area_readrampmon;

    gradxmon[GX1MON_SLOT].num = 1;
   	gradxmon[GXWMON_SLOT].num = 1;
    if(mon_fcomp)
    {
        gradxmon[GXFCMON_SLOT].num = 1;
    } else {
        gradxmon[GXFCMON_SLOT].num = 0;
    }
  	gradzmon[GZKMON_SLOT].num = 1;

    if (!navigatorCYL_flag)
    {
    	gradymon[GYRF2LMON_SLOT].num = 1;
    	gradymon[GYRF2RMON_SLOT].num = 1;
    	gradymon[GYRF2MON_SLOT].num  = 1;
    	gradymon[GYRF1MON_SLOT].num  = 1;
    	gradymon[GY1MON_SLOT].num    = 1;
    
        gradzmon[GZRF1MON_SLOT].num  = 1;
    	gradzmon[GZ1MON_SLOT].num    = 1;

        gradymon[GYCYLRA_SLOT].num    = 0;
        gradymon[GYCYLR_SLOT].num    = 0;
        gradzmon[GZCYLRA_SLOT].num    = 0;
        gradzmon[GZCYLR_SLOT].num    = 0;
    } else {
    	gradymon[GYRF2LMON_SLOT].num = 0;
    	gradymon[GYRF2RMON_SLOT].num = 0;
    	gradymon[GYRF2MON_SLOT].num  = 0;
    	gradymon[GYRF1MON_SLOT].num  = 0;
    	gradymon[GY1MON_SLOT].num    = 0;
   
        gradzmon[GZRF1MON_SLOT].num  = 0;
    	gradzmon[GZ1MON_SLOT].num    = 0;

        gradymon[GYCYLRA_SLOT].num = 1;
        gradymon[GYCYLR_SLOT].num = 1;
        gradzmon[GZCYLRA_SLOT].num = 1;
        gradzmon[GZCYLR_SLOT].num = 1;
    }

    if (navigator_flag)
    {
        cvmin(opmonthick,10.);
        cvmax(opmonthick,40.);
    } else {
        cvmin(opmonthick,5.);
        cvmax(opmonthick,100.);
    }

    mon_vthicky  = _mon_vthicky.fixedflag ?  ((void)(exist(opmonthick)), mon_vthicky) : exist(opmonthick);
    mon_vthickz  = _mon_vthickz.fixedflag ?  ((void)(exist(opmonthick)), mon_vthickz) : exist(opmonthick);
    mon_fov  = _mon_fov.fixedflag ?  ((void)(exist(opmonfov)), mon_fov) : exist(opmonfov);

    if (save_fft)
        detector_mode  = _detector_mode.fixedflag ?  ((void)(1), detector_mode) : 1;
    else
        detector_mode  = _detector_mode.fixedflag ?  ((void)(0), detector_mode) : 0;

    /* minimum fov acquired will be 20 cm */
    if (mon_fov < MIN_ACQ_FOV)
    {
        data_type  = _data_type.fixedflag ?  ((void)(1), data_type) : 1;
        fov_factor  = _fov_factor.fixedflag ?  ((void)((float)(mon_fov/MIN_ACQ_FOV)), fov_factor) : (float)(mon_fov/MIN_ACQ_FOV);
        mon_acqfov  = _mon_acqfov.fixedflag ?  ((void)(MIN_ACQ_FOV), mon_acqfov) : MIN_ACQ_FOV;

        /* since we are doing only 128 FFT's in the spu
           the pixel sizes are doubled in the spu for the
           same image FOV.  Therefore the fov_factor
           is the fraction we need to reduce the fov by
           in the spu in terms of the number of pixels. */
    } else {
        data_type  = _data_type.fixedflag ?  ((void)(1), data_type) : 1; /* MRIge47553: always do FFT */
        mon_acqfov  = _mon_acqfov.fixedflag ?  ((void)(mon_fov), mon_acqfov) : mon_fov;
        fov_factor  = _fov_factor.fixedflag ?  ((void)(1.0), fov_factor) : 1.0;
    }

    Monitor_setpulsenumon(Rfpulse);

    /* MRIge91409: moved the scalerfpulses to be performed
     * before timing calculation */

    /* MRIge88343: Check to see if rf pw's need scaling for large patients */
    if(navigatorCYL_flag)
    {
        scalerfpulses(opweight,cfgcoiltype,1,&Rfpulse[RFCYLR_SLOT],
                      L_TEST,&rfpulseInfo[RFCYLR_SLOT]);
    } else {
        scalerfpulses(opweight,cfgcoiltype,2,&Rfpulse[RF1MON_SLOT],
                      L_TEST,&rfpulseInfo[RF1MON_SLOT]);
    }

    if (!navigatorCYL_flag)
    {
        /* Z slice select for 90 pulse */
        pw_gzrf1mon  = _pw_gzrf1mon.fixedflag ?  ((void)(pw_rf1mon), pw_gzrf1mon) : pw_rf1mon;
        pw_gyrf1mon  = _pw_gyrf1mon.fixedflag ?  ((void)(pw_gzrf1mon), pw_gyrf1mon) : pw_gzrf1mon;

        bw_rf1mon  = _bw_rf1mon.fixedflag ?  ((void)(Rfpulse[RF1MON_SLOT].nom_bw*Rfpulse[RF1MON_SLOT].nom_pw/pw_rf1mon), bw_rf1mon) : Rfpulse[RF1MON_SLOT].nom_bw*Rfpulse[RF1MON_SLOT].nom_pw/pw_rf1mon;

        if (ampslice(_a_gzrf1mon.fixedflag ? (_temp388_a_gzrf1mon=a_gzrf1mon,&_temp388_a_gzrf1mon) : &a_gzrf1mon,bw_rf1mon,mon_vthickz,gscale_rf1mon,TYPDEF)
            == FAILURE)
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"ampslice for gzrf1mon");
            return FAILURE;
        }

        /* slice selection ramp */
        if (optramp(_pw_gzrf1mona.fixedflag ? (_temp389_pw_gzrf1mona=pw_gzrf1mona,&_temp389_pw_gzrf1mona) : &pw_gzrf1mona, a_gzrf1mon, monloggrd.tz_yz, monloggrd.zrt,
                    TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"optramp for gzrf1mona");
            return FAILURE;
        }
        pw_gzrf1mond  = _pw_gzrf1mond.fixedflag ?  ((void)(pw_gzrf1mona), pw_gzrf1mond) : pw_gzrf1mona;

        pw_gyrf1mona  = _pw_gyrf1mona.fixedflag ?  ((void)(pw_gzrf1mona), pw_gyrf1mona) : pw_gzrf1mona;
        pw_gyrf1mond  = _pw_gyrf1mond.fixedflag ?  ((void)(pw_gzrf1mond), pw_gyrf1mond) : pw_gzrf1mond;

        if(nav_angle_adj)
        {
            a_gzrf1mon  = _a_gzrf1mon.fixedflag ?    ((void)(a_gzrf1mon*cos(DEG_TO_RAD*mon_angle)), a_gzrf1mon) : a_gzrf1mon*cos(DEG_TO_RAD*mon_angle);
            a_gyrf1mon  = _a_gyrf1mon.fixedflag ?    ((void)(a_gzrf1mon*sin(DEG_TO_RAD*mon_angle)), a_gyrf1mon) : a_gzrf1mon*sin(DEG_TO_RAD*mon_angle);
        } else {
            a_gyrf1mon = _a_gyrf1mon.fixedflag ? ((void)(0.0), a_gyrf1mon) : 0.0;
        }

        /* Z gradient refocus */
        area_pulse = a_gzrf1mon*(pw_gzrf1mon/2 + 80   + pw_gzrf1mond/2);
        if (amppwgz1(_a_gz1mon.fixedflag ? (_temp390_a_gz1mon=a_gz1mon,&_temp390_a_gz1mon) : &a_gz1mon,_pw_gz1mon.fixedflag ? (_temp391_pw_gz1mon=pw_gz1mon,&_temp391_pw_gz1mon) : &pw_gz1mon,_pw_gz1mona.fixedflag ? (_temp392_pw_gz1mona=pw_gz1mona,&_temp392_pw_gz1mona) : &pw_gz1mona,_pw_gz1mond.fixedflag ? (_temp393_pw_gz1mond=pw_gz1mond,&_temp393_pw_gz1mond) : &pw_gz1mond,area_pulse,
                     (int)(10000),MIN_PLATEAU_TIME,monloggrd.zrt,monloggrd.tz_yz) == FAILURE) 
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                       STRING_ARG,"amppwgz1 for gz1mon");
            return FAILURE;
        }

        pw_gy1mon  = _pw_gy1mon.fixedflag ?  ((void)(pw_gz1mon), pw_gy1mon) : pw_gz1mon;
        pw_gy1mona  = _pw_gy1mona.fixedflag ?  ((void)(pw_gz1mona), pw_gy1mona) : pw_gz1mona;
        pw_gy1mond  = _pw_gy1mond.fixedflag ?  ((void)(pw_gz1mond), pw_gy1mond) : pw_gz1mond;

        if(nav_angle_adj)
        {
            a_gz1mon  = _a_gz1mon.fixedflag ?    ((void)(a_gz1mon*cos(DEG_TO_RAD*mon_angle)), a_gz1mon) : a_gz1mon*cos(DEG_TO_RAD*mon_angle);
            a_gy1mon  = _a_gy1mon.fixedflag ?    ((void)(a_gz1mon*sin(DEG_TO_RAD*mon_angle)), a_gy1mon) : a_gz1mon*sin(DEG_TO_RAD*mon_angle);
        } else {
            a_gy1mon = _a_gy1mon.fixedflag ? ((void)(0.0), a_gy1mon) : 0.0;
        }

        /* Y gradient crushers for 180 pulse */
        /* Left crusher. Denoted by the "l" after the "2"  in "gyrf2lmon" */
        if (amppwgrad(700.0, monloggrd.ty_xyz, 0.0, 0.0, monloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gyrf2lmon.fixedflag ? (_temp394_a_gyrf2lmon=a_gyrf2lmon,&_temp394_a_gyrf2lmon) : &a_gyrf2lmon, _pw_gyrf2lmona.fixedflag ? (_temp395_pw_gyrf2lmona=pw_gyrf2lmona,&_temp395_pw_gyrf2lmona) : &pw_gyrf2lmona,
                      _pw_gyrf2lmon.fixedflag ? (_temp396_pw_gyrf2lmon=pw_gyrf2lmon,&_temp396_pw_gyrf2lmon) : &pw_gyrf2lmon, _pw_gyrf2lmond.fixedflag ? (_temp397_pw_gyrf2lmond=pw_gyrf2lmond,&_temp397_pw_gyrf2lmond) : &pw_gyrf2lmond) == FAILURE) 
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                       STRING_ARG,"amppwgrad for gyrf2mon");
            return FAILURE;
        }

        /* Right crusher. Denoted by the "r" after the "2" in "gyrf2rmon"*/
        /* This is identical to left crusher */

        pw_gyrf2rmon  = _pw_gyrf2rmon.fixedflag ?  ((void)(pw_gyrf2lmon), pw_gyrf2rmon) : pw_gyrf2lmon;
        a_gyrf2rmon  = _a_gyrf2rmon.fixedflag ?   ((void)(a_gyrf2lmon), a_gyrf2rmon) : a_gyrf2lmon;

        /* right crusher ramps */
        pw_gyrf2rmona  = _pw_gyrf2rmona.fixedflag ?  ((void)(pw_gyrf2lmona), pw_gyrf2rmona) : pw_gyrf2lmona;
        pw_gyrf2rmond  = _pw_gyrf2rmond.fixedflag ?  ((void)(pw_gyrf2lmond), pw_gyrf2rmond) : pw_gyrf2lmond;

        /* Z slice select for 180 pulse */
        pw_gyrf2mon  = _pw_gyrf2mon.fixedflag ?  ((void)(pw_rf2mon), pw_gyrf2mon) : pw_rf2mon;

        bw_rf2mon  = _bw_rf2mon.fixedflag ?  ((void)(Rfpulse[RF2MON_SLOT].nom_bw*Rfpulse[RF2MON_SLOT].nom_pw/pw_rf2mon), bw_rf2mon) : Rfpulse[RF2MON_SLOT].nom_bw*Rfpulse[RF2MON_SLOT].nom_pw/pw_rf2mon;

        if (ampslice(_a_gyrf2mon.fixedflag ? (_temp398_a_gyrf2mon=a_gyrf2mon,&_temp398_a_gyrf2mon) : &a_gyrf2mon,bw_rf2mon,mon_vthicky,gscale_rf2mon,TYPDEF)
            == FAILURE) 
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                       STRING_ARG,"ampslice for gyrf2mon");
            return FAILURE;
        }

        /* match ramps so gradient can be bridged in pulsegen */
        pw_gyrf2mona  = _pw_gyrf2mona.fixedflag ?  ((void)(pw_gyrf2lmond), pw_gyrf2mona) : pw_gyrf2lmond;
        pw_gyrf2mond  = _pw_gyrf2mond.fixedflag ?  ((void)(pw_gyrf2rmona), pw_gyrf2mond) : pw_gyrf2rmona;

        if(exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
        {
            pw_gyrfmontipup  = _pw_gyrfmontipup.fixedflag ?  ((void)(pw_rfmontipup), pw_gyrfmontipup) : pw_rfmontipup;
            bw_rfmontipup  = _bw_rfmontipup.fixedflag ?   
                             ((void)(Rfpulse[RFMONTIPUP_SLOT].nom_bw*Rfpulse[RFMONTIPUP_SLOT].nom_pw/pw_rfmontipup), bw_rfmontipup) : Rfpulse[RFMONTIPUP_SLOT].nom_bw*Rfpulse[RFMONTIPUP_SLOT].nom_pw/pw_rfmontipup;

            if (ampslice(_a_gyrfmontipup.fixedflag ? (_temp399_a_gyrfmontipup=a_gyrfmontipup,&_temp399_a_gyrfmontipup) : &a_gyrfmontipup,bw_rfmontipup,mon_vthicky,gscale_rfmontipup,TYPDEF)
                == FAILURE) 
            {
                epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                           STRING_ARG,"ampslice for gyrfmontipup");
                return FAILURE;
            }
    
            /* slice selection ramp */
            if (optramp(_pw_gyrfmontipupa.fixedflag ? (_temp400_pw_gyrfmontipupa=pw_gyrfmontipupa,&_temp400_pw_gyrfmontipupa) : &pw_gyrfmontipupa, a_gyrfmontipup, monloggrd.ty, monloggrd.yrt,
                    TYPDEF)==FAILURE) 
            {
                epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                           STRING_ARG,"optramp for gyrfmontipupa");
                return FAILURE;
            }
            pw_gyrfmontipupd  = _pw_gyrfmontipupd.fixedflag ?  ((void)(pw_gyrfmontipupa), pw_gyrfmontipupd) : pw_gyrfmontipupa;
        }
    }
    else 
    {
        pw_thcylr  = _pw_thcylr.fixedflag ?  ((void)(pw_rfcylr), pw_thcylr) : pw_rfcylr;
        pw_gycylr  = _pw_gycylr.fixedflag ?  ((void)(pw_rfcylr), pw_gycylr) : pw_rfcylr;
        pw_gzcylr  = _pw_gzcylr.fixedflag ?  ((void)(pw_rfcylr), pw_gzcylr) : pw_rfcylr;
        
        res_thcylr  = _res_thcylr.fixedflag ?  ((void)(res_rfcylr), res_thcylr) : res_rfcylr;
        res_gycylr  = _res_gycylr.fixedflag ?  ((void)(res_rfcylr), res_gycylr) : res_rfcylr;
        res_gzcylr  = _res_gzcylr.fixedflag ?  ((void)(res_rfcylr), res_gzcylr) : res_rfcylr;
        
        if (CYLR_CONSTANT_DENSITY == cylr_rf_type)
        {
            a_gycylr  = _a_gycylr.fixedflag ?  ((void)(a_nomcyl*rootcyl*(float)pw_estim/(float)pw_rfcylr), a_gycylr) : a_nomcyl*rootcyl*(float)pw_estim/(float)pw_rfcylr;
        } else {
            a_gycylr  = _a_gycylr.fixedflag ?  ((void)(gmax_cylr*MIN_DIAMETER_CYL/exist(opmonthick)*nom_pw_cylr/pw_rfcylr), a_gycylr) : gmax_cylr*MIN_DIAMETER_CYL/exist(opmonthick)*nom_pw_cylr/pw_rfcylr;
        }
        a_gzcylr  = _a_gzcylr.fixedflag ?  ((void)(a_gycylr), a_gzcylr) : a_gycylr;
        a_thcylr  = _a_thcylr.fixedflag ?  ((void)(1.0), a_thcylr) : 1.0;
     
        pw_gycylra  = _pw_gycylra.fixedflag ?  ((void)(RUP_GRD(a_gycylr/monloggrd.ty_yz*monloggrd.yrt)), pw_gycylra) : RUP_GRD(a_gycylr/monloggrd.ty_yz*monloggrd.yrt);
        pw_gzcylra  = _pw_gzcylra.fixedflag ?  ((void)(RUP_GRD(a_gzcylr/monloggrd.tz_yz*monloggrd.zrt)), pw_gzcylra) : RUP_GRD(a_gzcylr/monloggrd.tz_yz*monloggrd.zrt);
        pw_gycylra = _pw_gycylra.fixedflag ? ((void)(IMax(2,pw_gycylra,pw_gzcylra)), pw_gycylra) : IMax(2,pw_gycylra,pw_gzcylra);
        pw_gzcylra = _pw_gzcylra.fixedflag ? ((void)(pw_gycylra), pw_gzcylra) : pw_gycylra;

        end_gycylra = _end_gycylra.fixedflag ? ((void)(a_gycylr), end_gycylra) : a_gycylr;
        end_gzcylra = _end_gzcylra.fixedflag ? ((void)(a_gzcylr), end_gzcylra) : a_gzcylr;

        if(exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
        {
            pw_thcylrtipup  = _pw_thcylrtipup.fixedflag ?  ((void)(pw_rfcylrtipup), pw_thcylrtipup) : pw_rfcylrtipup;
            pw_gycylrtipup  = _pw_gycylrtipup.fixedflag ?  ((void)(pw_rfcylrtipup), pw_gycylrtipup) : pw_rfcylrtipup;
            pw_gzcylrtipup  = _pw_gzcylrtipup.fixedflag ?  ((void)(pw_rfcylrtipup), pw_gzcylrtipup) : pw_rfcylrtipup;

            res_thcylrtipup  = _res_thcylrtipup.fixedflag ?  ((void)(res_rfcylrtipup), res_thcylrtipup) : res_rfcylrtipup;
            res_gycylrtipup  = _res_gycylrtipup.fixedflag ?  ((void)(res_rfcylrtipup), res_gycylrtipup) : res_rfcylrtipup;
            res_gzcylrtipup  = _res_gzcylrtipup.fixedflag ?  ((void)(res_rfcylrtipup), res_gzcylrtipup) : res_rfcylrtipup;

            if (CYLR_CONSTANT_DENSITY == cylr_rf_type)
            {
                a_gycylrtipup  = _a_gycylrtipup.fixedflag ?  ((void)(a_nomcyl*rootcyl*(float)pw_estim/(float)pw_rfcylrtipup/nav_tipup_ratio), a_gycylrtipup) : a_nomcyl*rootcyl*(float)pw_estim/(float)pw_rfcylrtipup/nav_tipup_ratio;
            } else {
                a_gycylrtipup  = _a_gycylrtipup.fixedflag ?  
                    ((void)(gmax_cylr*MIN_DIAMETER_CYL/exist(opmonthick)*nom_pw_cylr/pw_rfcylrtipup/nav_tipup_ratio), a_gycylrtipup) : gmax_cylr*MIN_DIAMETER_CYL/exist(opmonthick)*nom_pw_cylr/pw_rfcylrtipup/nav_tipup_ratio;
            }
            a_gzcylrtipup  = _a_gzcylrtipup.fixedflag ?  ((void)(a_gycylrtipup), a_gzcylrtipup) : a_gycylrtipup;
            a_thcylrtipup  = _a_thcylrtipup.fixedflag ?  ((void)(1.0), a_thcylrtipup) : 1.0;

            pw_gycylratipup  = _pw_gycylratipup.fixedflag ?  ((void)(RUP_GRD(a_gycylrtipup/monloggrd.ty_yz*monloggrd.yrt)), pw_gycylratipup) : RUP_GRD(a_gycylrtipup/monloggrd.ty_yz*monloggrd.yrt);
            pw_gzcylratipup  = _pw_gzcylratipup.fixedflag ?  ((void)(RUP_GRD(a_gzcylrtipup/monloggrd.tz_yz*monloggrd.zrt)), pw_gzcylratipup) : RUP_GRD(a_gzcylrtipup/monloggrd.tz_yz*monloggrd.zrt);
            pw_gycylratipup = _pw_gycylratipup.fixedflag ? ((void)(IMax(2,pw_gycylratipup,pw_gzcylratipup)), pw_gycylratipup) : IMax(2,pw_gycylratipup,pw_gzcylratipup);
            pw_gzcylratipup = _pw_gzcylratipup.fixedflag ? ((void)(pw_gycylratipup), pw_gzcylratipup) : pw_gycylratipup;
            end_gycylratipup = _end_gycylratipup.fixedflag ? ((void)(a_gycylrtipup), end_gycylratipup) : a_gycylrtipup;
            end_gzcylratipup = _end_gzcylratipup.fixedflag ? ((void)(a_gzcylrtipup), end_gzcylratipup) : a_gzcylrtipup;
        }
    }
 
    /* X gradient */
    /* readout collects the same number of points as normal acquisition */

    /* Fix bandwidth at 31.25 kHz */
    echo1monbw  = _echo1monbw.fixedflag ?   ((void)(31.25), echo1monbw) : 31.25; 

    if (xres2use > mon_xres) 
    {
        xres2use  = _xres2use.fixedflag ?  ((void)(mon_xres), xres2use) : mon_xres;
    } 
    else if (navigator_flag) 
    {  /* MRIhc07115 */
        xres2use  = _xres2use.fixedflag ?  ((void)(DEFAULT_FFT_LENGTH_256), xres2use) : DEFAULT_FFT_LENGTH_256;
    } else {
        xres2use  = _xres2use.fixedflag ?  ((void)(DEFAULT_FFT_LENGTH), xres2use) : DEFAULT_FFT_LENGTH;
    }

    /* FOR MERGE */
    if (calcfilter(&echo1mon_rtfilt, echo1monbw,
                      mon_xres, OVERWRITE_NONE)== FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter");
        return FAILURE;
    }
    
    echo1mon_filt = &echo1mon_rtfilt;

    if (ampfov(_a_gxwmon.fixedflag ? (_temp401_a_gxwmon=a_gxwmon,&_temp401_a_gxwmon) : &a_gxwmon, echo1monbw, mon_acqfov) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG,"ampfov for gxwmon");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmona.fixedflag ? (_temp402_pw_gxwmona=pw_gxwmona,&_temp402_pw_gxwmona) : &pw_gxwmona, a_gxwmon, monloggrd.tx_xy, monloggrd.xrt,
                TYPDEF)==FAILURE) 
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG,"optramp for gxwmona");
        return FAILURE;
    }
    pw_gxwmond  = _pw_gxwmond.fixedflag ?  ((void)(pw_gxwmona), pw_gxwmond) : pw_gxwmona;
    pw_gxwmon  = _pw_gxwmon.fixedflag ?  ((void)(echo1mon_filt->tdaq), pw_gxwmon) : echo1mon_filt->tdaq;

    /* Calculate echo fraction for Tracker such that there are
       xres2use/2 points to the left of the echo center */
    fnecho_frac  = _fnecho_frac.fixedflag ?       ((void)(0.5+(float)xres2use/(2*mon_xres)), fnecho_frac) : 0.5+(float)xres2use/(2*mon_xres);

    if (mon_fcomp)
    {
        if (amppwgxfcmin(a_gxwmon, pw_gxwmona, pw_gxwmon, pw_gxwmond, 
                         10000, fnecho_frac,
                         monloggrd.tx_xy, monloggrd.xrt, monloggrd.xbeta,
                         _a_gx1mon.fixedflag ? (_temp403_a_gx1mon=a_gx1mon,&_temp403_a_gx1mon) : &a_gx1mon,_pw_gx1mona.fixedflag ? (_temp404_pw_gx1mona=pw_gx1mona,&_temp404_pw_gx1mona) : &pw_gx1mona,_pw_gx1mon.fixedflag ? (_temp405_pw_gx1mon=pw_gx1mon,&_temp405_pw_gx1mon) : &pw_gx1mon,_pw_gx1mond.fixedflag ? (_temp406_pw_gx1mond=pw_gx1mond,&_temp406_pw_gx1mond) : &pw_gx1mond,
                         _a_gxfcmon.fixedflag ? (_temp407_a_gxfcmon=a_gxfcmon,&_temp407_a_gxfcmon) : &a_gxfcmon,_pw_gxfcmona.fixedflag ? (_temp408_pw_gxfcmona=pw_gxfcmona,&_temp408_pw_gxfcmona) : &pw_gxfcmona,_pw_gxfcmon.fixedflag ? (_temp409_pw_gxfcmon=pw_gxfcmon,&_temp409_pw_gxfcmon) : &pw_gxfcmon,_pw_gxfcmond.fixedflag ? (_temp410_pw_gxfcmond=pw_gxfcmond,&_temp410_pw_gxfcmond) : &pw_gxfcmond)==FAILURE)
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgxfcmin for monitor");
            return FAILURE;
        }
    }
    else
    {
        pw_gxfcmon   = _pw_gxfcmon.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxfcmon) : GRAD_UPDATE_TIME;
        pw_gxfcmona  = _pw_gxfcmona.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxfcmona) : GRAD_UPDATE_TIME;
        pw_gxfcmond  = _pw_gxfcmond.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gxfcmond) : GRAD_UPDATE_TIME;
        ia_gxfcmon   = _ia_gxfcmon.fixedflag ?  ((void)(0), ia_gxfcmon) : 0; 
        /* dephaser */
        area_gxwmon = a_gxwmon * pw_gxwmon;
        area_readrampmon = 0.5*a_gxwmon*pw_gxwmona; 

        if (amppwgx1(_a_gx1mon.fixedflag ? (_temp411_a_gx1mon=a_gx1mon,&_temp411_a_gx1mon) : &a_gx1mon, _pw_gx1mon.fixedflag ? (_temp412_pw_gx1mon=pw_gx1mon,&_temp412_pw_gx1mon) : &pw_gx1mon, _pw_gx1mona.fixedflag ? (_temp413_pw_gx1mona=pw_gx1mona,&_temp413_pw_gx1mona) : &pw_gx1mona ,_pw_gx1mond.fixedflag ? (_temp414_pw_gx1mond=pw_gx1mond,&_temp414_pw_gx1mond) : &pw_gx1mond, TYPGRAD,
                     area_gxwmon, (float)area_readrampmon, 
                     10000, fnecho_frac, MIN_PLATEAU_TIME, monloggrd.xrt, monloggrd.tx_xy) == FAILURE) 
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                       STRING_ARG,"amppwgx1 for gx1mon");
            return FAILURE;
        }
    }

    /* zkiller */
    if (amppwgrad(area_gzkmon,monloggrd.tz_xz, 0.0, 0.0, monloggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzkmon.fixedflag ? (_temp415_a_gzkmon=a_gzkmon,&_temp415_a_gzkmon) : &a_gzkmon, _pw_gzkmona.fixedflag ? (_temp416_pw_gzkmona=pw_gzkmona,&_temp416_pw_gzkmona) : &pw_gzkmona,
                  _pw_gzkmon.fixedflag ? (_temp417_pw_gzkmon=pw_gzkmon,&_temp417_pw_gzkmon) : &pw_gzkmon, _pw_gzkmond.fixedflag ? (_temp418_pw_gzkmond=pw_gzkmond,&_temp418_pw_gzkmond) : &pw_gzkmond) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG,"amppwgrad:gzkmon");
        return FAILURE;
    }

    if (exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
    {
        /* montipup zkiller */
        if (amppwgrad(area_gzkmontipup,monloggrd.tz_xz, 0.0, 0.0, monloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzkmontipup.fixedflag ? (_temp419_a_gzkmontipup=a_gzkmontipup,&_temp419_a_gzkmontipup) : &a_gzkmontipup, _pw_gzkmontipupa.fixedflag ? (_temp420_pw_gzkmontipupa=pw_gzkmontipupa,&_temp420_pw_gzkmontipupa) : &pw_gzkmontipupa,
                      _pw_gzkmontipup.fixedflag ? (_temp421_pw_gzkmontipup=pw_gzkmontipup,&_temp421_pw_gzkmontipup) : &pw_gzkmontipup, _pw_gzkmontipupd.fixedflag ? (_temp422_pw_gzkmontipupd=pw_gzkmontipupd,&_temp422_pw_gzkmontipupd) : &pw_gzkmontipupd) == FAILURE)
        {
            epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,1,
                       STRING_ARG,"amppwgrad:gzkmontipup");
            return FAILURE;
        }
    }

    rda_mon  = _rda_mon.fixedflag ?     ((void)((int)((float)pw_gxwmon*(fnecho_frac-0.5))), rda_mon) : (int)((float)pw_gxwmon*(fnecho_frac-0.5)); 
    
    if (!navigatorCYL_flag)
    {
        /* figure out minimum te from z grad, compare needed 
         * time before and after 180 
         */
        tb_180sp   = _tb_180sp.fixedflag ?        
                 
            ((void)(pw_rf1mon/2+80+IMax(2,pw_gzrf1mond,(pw_gyrf2lmona+pw_gyrf2lmon+pw_gyrf2lmond))+pw_rf2mon/2), tb_180sp) : pw_rf1mon/2+80+IMax(2,pw_gzrf1mond,(pw_gyrf2lmona+pw_gyrf2lmon+pw_gyrf2lmond))+pw_rf2mon/2;

        ta_180sp   = _ta_180sp.fixedflag ?    
                
                             
                    ((void)(pw_rf2mon/2+IMax(2,(pw_gyrf2rmona+pw_gyrf2rmon+pw_gyrf2rmond),(pw_gxfcmona+pw_gxfcmon+pw_gxfcmond+pw_gx1mona+pw_gx1mon+pw_gx1mond+pw_gxwmona+rda_mon))), ta_180sp) : pw_rf2mon/2+IMax(2,(pw_gyrf2rmona+pw_gyrf2rmon+pw_gyrf2rmond),(pw_gxfcmona+pw_gxfcmon+pw_gxfcmond+pw_gx1mona+pw_gx1mon+pw_gx1mond+pw_gxwmona+rda_mon));

        te_180sp  = _te_180sp.fixedflag ?        ((void)(RUP_GRD(2*(IMax(2,ta_180sp,tb_180sp))+60)), te_180sp) : RUP_GRD(2*(IMax(2,ta_180sp,tb_180sp))+60);

        tlead_monitor  = _tlead_monitor.fixedflag ?   
                                               
                                            ((void)(RUP_GRD((int)(IMax(2,pw_gzrf1mona,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())))), tlead_monitor) : RUP_GRD((int)(IMax(2,pw_gzrf1mona,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())));
        tlead_montipup  = _tlead_montipup.fixedflag ?   
                                               
                                            ((void)(RUP_GRD((int)(IMax(2,pw_gyrfmontipupa,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())))), tlead_montipup) : RUP_GRD((int)(IMax(2,pw_gyrfmontipupa,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())));
    } else {
        tlead_monitor  = _tlead_monitor.fixedflag ?   
                                               
                                            ((void)(RUP_GRD((int)(IMax(3,pw_gycylra,pw_gzcylra,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())))), tlead_monitor) : RUP_GRD((int)(IMax(3,pw_gycylra,pw_gzcylra,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())));
        tlead_montipup  = _tlead_montipup.fixedflag ?   
                                               
                                            ((void)(RUP_GRD((int)(IMax(3,pw_gycylratipup,pw_gzcylratipup,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())))), tlead_montipup) : RUP_GRD((int)(IMax(3,pw_gycylratipup,pw_gzcylratipup,pass_length+14+delay_rfhubsel+pw_contrfhubsel+minimumPreRfSspTime())));
    }

    mon_ssi_time  = _mon_ssi_time.fixedflag ?  ((void)(time_ssi), mon_ssi_time) : time_ssi;

    if (navigator_flag && (mon_ssi_time<200))
    {
        mon_ssi_time  = _mon_ssi_time.fixedflag ?  ((void)(200), mon_ssi_time) : 200;
    }

    if (navigator_flag && navigatorCYL_flag)
    {
        int min_tegx=0;

        /* t_exb is the isodelay, skew being the skewness of the rf pulse
         * defined as the time point where spins are effectively in the xy-plane */
        t_exa_cylr  = _t_exa_cylr.fixedflag ?  ((void)(cylr_skew*pw_rfcylr), t_exa_cylr) : cylr_skew*pw_rfcylr;
        t_exb_cylr = _t_exb_cylr.fixedflag ?  ((void)((1-cylr_skew)*pw_rfcylr), t_exb_cylr) : (1-cylr_skew)*pw_rfcylr;

        /* Time from echo_peak to end of readout */
        t_rdb_cylr  = _t_rdb_cylr.fixedflag ?    ((void)(pw_gxwmon-rda_mon), t_rdb_cylr) : pw_gxwmon-rda_mon;

        /* Minimum Z,Y,X seqtime */
        /* Since there are no phase encodes, Gx determines te !! */
        min_tegx = t_exb_cylr + pw_gx1mona + pw_gx1mon + pw_gx1mond
                   + pw_gxwmona + rda_mon;
        if(mon_fcomp)
        {
            min_tegx += pw_gxfcmona + pw_gxfcmon + pw_gxfcmond;
        }

#ifdef NAV_EFGRE3D
        if ((cffield == B0_30000) &&
            (navtrig_flag || (navgate_flag && (PSD_OFF == specir_flag) && (PSD_OFF == exist(opfat)) && (PSD_OFF == exist(opfatcl)))))
        {
            act_te_cylr  = _act_te_cylr.fixedflag ?       ((void)(((int)(RUP_GRD(min_tegx)/INPHASE_TE_3T)+1)*INPHASE_TE_3T), act_te_cylr) : ((int)(RUP_GRD(min_tegx)/INPHASE_TE_3T)+1)*INPHASE_TE_3T;
        }
#else
        if ((cffield == B0_30000) && navtrig_flag)
        {
            act_te_cylr  = _act_te_cylr.fixedflag ?       ((void)(((int)(RUP_GRD(min_tegx)/INPHASE_TE_3T)+1)*INPHASE_TE_3T), act_te_cylr) : ((int)(RUP_GRD(min_tegx)/INPHASE_TE_3T)+1)*INPHASE_TE_3T;
        }
#endif
        else
        {
            act_te_cylr  = _act_te_cylr.fixedflag ?  ((void)(RUP_GRD(min_tegx)), act_te_cylr) : RUP_GRD(min_tegx);
        }

        non_tetime_mon  = _non_tetime_mon.fixedflag ?       
                               
                                ((void)(RUP_GRD(tlead_monitor+t_exa_cylr+t_rdb_cylr+IMax(2,pw_gxwmond,pw_gzkmona+pw_gzkmon+pw_gzkmond)+mon_ssi_time+2*GRAD_UPDATE_TIME+psd_grd_wait)), non_tetime_mon) : RUP_GRD(tlead_monitor+t_exa_cylr+t_rdb_cylr+IMax(2,pw_gxwmond,pw_gzkmona+pw_gzkmon+pw_gzkmond)+mon_ssi_time+2*GRAD_UPDATE_TIME+psd_grd_wait);

        tmin_mon  = _tmin_mon.fixedflag ?          ((void)(act_te_cylr+non_tetime_mon+pass_length+10), tmin_mon) : act_te_cylr+non_tetime_mon+pass_length+10;
 
        tmin_montipup  = _tmin_montipup.fixedflag ?   
                                 
                                      
                                       
                                     ((void)(RUP_GRD(tlead_montipup+pw_gycylrtipup+pw_gzkmontipupa+pw_gzkmontipup+pw_gzkmontipupd+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait)), tmin_montipup) : RUP_GRD(tlead_montipup+pw_gycylrtipup+pw_gzkmontipupa+pw_gzkmontipup+pw_gzkmontipupd+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait);
    } else {
        tmin_mon  = _tmin_mon.fixedflag ?       
                               
                                
                                  
                                ((void)(RUP_GRD(tlead_monitor+(pw_gzrf1mon/2)+te_180sp+(pw_gxwmon-rda_mon)+IMax(2,pw_gxwmond,(pw_gzkmona+pw_gzkmon+pw_gzkmond))+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait)), tmin_mon) : RUP_GRD(tlead_monitor+(pw_gzrf1mon/2)+te_180sp+(pw_gxwmon-rda_mon)+IMax(2,pw_gxwmond,(pw_gzkmona+pw_gzkmon+pw_gzkmond))+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait);
 
        tmin_montipup  = _tmin_montipup.fixedflag ?  
                                     
                                     
                                       
                                     ((void)(RUP_GRD(tlead_montipup+pw_gyrfmontipupa+pw_gyrfmontipup+pw_gyrfmontipupd+pw_gzkmontipupa+pw_gzkmontipup+pw_gzkmontipupd+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait)), tmin_montipup) : RUP_GRD(tlead_montipup+pw_gyrfmontipupa+pw_gyrfmontipup+pw_gyrfmontipupd+pw_gzkmontipupa+pw_gzkmontipup+pw_gzkmontipupd+mon_ssi_time+pass_length+10+2*GRAD_UPDATE_TIME+psd_grd_wait);
    }

    if (minseqrfamp_b1scale(_min_seqrfampmon.fixedflag ? (_temp423_min_seqrfampmon=min_seqrfampmon,&_temp423_min_seqrfampmon) : &min_seqrfampmon, (int)RF_FREE, Rfpulse, L_TEST)==FAILURE) 
    {
        epic_error(use_ermes, "%s failed.",EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), 
                   STRING_ARG,"min_seqrfamp_b1scale");
        return FAILURE; 
    }

    if (maxseqsar(_max_seqsarmon.fixedflag ? (_temp424_max_seqsarmon=max_seqsarmon,&_temp424_max_seqsarmon) : &max_seqsarmon, (int)RF_FREE, Rfpulse, L_TEST)==FAILURE)
    {
        epic_error(use_ermes, "%s failed",EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), 
                   STRING_ARG, "maxseqsar");
        return FAILURE;
    }

    Monitor_setpulsenumoff(Rfpulse);

    /* RF amp, SAR, and system limitations on seq time */
    /* Initialize .powscale for each pulse */
    gradxmon[GXFCMON_SLOT].powscale =1.0;
    gradxmon[GX1MON_SLOT].powscale =1.0;
    gradxmon[GXWMON_SLOT].powscale =1.0; 
    gradymon[GYRF2LMON_SLOT].powscale =1.0;
    gradymon[GYRF2RMON_SLOT].powscale =1.0;
    gradymon[GYRF2MON_SLOT].powscale =1.0;
    gradymon[GYCYLRA_SLOT].powscale = 1.0;
    gradymon[GYCYLR_SLOT].powscale = 1.0;
    gradymon[GYRF1MON_SLOT].powscale =1.0;
    gradymon[GY1MON_SLOT].powscale =1.0;
    gradymon[GYCYLRATIPUP_SLOT].powscale =1.0;
    gradymon[GYCYLRTIPUP_SLOT].powscale =1.0;
    gradymon[GYMONTIPUP_SLOT].powscale =1.0;
    gradzmon[GZRF1MON_SLOT].powscale =1.0;
    gradzmon[GZ1MON_SLOT].powscale =1.0;
    gradzmon[GZKMON_SLOT].powscale =1.0;
    gradzmon[GZCYLRA_SLOT].powscale  =1.0;
    gradzmon[GZCYLR_SLOT].powscale  =1.0;
    gradzmon[GZCYLRATIPUP_SLOT].powscale  =1.0;
    gradzmon[GZCYLRTIPUP_SLOT].powscale  =1.0;
    gradzmon[GZKMONTIPUP_SLOT].powscale  =1.0;

    minseqcoilmon_t  = _minseqcoilmon_t.fixedflag ?  ((void)(0), minseqcoilmon_t) : 0;
    minseqcablemon_t  = _minseqcablemon_t.fixedflag ?  ((void)(0), minseqcablemon_t) : 0;
    minseqbusbarmon_t  = _minseqbusbarmon_t.fixedflag ?  ((void)(0), minseqbusbarmon_t) : 0;
    minseqgrddrvxmon_t  = _minseqgrddrvxmon_t.fixedflag ?  ((void)(0), minseqgrddrvxmon_t) : 0;
    minseqgrddrvymon_t  = _minseqgrddrvymon_t.fixedflag ?  ((void)(0), minseqgrddrvymon_t) : 0;
    minseqgrddrvzmon_t  = _minseqgrddrvzmon_t.fixedflag ?  ((void)(0), minseqgrddrvzmon_t) : 0;
    minseqgrddrvmon_t  = _minseqgrddrvmon_t.fixedflag ?  ((void)(0), minseqgrddrvmon_t) : 0;

    /* check the gradient driver heating  for all pulses */
    if (minseqgrddrv(_minseqgrddrvxmon_t.fixedflag ? (_temp425_minseqgrddrvxmon_t=minseqgrddrvxmon_t,&_temp425_minseqgrddrvxmon_t) : &minseqgrddrvxmon_t, _powerx.fixedflag ? (_temp426_powerx=powerx,&_temp426_powerx) : &powerx, _pospowerx.fixedflag ? (_temp427_pospowerx=pospowerx,&_temp427_pospowerx) : &pospowerx, _negpowerx.fixedflag ? (_temp428_negpowerx=negpowerx,&_temp428_negpowerx) : &negpowerx,
                     (int)GXMON_FREE, gradxmon, 
                     (INT)((sigrammode & XGRAM)/XGRAM), 
                     monloggrd.xirmspos, monloggrd.xirmsneg, 
                     monloggrd.xirms, monloggrd.xipeak, monloggrd.xfs) == FAILURE)
    {	
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"minseqgrddrv:xmon");
        return FAILURE;
    }

    if (minseqgrddrv(_minseqgrddrvymon_t.fixedflag ? (_temp429_minseqgrddrvymon_t=minseqgrddrvymon_t,&_temp429_minseqgrddrvymon_t) : &minseqgrddrvymon_t, _powery.fixedflag ? (_temp430_powery=powery,&_temp430_powery) : &powery, _pospowery.fixedflag ? (_temp431_pospowery=pospowery,&_temp431_pospowery) : &pospowery, _negpowery.fixedflag ? (_temp432_negpowery=negpowery,&_temp432_negpowery) : &negpowery,
                     (int)GYMON_FREE, gradymon, 
                     (INT)((sigrammode & YGRAM)/YGRAM), 
                     monloggrd.yirmspos, monloggrd.yirmsneg, 
                     monloggrd.yirms, monloggrd.yipeak, monloggrd.yfs) == FAILURE)
    {	
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"minseqgrddrv:ymon");
        return FAILURE;
    }

    if (minseqgrddrv(_minseqgrddrvzmon_t.fixedflag ? (_temp433_minseqgrddrvzmon_t=minseqgrddrvzmon_t,&_temp433_minseqgrddrvzmon_t) : &minseqgrddrvzmon_t, _powerz.fixedflag ? (_temp434_powerz=powerz,&_temp434_powerz) : &powerz, _pospowerz.fixedflag ? (_temp435_pospowerz=pospowerz,&_temp435_pospowerz) : &pospowerz, _negpowerz.fixedflag ? (_temp436_negpowerz=negpowerz,&_temp436_negpowerz) : &negpowerz,
                     (int)GZMON_FREE, gradzmon, 
                     (INT)((sigrammode & ZGRAM)/ZGRAM), 
                     monloggrd.zirmspos, monloggrd.zirmsneg, 
                     monloggrd.zirms, monloggrd.zipeak, monloggrd.zfs) == FAILURE)
    {	
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"minseqgrddrv:zmon");
        return FAILURE;
    }

    minseqgrddrvmon_t  = _minseqgrddrvmon_t.fixedflag ?     ((void)(IMax(3,minseqgrddrvxmon_t,minseqgrddrvymon_t,minseqgrddrvzmon_t)), minseqgrddrvmon_t) : IMax(3,minseqgrddrvxmon_t,minseqgrddrvymon_t,minseqgrddrvzmon_t);


    /* check gradient coil heating     QT*/
    if (minseqcoil(_minseqcoilmon_t.fixedflag ? (_temp437_minseqcoilmon_t=minseqcoilmon_t,&_temp437_minseqcoilmon_t) : &minseqcoilmon_t, _xa2s.fixedflag ? (_temp438_xa2s=xa2s,&_temp438_xa2s) : &xa2s, _ya2s.fixedflag ? (_temp439_ya2s=ya2s,&_temp439_ya2s) : &ya2s, _za2s.fixedflag ? (_temp440_za2s=za2s,&_temp440_za2s) : &za2s, cfsrmode, 
                   gradxmon, gradymon, gradzmon, (int)GXMON_FREE, 
                   (int)GYMON_FREE, (int)GZMON_FREE, cfgcontirms) == FAILURE)
    { 
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"minseqcoilmon");
        return FAILURE;
    }  

    if ( (8920 == cfgradamp) || (8921 == cfgradamp) || (5550 == cfgradamp) || (9000 == cfgradamp)) /* XGD, XG2, SSSD or RGD */
    {
        if (minseqcable(_minseqcablemon_t.fixedflag ? (_temp441_minseqcablemon_t=minseqcablemon_t,&_temp441_minseqcablemon_t) : &minseqcablemon_t, _xa2s.fixedflag ? (_temp442_xa2s=xa2s,&_temp442_xa2s) : &xa2s, _ya2s.fixedflag ? (_temp443_ya2s=ya2s,&_temp443_ya2s) : &ya2s, _za2s.fixedflag ? (_temp444_za2s=za2s,&_temp444_za2s) : &za2s, cfsrmode,
                        gradxmon, gradymon, gradzmon, 
                        (int)GXMON_FREE, (int)GYMON_FREE,
                        (int)GZMON_FREE, cfgcontirms, tmin_mon) == FAILURE)
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"minseqcablemon");
            return FAILURE;
        }

        /* busbar model is unnecessary for SSSD (Kizuna)   and RGD (Rio) */
        if ( !(isKizunaSystem() || isRioSystem()) ) 
        {
            if (minseqbusbar(_minseqbusbarmon_t.fixedflag ? (_temp445_minseqbusbarmon_t=minseqbusbarmon_t,&_temp445_minseqbusbarmon_t) : &minseqbusbarmon_t, minseqcablemon_t, tmin_mon) == FAILURE)
            { 
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, 
                           EE_ARGS(1), STRING_ARG, "minseqbusbarmon");
                return FAILURE;
            }
        }
    }

    min_montr  = _min_montr.fixedflag ?      
                       
                      ((void)(IMax(7,tmin_mon,max_seqsarmon,min_seqrfampmon,minseqgrddrvmon_t,minseqcoilmon_t,minseqcablemon_t,minseqbusbarmon_t)), min_montr) : IMax(7,tmin_mon,max_seqsarmon,min_seqrfampmon,minseqgrddrvmon_t,minseqcoilmon_t,minseqcablemon_t,minseqbusbarmon_t);

    min_montr  = _min_montr.fixedflag ?  ((void)(10), min_montr) : min_montr*10;	
    advroundup(_min_montr.fixedflag ? (_temp446_min_montr=min_montr,&_temp446_min_montr) : &min_montr);
    min_montr = _min_montr.fixedflag ?  ((void)(10), min_montr) : min_montr/10;

    /* FOR MERGE */
    /* Hardcoded values of mon_tr have been removed */
    /* mon_tr for navigator is defined in Navigator.e */
    if( smartprep_flag )
    {
        mon_tr  = _mon_tr.fixedflag ?    ((void)(IMax(2,mon_tr,min_montr)), mon_tr) : IMax(2,mon_tr,min_montr);
    }

    if( SUCCESS != monitorCalcSar( Rfpulse, numPulses, average_sar, avecoil_sar, peak_sar_mon ) )
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG,
                   "monitorCalcSar");
        return FAILURE;
    }

    return SUCCESS;
}

STATUS
dump_rot( long rotation_matrix[] )
{
    printf("\t\t%+6ld, %+6ld, %+6ld \n",
           rotation_matrix[0],  rotation_matrix[1],  rotation_matrix[2]);
    printf("\t\t%+6ld, %+6ld, %+6ld \n",
           rotation_matrix[3],  rotation_matrix[4],  rotation_matrix[5]);
    printf("\t\t%+6ld, %+6ld, %+6ld \n",
           rotation_matrix[6],  rotation_matrix[7],  rotation_matrix[8]);

    return SUCCESS;
}

STATUS
Monitor_Predownload( RF_PULSE Rfpulse[], ENTRY_POINT_TABLE entryPoint[], INT numPulses,
                     INT actTR, FLOAT *average_sar, FLOAT *avecoil_sar, FLOAT *peak_sar_mon )
{
    /* FOR MERGE */
    /* int tmp_taps, tmp_prefill; */
    int i;
    float tempf,tempf2;
    /* NAV temporary variables */
    float cosphi,sinphi;
    int mon_mat[9];
#ifdef PSD_HW
    FILE *fp;
#endif /* PSD_HW */

    cosphi = cos(DEG_TO_RAD*monrot_phi);
    sinphi = sin(DEG_TO_RAD*monrot_phi);

#ifdef SPIRAL
    mon_loc = mymon_loc;
#else /* !SPIRAL */
#ifdef PSD_HW
    /* Write out monloc for 2d PSDs */ /* MRIhc35899 */
    if (navigator_flag || smartprep_flag) 
    {
        if (!(fp = fopen("/tmp/monloc.dat","w")))
        {
            fprintf(stderr, "Can't open /tmp/monloc.dat, please download a nav scan with a tracker first\n");
        } else {
            fprintf(fp, "%4.2f\t%4.2f\t%4.2f\n",mon_loc.optloc,mon_loc.oprloc,
                    mon_loc.opphasoff);
            fprintf(fp, "%4.2f\t%4.2f\t%4.2f\n",mon_loc.optloc_shift,mon_loc.oprloc_shift,
                    mon_loc.opphasoff_shift);
            fprintf(fp,"%f\t%f\t%f\n",mon_loc.oprot[0],mon_loc.oprot[1],
                    mon_loc.oprot[2]);
            fprintf(fp,"%f\t%f\t%f\n",mon_loc.oprot[3],mon_loc.oprot[4],
                    mon_loc.oprot[5]);
            fprintf(fp,"%f\t%f\t%f\n",mon_loc.oprot[6],mon_loc.oprot[7],
                    mon_loc.oprot[8]);
            fclose(fp);
        }
    }
#endif /* PSD_HW */
#endif /* !SPIRAL */
 
    if (smartprep_flag || navigator_flag) 
    {
        if (floatsAlmostEqualEpsilons(monrot_phi, 0.0, 2))
        {
            rf1mon_shift  = _rf1mon_shift.fixedflag ?    ((void)(mon_loc.optloc+mon_loc.optloc_shift), rf1mon_shift) : mon_loc.optloc+mon_loc.optloc_shift;
            
            if (swap_monplane == PSD_ON) 
            {
            	monloc_shift  = _monloc_shift.fixedflag ?    ((void)(mon_loc.opphasoff+mon_loc.opphasoff_shift), monloc_shift) : mon_loc.opphasoff+mon_loc.opphasoff_shift;
              	rf2mon_shift  = _rf2mon_shift.fixedflag ?    ((void)(mon_loc.oprloc+mon_loc.oprloc_shift), rf2mon_shift) : mon_loc.oprloc+mon_loc.oprloc_shift;
            } else {
            	monloc_shift  = _monloc_shift.fixedflag ?    ((void)(mon_loc.oprloc+mon_loc.oprloc_shift), monloc_shift) : mon_loc.oprloc+mon_loc.oprloc_shift;
            	rf2mon_shift  = _rf2mon_shift.fixedflag ?    ((void)(mon_loc.opphasoff+mon_loc.opphasoff_shift), rf2mon_shift) : mon_loc.opphasoff+mon_loc.opphasoff_shift;
            }        

            mon_rsp_info[0].rsptloc = rf1mon_shift;
            mon_rsp_info[0].rsprloc = monloc_shift; 
            mon_rsp_info[0].rspphasoff = mon_loc.opphasoff + mon_loc.opphasoff_shift;  /* Not used */
            mon_rsp_info[0].slloc = rsp_info[0].slloc; /* Not used */
      
            mon_rsp_info2[0].rsptloc = rf2mon_shift;
            mon_rsp_info2[0].rsprloc = mon_loc.oprloc + mon_loc.oprloc_shift;          /* Not used */
            mon_rsp_info2[0].rspphasoff = mon_loc.opphasoff + mon_loc.opphasoff_shift; /* Not used*/
            mon_rsp_info2[0].slloc = rsp_info[0].slloc; /* Not used */
        } else {
            rf1mon_shift  = _rf1mon_shift.fixedflag ?    ((void)(mon_loc.optloc+mon_loc.optloc_shift), rf1mon_shift) : mon_loc.optloc+mon_loc.optloc_shift;
            rf2mon_shift  = _rf2mon_shift.fixedflag ?    ((void)(mon_loc.opphasoff+mon_loc.opphasoff_shift), rf2mon_shift) : mon_loc.opphasoff+mon_loc.opphasoff_shift;
            monloc_shift  = _monloc_shift.fixedflag ?    ((void)(mon_loc.oprloc+mon_loc.oprloc_shift), monloc_shift) : mon_loc.oprloc+mon_loc.oprloc_shift; 

            tempf = rf1mon_shift;
            tempf2 = rf2mon_shift;

            /* rotate only the logical slice*/
            rf1mon_shift  = _rf1mon_shift.fixedflag ?   
                           ((void)(tempf*cos(monrot_phi*DEG_TO_RAD)+tempf2*sin(monrot_phi*DEG_TO_RAD)), rf1mon_shift) : tempf*cos(monrot_phi*DEG_TO_RAD)+tempf2*sin(monrot_phi*DEG_TO_RAD);
	  
            rf2mon_shift  = _rf2mon_shift.fixedflag ?   
                           ((void)(-tempf*sin(monrot_phi*DEG_TO_RAD)+tempf2*cos(monrot_phi*DEG_TO_RAD)), rf2mon_shift) : -tempf*sin(monrot_phi*DEG_TO_RAD)+tempf2*cos(monrot_phi*DEG_TO_RAD);

            if (opentry != 1) 
            {
                rf1mon_shift  = _rf1mon_shift.fixedflag ?   
                               ((void)(tempf*cos(monrot_phi*DEG_TO_RAD)-tempf2*sin(monrot_phi*DEG_TO_RAD)), rf1mon_shift) : tempf*cos(monrot_phi*DEG_TO_RAD)-tempf2*sin(monrot_phi*DEG_TO_RAD);
                rf2mon_shift  = _rf2mon_shift.fixedflag ?   
                               ((void)(tempf*sin(monrot_phi*DEG_TO_RAD)+tempf2*cos(monrot_phi*DEG_TO_RAD)), rf2mon_shift) : tempf*sin(monrot_phi*DEG_TO_RAD)+tempf2*cos(monrot_phi*DEG_TO_RAD);
            }

            if (swap_monplane) 
            {
                tempf = rf2mon_shift;
                rf2mon_shift  = _rf2mon_shift.fixedflag ?  ((void)(monloc_shift), rf2mon_shift) : monloc_shift;
                monloc_shift  = _monloc_shift.fixedflag ?  ((void)(tempf), monloc_shift) : tempf;
            }

            if (swap_mon_zy)
            {
                tempf = rf2mon_shift;
                rf2mon_shift  = _rf2mon_shift.fixedflag ?  ((void)(rf1mon_shift), rf2mon_shift) : rf1mon_shift;
                rf1mon_shift  = _rf1mon_shift.fixedflag ?  ((void)(tempf), rf1mon_shift) : tempf;
            }

            mon_rsp_info[0].rsptloc = rf1mon_shift;
            mon_rsp_info[0].rsprloc = monloc_shift; 
            mon_rsp_info[0].rspphasoff = mon_loc.opphasoff + mon_loc.opphasoff_shift;  /* Not used */
            mon_rsp_info[0].slloc = rsp_info[0].slloc;         /* Not used */
	  
            mon_rsp_info2[0].rsptloc = rf2mon_shift;
            mon_rsp_info2[0].rsprloc = mon_loc.oprloc + mon_loc.oprloc_shift;          /* Not used */
            mon_rsp_info2[0].rspphasoff = mon_loc.opphasoff + mon_loc.opphasoff_shift; /* Not used*/
            mon_rsp_info2[0].slloc = rsp_info[0].slloc;       /* Not used */
        }

        /* Transpose */        
        for (i=0;i<9;i++)
        {
            if (transpose_monloc == PSD_ON)
             	rsprot_monitor[0][(i%3)*3 + i/3] = hostToRspRotMat(mon_loc.oprot[i]); 
            else
             	rsprot_monitor[0][i] = hostToRspRotMat(mon_loc.oprot[i]);
        }

		/* rotate about logical frequency axis */

      	if (!floatsAlmostEqualEpsilons(monrot_phi, 0.0, 2))
        {
            if (debug_monrotphi)
            {
                printf("prior to phi= %f rotation\n",monrot_phi);
                dump_rot(rsprot_monitor[0]);
                printf(".........................................\n");
            }

            for(i=0;i<9;i++) mon_mat[i] = (INT)rsprot_monitor[0][i];

            /* MRIge91425: feet first, rotate by 45 degrees not -45 */
            if(opentry != 1) 
            {
                sinphi = -1.0 * sinphi;
            }

            /* MRIge91425: rotation matrix calculations were wrong */

            /* rotate logical slice select*/
            rsprot_monitor[0][1] = (INT) ((float) mon_mat[1] * cosphi - 
                                          (float) mon_mat[2] * sinphi);
            rsprot_monitor[0][2] = (INT) ((float) mon_mat[1] * sinphi + 
                                          (float) mon_mat[2] * cosphi);
            rsprot_monitor[0][4] = (INT) ((float) mon_mat[4] * cosphi - 
                                          (float) mon_mat[5] * sinphi);
            rsprot_monitor[0][5] = (INT) ((float) mon_mat[4] * sinphi + 
                                          (float) mon_mat[5] * cosphi);
            rsprot_monitor[0][7] = (INT) ((float) mon_mat[7] * cosphi - 
                                          (float) mon_mat[8] * sinphi);
            rsprot_monitor[0][8] = (INT) ((float) mon_mat[7] * sinphi + 
                                          (float) mon_mat[8] * cosphi);

            if (debug_monrotphi)
            {
	            printf("After to phi= %f rotation\n",monrot_phi);
	            dump_rot(rsprot_monitor[0]);
	            printf(".........................................\n");
            }
        }
      
        if(scalerotmats(rsprot_monitor,&monloggrd,&monphygrd,(int)1, debug_monrot) == FAILURE)
        {
            epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                       EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
            return FAILURE;
        }

      	scanclocktime  = _scanclocktime.fixedflag ?  ((void)(max_avg_time), scanclocktime) : max_avg_time;

#ifdef NAV_EFGRE3D
        if (!opcgate && navgate_flag)
        {
            if (navigatorCYL_flag)
            {
                *Rfpulse[RFCYLR_SLOT].act_fa = *Rfpulse[RFCYLR_SLOT].act_fa/ num_views_per_nav_tr;
                *Rfpulse[RFCYLR_SLOT].pw     = *Rfpulse[RFCYLR_SLOT].pw/ num_views_per_nav_tr;
            } else {
                *Rfpulse[RF1MON_SLOT].act_fa = *Rfpulse[RF1MON_SLOT].act_fa/ num_views_per_nav_tr;
                *Rfpulse[RF1MON_SLOT].pw     = *Rfpulse[RF1MON_SLOT].pw/ num_views_per_nav_tr;
                *Rfpulse[RF2MON_SLOT].act_fa = *Rfpulse[RF2MON_SLOT].act_fa/ num_views_per_nav_tr;
                *Rfpulse[RF2MON_SLOT].pw     = *Rfpulse[RF2MON_SLOT].pw/ num_views_per_nav_tr;
            }
        } else if (navgate_flag) {
            if (navigatorCYL_flag)
            {
                *Rfpulse[RFCYLR_SLOT].act_fa = *Rfpulse[RFCYLR_SLOT].act_fa/ pe_acq2;
                *Rfpulse[RFCYLR_SLOT].pw     = *Rfpulse[RFCYLR_SLOT].pw/ pe_acq2;
            } else {
                *Rfpulse[RF1MON_SLOT].act_fa = *Rfpulse[RF1MON_SLOT].act_fa/ pe_acq2;
                *Rfpulse[RF1MON_SLOT].pw     = *Rfpulse[RF1MON_SLOT].pw/ pe_acq2;
                *Rfpulse[RF2MON_SLOT].act_fa = *Rfpulse[RF2MON_SLOT].act_fa/ pe_acq2;
                *Rfpulse[RF2MON_SLOT].pw     = *Rfpulse[RF2MON_SLOT].pw/ pe_acq2;
            }
        }
#endif

        if( SUCCESS != monitorCalcSar( Rfpulse, numPulses, average_sar, avecoil_sar, peak_sar_mon ) )
        {
            epic_error(use_ermes, "%s failed",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG,
                       "monitorCalcSar");
            return FAILURE;
        }

#ifdef NAV_EFGRE3D
        if (!opcgate && navgate_flag)
        {
            if (navigatorCYL_flag)
            {
                *Rfpulse[RFCYLR_SLOT].act_fa = *Rfpulse[RFCYLR_SLOT].act_fa * num_views_per_nav_tr;
                *Rfpulse[RFCYLR_SLOT].pw     = *Rfpulse[RFCYLR_SLOT].res *
                    ceil( (*Rfpulse[RFCYLR_SLOT].pw * num_views_per_nav_tr)/ (float)*Rfpulse[RFCYLR_SLOT].res );
            } else {
                *Rfpulse[RF1MON_SLOT].act_fa = *Rfpulse[RF1MON_SLOT].act_fa * num_views_per_nav_tr;
                *Rfpulse[RF1MON_SLOT].pw     = *Rfpulse[RF1MON_SLOT].res *
                    ceil( (*Rfpulse[RF1MON_SLOT].pw * num_views_per_nav_tr)/ (float)*Rfpulse[RF1MON_SLOT].res );
                *Rfpulse[RF2MON_SLOT].act_fa = *Rfpulse[RF2MON_SLOT].act_fa * num_views_per_nav_tr;
                *Rfpulse[RF2MON_SLOT].pw     = *Rfpulse[RF2MON_SLOT].res *
                    ceil( (*Rfpulse[RF2MON_SLOT].pw * num_views_per_nav_tr)/ (float)*Rfpulse[RF2MON_SLOT].res );
            }
        } else if (navgate_flag) {
            if (navigatorCYL_flag)
            {
                *Rfpulse[RFCYLR_SLOT].act_fa = *Rfpulse[RFCYLR_SLOT].act_fa * pe_acq2;
                *Rfpulse[RFCYLR_SLOT].pw     = *Rfpulse[RFCYLR_SLOT].res *
                    ceil( (*Rfpulse[RFCYLR_SLOT].pw * pe_acq2)/ (float)*Rfpulse[RFCYLR_SLOT].res );
            } else {
                *Rfpulse[RF1MON_SLOT].act_fa = *Rfpulse[RF1MON_SLOT].act_fa * pe_acq2;
                *Rfpulse[RF1MON_SLOT].pw     = *Rfpulse[RF1MON_SLOT].res *
                    ceil( (*Rfpulse[RF1MON_SLOT].pw * pe_acq2)/ (float)*Rfpulse[RF1MON_SLOT].res );
                *Rfpulse[RF2MON_SLOT].act_fa = *Rfpulse[RF2MON_SLOT].act_fa * pe_acq2;
                *Rfpulse[RF2MON_SLOT].pw     = *Rfpulse[RF2MON_SLOT].res *
                    ceil( (*Rfpulse[RF2MON_SLOT].pw * pe_acq2)/ (float)*Rfpulse[RF2MON_SLOT].res );
            }
        }
#endif

        if (navigatorCYL_flag)
        {
            ia_rfcylr  = _ia_rfcylr.fixedflag ?  ((void)(max_pg_iamp*(*(Rfpulse[RFCYLR_SLOT].amp))), ia_rfcylr) : max_pg_iamp*(*(Rfpulse[RFCYLR_SLOT].amp));
            ia_thcylr  = _ia_thcylr.fixedflag ?  ((void)(max_pg_iamp), ia_thcylr) : max_pg_iamp;
            ia_gycylr  = _ia_gycylr.fixedflag ?  ((void)(max_pg_iamp*(a_gycylr/monloggrd.ty)), ia_gycylr) : max_pg_iamp*(a_gycylr/monloggrd.ty);
            ia_gzcylr  = _ia_gzcylr.fixedflag ?  ((void)(max_pg_iamp*(a_gzcylr/monloggrd.tz)), ia_gzcylr) : max_pg_iamp*(a_gzcylr/monloggrd.tz);

            if (exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
            {       
                ia_rfcylrtipup  = _ia_rfcylrtipup.fixedflag ?  ((void)(max_pg_iamp*(*(Rfpulse[RFCYLRTIPUP_SLOT].amp))), ia_rfcylrtipup) : max_pg_iamp*(*(Rfpulse[RFCYLRTIPUP_SLOT].amp));
                ia_thcylrtipup  = _ia_thcylrtipup.fixedflag ?  ((void)(max_pg_iamp), ia_thcylrtipup) : max_pg_iamp;
                ia_gycylrtipup  = _ia_gycylrtipup.fixedflag ?  ((void)(max_pg_iamp*(a_gycylrtipup/monloggrd.ty)), ia_gycylrtipup) : max_pg_iamp*(a_gycylrtipup/monloggrd.ty);
                ia_gzcylrtipup  = _ia_gzcylrtipup.fixedflag ?  ((void)(max_pg_iamp*(a_gzcylrtipup/monloggrd.tz)), ia_gzcylrtipup) : max_pg_iamp*(a_gzcylrtipup/monloggrd.tz);
            }
        } else {
            ia_rf1mon  = _ia_rf1mon.fixedflag ?   ((void)(max_pg_iamp*(*(Rfpulse[RF1MON_SLOT].amp))), ia_rf1mon) : max_pg_iamp*(*(Rfpulse[RF1MON_SLOT].amp));
            ia_rf2mon  = _ia_rf2mon.fixedflag ?   ((void)(max_pg_iamp*(*(Rfpulse[RF2MON_SLOT].amp))), ia_rf2mon) : max_pg_iamp*(*(Rfpulse[RF2MON_SLOT].amp));
            if (exist(opcgate) && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
            {       
                ia_rfmontipup  = _ia_rfmontipup.fixedflag ?  ((void)(-max_pg_iamp*(*(Rfpulse[RFMONTIPUP_SLOT].amp))), ia_rfmontipup) : -max_pg_iamp*(*(Rfpulse[RFMONTIPUP_SLOT].amp));
            }
        }
    }

    if (debug_monloc)
    {
        printf("mon_loc.optloc = %3.2f\n",mon_loc.optloc);
        printf("mon_loc.oprloc = %3.2f\n",mon_loc.oprloc);
        printf("mon_loc.opphasoff = %3.2f\n",mon_loc.opphasoff);
        printf("mon_loc.optloc_shift = %3.2f\n",mon_loc.optloc_shift);
        printf("mon_loc.oprloc_shift = %3.2f\n",mon_loc.oprloc_shift);
        printf("mon_loc.opphasoff_shift = %3.2f\n",mon_loc.opphasoff_shift);
        printf("mon_loc.oprot = \n");
        printf("\t%d\t%d\t%d\n",(int)mon_loc.oprot[0],(int)mon_loc.oprot[1],(int)mon_loc.oprot[2]);
        printf("\t%d\t%d\t%d\n",(int)mon_loc.oprot[3],(int)mon_loc.oprot[4],(int)mon_loc.oprot[5]);
        printf("\t%d\t%d\t%d\n",(int)mon_loc.oprot[6],(int)mon_loc.oprot[7],(int)mon_loc.oprot[8]);
    }

    return SUCCESS;
}

STATUS
monitorCalcSar( RF_PULSE Rfpulse[],
                const INT numPulses,
                FLOAT *average_sar,
                FLOAT *avecoil_sar,
                FLOAT *peak_sar_mon1 )
{
    STATUS status = SUCCESS;
    DOUBLE mon_ave_sar;
    DOUBLE mon_cave_sar;
    DOUBLE mon_pk_sar;
    DOUBLE mon_b1rms;

    /*
     * Activate the necessary monitoring pulses for both TEST.
     * allowing analysis in combination with the other SCAN pulses or
     * by themselves as TEST pulses. The active pulses will contribute
     * have appropriate "num" fields set such that they contribute
     * to pulse width, duty cycle, and amplitude pulse limits.
     */
    Monitor_setpulsenumon(Rfpulse);

    /*
     * Calculate the SAR for the monitor period itsef using only the TEST
     * pulses active during the monitor period.
     */
    status = peakAveSars( &mon_ave_sar,
                          &mon_cave_sar,
                          &mon_pk_sar,
                          &mon_b1rms,  
                          numPulses,
                          Rfpulse,
                          L_TEST,
                          mon_tr );
    if( SUCCESS != status )
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "pealAveSars: monitor");
        resetPulseNumActivity(Rfpulse);
        return FAILURE;
    }

    /* Monitor label for test (unused) entry point */
    strcpy(entry_point_table[L_TEST].epname, "Monitor+Scan");

    /*
     * Report the monitor period SAR back to the calling function
     */
    *average_sar = mon_ave_sar;
    *avecoil_sar = mon_cave_sar;
    *peak_sar_mon1 = mon_pk_sar;

    /*
     * Set the pulses back to the default state the flags say they
     * should be in before this function started manipulating the
     * activity and number fields.
     */
    resetPulseNumActivity(Rfpulse);

    return SUCCESS;
}

/*
 * When exiting out of the setupPowerMonitor function, make sure that the
 * monitoring pulses are set to the state appropriate for the active
 * flags, smartprep, navigator, aand navigatorCYL. This means that the
 * activity flags will be on but the pulse number will be 0 (off).
 */
void
resetPulseNumActivity( RF_PULSE Rfpulse[] )
{
    Monitor_setpulsenumoff(Rfpulse);
    return;
}

STATUS Monitor_Cvcheck( void )
{
    if (smartprep_flag && navigator_flag) 
    {
        epic_error( use_ermes, "%s is incompatible with %s ",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Navigator",
                    STRING_ARG, "Smartprep" );
        return FAILURE;
    }

    if ((PSD_OFF != piautonavtracker) && (PSD_ON == smartprep_flag))
    {
        epic_error( use_ermes, "%s is incompatible with %s ",
                    EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Auto Tracker",
                    STRING_ARG, "Smartprep" );
        return FAILURE;
    }

#ifdef NAV_EFGRE3D
    if ((exist(opt2prep)) && (!exist(opnav)) && (!heart3d_flag))
    {
        epic_error( use_ermes, "%s needs to be chosen with %s ",
                    EM_PSD_ONLY_COMPATIBLE, EE_ARGS(2), STRING_ARG, "Navigator",
                    STRING_ARG, "T2Prep" );   
        return FAILURE;
    }
#endif

    /* MRIge41978 - latha@mr */
    if ((opsmartprep == PSD_ON) && (sp_key_on == FAILURE))
    {
        epic_error(use_ermes,"Smartprep is Not available without Option Key.",EM_PSD_SMARTPREP_OPTION_KEY,EE_ARGS(0));
        return FAILURE;
    }

    /* End MRIge41978 */
    /* MRIge42275 */
    if ((opsmartprep == PSD_ON) && (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP) 
        && (exist(oppseq) != PSD_GE) && (exist(oppseq) != PSD_SPGR))
    {
        epic_error(use_ermes,"Smartprep is compatible with only vascular TOF and vascular TOFSPGR",EM_PSD_SMARTPREP_TOF_TOFSPGR,EE_ARGS(0));
        return FAILURE;
    }

#ifdef NAV_EFGRE3D
    if (existcv(opt2prep) && exist(opt2prep) && (!heart3d_flag))
    {
        epic_error( 0, "T2 Prep is not currently available in 3D fast GRE/SPGR", 0, EE_ARGS(0));
        return FAILURE;
    }  
#endif

    if (navigator_flag)
    {
#ifdef NAV_EFGRE3D
        if ((existcv(opdose)) && (exist(opdose)>0) && (t2prep_flag))
        {
            epic_error( use_ermes, "%s is incompatible with %s ",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Contrast agent",
                        STRING_ARG, "T2 Prep" );
            return FAILURE;
        }
#endif /* NAV_EFGRE3D */

        if ((PSD_ON == navtrig_flag) && (existcv(opslquant)) && (existcv(oprtrep)) &&
            (exist(opslquant) < exist(oprtrep))) {
            epic_error( use_ermes, "%s is incompatible with %s ",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Navigator",
                        STRING_ARG, "# of Resp Interval > #Slices" );
            return FAILURE;
        }

        if( PSD_ON == exist(oprtcgate) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Navigator",
                        STRING_ARG, "Respiratory triggering" );
            return FAILURE;
        }

        if( (PSD_ON == exist(opmph)) && (PSD_OFF == exist(opdynaplan)) && 
            (PSD_OFF == exist(opdisco) && (PSD_OFF == exist(opssfse)) )) 
        {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Multi Phase without Variable Delays",
                        STRING_ARG, "Navigator" );
            return FAILURE;
        }

#ifdef NAV_EFGRE3D
        if( ifir_flag && (B0_30000 == cffield) )
        {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Body Navigator",
                        STRING_ARG, "Inhance IFIR" );
            return FAILURE;
        }
#endif

#ifdef NAV_EFGRE3D
        if( lava_flag || medal_flag || de3d_flag || ifir_flag || disco_seq_flag) {
            if( PSD_ON == exist(opcgate) ) {
                epic_error( use_ermes,
                            "%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                            STRING_ARG, "Cardiac gating",
                            STRING_ARG, "Body Navigator" );
                return FAILURE;
            }
        } else {
            if( PSD_ON == exist(opdisco ) ) {
                epic_error( use_ermes,
                        "%s needs to be chosen with %s.",
                        EM_PSD_ONLY_COMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Single echo DISCO Navigator",
                        STRING_ARG, "Special" );
                return FAILURE;
            } else if( (PSD_OFF == exist(opcgate)) && (PSD_ON == _opnecho.fixedflag) ) { /* HCSDM00172035 */
                epic_error( use_ermes,
                        "%s needs to be chosen with %s.",
                        EM_PSD_ONLY_COMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Cardiac gating",
                        STRING_ARG, "Navigator" );
                return FAILURE;
            }
        }
#else
        if( PSD_ON == exist(opcgate) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Cardiac gating",
                        STRING_ARG, "Body Navigator" );
            return FAILURE;
        }
#endif

#ifdef NAV_EFGRE3D
        if( !(lava_flag || medal_flag || de3d_flag || disco_seq_flag) &&
            ((PSD_ON == exist(opmph)) || (PSD_ON == exist(opdynaplan))) ) {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Multi-Phase with Navigator",
                        STRING_ARG, "in this pulse sequence" );
            return FAILURE;
        }
#else
        if( ((PSD_ON == exist(opmph)) || (PSD_ON == exist(opdynaplan))) && (PSD_OFF == exist(opssfse)) ) 
        {
            epic_error( use_ermes,
                        "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                        STRING_ARG, "Multi-Phase with Navigator",
                        STRING_ARG, "in this pulse sequence" );
            return FAILURE;
        }
#endif

        if (existcv(opnavaccwin) && ((exist(opnavaccwin) > avmaxnavaccwin) || (exist(opnavaccwin) < avminnavaccwin))) {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"Acceptance Window");
            return FAILURE;
        }

        if (existcv(opnavautotrigtime) && ((exist(opnavautotrigtime) > avmaxnavautotrigtime) || (exist(opnavautotrigtime) < avminnavautotrigtime))) {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"Auto Trigger Time");
            return FAILURE;
        }

        if (existcv(opnavpsctime) && ((exist(opnavpsctime) > avmaxnavpsctime) || (exist(opnavpsctime) < avminnavpsctime))) {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"Navigator Prescan Time");
            return FAILURE;
        }

        if (existcv(opnavrrmeastime) && ((exist(opnavrrmeastime) > avmaxnavrrmeastime) || (exist(opnavrrmeastime) < avminnavrrmeastime))) {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"Max RR Measurement Time");
            return FAILURE;
        }

        if (existcv(opnavmaxinterval) && ((exist(opnavmaxinterval) > avmaxnavmaxinterval) || (exist(opnavmaxinterval) < avminnavmaxinterval))) {
            epic_error(use_ermes,"%s is out of range",EM_PSD_CV_OUT_OF_RANGE,
                       EE_ARGS(1),STRING_ARG,"Max Navigator Interval");
            return FAILURE;
        }

        if ((exist(opnav)) && (exist(ophrate)>MAX_NAV_HRATE))
        {
            epic_error(use_ermes,"Heart rate must be between %d and %d",EM_PSD_HRATE_OUT_OF_RANGE2,
                       EE_ARGS(2),INT_ARG,30,INT_ARG,MAX_NAV_HRATE);
            return FAILURE;
        }

        if(PSD_ON == navgate_flag)
        {
            if( (exist(opnex) > 1) && existcv(opnex) ){
                epic_error( use_ermes, "NEX must be 1 or less for the current prescription.", EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
                return FAILURE;
            }
        }

        if (navigatorCYL_flag)
        {
            if (CYLR_CONSTANT_DENSITY != cylr_rf_type)
            {
                if(a_gycylr>gmax_cylr)
                {
                    epic_error( 0, "a_gycylr is too big, larger than %10.6f", 0, EE_ARGS(1), FLOAT_ARG, gmax_cylr);
                    return FAILURE;
                }   

                if(a_gzcylr>gmax_cylr)
                {
                    epic_error( 0, "a_gzcylr is too big, larger than %10.6f", 0, EE_ARGS(1), FLOAT_ARG, gmax_cylr);
                    return FAILURE;
                }   

                if(a_gycylrtipup>gmax_cylr)
                {
                    epic_error( 0, "a_gycylrtipup is too big, larger than %10.6f", 0, EE_ARGS(1), FLOAT_ARG, gmax_cylr);
                    return FAILURE;
                }   

                if(a_gzcylrtipup>gmax_cylr)
                {
                    epic_error( 0, "a_gzcylrtipup is too big, larger than %10.6f", 0, EE_ARGS(1), FLOAT_ARG, gmax_cylr);
                    return FAILURE;
                }   
            }
        }
    }

#ifdef NAV_EFGRE3D
    if (smartprep_flag)
    {
        /* Fix for  MRIge42502 */
        if (respgate_flag)
        {
            epic_error(use_ermes,"Respirator triggering is not compatible with Smartprep",EM_PSD_SMARTPREP_RESP,EE_ARGS(0));
            return FAILURE;
        }

        /* Fix for  MRIge45197 */
        if (exist(opuser2) < _opuser2.minval || exist(opuser2) > _opuser2.maxval)
        {
            epic_error(use_ermes,"The Monitor Period is out of range.",EM_PSD_MONITOR_RANGE,EE_ARGS(0));
            return FAILURE;
        }

        if (exist(opuser4) < _opuser4.minval || exist(opuser4) > _opuser4.maxval)
        {
            epic_error(use_ermes,"%s is out of range.",EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),STRING_ARG,_opuser4.descr );
            return FAILURE;
        }
        /* end MRIge45197 */

        if ((max_avg_time/mon_tr + (navgs*num_baseline_pts)) > (MAX_DATA_POINTS/numpts2pass))
        {
            epic_error(use_ermes,"Max. data pts exceeded. Reduce max_avg_time or increase mon_tr or navgs.",EM_PSD_DATA_MAXED,EE_ARGS(0));	  
            return FAILURE;
        }

        if (mon_trigger_delay < min_delay_time)
        {
            epic_error(use_ermes,"Image acq. delay is too short, minimum is %d sec.",EM_PSD_SHORT_IM_ACQ_DELAY,EE_ARGS(1),
                       INT_ARG,(int)((float)(min_delay_time+999999)/1000000));
            return FAILURE;
        }


        if (smartprep_flag == PSD_ON && sp_key_on == FAILURE)
        {
            epic_error(use_ermes,"Smartprep is an invalid option at this time.",EM_PSD_INVALID_SMARTPREP,EE_ARGS(0));
            return FAILURE;
        }

        if ((smartprep_flag == PSD_ON) && (exist(opstation)>1) && existcv(opstation))
        {
            epic_error(use_ermes,"Smartprep is an invalid option at this time.",EM_PSD_INVALID_SMARTPREP,EE_ARGS(0));
            return FAILURE;
        }

        if ((existcv(opnex) == PSD_ON) && floatsAlmostEqualEpsilons(exist(opdose), 0.0, 2) && (existcv(opdose) == PSD_ON))
        {  
            epic_error(use_ermes,"Must enter a valid value for contrast dose.",
                       EM_PSD_INVALID_CONTRAST_DOSE,EE_ARGS(0));
            return FAILURE;
        }

        /* MRIge43959 -  JFS */
        if (rhfrsize < 128)
        {
            epic_error(use_ermes, "Use Minimum-Full TE or increase Freq Encoding Matrix",
                       EM_FREQENCODE_MINFULLTE_ERMES, EE_ARGS(0));
            return FAILURE;
        }
        /* end MRIge43959 */
    }
#endif /* NAV_EFGRE3D */

    return SUCCESS;
}





/* optimize gradient and esp based on rectangular dbdt model */
STATUS optGradAndEsp_rect(void)
{
    int readout_phyaxis;

    if(isGradAndEspReoptNeeded() == PSD_OFF) return SUCCESS;

    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
    if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
    if(epigradopt_debug) printEpigradoptLog();

    if(!esprange_check) return SUCCESS;

    readout_phyaxis = getReadoutPhyAxis();
    if(isEspOutOfUnwantedRange(esp, readout_phyaxis, a_gxw) == PSD_OFF)
    {
        if(searchEspLonger_rect(esp, readout_phyaxis) == FAILURE) return FAILURE;
        if(epigradopt_debug) printEpigradoptLog();
    }
    return SUCCESS;
}


/* optimize gradient and esp based on convolution dbdt model */
STATUS optGradAndEsp_conv(void)
{
    int dbdtper_inc;

    int esp_value[DBDT_MAXNUMSTEPS];
    int dbdtper_value[DBDT_MAXNUMSTEPS];
    int prev_esp;
    int esp_notchanged;

    int hit_esp_index;
    int i;
    int readout_phyaxis;

    int esp_first;

    if(isGradAndEspReoptNeeded() == PSD_OFF) return SUCCESS;

    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    readout_phyaxis = getReadoutPhyAxis();
    if((!espopt) && (!esprange_check))
    {
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
        return SUCCESS;
    }

    /* Search for shortest esp with pidbdtper smaller than cfdbdtper */
    dbdtper_count = 0;
    dbdtper_inc = DBDT_STEPSIZE;
    dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
    esp_notchanged = 0;
    prev_esp = -1;
    esp_first = -1;
    do
    {
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        if(esp_first == -1) esp_first = esp;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();

        if(pidbdtper > cfdbdtper) break; /* break when pidbdtper reaches cfdbdtper */

        esp_value[dbdtper_count] = esp;
        dbdtper_value[dbdtper_count] = dbdtper_new;
        dbdtper_count++;
        if(dbdtper_count >= DBDT_MAXNUMSTEPS) break; /* break if too many steps */

        if(esp == prev_esp)
        {
            esp_notchanged++;
            if(esp_notchanged >= 3) break; /* break if esp not changed in 3 continous steps */
        }
        else
        {
            prev_esp = esp;
            esp_notchanged = 0;
        }

        if(!espopt)
        {
            if(isEspOutOfUnwantedRange(esp, readout_phyaxis, a_gxw) == PSD_ON)
            {
                return SUCCESS;
            }
        }

        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new+dbdtper_inc;
    } while(1);

    if(!espopt) /* increase esp until out of unwanted range */
    {
        if(searchEspLonger_rect(esp_first, readout_phyaxis) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
        return SUCCESS;
    }

    if(!esprange_check) /* no need to check esp range */
    {
        if(pidbdtper > cfdbdtper) /* one step back */
        {
            dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new-dbdtper_inc;
            if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
            pidbdtper = calcdbdtper_conv();
            if(epigradopt_debug) printEpigradoptLog();
        }
        return SUCCESS;
    }

    /* search for shortest esp out of unwanted range */
    hit_esp_index = -1;
    for(i=dbdtper_count-1; i>=0; i--)
    {
        if(isEspOutOfUnwantedRange(esp_value[i], readout_phyaxis, a_gxw) == PSD_ON)
        {
            hit_esp_index = i;
            break;
        }
    }

    if(hit_esp_index < 0) /* search esp in terms of out of unwanted range */
    {
        if(searchEspLonger_rect(esp_first, readout_phyaxis) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
    }
    else
    {
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_value[hit_esp_index]), dbdtper_new) : dbdtper_value[hit_esp_index];
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE) return FAILURE;
        pidbdtper = calcdbdtper_conv();
        if(epigradopt_debug) printEpigradoptLog();
    }

    return SUCCESS;
}

/* get esp out of unwanted range */
/* if get esp longer than esp_start, longer_shorter = 1;
   else longer_shorter = -1 */
int getEspOutOfUnwantedRange(int esp_start, int longer_shorter, int readout_phyaxis)
{
    if(longer_shorter < 0) longer_shorter = -1;
    else longer_shorter = 1;

    while(isEspOutOfUnwantedRange(esp_start, readout_phyaxis, a_gxw) == PSD_OFF)
    {
        esp_start += GRAD_UPDATE_TIME*longer_shorter;
    }

    return esp_start;
}

/* search esp out of unwanted range by increasing esp */
STATUS searchEspLonger_rect(int esp_start, int readout_phyaxis)
{

    if(espincway == 0)
    {
        int dbdtper_inc;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        dbdtper_inc = DBDT_STEPSIZE;
        do /* search for optimal esp in terms of shortest out of the unwanted range */
        {
            dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(dbdtper_inc), dbdtper_new) : dbdtper_new-dbdtper_inc;
            if(dbdtper_new <= 0)
            {
                epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "optGradAndEsp");
                return FAILURE;
            }
            epigradopt_rect(dbdtper_new, 0);
            if(epigradopt_debug) printEpigradoptLog();
        } while(isEspOutOfUnwantedRange(esp, readout_phyaxis, a_gxw) == PSD_OFF);
    }
    else
    {
        int esp_new;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;

        epigradopt_rect(dbdtper_new, 0);
        if(epigradopt_debug) printEpigradoptLog();
        esp_new =  getEspOutOfUnwantedRange(esp, 1, readout_phyaxis);
        pw_gxgap  = _pw_gxgap.fixedflag ?      ((void)(pw_gxgap+(esp_new-esp)), pw_gxgap) : pw_gxgap+(esp_new-esp);
        if ((pw_gxgap % pwmin_gap) != 0)
            pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;
        if( FAILURE == setEpiEsp() )
        {
            epic_error(use_ermes, "setEpiEsp_failed", EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG, "setEpiEsp()");
            return FAILURE;
        }
    }

    return SUCCESS;
}


/* Get physical axis of readout gradient */
int getReadoutPhyAxis(void)
{
    int readout_phyaxis, i;
    readout_phyaxis = 0;
    for(i=0; i<exist(opslquant); i++)
    {
        if(rsprot[i][0] != 0) readout_phyaxis |= XAXIS;
        if(rsprot[i][3] != 0) readout_phyaxis |= YAXIS;
        if(rsprot[i][6] != 0) readout_phyaxis |= ZAXIS;
    }
    return readout_phyaxis;
}

/*
 * Check if esp is out of unwanted range or not;
 * and if necessary, check the amplitude along physical axis:
 * if esp falls into the range but amplitude does not exceed, it will be accepted
 */
int isEspOutOfUnwantedRange(int esp_v, int readout_phyaxis, float amp_gxw)
{
    int i;

    if(readout_phyaxis & XAXIS)
    {
        for(i=0; i<numesprange_x; i++)
        {
            if ( ((esp_v >= esprange_x[i][0]) && (esp_v <= esprange_x[i][1])) &&
                ( ((PSD_ON == espamp_check) && (fabs(amp_gxw * scan_info[0].oprot[0]) > espamp_x[i])) ||
                    (PSD_OFF == espamp_check) ) )
                return PSD_OFF;
        }
    }
    if(readout_phyaxis & YAXIS)
    {
        for(i=0; i<numesprange_y; i++)
        {
            if ( ((esp_v >= esprange_y[i][0]) && (esp_v <= esprange_y[i][1])) &&
                ( ((PSD_ON == espamp_check) && (fabs(amp_gxw * scan_info[0].oprot[3]) > espamp_y[i])) ||
                    (PSD_OFF == espamp_check) ) )
                return PSD_OFF;
        }
    }
    if(readout_phyaxis & ZAXIS)
    {
        for(i=0; i<numesprange_z; i++)
        {
            if ( ((esp_v >= esprange_z[i][0]) && (esp_v <= esprange_z[i][1])) &&
                ( ((PSD_ON == espamp_check) && (fabs(amp_gxw * scan_info[0].oprot[6]) > espamp_z[i])) ||
                    (PSD_OFF == espamp_check)) )
                return PSD_OFF;
        }
    }

    return PSD_ON;
}

/* generate epi readout gradient waveform and set esp */
STATUS epigradopt_rect(float cfdbdtper_new, int reqesp_new)
{
    if (mux_flag && use_slice_fov_shift_blips)
    {
        epigradopt_zblips( &gradin, &gradout, &pidbdtts, &pidbdtper, _dbdtperx.fixedflag ? (_temp447_dbdtperx=dbdtperx,&_temp447_dbdtperx) : &dbdtperx, _dbdtpery.fixedflag ? (_temp448_dbdtpery=dbdtpery,&_temp448_dbdtpery) : &dbdtpery, _dbdtperz.fixedflag ? (_temp449_dbdtperz=dbdtperz,&_temp449_dbdtperz) : &dbdtperz, cfdbdtts, cfdbdtper_new,
                          cfdbdtdx, cfdbdtdy, cfdbdtdz, reqesp_new, autogap, (int)rampsamp,
                          (int)vrgfsamp, (int)(debug));
    }
    else
    {
        epigradopt( &gradin, &gradout, &pidbdtts, &pidbdtper, cfdbdtts, cfdbdtper_new,
                    cfdbdtdx, cfdbdtdy, reqesp_new, autogap, (int)vrgfsamp,
                    (int)vrgfsamp, (int)debug );
    }

    rhfrsize  = _rhfrsize.fixedflag ?  ((void)(temprhfrsize), rhfrsize) : temprhfrsize;
    /* SXZ::MRIge72411: calc actual ratio */
    if(vrgfsamp == PSD_ON && rampopt == 1){

        int tempvar;
        /* ramp area */
        tempvar = ((float)a_gxw*pw_gxwad-a_gxw*(pw_gyba+pw_gyb/2)*(pw_gyba+pw_gyb/2)/pw_gxwad);
        /* top area */
        tempvar = totarea - tempvar;
        actratio  = _actratio.fixedflag ?  ((void)(tempvar/totarea), actratio) : tempvar/totarea;
    } else {
        actratio  = _actratio.fixedflag ?  ((void)(1), actratio) : 1;
    }

    /* MGD: call calcfilter() */
    /* MRIge66608: need rhfrsize input pts and no exist(oprbw) for VRGF */
    if( FAILURE == (calcfilter(&echo1_filt, oprbw, rhfrsize, OVERWRITE_OPRBW)) ) {
        epic_error(use_ermes, "calfilter_failed", EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG, "calcfilter");
        return FAILURE;
    }

    getminesp(echo1_filt, xtr_offset, intleaves, hrdwr_period, vrgfsamp, _minesp.fixedflag ? (_temp450_minesp=minesp,&_temp450_minesp) : &minesp);

    /* There is a bug in epigradopt for non-vrg.  Bump up pw_gxwad */
    pw_gxwad  = _pw_gxwad.fixedflag ?  ((void)(RUP_GRD(pw_gxwad)), pw_gxwad) : RUP_GRD(pw_gxwad);

    /* Also, epigradopt does not make pw_gxgap a mult. of 2*GRAD_UPDATE_TIME,
       so do it here (MRIge23911) */
    if ((pw_gxgap % pwmin_gap) != 0)
        pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;

    /* need to set the decay of the blip to = the attack found in epgradopt() */
    pw_gybd  = _pw_gybd.fixedflag ?  ((void)(pw_gyba), pw_gybd) : pw_gyba;

    /* Call to calculate the echo-sapcing (esp) */
    if( FAILURE == setEpiEsp() ) {

        epic_error(use_ermes, "setEpiEsp_failed", EM_PSD_SUPPORT_FAILURE,1,
                   STRING_ARG, "setEpiEsp()");
        return FAILURE;
    }
    return SUCCESS;
}

/* check if EPI readout gradient waveforms need to be regenerated  */
int isGradAndEspReoptNeeded(void)
{
    if((reopt_flag == PSD_ON) ||
       memcmp(&gradin, &gradin_old, sizeof(OPT_GRAD_INPUT)) || memcmp(rsprot[0], rsprot_old, 9*sizeof(long)) ||
       (!floatsAlmostEqualEpsilons(cfdbdtper, cfdbdtper_old, 2)) || (dbdt_model != dbdt_model_old) ||
       (esprange_check != esprange_check_old) || (espamp_check != espamp_check_old)|| (mph_flag != opmph_old) ||
       (rampopt != rampopt_old) || (espopt != espopt_old) || (espincway != espincway_old)
       || (max_dbdtper_hb_zblips != max_dbdtper_hb_zblips_old))
    {
        reopt_flag = PSD_OFF;
        memcpy(&gradin_old, &gradin, sizeof(OPT_GRAD_INPUT));
        memcpy(rsprot_old, rsprot[0], 9*sizeof(long));
        cfdbdtper_old = cfdbdtper;
        dbdt_model_old = dbdt_model;
        esprange_check_old = esprange_check;
        espamp_check_old = espamp_check;
        opmph_old = mph_flag;
        rampopt_old = rampopt;
        espopt_old = espopt;
        espincway_old = espincway;
        epigradopt_debug_old = epigradopt_debug;
        max_dbdtper_hb_zblips_old = max_dbdtper_hb_zblips;
        return PSD_ON;
    }

    if(epigradopt_debug && epigradopt_debug != epigradopt_debug_old)
    {
        epigradopt_debug_old = epigradopt_debug;
        return PSD_ON;
    }
    epigradopt_debug_old = epigradopt_debug;

    return PSD_OFF;
}

/* calculate dbdtper of EPI readout gradient waveforms using convolution dbdt model */
float calcdbdtper_conv(void)
{
/*
    The epi readout gradient waveforms could be considered three parts:
       1. The first ramp. There is no epi blip here. 3 corner points for this part.
       2. Parity switching period. There is epi bilp within this period. This period is repeated, and 10
          corner points needed for each repetation.
       3. The last ramp: There is no epi blip here. 3 corner points for this part.
*/
    int i, j;
    float max_dbdtper;

    int tcon1[3], tcon2[10], tcon3[3];
    float aconx1[3], aconx2[10], aconx3[3];
    float acony1[3], acony2[10], acony3[3];

    /* generate corner points */
    tcon1[0]=0; tcon1[1]=pw_gxwad; tcon1[2]=pw_gxwl;
    aconx1[0]=0; aconx1[1]=a_gxw; aconx1[2]=a_gxw;
    acony1[0]=0; acony1[1]=0; acony1[2]=0;

    tcon3[0]=pw_gxw; tcon3[1]=pw_gxwr; tcon3[2]=pw_gxwad;
    aconx3[0]=a_gxw; aconx3[1]=a_gxw; aconx3[2]=0;
    acony3[0]=0; acony3[1]=0; acony3[2]=0;

    tcon2[0]=pw_gxw; aconx2[0]=a_gxw;  acony2[0]=0;
    if(pw_gyba+pw_gyb/2 > pw_gxwad+pw_gxgap/2)
    {
        tcon2[1]=pw_gxwr+(pw_gxwad+pw_gxgap/2)-(pw_gyba+pw_gyb/2); aconx2[1]=a_gxw;  acony2[1]=0;
        if(pw_gyb/2 > pw_gxwad+pw_gxgap/2)
        {
            tcon2[2]=pw_gyba; aconx2[2]=a_gxw;  acony2[2]=a_gyb;
            tcon2[3]=(pw_gyb/2)-(pw_gxwad+pw_gxgap/2); aconx2[3]=a_gxw; acony2[3]=a_gyb;
            tcon2[4]=pw_gxwad; aconx2[4]=0; acony2[4]=a_gyb;
        }
        else
        {
            tcon2[2]=(pw_gyba+pw_gyb/2)-(pw_gxwad+pw_gxgap/2); aconx2[2]=a_gxw;  acony2[2]=0;
            if(pw_gyb/2 > pw_gxgap/2)
            {
                tcon2[3]=(pw_gxwad+pw_gxgap/2)-(pw_gyb/2);
                aconx2[3]=intercept(a_gxw, 0, pw_gxwad,tcon2[3]);
                acony2[3]=a_gyb;
                tcon2[4]=pw_gxwr+pw_gxwad; aconx2[4]=0; acony2[4]=a_gyb;
            }
            else
            {
                tcon2[3]=pw_gxwad;
                aconx2[3]=0;
                acony2[3]=intercept(0, a_gyb, pw_gyba,tcon2[2]+tcon2[3]);
                tcon2[4]=(pw_gxgap/2)-(pw_gyb/2); aconx2[4]=0; acony2[4]=a_gyb;
            }

        }
    }
    else
    {
        tcon2[1]=pw_gxwr; aconx2[1]=a_gxw;  acony2[1]=0;
        if(pw_gyba+pw_gyb/2 > pw_gxgap/2)
        {
            tcon2[2]=(pw_gxwad+pw_gxgap/2)-(pw_gyba+pw_gyb/2);
            aconx2[2]=intercept(a_gxw, 0, pw_gxwad, tcon2[2]);
            acony2[2]=0;
            if(pw_gyb/2 > pw_gxgap/2)
            {
                tcon2[3]=pw_gyba;
                aconx2[3]=intercept(a_gxw, 0, pw_gxwad,pw_gxwad+pw_gxgap/2-pw_gyb/2);
                acony2[3]=a_gyb;
                tcon2[4]=pw_gyb/2-pw_gxgap/2; aconx2[4]=0; acony2[4]=a_gyb;
            }
            else
            {
                tcon2[3]=(pw_gyba+pw_gyb/2)-(pw_gxgap/2);
                aconx2[3]=0;
                acony2[3]=intercept(0, a_gyb, pw_gyba, tcon2[3]);
                tcon2[4]=pw_gxgap/2-pw_gyb/2; aconx2[4]=0; acony2[4]=a_gyb;
            }
        }
        else
        {
            tcon2[2]=pw_gxwad; aconx2[2]=0;  acony2[2]=0;
            tcon2[3]=(pw_gxgap/2)-(pw_gyba+pw_gyb/2); aconx2[3]=0; acony2[3]=0;
            tcon2[4]=pw_gyba; aconx2[4]=0; acony2[4]=a_gyb;
        }

    }

    tcon2[5]=2*((pw_gxwr+pw_gxwad+pw_gxgap/2)-tcon2[1]-tcon2[2]-tcon2[3]-tcon2[4]);
    for(i=6;i<10;i++)
    {
        tcon2[i]=tcon2[10-i];
    }
    for(i=5;i<10;i++)
    {
        aconx2[i]=-aconx2[9-i];
        acony2[i]=acony2[9-i];
    }


    /* calculate dbdtper with convolution dbdt model*/
    {
        int etl_1, num_cornerpoints;
        int * tcon;
        float * aconx, * acony;
        float * dbdtper_x_data, * dbdtper_y_data, * dbdtper_data;

        float us2s = 1.0e-6;
        float gcm2Tm = 1.0e-2;
        float cm2m = 1.0e-2;

        int sign = 1;
        float dbdtdxyz;

        etl_1 = DBDT_ETL;
        num_cornerpoints = 3+10*(etl_1-1)+3;

        tcon = (int *)malloc(num_cornerpoints*sizeof(int));
        aconx = (float *)malloc(num_cornerpoints*sizeof(float));
        acony = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_x_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_y_data = (float *)malloc(num_cornerpoints*sizeof(float));
        dbdtper_data = (float *)malloc(num_cornerpoints*sizeof(float));

        tcon[0]=0;
        aconx[0]=0;
        acony[0]=0;
        for(i=1; i<num_cornerpoints; i++)
        {
            if(i<3)
            {
                tcon[i] = tcon[i-1]+tcon1[i];
                aconx[i] = aconx1[i];
                acony[i] = acony1[i];
            }
            else if(i>=num_cornerpoints-3)
            {
                tcon[i] = tcon[i-1]+tcon3[i-(num_cornerpoints-3)];
                aconx[i] = aconx3[i-(num_cornerpoints-3)]*sign;
                acony[i] = acony3[i-(num_cornerpoints-3)];
            }
            else
            {
                tcon[i] = tcon[i-1]+tcon2[(i-3)%10];
                aconx[i] = aconx2[(i-3)%10]*sign;
                acony[i] = acony2[(i-3)%10];
                if(((i-3)%10)==9) sign *= -1;
            }
        }

        if(epigradopt_debug) printCornerPoint(num_cornerpoints, tcon, aconx, acony);

        dbdtdxyz = FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);
        for(i=0;i<num_cornerpoints; i++)
        {
            aconx[i] *= dbdtdxyz*cm2m*gcm2Tm;
            acony[i] *= dbdtdxyz*cm2m*gcm2Tm;
        }

        max_dbdtper=0.0;
        dbdtper_x_data[0] = dbdtper_y_data[0] = dbdtper_data[0] = 0.0;
        for(i=1; i<num_cornerpoints; i++)
        {
            float the_dbdtper_x=0.0;
            float the_dbdtper_y=0.0;
            float the_dbdtper;

            for(j=0;j<i;j++)
            {
                float dbdt_x, dbdt_y;
                if(tcon[j+1]==tcon[j]) continue;

                dbdt_x=(aconx[j+1]-aconx[j])/(tcon[j+1]-tcon[j])/us2s;
                dbdt_y=(acony[j+1]-acony[j])/(tcon[j+1]-tcon[j])/us2s;
                the_dbdtper_x=the_dbdtper_x+dbdt_x*cfrfact/cfrinf*
                              (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
                the_dbdtper_y=the_dbdtper_y+dbdt_y*cfrfact/cfrinf*
                              (1.0/(cfrfact+tcon[i]-tcon[j+1]) - 1.0/(cfrfact+tcon[i]-tcon[j]));
            }
            the_dbdtper = sqrt(the_dbdtper_x*the_dbdtper_x+the_dbdtper_y*the_dbdtper_y);
            if(the_dbdtper>max_dbdtper) max_dbdtper=the_dbdtper;

            dbdtper_x_data[i] = the_dbdtper_x;
            dbdtper_y_data[i] = the_dbdtper_y;
            dbdtper_data[i] = the_dbdtper;
        }

        if(epigradopt_debug) printDbdtper(max_dbdtper*100.0, num_cornerpoints, tcon, dbdtper_x_data, dbdtper_y_data, dbdtper_data);

        free(tcon);
        free(aconx);
        free(acony);
        free(dbdtper_x_data);
        free(dbdtper_y_data);
        free(dbdtper_data);
    }
    /* For hyperband, x and y axis are calculated with convolutional model,
     * z is then taken into account later*/
    if (mux_flag && use_slice_fov_shift_blips && (max_dbdtper_hb_zblips > 0))
    {
        if(max_dbdtper_hb_zblips==1)/*default behavior*/
            max_dbdtper = sqrt(max_dbdtper * max_dbdtper + dbdtperz/100.0 * dbdtperz/100.0);
        else
            max_dbdtper += dbdtperz/100.0;
    }
    /* return the minimum dbdtper value of rect and conv models */
    return (pidbdtper > 0.0 ? FMin(2, pidbdtper, max_dbdtper*100.0) : max_dbdtper*100.0);

}


float intercept(float y1, float y2, int xl, int x)
{
    return (y2-y1)/xl*x+y1;
}

/* read unwanted ESP range from a host file epiesp.dat
   File format:
   1  <--- number of ranges of X axisi, could be 0-5
   420 460   <--- first range of X axis
   1  <--- number of ranges of Y axis, could be 0-5
   420 460   <--- first range of Y axis
   1  <--- number of ranges of Z axis, could be 0-5
   360 400   <--- first range of Z axis

   comments could be inserted with # as the first character of the line
*/
STATUS readEspRange(void)
{
    FILE * fp;
    char tempstring[MAXCHAR];
    int i;

    if( epigradopt_debug && no_esprangefile == 1 )
    {
        printEspRange();
    }

    if( no_esprangefile == 1 ) /* Handles two conditions, a) File NOT found and corrupted b) File found and succcessfully read to avoid re-reading */
    {
        if(esp_crc_check_passed) /* Set to 1 if a) successfull CRC check is done, b) CRC check is disabled, c) SIM mode when file is corrupted or not found */
        {
            return SUCCESS;
        }
        else
        {
            return FAILURE;
        }
    }

#ifndef SIM
    if(PSD_XRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("/usr/g/bin/epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    }
    else if(PSD_VRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("/usr/g/bin/epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    }
    else if (PSD_HRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("/usr/g/bin/epiespHRMw.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    }
    else
    {
        if((fp=fopen("/usr/g/bin/epiesp.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    }
#else
    if(PSD_XRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return SUCCESS;}
    }
    else if(PSD_VRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("epiespW.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return SUCCESS;}
    }
    else if (PSD_HRMW_COIL == cfgcoiltype)
    {
        if((fp=fopen("epiespHRMw.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return SUCCESS;}
    }
    else
    {
        if((fp=fopen("epiesp.dat", "rt")) == NULL) {procNoEspRangeFile(fp); return SUCCESS;}
    }
#endif
    /* reading esp range on X axis */
    do
    {
        if( fgets(tempstring, MAXCHAR, fp) == NULL )
        {
            procNoEspRangeFile(fp);
            return FAILURE;
        }
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_x) != 1) {procNoEspRangeFile(fp); return FAILURE;}
    if(numesprange_x < 0 || numesprange_x > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return FAILURE;}
    for(i=0; i<numesprange_x; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d %f", &esprange_x[i][0], &esprange_x[i][1], &espamp_x[i]) != 3) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_x[i][0] <= 0 || esprange_x[i][1] <= 0) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_x[i][1] < esprange_x[i][0]) {procNoEspRangeFile(fp); return FAILURE;}
        if(espamp_x[i] < 0.0) {procNoEspRangeFile(fp); return FAILURE;}
    }

    /* reading esp range on Y axis */
    do
    {
        if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_y) != 1) {procNoEspRangeFile(fp); return FAILURE;}
    if(numesprange_y < 0 || numesprange_y > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return FAILURE;}
    for(i=0; i<numesprange_y; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d %f", &esprange_y[i][0], &esprange_y[i][1], &espamp_y[i]) != 3) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_y[i][0] <= 0 || esprange_y[i][1] <= 0) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_y[i][1] < esprange_y[i][0]) {procNoEspRangeFile(fp); return FAILURE;}
        if(espamp_y[i] < 0.0) {procNoEspRangeFile(fp); return FAILURE;}

    }

    /* reading esp range on Z axis */
    do
    {
        if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
    } while(isCommentOrBlankLine(tempstring));
    if(sscanf(tempstring, "%d", &numesprange_z) != 1) {procNoEspRangeFile(fp); return FAILURE;}
    if(numesprange_z < 0 || numesprange_z > MAXNUMESPRANGE) {procNoEspRangeFile(fp); return FAILURE;}
    for(i=0; i<numesprange_z; i++)
    {
        do
        {
            if(fgets( tempstring, MAXCHAR, fp ) == NULL) {procNoEspRangeFile(fp); return FAILURE;}
        } while(isCommentOrBlankLine(tempstring));
        if(sscanf(tempstring, "%d %d %f", &esprange_z[i][0], &esprange_z[i][1], &espamp_z[i]) != 3) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_z[i][0] <= 0 || esprange_z[i][1] <= 0) {procNoEspRangeFile(fp); return FAILURE;}
        if(esprange_z[i][1] < esprange_z[i][0]) {procNoEspRangeFile(fp); return FAILURE;}
        if(espamp_z[i] < 0.0) {procNoEspRangeFile(fp); return FAILURE;}

    }

    /* CRC Check */
    if( !disable_crc_check_for_esp)
    {
        n32 crcValue;
        n32 configCrcValue;

        do
        {
            if( fgets(tempstring, MAXCHAR, fp) == NULL )
            {
                procNoEspRangeFile(fp);
                return FAILURE;
            }
        }while( isCommentOrBlankLine(tempstring) );

        if( sscanf(tempstring, "%lu", &configCrcValue) != 1 )
        {
            procNoEspRangeFile(fp);
            return FAILURE;
        }

        crcValue = getCRCValueForAcousticLockout(numesprange_x, esprange_x, espamp_x, numesprange_y, esprange_y,
                                espamp_y, numesprange_z, esprange_z, espamp_z);

        if( crcValue != configCrcValue )
        {
            epic_error(
                1, "PSD data (acoustic) integrity violation detected in PSD. \nPlease try again or restart the system.",
                EM_PSD_PSDCRUCIAL_DATA_FAILURE,
                EE_ARGS(1), SYSLOG_ARG);
            resetVariables(fp);
            esp_crc_check_passed = 0;
            return FAILURE;
        }
        else
        {
            esp_crc_check_passed = 1;
        }
    }
    else
    {
        esp_crc_check_passed = 1;
    }

    no_esprangefile = 1;
    if( fp != NULL )
    {
        fclose(fp);
    }

    return SUCCESS;
}

void procNoEspRangeFile(FILE * fp)
{
    resetVariables(fp);
    epic_error( 0, "epiesp.dat was corrupted or not found", 0, EE_ARGS(0));

#ifdef SIM
    esp_crc_check_passed = 1;
#endif

}

void resetVariables(FILE * fp)
{
    if( fp != NULL )
    {
        fclose(fp);
    }
    numesprange_x = 0;
    numesprange_y = 0;
    numesprange_z = 0;
    no_esprangefile = 1;
}

void printEpigradoptLog(void)
{
    FILE * fp;

    total_gradopt_count++;
    each_gradopt_count++;

    char fname[255];
    sprintf(fname,"%sgradopt.log",_header_name);
    if((fp=fopen(fname,"a"))==NULL) return;

    fprintf(fp, "dbdtper and esp:\n");
    fprintf(fp, "%d %d %d %f %f %f %d\n",dbdt_model, total_gradopt_count, each_gradopt_count,
        cfdbdtper, dbdtper_new, pidbdtper, esp);
    fclose(fp);
}

void printEspRange(void)
{
    FILE * fp;
    int i;

    char fname[255];
    sprintf(fname,"%sgradopt.log",_header_name);
    if((fp=fopen(fname,"a"))==NULL) return;

    fprintf(fp, "X esp range:\n");
    for(i=0; i<numesprange_x; i++)
    {
        fprintf(fp, "%d %d %d %f\n", i+1, esprange_x[i][0], esprange_x[i][1], espamp_x[i]);
    }
    fprintf(fp, "Y esp range:\n");
    for(i=0; i<numesprange_y; i++)
    {
        fprintf(fp, "%d %d %d %f\n", i+1, esprange_y[i][0], esprange_y[i][1], espamp_y[i]);
    }
    fprintf(fp, "Z esp range:\n");
    for(i=0; i<numesprange_z; i++)
    {
        fprintf(fp, "%d %d %d %f\n", i+1, esprange_z[i][0], esprange_z[i][1], espamp_z[i]);
    }

    fprintf(fp,"a_gxw: %f, and its components - x:%f, y:%f, z:%f\n",a_gxw, a_gxw * fabs(scan_info[0].oprot[0]),
            a_gxw * fabs(scan_info[0].oprot[3]),a_gxw * fabs(scan_info[0].oprot[6]));

    fclose(fp);
}

void printCornerPoint(int nump, int * tcon, float * aconx, float * acony)
{
    FILE * fp;
    int i;

    char fname[255];
    sprintf(fname,"%sgradopt.log",_header_name);
    if((fp=fopen(fname,"a"))==NULL) return;

    fprintf(fp, "readout and phase waveform:\n");
    fprintf(fp, "%d %d %d\n",dbdt_model, total_gradopt_count+1, each_gradopt_count+1);
    fprintf(fp, "dbdtinf %f dbdtfactor %d efflength %f\n", cfrinf, cfrfact, FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz));
    fprintf(fp, "all %d\n", nump);
    for(i=0; i<nump; i++)
    {
        fprintf(fp, "%d %f %f 0.0\n", tcon[i], aconx[i], acony[i]);
    }
    fclose(fp);
}

void printDbdtper(float the_dbdtper, int nump, int * tcon, float * dbdtper_x, float * dbdtper_y, float * dbdtper_t)
{
    FILE * fp;
    int i;

    char fname[255];
    sprintf(fname,"%sgradopt.log",_header_name);
    if((fp=fopen(fname,"a"))==NULL) return;

    fprintf(fp, "convolution model dbdtper waveform:\n");
    fprintf(fp, "%d %d %d %f\n",dbdt_model, total_gradopt_count+1, each_gradopt_count+1, the_dbdtper);
    for(i=0; i<nump; i++)
    {
        fprintf(fp, "%d %f %f %f\n", tcon[i], dbdtper_x[i], dbdtper_y[i], dbdtper_t[i]);
    }
    fclose(fp);
}

void printEpigradoptResult(void)
{
    FILE * fp;
    float ta;

    char fname[255];
    sprintf(fname,"%sgradopt_result.log",_header_name);
    if((fp=fopen(fname,"a"))==NULL) return;

    if(vrgfsamp == PSD_OFF) ta = 1.0;
    else ta = ((float)pw_gxw)/(pw_gxw+(float)pw_gxwad-(pw_gyba+pw_gyb/2.0)*(pw_gyba+pw_gyb/2.0)/pw_gxwad);

    fprintf(fp, "%d %d %d %d %f %d %d %f %f %f %d %f %d %d %d %d\n", dbdt_model, rampopt,
        esprange_check, espopt, opfov, opxres, opyres, cfdbdtper, dbdtper_new,
        pidbdtper, esp, ta, min_seqgrad, tmin, tmin_total, avmaxslquant);
    fclose(fp);
}

/**************************************************************************/
/* CVEVAL                                                                 */
/**************************************************************************/
STATUS
cveval( void )
{
    double ave_sar;
    double peak_sar; /* temp sar value locations */
    double cave_sar;
    double b1rms;

    struct stat file_status[1];
    
    float scale = 1.0; /*MRIhc05854 : 1*/

    int bval_counter = 0;
    float total_bval = 0.0;
    int valid_numbvals_forsyndwi = 0;

    /*RTB0 correction*/
    int pack_ix;

    /* HCSDM00398133 HCSDM00419770 */
    {
        int rtnval;
        rtnval = setUserCVs();
        if(rtnval != SUCCESS)
        {
            return rtnval;
        }
    }

    if ( (PSD_ON == exist(opdiffuse)) && (FOCUS == exist(opexcitemode)) )
    {
        rfov_flag  = _rfov_flag.fixedflag ?  ((void)(PSD_ON), rfov_flag) : PSD_ON;
        rf_chop  = _rf_chop.fixedflag ?  ((void)(PSD_OFF), rf_chop) : PSD_OFF;
    }
    else
    {
        rfov_flag  = _rfov_flag.fixedflag ?  ((void)(PSD_OFF), rfov_flag) : PSD_OFF;
        rf_chop  = _rf_chop.fixedflag ?  ((void)(PSD_ON), rf_chop) : PSD_ON;
    }

    if ( exist(optensor) > 0 )
    {
        tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_ON), tensor_flag) : PSD_ON;

    
#ifdef PSD_HW
        /* Option key check */
        if ( checkOptionKey( SOK_TENSOR ) != KEY_PRESENT )
            tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_OFF), tensor_flag) : PSD_OFF;
#endif
    }
    else
        tensor_flag  = _tensor_flag.fixedflag ?  ((void)(PSD_OFF), tensor_flag) : PSD_OFF;

   if( (PSD_ON == focus_status) &&
        existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) &&
        (PSD_OFF == exist(opflair)) && (PSD_OFF == exist(opasset)) &&
        (opnumgroups <= 1) && (strcmp(get_psd_name(), "epi2alt")) && (mux_flag == PSD_OFF) && (muse_flag == PSD_OFF)) /*disable FOCUS for Multiband and MUSE */
    {
        /* Allow RFOV Focus DWI */
        piexcitemodenub = 1 + 4; /* 1:Selective + 4:Focus */
    }
    else
    {
        piexcitemodenub = 1;     /* Selective only */
    }


    /* Determine if HOEC is supported or not */
{ /* Start of code inlined from HoecCorr.e HoecSupportMode */

    /* Determine if HOECC feature is supported. Currently it is supported unconditionally;
       if some future program decides to not support HOECC, hoecc_support can be set to PSD_OFF */    
    /* SVBranch HCSDM00267592: Disable HOECC in SV25 platform */
    if ((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag))       
    {
        hoecc_support  = _hoecc_support.fixedflag ?  ((void)(PSD_OFF), hoecc_support) : PSD_OFF;
    }
    else
    {
        hoecc_support  = _hoecc_support.fixedflag ?  ((void)(PSD_ON), hoecc_support) : PSD_ON;
    }

} /* End of code inlined from HoecCorr.e HoecSupportMode */

/* Initialize HOEC correction configuration */
    /* Determine if RTB0 is supported or not */
{ /* Start of code inlined from RTB0.e RTB0SupportMode */

    /* Open RTB0 feature for all systems */
    rtb0_support  = _rtb0_support.fixedflag ?  ((void)(PSD_ON), rtb0_support) : PSD_ON;

} /* End of code inlined from RTB0.e RTB0SupportMode */


    /* HCSDM00155198 */
    if ((PSD_ON == tensor_flag) && (PSD_OFF == rfov_flag) &&
        (PSD_OFF == hoecc_support) && (PSD_OFF == muse_flag)) /* Make DSE selectable if HOECC is supported. */
    {
        cvoverride(opdualspinecho, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        pidualspinechonub = 0;
    }
    else if (PSD_ON == muse_flag)
    {
        cvoverride(opdualspinecho, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
        pidualspinechonub = 0;
    }
    else
    {
        pidualspinechonub = 1;
    }
    
    /***SVBranch: HCSDM00259119  eco mpg ***/
    if (FAILURE == eco_mpg_cveval())
    {
        epic_error(use_ermes, "ECO-MPG cveval Failed",
                   EM_PSD_SUPPORT_FAILURE, 1, STRING_ARG, "eco_mpg_cveval()");    
        return FAILURE;
    }        
    /*********************/    
    
    /* MRIhc56268: Dual Spin Echo */
    if( existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) &&
        existcv(opdualspinecho) && (PSD_ON == exist(opdualspinecho)) )
    {
        dualspinecho_flag  = _dualspinecho_flag.fixedflag ?  ((void)(1), dualspinecho_flag) : 1;
    }
    else
    {
        dualspinecho_flag  = _dualspinecho_flag.fixedflag ?  ((void)(0), dualspinecho_flag) : 0;
    }

    piseparatesynbnub = 0;
    cvoverride(opseparatesynb,1, PSD_FIX_ON, PSD_EXIST_ON);
    if(syndwi_status!=PSD_ON)
    {
        cvoverride(syndwi_flag, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opnumsynbvals, 0, PSD_FIX_ON, PSD_EXIST_ON);
        pinumsynbnub = 0;
    }
    else if( existcv(opdiffuse) && (PSD_ON == exist(opdiffuse)) &&
        ( (exist(opdifnumt2) > 0) || (exist(opnumbvals) > 1) ) &&
        (PSD_OFF == tensor_flag))
    {
        /* Multi b-values case (including T2 or more than 1  b-values) */
        prescribed_min_bval = _prescribed_min_bval.fixedflag ? ((void)(1000000), prescribed_min_bval) : 1000000;
        prescribed_max_bval = _prescribed_max_bval.fixedflag ? ((void)(0), prescribed_max_bval) : 0;
        valid_numbvals_forsyndwi = 0;
        for(bval_counter=0;bval_counter< exist(opnumbvals);bval_counter++){
            if(bvalstab[bval_counter] <= UPPER_SYNB_LIMIT_RESTRICT_DIFF){
                valid_numbvals_forsyndwi++;
                if (bvalstab[bval_counter] < prescribed_min_bval)
                    prescribed_min_bval = _prescribed_min_bval.fixedflag ? ((void)(bvalstab[bval_counter]), prescribed_min_bval) : bvalstab[bval_counter];
                if (bvalstab[bval_counter] > prescribed_max_bval)
                    prescribed_max_bval = _prescribed_max_bval.fixedflag ? ((void)(bvalstab[bval_counter]), prescribed_max_bval) : bvalstab[bval_counter];
            }
        }
        if(exist(opdifnumt2)>0){
            valid_numbvals_forsyndwi++;
            prescribed_min_bval = _prescribed_min_bval.fixedflag ? ((void)(0.0), prescribed_min_bval) : 0.0;
        }
        prescribed_bval_range  = _prescribed_bval_range.fixedflag ?    ((void)(prescribed_max_bval-prescribed_min_bval), prescribed_bval_range) : prescribed_max_bval-prescribed_min_bval;

        if(valid_numbvals_forsyndwi > 1 && prescribed_bval_range > 0.0)
        {
            syndwi_flag  = _syndwi_flag.fixedflag ?  ((void)(PSD_ON), syndwi_flag) : PSD_ON;
            /* Synthetic b-vals */
            pinumsynbnub = 1 + 2 + 4 + 8 + 16;
            pinumsynbval2 = 0;
            pinumsynbval3 = 1;
            pinumsynbval4 = 2;
            pinumsynbval5 = 3;
        }
        else
        {
            syndwi_flag  = _syndwi_flag.fixedflag ?  ((void)(PSD_OFF), syndwi_flag) : PSD_OFF;
            pinumsynbnub = 0;
            cvoverride(opnumsynbvals, 0, PSD_FIX_ON, PSD_EXIST_ON);
        }
    }
    else
    {
        syndwi_flag  = _syndwi_flag.fixedflag ?  ((void)(PSD_OFF), syndwi_flag) : PSD_OFF;
        pinumsynbnub = 0;
        cvoverride(opnumsynbvals, 0, PSD_FIX_ON, PSD_EXIST_ON);
    }

    avminsynbvalstab = LOWER_SYNB_LIMIT_IVIM;
    avmaxsynbvalstab = UPPER_SYNB_LIMIT_RESTRICT_DIFF;
    avminnumbvals = MIN_NUM_SYNBVALS;
    avmaxnumbvals = MAX_NUM_SYNBVALS;

    /* Initialize HOEC correction configuration */
{ /* Start of code inlined from HoecCorr.e HoecEval */

    /* Determine is HOECC feature is enabled in the current configuration */
    if ((hoecc_support == PSD_ON) && (exist(opdiffuse) == PSD_ON) && (dualspinecho_flag == PSD_OFF) && (opnumgroups <= 1) )
    {
        hoecc_enable  = _hoecc_enable.fixedflag ?  ((void)(PSD_ON), hoecc_enable) : PSD_ON;
    }
    else
    {
        hoecc_enable  = _hoecc_enable.fixedflag ?  ((void)(PSD_OFF), hoecc_enable) : PSD_OFF;
    }

    /* Show/hide HOECC checkbox according to hoecc_enable value */
    if (hoecc_enable)
    {
        pihoeccvis = 1;
        pihoeccnub = 1;
        hoecc_flag  = _hoecc_flag.fixedflag ?  ((void)(ophoecc), hoecc_flag) : ophoecc; /* hoecc_flag determines HOECC is on or off; ophoecc is input from UI */
        if (mux_flag && ophoecc){
            hoecc_flag  = _hoecc_flag.fixedflag ?  ((void)(3), hoecc_flag) : 3; /* ZZ: multiband use recon correction for all the terms*/
        }
    }
    else
    {
        pihoeccvis = 0;
        pihoeccnub = 0;
        hoecc_flag  = _hoecc_flag.fixedflag ?  ((void)(0), hoecc_flag) : 0;
    }

    /* turn on the option of SSE for the tensor case, which overrides HCSDM00155198 */
    if (hoecc_support == PSD_ON && muse_flag == PSD_OFF)
    {
        pidualspinechonub = 1;
        _opdualspinecho.fixedflag = 0;
    }

    /* read in high order eddy current alphas and taus. These coefficients are split into PSD and recon
       correction coefficients in cveval() */
    if (hoecc_flag != PSD_OFF)
    {
        int i, j, k;
        int xorder, yorder, zorder;

        for (i=0; i<HOEC_TOTAL_NUM_AXES; i++)
        {
            for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
            {
                for (k=0; k<hoec_cal_info.num_terms[i][j]; k++)
                {
                    alpha_scale[i][j][k] = 1.0;  /* Initialize alpha_scale to 1; some of them can be set to 0 in manual mode;
                                                    all of them stay as 1 for auto mode */
                }
            }
        }

        if (hoecc_flag == 2) /* Manual mode for HOEC correction */
        {
            if (ReadHoecCorrTerms() == FAILURE)
            {
#ifndef SIM
                if (hoecc_manual_mode_warning_flag == 0)
                {
                    epic_warning("Reading hoecCorrTerms.txt failed. Manual Mode ignored.");
                    hoecc_manual_mode_warning_flag  = _hoecc_manual_mode_warning_flag.fixedflag ?  ((void)(1), hoecc_manual_mode_warning_flag) : 1;
                }
#endif
                cvoverride(hoecc_flag, ophoecc, PSD_FIX_OFF, PSD_EXIST_ON);
                hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(hoecc_flag), hoecc_psd_flag) : hoecc_flag;
                hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(hoecc_flag), hoecc_recon_flag) : hoecc_flag;
            }
            else
            {
                int changeFlag = PSD_OFF;

                hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(PSD_OFF), hoecc_psd_flag) : PSD_OFF;
                hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(PSD_OFF), hoecc_recon_flag) : PSD_OFF;

                for (i=0; i<HOEC_TOTAL_NUM_AXES; i++)
                    for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                    {
                        xorder = hoec_cal_info.termIndex2xyzOrderMapping[0][j];
                        yorder = hoec_cal_info.termIndex2xyzOrderMapping[1][j];
                        zorder = hoec_cal_info.termIndex2xyzOrderMapping[2][j];

                        /* PSD correction terms should be those type-A terms, otherwise set the
                           correspoinding terms to no-correction */
                        if (ext_corr_term[i][j] == 1) /* intended for PSD correction */
                        {
                            if (xorder+yorder>1)
                            {
                                ext_corr_term[i][j] = 0;
                                changeFlag = PSD_ON;
                            }
                        }
                        if (ext_corr_term[i][j] == 1) hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(PSD_ON), hoecc_psd_flag) : PSD_ON;
                        else if (ext_corr_term[i][j] == 2) hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(PSD_ON), hoecc_recon_flag) : PSD_ON;
                    }
#ifndef SIM
                if (changeFlag == PSD_ON && hoecc_manual_mode_psd_override_flag == 0)
                {
                    epic_warning("PSD only can correct X or Y linear terms. Correction terms modified.");
                    hoecc_manual_mode_psd_override_flag  = _hoecc_manual_mode_psd_override_flag.fixedflag ?  ((void)(1), hoecc_manual_mode_psd_override_flag) : 1;
                }
#endif
                if (hoecc_psd_flag == PSD_OFF && hoecc_recon_flag == PSD_OFF)
                {
                    cvoverride(hoecc_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
                }
                else
                {
                    /* set alpha to 0 if the term is not intended to correct */
                    for (i=0; i<HOEC_TOTAL_NUM_AXES; i++)
                        for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                            for (k=0; k<hoec_cal_info.num_terms[i][j]; k++)
                            {
                                if (ext_corr_term[i][j] == 0)
                                {
                                    alpha_scale[i][j][k] = 0.0;
                                }
                            }
                }
            }
        }

        if (hoecc_flag == 1) /* correct all terms */
        {
            for (i=0; i<HOEC_TOTAL_NUM_AXES; i++)
                for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                {
                    xorder = hoec_cal_info.termIndex2xyzOrderMapping[0][j];
                    yorder = hoec_cal_info.termIndex2xyzOrderMapping[1][j];
                    zorder = hoec_cal_info.termIndex2xyzOrderMapping[2][j];

                    if (xorder+yorder < 2) /* for PSD correction */
                    {
                       ext_corr_term[i][j] = 1;
                    }
                    else /* for recon correction */
                    {
                       ext_corr_term[i][j] = 2;
                    }
                }
            hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(PSD_ON), hoecc_psd_flag) : PSD_ON;
            hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(PSD_ON), hoecc_recon_flag) : PSD_ON;
        }

        if (hoecc_flag == 3) /* correct all terms with recon*/
        {
            for (i=0; i<HOEC_TOTAL_NUM_AXES; i++)
                for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                {
                    ext_corr_term[i][j] = 2;
                }
            hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(PSD_OFF), hoecc_psd_flag) : PSD_OFF;
            hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(PSD_ON), hoecc_recon_flag) : PSD_ON;
        }
    }
    else
    {
        hoecc_psd_flag  = _hoecc_psd_flag.fixedflag ?  ((void)(PSD_OFF), hoecc_psd_flag) : PSD_OFF;
        hoecc_recon_flag  = _hoecc_recon_flag.fixedflag ?  ((void)(PSD_OFF), hoecc_recon_flag) : PSD_OFF;
    }

    /* if HOEC compensation is on, turn off linear correction */
    dwicntrl  = _dwicntrl.fixedflag ?  ((void)(0), dwicntrl) : 0;

} /* End of code inlined from HoecCorr.e HoecEval */

/* cvcheck for HOEC correction */


    {
        INT numcoils = ((cfrecvend - cfrecvst)+1);
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if ( (rtb0_support == PSD_ON) && (exist(opdiffuse) == PSD_ON) && exist(opirmode) == 0 && epi_flair == PSD_OFF 
            && (((ss_rf1 > 0) || (exist(opirprep) == PSD_ON)) || (cffield == B0_15000))
            && rfov_flag == PSD_OFF && exist(opnav) == PSD_OFF && mux_flag == PSD_OFF 
            && (opnumgroups <= 1) && numcoils > 1
            && !(strstr(attribute_codeMeaning, "Breast")) ) /*HCSDM00405553 lock out breast in clinical mode*/
        {
            rtb0_enable  = _rtb0_enable.fixedflag ?  ((void)(PSD_ON), rtb0_enable) : PSD_ON;
        }
        else
        {
            rtb0_enable  = _rtb0_enable.fixedflag ?  ((void)(PSD_OFF), rtb0_enable) : PSD_OFF;
        }	

        /* Show/hide RTB0 checkbox according to rtb0_enable value */
        if (rtb0_enable)
        {
            pirtb0vis  = _pirtb0vis.fixedflag ?  ((void)(1), pirtb0vis) : 1;
            pirtb0nub  = _pirtb0nub.fixedflag ?  ((void)(1), pirtb0nub) : 1;
            rtb0_flag  = _rtb0_flag.fixedflag ?  ((void)(oprtb0), rtb0_flag) : oprtb0; /* rtb0_flag determines RTB0 is on or off; oprtb0 is input from UI */
        }
        else
        {
            pirtb0vis  = _pirtb0vis.fixedflag ?  ((void)(1), pirtb0vis) : 1;
            pirtb0nub  = _pirtb0nub.fixedflag ?  ((void)(0), pirtb0nub) : 0;
            rtb0_flag  = _rtb0_flag.fixedflag ?  ((void)(0), rtb0_flag) : 0;
        }

    }
	

    /* HCSDM00155636: copied t1flair_flag setting from cvinit() */
    if ( !strncmp(get_psd_name(), "epi2_stircl",11) )
    {
        /* non-interleaved STIR */
        t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
        ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
    }
    else
    {
        if (irprep_flag)
        {
            if ((exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON) ||
                (navtrig_flag == PSD_ON) || (exist(opirmode) == PSD_ON) ||
                (rfov_flag == PSD_ON))
            {
                t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
                ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
            }
            else
            {
                /* T1flair STIR and Auto TI support only 3T at this time. */
                /* Need evaluation for 1.5T to make them compatible.      */
                if (B0_30000 == cffield)
                {
                    t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_ON), t1flair_flag) : PSD_ON;
                    ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
                }
                else
                {
                    /* Non 3T cases */
                    t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
                    ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
                }
            }
        }
        else
        {
            t1flair_flag  = _t1flair_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_flag) : PSD_OFF;
            ir_prep_manual_tr_mode  = _ir_prep_manual_tr_mode.fixedflag ?  ((void)(PSD_OFF), ir_prep_manual_tr_mode) : PSD_OFF;
        }
    }

    if ((t1flair_flag == PSD_ON) && (ir_prep_manual_tr_mode == PSD_ON))
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2), STRING_ARG, "T1flair mode",STRING_ARG, "Manual TR mode");
        return FAILURE;
    }

    epi_asset_override();
    epi_arc_override();

/* AssetEval inlined from Asset.e  */
{
    /* New flags, originally used in efgre3d , being expanded */
    assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;

    /* Pick up default step size computed from avmaxaccel_ph_stride
     * and avmaxaccel_sl_stride
     * */

    avmaxaccel_sl_stride = 1.0;
    avmaxaccel_ph_stride = 1.0;
    avminaccel_sl_stride = 1.0;
    avminaccel_ph_stride = 1.0;
    piaccel_sl_stride = 1.0;
    piaccel_ph_stride = 1.0;

    assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_sl_maxstride > 1.0) && 
        (ASSET_SUPPORT_SLICE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support slice ASSET */

        /* Enable slice ASSET (host no longer sets slices ASSET) */
        cvoverride(opasset, ASSET_SCAN_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_ON), assetsl_flag) : PSD_ON;
        avmaxaccel_sl_stride = cfaccel_sl_maxstride;

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride, avmaxaccel_sl_stride);
        }

        if (exist(opaccel_sl_stride) > 1.0) {
            assetsl_factor  = _assetsl_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_sl_stride))), assetsl_factor) : FMin(2,1.0,1.0/exist(opaccel_sl_stride));
        } else {
            assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        }
    }

    asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_ph_maxstride > 1.0) && 
        (ASSET_SUPPORT_PHASE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support phase ASSET */

        /* Reset to phase ASSET (host no longer sets slice ASSET ) */
        cvoverride(opasset, ASSET_SCAN_PHASE, PSD_FIX_ON, PSD_EXIST_ON);

        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_ON), assetph_flag) : PSD_ON;
        avmaxaccel_ph_stride = cfaccel_ph_maxstride;

        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 and the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride, avmaxaccel_ph_stride);
        }

        if (exist(opaccel_ph_stride) > 1.0) {
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_ph_stride))), asset_factor) : FMin(2,1.0,1.0/exist(opaccel_ph_stride));
        } else {
            asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        }
    }

    /* Set asset_factor */
    /* MRIge92386 */
    if( existcv(opasset) &&  exist(opassetscan) == PSD_ON )
    {
        float temp_maxaccel_ph;
        float temp_maxaccel_sl;
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);
        int cardiac_scan = (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                            && (!strcmp(attribute_codeMeaning, "Heart") || !strcmp(attribute_codeMeaning, "Aorta")
                                || !strcmp(attribute_codeMeaning, "Aortic arch")));

        piaccelscrn = PSD_ON;

        /* Set up the PI pulldown */
        if(PSD_ON == cardiac_scan)  /* pulldown to show up to factor of 3 for cardiac scans */
        {
            temp_maxaccel_ph = FMin(2, 3.0, avmaxaccel_ph_stride);
            temp_maxaccel_sl = FMin(2, 3.0, avmaxaccel_sl_stride);
        }
        else
        {
            temp_maxaccel_ph = avmaxaccel_ph_stride;
            temp_maxaccel_sl = avmaxaccel_sl_stride;
        }

        setAccelPulldown (temp_maxaccel_ph, temp_maxaccel_sl, 
                          &piaccel_phval2, &piaccel_phval3,
                          &piaccel_phval4, &piaccel_phval5,
                          &piaccel_phval6, &piaccel_phnub,
                          &piaccel_phedit, &piaccel_slval2,
                          &piaccel_slval3, &piaccel_slval4,
                          &piaccel_slval5, &piaccel_slval6,
                          &piaccel_slnub, &piaccel_sledit,
                          &piaccel_ph_step, &piaccel_sl_step);

    } 
    else
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
        if(PSD_OFF == exist(oparc))
        {
            piaccel_slnub = 0.0;
            piaccel_phnub = 0.0;
            piaccelscrn = PSD_OFF;
        }        
    }
} 

/* AssetEval inlined from Asset.e  */
/* Set default phase acceleration value for MUSE */
{
	int i;

	if ( muse_flag == PSD_ON)
	{
		if ( existcv(opaccel_ph_stride) )
		{
			 /* If user specified value, display it */
			 piaccel_ph_stride = opaccel_ph_stride;
		}
		else
		{
			/* Otherwise default to 1.0 */   
			piaccel_ph_stride = 1.0; 
		}

		max_nshots  = _max_nshots.fixedflag ?      ((void)((exist(opresearch)==PSD_ON)?MUSE_MAX_NSHOTS:(int)(ceil(avmaxaccel_ph_stride))), max_nshots) : (exist(opresearch)==PSD_ON)?MUSE_MAX_NSHOTS:(int)(ceil(avmaxaccel_ph_stride));

		cvmax(opnshots, max_nshots);

		pishotnub = 1;
		for (i = 1; i < max_nshots; i++)
		{
			pishotnub += 1<<i;
		}

		if ( pishotnub >=63 )
			pishotnub = 63; /* maximum is 6 values */

		pishotval2 = 2;
		pishotval3 = 3;
		pishotval4 = 4;
		pishotval5 = 5;
		pishotval6 = max_nshots;

	}
}
    if(mux_flag)
    {
/* ARCEval inlined from ARC.e */
/* arc_sl_fn need to be set before the following code */

{
    int round_factor = 2.0;
    arc_ph_fullencode  = _arc_ph_fullencode.fixedflag ?           ((void)((int)(ceil(exist(opyres)*nop*exist(opphasefov)/round_factor)*round_factor)), arc_ph_fullencode) : (int)(ceil(exist(opyres)*nop*exist(opphasefov)/round_factor)*round_factor);

    if (arc_ph_fullencode < _arc_ph_fullencode.minval)
    {
        epic_error(use_ermes,"Increase Phase FOV or YRes for the current prescription.",
                   EM_PSD_ARCPHFULL_OUT_OF_RANGE,EE_ARGS(0));
        return FAILURE;
    }

    if (arc_ph_fullencode > YRES_MAX)
    {
        avmaxyres = IMin(2, avmaxyres, (int)floorf(YRES_MAX/ exist(opphasefov)/ nop/ round_factor) * round_factor);

        epic_error(use_ermes,"this YRES cannot be achieved with current prescription",
                   EM_PSD_YRES_OUT_OF_RANGE,1,INT_ARG,avmaxyres);
        return ADVISORY_FAILURE;
    }

    arc_ph_spanned  = _arc_ph_spanned.fixedflag ?      ((void)(arc_ph_fullencode*fn+rhhnover), arc_ph_spanned) : arc_ph_fullencode*fn+rhhnover;

    if (PSD_3D == exist(opimode))
    {
        arc_sl_fullencode  = _arc_sl_fullencode.fixedflag ?  ((void)(exist(opslquant)), arc_sl_fullencode) : exist(opslquant);
        arc_sl_spanned  = _arc_sl_spanned.fixedflag ?    ((void)((int)floor(arc_sl_fullencode*arc_sl_fn)), arc_sl_spanned) : (int)floor(arc_sl_fullencode*arc_sl_fn);
    }
}
if ((PSD_3D != exist(opimode)) && arc_flag) 
{
    arc_split_method  = _arc_split_method.fixedflag ?  ((void)(ARC_PHASE), arc_split_method) : ARC_PHASE;
}

if ((PSD_OFF == exist(opassetscan)) && arc_flag && ( 0 < arc_split_method))
{
    float temp_maxaccel_ph;
    float temp_maxaccel_sl;
    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);
    int cardiac_scan = (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                        && (!strcmp(attribute_codeMeaning, "Heart") || !strcmp(attribute_codeMeaning, "Aorta")
                            || !strcmp(attribute_codeMeaning, "Aortic arch")));

    /* User controlled  acceleration */ 
    init_arc_variables();

    /* For coil acceleration factors, max coil limits need to be bumped
     * up/overridden. This removes the need for user CVs for indicating max
     * acceleration factors. 
     * MRIhc46119 - PIUI
     * */
    if (arc_research_flag)
    {
        if (ARC_PHASE == arc_split_method)
        {
            avmaxaccel_ph_stride = MAX_ACCEL;
            arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(avmaxaccel_ph_stride), arc_ph_maxstride) : avmaxaccel_ph_stride;
        }
        if ( ARC_SLICE == arc_split_method )
        {
            avmaxaccel_sl_stride = MAX_ACCEL;
            arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(avmaxaccel_sl_stride), arc_sl_maxstride) : avmaxaccel_sl_stride;
        }
        if (ARC_PHASE_THEN_SLICE == arc_split_method  || ARC_SLICE_THEN_PHASE ==  arc_split_method) 
        {
            avmaxaccel_ph_stride = MAX_ACCEL;
            arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(avmaxaccel_ph_stride), arc_ph_maxstride) : avmaxaccel_ph_stride;
            avmaxaccel_sl_stride = MAX_ACCEL;
            arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(avmaxaccel_sl_stride), arc_sl_maxstride) : avmaxaccel_sl_stride;
        }

        /* Made the step sizes to ZERO in epic.h so that its computed on the fly,
         * if not set to ZERO, the stepsize would be used. This is
         * especially for EPI scans where we need to only allow 2 or 1
         * accel factors, stepsize == 1
         */

    } /* arc_research_flag*/
    /* For Integer acceleration , they are set in the top in the init*/
    if(PSD_ON == cardiac_scan)  /* pulldown to show max factor up to 3 for cardiac scans */
    {
        temp_maxaccel_ph = FMin(2, 3.0, avmaxaccel_ph_stride);
        temp_maxaccel_sl = FMin(2, 3.0, avmaxaccel_sl_stride);
    }
    else
    {
        temp_maxaccel_ph = avmaxaccel_ph_stride;
        temp_maxaccel_sl = avmaxaccel_sl_stride;
    }

    /* Set up the PI pulldown */
    setAccelPulldown(temp_maxaccel_ph, temp_maxaccel_sl,
                      &piaccel_phval2, &piaccel_phval3,
                      &piaccel_phval4, &piaccel_phval5,
                      &piaccel_phval6, &piaccel_phnub,
                      &piaccel_phedit, &piaccel_slval2,
                      &piaccel_slval3, &piaccel_slval4,
                      &piaccel_slval5, &piaccel_slval6,
                      &piaccel_slnub, &piaccel_sledit,
                      &piaccel_ph_step, &piaccel_sl_step );

    /* Initialize the integer acceleration factors and strides */
        if (arc_ph_intaccel) 
        {
            arc_ph_stride  = _arc_ph_stride.fixedflag ?    ((void)((int)ceil(exist(opaccel_ph_stride))), arc_ph_stride) : (int)ceil(exist(opaccel_ph_stride));
            arc_ph_userstride  = _arc_ph_userstride.fixedflag ?  ((void)(exist(opaccel_ph_stride)), arc_ph_userstride) : exist(opaccel_ph_stride);
        } 
        else 
        {
            arc_ph_stride  = _arc_ph_stride.fixedflag ?  ((void)(exist(opaccel_ph_stride)), arc_ph_stride) : exist(opaccel_ph_stride);
        }

        if (arc_sl_intaccel) 
        {
            arc_sl_stride  = _arc_sl_stride.fixedflag ?    ((void)((int)ceil(exist(opaccel_sl_stride))), arc_sl_stride) : (int)ceil(exist(opaccel_sl_stride));
            arc_sl_userstride  = _arc_sl_userstride.fixedflag ?  ((void)(exist(opaccel_sl_stride)), arc_sl_userstride) : exist(opaccel_sl_stride);
        } 
        else 
        {
            arc_sl_stride  = _arc_sl_stride.fixedflag ?  ((void)(exist(opaccel_sl_stride)), arc_sl_stride) : exist(opaccel_sl_stride);
        }

    /* Compute arc_ph_factor from the net acceleration MRIhc46119 & MRIhc46954 - PIUI*/
    if ( exist(opaccel_ph_stride) > 1.0)
    {
        if ( arc_extCal )
        {
            cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
            override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;

            if (arc_ph_intaccel)
            {
                arc_ph_factor  = _arc_ph_factor.fixedflag ?   ((void)((float)(1.0/arc_ph_stride)), arc_ph_factor) : (float)(1.0/arc_ph_stride);
            }
            else
            {
                arc_ph_factor  = _arc_ph_factor.fixedflag ?   ((void)((float)(1.0/arc_ph_userstride)), arc_ph_factor) : (float)(1.0/arc_ph_userstride);
            }
        }
        else
        {
            /* set opcalrequired value in loadrheader.e */
            override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_OFF), override_opcalrequired) : PSD_OFF;
            arc_ph_factor  = _arc_ph_factor.fixedflag ?      ((void)((float)((float)((arc_ph_fullencode/arc_ph_userstride))+arc_ph_acs_min)/arc_ph_fullencode), arc_ph_factor) : (float)((float)((arc_ph_fullencode/arc_ph_userstride))+arc_ph_acs_min)/arc_ph_fullencode;
            arc_ph_factor  = _arc_ph_factor.fixedflag ?    ((void)(FMin(2,1.0,arc_ph_factor)), arc_ph_factor) : FMin(2,1.0,arc_ph_factor);
        }
    }
    else 
    {
        arc_ph_factor  = _arc_ph_factor.fixedflag ?  ((void)(1.0), arc_ph_factor) : 1.0;
    }


    if((ARC_SLICE == arc_split_method  || ARC_PHASE_THEN_SLICE == arc_split_method || 
        ARC_SLICE_THEN_PHASE == arc_split_method) && exist(opaccel_sl_stride) > 1.0) 
    {
        arc_sl_factor  = _arc_sl_factor.fixedflag ?      ((void)((float)((float)((arc_sl_fullencode/arc_sl_userstride))+arc_sl_acs_min)/arc_sl_fullencode), arc_sl_factor) : (float)((float)((arc_sl_fullencode/arc_sl_userstride))+arc_sl_acs_min)/arc_sl_fullencode;
    }
    arc_ph_flag  = _arc_ph_flag.fixedflag ?    ((void)((arc_ph_factor<1.0)), arc_ph_flag) : (arc_ph_factor<1.0);
    arc_sl_flag  = _arc_sl_flag.fixedflag ?    ((void)((arc_sl_factor<1.0)), arc_sl_flag) : (arc_sl_factor<1.0);
    if (arc_ph_flag || arc_sl_flag)
    {
        /* Enable ARC Recon: needed earlier for recon lag model */
        rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC;
    }

}
else
{
    arc_ph_flag  = _arc_ph_flag.fixedflag ?  ((void)(PSD_OFF), arc_ph_flag) : PSD_OFF;
    arc_ph_factor  = _arc_ph_factor.fixedflag ?  ((void)(1.0), arc_ph_factor) : 1.0;
    arc_ph_stride  = _arc_ph_stride.fixedflag ?  ((void)(1), arc_ph_stride) : 1;
    arc_sl_flag  = _arc_sl_flag.fixedflag ?  ((void)(PSD_OFF), arc_sl_flag) : PSD_OFF;
    arc_sl_factor  = _arc_sl_factor.fixedflag ?  ((void)(1.0), arc_sl_factor) : 1.0;
    arc_sl_stride  = _arc_sl_stride.fixedflag ?  ((void)(1), arc_sl_stride) : 1;
    rhasset  = _rhasset.fixedflag ?  ((void)(exist(opasset)), rhasset) : exist(opasset);
    reset_accel_variables();
    
}

/* Compute cal widths, acs lines, walk through the kspace, count and
 * keep track of acquired and spanned lines.
 * */
if (arc_ph_flag)
{
    int index, view, tempIndex;
    int viewOnFlag[YRES_MAX+1];

    arc_ph_acs  = _arc_ph_acs.fixedflag ?     
         ((void)((int)floor(arc_ph_fullencode*arc_ph_factor)-(int)floor((float)arc_ph_fullencode/(float)arc_ph_stride)), arc_ph_acs) : (int)floor(arc_ph_fullencode*arc_ph_factor)-(int)floor((float)arc_ph_fullencode/(float)arc_ph_stride);
    if (arc_ph_acs < arc_ph_acs_min)
    {
        arc_ph_acs  = _arc_ph_acs.fixedflag ?  ((void)(arc_ph_acs_min), arc_ph_acs) : arc_ph_acs_min;
    }

    for (index=0; index <= YRES_MAX; index++)
    {
        arcPhIndex[index] = 0;
        viewOnFlag[index] = 0;
    }

    /* Calculate view remapping table */

    /* Calculate views in second 1/2 of k-space */
    tempIndex = (int)(arc_ph_acs/2);
    for (view = arc_ph_fullencode/2+1; view <= arc_ph_fullencode; view++) 
    {
        if (1 == view % arc_ph_stride)
        {
            viewOnFlag[view] = 1;
        }
        else if (tempIndex > 0)
        {
            viewOnFlag[view] = 1;
            tempIndex--;
        }

        if (PSD_ON == exist(opssfse))
        {
            /* Half NEX support for SSFSE */
            if ( 1 == viewOnFlag[view] )
            {
                arc_ph_hnover  = _arc_ph_hnover.fixedflag ?    ((void)(arc_ph_hnover-1), arc_ph_hnover) : arc_ph_hnover-1;
            }
            if (0 == arc_ph_hnover)
            {
                arc_ph_spanned  = _arc_ph_spanned.fixedflag ?  ((void)(view), arc_ph_spanned) : view;
                arc_ph_spanned  = _arc_ph_spanned.fixedflag ?  ((void)(arc_ph_spanned%2), arc_ph_spanned) : arc_ph_spanned+arc_ph_spanned%2;  /* Require arc_ph_spanned to be even.  This is necessary because
                                                        /vobs/vre/recon/rcapps/rc_filter.cpp requires that rhdayres is odd.
                                                        This condition is met when arc_ph_spanned is even.

                                                        Add instead of subtract from arc_ph_spanned so that arc_ph_spanned
                                                        is always larger than or equal to the wanted kspace size.
                                                      */
                break;
            }
        }
        else
        {
            if (view >= arc_ph_spanned)
            {
                break;
            }
        }
    }

    /* Calculate view in first 1/2 of k-space */
    tempIndex = arc_ph_acs - (int)(arc_ph_acs/2) + tempIndex;
    for (view = arc_ph_fullencode/2; view > 0; view--)
    {
        if (1 == view%arc_ph_stride)
        {
            viewOnFlag[view] = 1;
        }
        else if (tempIndex > 0)
        {
            viewOnFlag[view]=1;
            tempIndex--;    
        }
    }

    /* Use viewOnFlag to fill view remapping table */
    index = 0;
    arc_ph_halfnex  = _arc_ph_halfnex.fixedflag ?  ((void)(0), arc_ph_halfnex) : 0;
    arc_ph_hnover  = _arc_ph_hnover.fixedflag ?  ((void)(0), arc_ph_hnover) : 0;
    arc_ph_acquired  = _arc_ph_acquired.fixedflag ?  ((void)(0), arc_ph_acquired) : 0;
    for (view = 1; view <= arc_ph_spanned; view++)
    {
        if (1 == viewOnFlag[view])
        {
            /* arcIndex is 1 based, view is 1 based */
            index++;
            arcPhIndex[index] = view;
            if ( view <= arc_ph_fullencode * PSD_HALF_NEX ) 
            {
                arc_ph_halfnex  = _arc_ph_halfnex.fixedflag ?    ((void)(arc_ph_halfnex+1), arc_ph_halfnex) : arc_ph_halfnex+1;
            }
            else if ( view > arc_ph_fullencode * PSD_HALF_NEX )
            {
                arc_ph_hnover  = _arc_ph_hnover.fixedflag ?    ((void)(arc_ph_hnover+1), arc_ph_hnover) : arc_ph_hnover+1;
            } 
            arc_ph_acquired  = _arc_ph_acquired.fixedflag ?    ((void)(arc_ph_acquired+1), arc_ph_acquired) : arc_ph_acquired+1;  
        }
    }
}
else
{
    /* Initialize view remapping table to handle 3D acquisitions with
       slice only acceleration */
    int view;
    for (view = 0; view <= arc_ph_fullencode; view++)
    {
        arcPhIndex[view] = view;
    }
    arc_ph_acquired  = _arc_ph_acquired.fixedflag ?  ((void)(arc_ph_spanned), arc_ph_acquired) : arc_ph_spanned;
}

if (PSD_3D == exist(opimode))
{  
    if ( arc_sl_flag )
    {
        int index, slice, tempIndex;  
        int sliceOnFlag[MAXSLQUANT3D+1];

        arc_sl_acs  = _arc_sl_acs.fixedflag ?     
             ((void)((int)floor(arc_sl_fullencode*arc_sl_factor)-(int)floor((float)arc_sl_fullencode/arc_sl_stride)), arc_sl_acs) : (int)floor(arc_sl_fullencode*arc_sl_factor)-(int)floor((float)arc_sl_fullencode/arc_sl_stride);
        if (arc_sl_acs < arc_sl_acs_min)
        {
            arc_sl_acs  = _arc_sl_acs.fixedflag ?  ((void)(arc_sl_acs_min), arc_sl_acs) : arc_sl_acs_min;
        }

        for (index=0; index <= MAXSLQUANT3D; index++)
        {
            arcSlIndex[index] = 0;
            sliceOnFlag[index] = 0;
        }

        /* Calculate slice encodes in second 1/2 of k-space */
        tempIndex = (int)(arc_sl_acs/2);
        for (slice = arc_sl_fullencode/2; slice < arc_sl_spanned; slice++) 
        {
            if (0 == slice % arc_sl_stride)
            {
                sliceOnFlag[slice] = 1;
            }
            else if (tempIndex > 0)
            {
                sliceOnFlag[slice] = 1;
                tempIndex--;    
            }
        }

        /* Calculate slice encodes in second 1/2 of k-space */
        tempIndex = arc_sl_acs - (int)(arc_sl_acs/2) + tempIndex;
        for (slice = arc_sl_fullencode/2-1; slice >= 0; slice--) 
        {
            if (0 == slice % arc_sl_stride)
            {
                sliceOnFlag[slice] = 1;
            }
            else if (tempIndex > 0)
            {
                sliceOnFlag[slice] = 1;
                tempIndex--;    
            }
        }

        /* Use sliceOnFlag to fill slice encode remapping table */
        index = 0;
        arc_sl_halfnex  = _arc_sl_halfnex.fixedflag ?  ((void)(0), arc_sl_halfnex) : 0;
        arc_sl_hnover  = _arc_sl_hnover.fixedflag ?  ((void)(0), arc_sl_hnover) : 0;
        arc_sl_acquired  = _arc_sl_acquired.fixedflag ?  ((void)(0), arc_sl_acquired) : 0;
        for (slice = 0; slice < arc_sl_spanned; slice++)
        {
            if (1 == sliceOnFlag[slice])
            {
                /* arcSlIndex is 0 based, slice is 0 based */
                arcSlIndex[index] = slice;
                index++;
                if ( slice < arc_sl_fullencode * PSD_HALF_NEX )
                {
                    arc_sl_halfnex  = _arc_sl_halfnex.fixedflag ?    ((void)(arc_sl_halfnex+1), arc_sl_halfnex) : arc_sl_halfnex+1;
                }
                else if ( slice >= arc_sl_fullencode * PSD_HALF_NEX )
                {
                    arc_sl_hnover  = _arc_sl_hnover.fixedflag ?    ((void)(arc_sl_hnover+1), arc_sl_hnover) : arc_sl_hnover+1;
                }
                arc_sl_acquired  = _arc_sl_acquired.fixedflag ?    ((void)(arc_sl_acquired+1), arc_sl_acquired) : arc_sl_acquired+1;
            }
        }

    }
    else
    {
        /* Initialize slice remapping table to handle 3D acquisitions
           with phase only acceleration */
        int slice;
        for (slice = 0; slice < arc_sl_fullencode; slice++)
        {
            arcSlIndex[slice] = slice; 
        }
        arc_sl_acquired  = _arc_sl_acquired.fixedflag ?  ((void)(arc_sl_spanned), arc_sl_acquired) : arc_sl_spanned;
    }
}

/* Set Acceleration Page UI Values : RFB 03-Oct-06 */
if ((PSD_OFF == exist(opassetscan)) && arc_flag && (arc_split_method > 0))
{
    cvoverride(oparc, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
    piaccelscrn    = PSD_ON;

    if (PSD_3D == exist(opimode) || PSD_CINE == exist(opimode) ) /* CINE is set by 3dphcon amongst other 2D PSDs */
    {
        arc_syn_pts  = _arc_syn_pts.fixedflag ?        ((void)(arc_ph_spanned*arc_sl_spanned-arc_ph_acquired*arc_sl_acquired), arc_syn_pts) : arc_ph_spanned*arc_sl_spanned-arc_ph_acquired*arc_sl_acquired;
        arc_ph_calwidth  = _arc_ph_calwidth.fixedflag ?       
                     ((void)((arc_ph_stride>1)?(arc_ph_acs+arc_ph_acs/(arc_ph_stride-1)+1):arc_ph_spanned), arc_ph_calwidth) : (arc_ph_stride>1)?(arc_ph_acs+arc_ph_acs/(arc_ph_stride-1)+1):arc_ph_spanned;
        arc_sl_calwidth  = _arc_sl_calwidth.fixedflag ?       
                     ((void)((arc_sl_stride>1)?(arc_sl_acs+arc_sl_acs/(arc_sl_stride-1)+1):arc_sl_spanned), arc_sl_calwidth) : (arc_sl_stride>1)?(arc_sl_acs+arc_sl_acs/(arc_sl_stride-1)+1):arc_sl_spanned;
    }
    else
    {
        arc_syn_pts  = _arc_syn_pts.fixedflag ?    ((void)(arc_ph_spanned-arc_ph_acquired), arc_syn_pts) : arc_ph_spanned-arc_ph_acquired;
        arc_ph_calwidth  = _arc_ph_calwidth.fixedflag ?       
                     ((void)((arc_ph_stride>1)?(arc_ph_acs+arc_ph_acs/(arc_ph_stride-1)+1):arc_ph_spanned), arc_ph_calwidth) : (arc_ph_stride>1)?(arc_ph_acs+arc_ph_acs/(arc_ph_stride-1)+1):arc_ph_spanned;
    }
}
else
{
    reset_accel_variables ();
}


/* ARCEval inlined from ARC.e */
    }
    epi_asset_set_dropdown();
    epi_arc_set_dropdown();

    /* DTI */
    /* granty edit for diffusion timings ide_max_bval and sde_max_bval is updated in predownload for specific waveform */

    /*if(exist(opdiffuse) == PSD_ON | exist(optensor) == PSD_ON)
    {
	if(floatsAlmostEqualEpsilons(120, opuser12, 2)){
		res_gd1 = 12914;
		res_gd2 = 11300;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 32513;
	}else if(floatsAlmostEqualEpsilons(110, opuser12, 2)){
		res_gd1 = 11714;
		res_gd2 = 10250;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 24729;
	}else if(floatsAlmostEqualEpsilons(100, opuser12, 2)){
		res_gd1 = 10514;
		res_gd2 = 8762;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 2054.3; 
		sde_max_bval = 16798;
	}else if(floatsAlmostEqualEpsilons(90, opuser12, 2)){
		res_gd1 = 9314;
		res_gd2 = 7568;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 11467;
		opuser12 = 80;
	}else if(floatsAlmostEqualEpsilons(80, opuser12, 2)){
		res_gd1 = 8114;
		res_gd2 = 6424;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 7474.9;
	}else if(floatsAlmostEqualEpsilons(70, opuser12, 2)){
		res_gd1 = 6770;
		res_gd2 = 5042;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 4064.2;
	}else{ *//* opuser12 = 60 */
		/*opuser12 = 60;
		res_gd1 = 5594;
		res_gd2 = 3810;
		pw_gd1 = res_gd1*4;
		pw_gd2 = res_gd2*4;
		ide_max_bval = 1787.4;
		sde_max_bval = 2039.8;
	}
    }*/
    if(floatsAlmostEqualEpsilons(0, exist(opuser12), 2)) opuser12  = _opuser12.fixedflag ?  ((void)(60), opuser12) : 60;
    read_grad_res(opuser12, _res_gd1.fixedflag ? (_temp451_res_gd1=res_gd1,&_temp451_res_gd1) : &res_gd1, _res_gd2.fixedflag ? (_temp452_res_gd2=res_gd2,&_temp452_res_gd2) : &res_gd2);
    pw_gd1  = _pw_gd1.fixedflag ?  ((void)(res_gd1*4), pw_gd1) : res_gd1*4;
    pw_gd2  = _pw_gd2.fixedflag ?  ((void)(res_gd2*4), pw_gd2) : res_gd2*4;

    if ( (exist(opdiffuse) == PSD_ON) && (tensor_flag == PSD_OFF) )
    {
        /* Load Diffusion Vector Matrix */
        loadDiffVecMatrix();
    }

    /* HCSDM00365336 */
    if (PSD_ON == exist(opdiffuse))
    {
        num_autotr_cveval_iter  = _num_autotr_cveval_iter.fixedflag ?  ((void)(2), num_autotr_cveval_iter) : 2;
    }
    else
    {
        num_autotr_cveval_iter  = _num_autotr_cveval_iter.fixedflag ?  ((void)(1), num_autotr_cveval_iter) : 1;
    }

    /* Obl 3in1 opt */
    if( ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF) ||
         ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON))) &&
        (exist(opplane) == PSD_OBL) && (exist(opcoax) != PSD_OFF) )
    {
        /*Turn off obl_3in1_opt on Rio due to spherical gradient model enforced*/
        if (isRioSystem())
            obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_OFF), obl_3in1_opt) : PSD_OFF;
        else
            obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_ON), obl_3in1_opt) : PSD_ON;
    }
    else
    {
        obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_OFF), obl_3in1_opt) : PSD_OFF;
    }

    if (PSD_XRMW_COIL == cfgcoiltype)
    {
        config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP321SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP321SR120;
        inittargets(&loggrd, &phygrd); 
        inittargets(&epiloggrd, &epiphygrd); 

        /* Obl 3in1 opt */
        if (obl_3in1_opt)
        {
            inittargets(&orthloggrd, &orthphygrd);
        }

        epiphygrd.xrt = cfrmp2xfs; 
        epiphygrd.yrt = cfrmp2yfs; 
        epiphygrd.zrt = cfrmp2zfs; 
        epiphygrd.xft = cffall2x0; 
        epiphygrd.yft = cffall2y0; 
        epiphygrd.zft = cffall2z0; 
        epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt = IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs); 
        epiloggrd.xft = epiloggrd.yft = epiloggrd.zft = IMax(3,cffall2x0,cffall2y0,cffall2z0); 
    }
    
    /* GEHmr01833, GEHmr02647 */
    if( (isSVSystem()) && (epi_flair == PSD_OFF) )
    {
        if( exist(opbval) < 300 )
        {
            cfxfd_power_limit = XFD_POWER_LIMIT_DWI_BASE;
        }
        else if( exist(opbval) < 900 )
        {
            cfxfd_power_limit = XFD_POWER_LIMIT_DWI_BASE + 0.5;
        }
        else
        {
            cfxfd_power_limit = XFD_POWER_LIMIT_DWI_BASE + 0.8;
        }

        if( PSD_ON == dualspinecho_flag )
        {
            cfxfd_power_limit += 0.5;
        }

        if( cfxfd_power_limit > XFD_POWER_LIMIT )
        {
            cfxfd_power_limit = XFD_POWER_LIMIT;
        }

        /* increase the reserved margin to avoid Under-Voltage for SV systems  -HCSDM00379157 HCSDM00394803*/
        if ((PSD_ON == opdiffuse) && (PSD_ON == tensor_flag) && (PSD_ON == dualspinecho_flag) && (PSD_ON == eco_mpg_flag))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dti_dse_ecoon_scaling_factor;
        }
        else if ((PSD_ON == opdiffuse) && (PSD_ON == tensor_flag) && (PSD_OFF == dualspinecho_flag) && (PSD_ON == eco_mpg_flag))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dti_sse_ecoon_scaling_factor;
        }
        else if ((PSD_ON == opdiffuse) && (PSD_ON == tensor_flag) && (PSD_OFF == dualspinecho_flag) && (PSD_OFF == eco_mpg_flag))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dti_sse_ecooff_scaling_factor;
        }
        else if ((PSD_ON == opdiffuse) && (PSD_ON == dualspinecho_flag) && (PSD_ON == eco_mpg_flag) && (opdfax3in1 > PSD_OFF ))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dwi_3in1_dse_ecoon_scaling_factor;
        }
        else if ((PSD_ON == opdiffuse) && ((opdfaxx > PSD_OFF) || (opdfaxy > PSD_OFF) || (opdfaxz > PSD_OFF)
                || (opdfaxall > PSD_OFF )) && (PSD_ON == dualspinecho_flag) && (PSD_ON == eco_mpg_flag))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dwi_single_all_dse_ecoon_scaling_factor;
        }
        else if ((PSD_ON == opdiffuse) && ((opdfaxx > PSD_OFF) || (opdfaxy > PSD_OFF) || (opdfaxz > PSD_OFF)
                || (opdfaxall > PSD_OFF )) && (PSD_OFF == dualspinecho_flag) && (PSD_ON == eco_mpg_flag))
        {
           cfxfd_power_limit = cfxfd_power_limit/ dwi_single_all_sse_ecoon_scaling_factor;
        }
    }
    else
    {
        cfxfd_power_limit = XFD_POWER_LIMIT;
    }

    /* SVBranch: HCSDM00102521 */
    if( isSVSystem() )
    {
        /* xfd_power/temp_limit has fix flag, but cfxfd_power/temp_limit has no.
           below code can let cfxfd_power/temp_limit has pseudo fix flag.
           cfxfd_power/temp_limit can be updated by modifying xfd_power/temp_limit*/
        xfd_power_limit  = _xfd_power_limit.fixedflag ?  ((void)(cfxfd_power_limit), xfd_power_limit) : cfxfd_power_limit;
        xfd_temp_limit   = _xfd_temp_limit.fixedflag ?  ((void)(cfxfd_temp_limit), xfd_temp_limit) : cfxfd_temp_limit;
        cfxfd_power_limit = xfd_power_limit;
        cfxfd_temp_limit  = xfd_temp_limit;
    }

    /* Silent Mode  05/19/2005 YI */
    /* Get gradient spec for silent mode */
    getSilentSpec(exist(opsilent), _grad_spec_ctrl.fixedflag ? (_temp453_grad_spec_ctrl=grad_spec_ctrl,&_temp453_grad_spec_ctrl) : &grad_spec_ctrl, _glimit.fixedflag ? (_temp454_glimit=glimit,&_temp454_glimit) : &glimit, _srate.fixedflag ? (_temp455_srate=srate,&_temp455_srate) : &srate);

    /* GEHmr01834, GEHmr02647 */
    if( (isSVSystem()) && (exist(opdiffuse) == PSD_ON) &&
        (!mpg_opt_flag)) /* for mpg opt, use max grad */
                         /***SVBranch: HCSDM00259119  eco mpg ***/
    {
        grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(GMAX_CHANGE), grad_spec_ctrl) : grad_spec_ctrl|GMAX_CHANGE;

        if( exist(optensor) > 0 )
        {
            glimit  = _glimit.fixedflag ?  ((void)(XFD_GMAX_DTI), glimit) : XFD_GMAX_DTI;
        }
        else
        {
            glimit  = _glimit.fixedflag ?  ((void)(XFD_GMAX_DWI), glimit) : XFD_GMAX_DWI;
        }
    }
    else
    {
        grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(~GMAX_CHANGE), grad_spec_ctrl) : grad_spec_ctrl&~GMAX_CHANGE;
        
        /***SVBranch: HCSDM00259119  eco mpg ***/
        /* start diff grad in mpg opt */
        if (mpg_opt_flag)
        {
            if( exist(optensor) > 0 )
            {
                mpg_opt_glimit_orig  = _mpg_opt_glimit_orig.fixedflag ?  ((void)(XFD_GMAX_DTI), mpg_opt_glimit_orig) : XFD_GMAX_DTI;
            }
            else
            {
                mpg_opt_glimit_orig  = _mpg_opt_glimit_orig.fixedflag ?  ((void)(XFD_GMAX_DWI), mpg_opt_glimit_orig) : XFD_GMAX_DWI;
            }         
        }
    }

    /* MRIhc56520: for EPI with ART on 750w. */
    if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_XRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(XRMW_3T_EPI_ART_SR), srate) : XRMW_3T_EPI_ART_SR;
    }
    else if (exist(opsilent) && (cffield == B0_30000) && (cfgcoiltype == PSD_VRMW_COIL))
    {
        srate  = _srate.fixedflag ?  ((void)(VRMW_3T_EPI_ART_SR), srate) : VRMW_3T_EPI_ART_SR;
    }

    if( PSD_OFF == exist(opsilent) )
    {
        if( (mkgspec_x_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_y_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_z_sr_flag & MK_SPEC_SR_CHANGE) )
        {
            grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(SRATE_CHANGE), grad_spec_ctrl) : grad_spec_ctrl|SRATE_CHANGE;
            srate  = _srate.fixedflag ?  ((void)(save_srate), srate) : save_srate;
        }
        if( mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
        {
            grad_spec_ctrl  = _grad_spec_ctrl.fixedflag ?  ((void)(GMAX_CHANGE), grad_spec_ctrl) : grad_spec_ctrl|GMAX_CHANGE;
            glimit  = _glimit.fixedflag ?  ((void)(save_gmax), glimit) : save_gmax;
        }
    }


    /* Update configurable variables */
    if(set_grad_spec(grad_spec_ctrl,glimit,srate,PSD_ON,debug_grad_spec) == FAILURE)
    {
      epic_error(use_ermes,"Support routine set_grad_spec failed",
        EM_PSD_SUPPORT_FAILURE,1, STRING_ARG,"set_grad_spec");
        return FAILURE;
    }
    
    /* Skip setupConfig() if grad_spec_ctrl is turned on */
    if(grad_spec_change_flag) {
        if(grad_spec_ctrl)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_SKIP), config_update_mode) : CONFIG_UPDATE_TYPE_SKIP;
        else {
            /* MRIhc56453 supported XRMW coil case  Apr 18,2011 YI */
            if (PSD_XRMW_COIL == cfgcoiltype) config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_DVW_AMP321SR120), config_update_mode) : CONFIG_UPDATE_TYPE_DVW_AMP321SR120;
            else if(tensor_flag)config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_TENSOR), config_update_mode) : CONFIG_UPDATE_TYPE_TENSOR;
            else           config_update_mode  = _config_update_mode.fixedflag ?  ((void)(CONFIG_UPDATE_TYPE_ACGD_PLUS), config_update_mode) : CONFIG_UPDATE_TYPE_ACGD_PLUS;
        }
        inittargets(&loggrd, &phygrd);
        inittargets(&epiloggrd, &epiphygrd);

        /* Obl 3in1 opt */
        if (obl_3in1_opt)
        {
            inittargets(&orthloggrd, &orthphygrd);
        }

        epiphygrd.xrt = cfrmp2xfs;
        epiphygrd.yrt = cfrmp2yfs;
        epiphygrd.zrt = cfrmp2zfs;
        epiphygrd.xft = cffall2x0;
        epiphygrd.yft = cffall2y0;
        epiphygrd.zft = cffall2z0;
        epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt = IMax(3,cfrmp2xfs,cfrmp2yfs,cfrmp2zfs);
        epiloggrd.xft = epiloggrd.yft = epiloggrd.zft = IMax(3,cffall2x0,cffall2y0,cffall2z0);
    }
    /* End Silent Mode */

    if((!rfov_flag) && (!rtb0_flag) && (exist(opdiffuse) == PSD_ON) && isRioSystem())
    {
        dpc_flag  = _dpc_flag.fixedflag ?  ((void)(PSD_ON), dpc_flag) : PSD_ON;
    }
    else
    {
        dpc_flag  = _dpc_flag.fixedflag ?  ((void)(PSD_OFF), dpc_flag) : PSD_OFF;
    }


   /* granty turn off dpc_flag by default */
    dpc_flag  = _dpc_flag.fixedflag ?  ((void)(PSD_OFF), dpc_flag) : PSD_OFF;

    if(dpc_flag)
    {
        iref_etl  = _iref_etl.fixedflag ?  ((void)(DEFAULT_IREF_ETL), iref_etl) : DEFAULT_IREF_ETL;
    }
    else
    {
        iref_etl  = _iref_etl.fixedflag ?  ((void)(0), iref_etl) : 0;
    }

    /*RTB0 correction*/
    rtb0_comp_flag  = _rtb0_comp_flag.fixedflag ?  ((void)(rtb0_flag?1:0), rtb0_comp_flag) : rtb0_flag?1:0;
    rtb0_recvphase_comp_flag  = _rtb0_recvphase_comp_flag.fixedflag ?  ((void)(rtb0_comp_flag), rtb0_recvphase_comp_flag) : rtb0_comp_flag;
    if(psd_board_type == PSDCERD || psd_board_type == PSDDVMR) 
    {
        pack_ix = PSD_XCVR2;
    }
    else 
    {
        pack_ix = 0;
    }
    rtb0_minintervalb4acq  = _rtb0_minintervalb4acq.fixedflag ?    
                                         
                                        ((void)(IMax(3,DABSETUP,XTRSETLNG+XTR_length[pack_ix]+DAB_length[pack_ix],XTRSETLNG+XTR_length[pack_ix]-rcvr_ub_off)), rtb0_minintervalb4acq) : IMax(3,DABSETUP,XTRSETLNG+XTR_length[pack_ix]+DAB_length[pack_ix],XTRSETLNG+XTR_length[pack_ix]-rcvr_ub_off);

    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
    /* when change from DWI to DTI, the cvinit() does not run, 
       so add below codes to initial TR popup menu */ 
    if( (epi_flair == PSD_OFF) && (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) )
    {
        pitrnub=6;
        pitrval2 = 2000000;
        pitrval3 = 4000000;
        pitrval4 = 6000000;
        pitrval5 = 8000000;
        pitrval6 = 10000000;
        tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
        tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(pitrval3), tr_acq_val3) : pitrval3;
        tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
    }

if( isValueSystem()
    && piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR)
{
    pitrval2 = (int) tr_acq_val2;
    pitrval3 = (int) tr_acq_val3;
    pitrval4 = (int) tr_acq_val4;
}
else if( !isValueSystem()
          && piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) 
{
    pitracqnub = 0;
    pitracqval2 = 0;
    pitracqval3 = 0;
}
else
{   
    pitracqnub = 0;
    pitracqval2 = 0;
    pitracqval3 = 0;
    pitracqval4 = 0;
}


    if( (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) && ( (PSD_ON == tensor_flag) || (PSD_ON == mux_flag) || (PSD_ON == muse_flag) ) )
    {
        cvmax(optracq, 1);
    }
    else
    {
        cvmax(optracq,1000);
    }

    /* 4/21/96 RJL: Init all new Advisory Cvs from InitAdvisories.e */
    InitAdvPnlCVs();
    
    /* HCSDM00232516 */
    if ((existcv(oprtcgate) && (oprtcgate == PSD_ON)) || (navtrig_flag == PSD_ON) ||
        (existcv(opcgate) && (opcgate == PSD_ON)))
    {
        avmaxtr = _act_tr.maxval;
        cvmax(optr, avmaxtr);
        cvmax(ihtr, avmaxtr);
    }
    else
    {
        avmaxtr = TR_MAX_EPI2;
        cvmax(optr, TR_MAX_EPI2);
        cvmax(ihtr, 31000000);
    }

    avminnecho = 1; 
    avmaxnecho = 1;
    avminsldelay  = _avminsldelay.fixedflag ?    ((void)(0), avminsldelay) : 0;
    avmaxsldelay = 20000000; /* YMSmr06685 */
    
    /* MRIhc56462 : overwrite initialization by InitAdvPnlCVs */
    if ((t1flair_flag || ir_prep_manual_tr_mode) && existcv(opuser8) && floatsAlmostEqualEpsilons(exist(opuser8), 2.0, 2))
    {
        avminslquant = 2;
    }

    if ( mux_flag )
    {
        avminslquant = 9;
    }

    /* YMSmr06831 */
    if((exist(opdiffuse) == PSD_ON) && (existcv(opbval) == PSD_OFF)) {
        cvoverride(opbval, pidefbval, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if (vrgfsamp == PSD_ON) {
        /* If Ramp Sampling is ON, set the max RBW to 500 kHz always */
        avmaxrbw = RBW_MAX;
    } else {
        float tsptmp;   /* min possible sampling period in micro seconds. */
        
        /* Calculate maximum RBW when ramp samp is not ON */
        /* MRIge51408 - Set max RBW based on max FOV */
        tsptmp = 10.0/ (GAM * xtarg * avmaxfov * 1.0e-6);
        /* round up to nearest 50 nanoseconds */
        tsptmp = (int)(5+100*tsptmp)/100.0;
        tsptmp -= ((int)(100*tsptmp)%5)/100.0;
        avmaxrbw = (1.0/ (2.0 * (tsptmp/ 1000.0)));
        avmaxrbw = (avmaxrbw > RBW_MAX) ? RBW_MAX : avmaxrbw;
    }       
    avmaxrbw2 = avmaxrbw;		/* avmaxrbw2 is not used in epi. But this value will be
                                           displayed in the insensitive field of bandwidth2 */
    
    if(PSD_ON != exist(opdiffuse) && PSD_ON != tensor_flag) {
        avminrbw = 31.25;
    } else {
        /* MRIge56895: limit RBW to 62.5 for diffusion since single shot */
        avminrbw = 62.5;
    }

    /* Make sure Y res is within a valid range */
    if( opyres < avminyres ) {
        epic_error( use_ermes, "The phase encoding steps must be increased to %d for the current prescription.", EM_PSD_YRES_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminyres );
        return ADVISORY_FAILURE;
    }
    if( opyres > avmaxyres ) {
        epic_error( use_ermes, "The phase encoding steps must be decreased to %d for the current prescription.", EM_PSD_YRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxyres );
        return ADVISORY_FAILURE;
    }

    /* SXZ::MRIge80335 */
    if( floatsAlmostEqualEpsilons(exist(opuser0), 1.0, 2) )
    {
        vrgfsamp  = _vrgfsamp.fixedflag ?  ((void)(1), vrgfsamp) : 1;

        if((dbdt_model == DBDTMODELCONV) || ( (cffield == B0_15000)
            && (PSD_XRMB_COIL == cfgcoiltype) ) )
        {
            rampopt  = _rampopt.fixedflag ?  ((void)(0), rampopt) : 0;
        }
        else
        {
            rampopt  = _rampopt.fixedflag ?  ((void)(1), rampopt) : 1;
        }

    }
    else
    {
        vrgfsamp  = _vrgfsamp.fixedflag ?  ((void)(0), vrgfsamp) : 0;
        rampopt  = _rampopt.fixedflag ?  ((void)(0), rampopt) : 0;
    }

    if( opdiffuse == PSD_ON && tensor_flag == PSD_OFF )
    {
        max_grad  = _max_grad.fixedflag ?  ((void)(1), max_grad) : 1;
    }
    else 
    {
        max_grad  = _max_grad.fixedflag ?  ((void)(0), max_grad) : 0;
    }

    if (isRioSystem())
    {
        max_grad  = _max_grad.fixedflag ?  ((void)(1), max_grad) : 1;
    }

    if (max_grad == 1) 
    {
        use_maxloggrad  = _use_maxloggrad.fixedflag ?  ((void)(PSD_ON), use_maxloggrad) : PSD_ON;
    }
    else 
    {
        use_maxloggrad  = _use_maxloggrad.fixedflag ?  ((void)(PSD_OFF), use_maxloggrad) : PSD_OFF;
    }

    if(PSD_ON == different_mpg_amp_flag)
    {
         use_maxloggrad  = _use_maxloggrad.fixedflag ?  ((void)(PSD_OFF), use_maxloggrad) : PSD_OFF;
    }

    /******************************************************/
    /*	check for grafidy.dwi file		      */
    /******************************************************/
    if( hoecc_flag == PSD_OFF && dwicntrl==0 )   /* skip additional linear correction if HOEC is on */
    {
        if(stat("/usr/g/caldir/grafidy.dwi",file_status)==0)dwicntrl = _dwicntrl.fixedflag ? ((void)(1), dwicntrl) : 1;
    }
    
    /******************************************************/
    /*	init opflip				      */
    /******************************************************/
    if(oppseq==PSD_SE)
    {
        cvoverride(opflip, 90, PSD_FIX_OFF, PSD_EXIST_ON);
    }
    
    /*MRIhc05898 limit flip angle to 70 degree for longbore 3T with
     *      * BODY or surface coil with spsp pulse*/
    if ((PSD_CRM_COIL == cfgcoiltype) && 
        (TX_COIL_BODY == getTxCoilType()) &&
        exist(opweight) > 130 && PSD_OFF == exist(opfat)  && 
        cffield == B0_30000) 
    {
        pifanub = 0; 
        cvoverride(opflip, 70, PSD_FIX_ON, PSD_EXIST_ON);
    }   


    /* Setsysparms sets the psd_grd_wait and psd_rf_wait
       parameters for the particular system. */
    if (_psd_rf_wait.fixedflag == 0) 
    {
        if (setsysparms() == FAILURE) 
	{
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setsysparms" );
            return FAILURE;
	}
    }
    
    /* JAH: Force SR20 systems to select ezdwi before selecting anything else */
    if( (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25) && (EZflag != PSD_ON)
        && ( existcv(opnshots) ||existcv(opte) || existcv(opautote) || existcv(optr)) ) {
        epic_error( use_ermes, "Only ezdwi can be run at sr%d. Please type ezdwi", EM_PSD_DWEPI_SRMODE_INCOMPATIBLE, EE_ARGS(1), INT_ARG, cfsrmode );
        return FAILURE;
    }
    
    /************************************************************************/
    
    /* Just in case...MRIge93923-Venkat*/
    if(exist(opmph) == PSD_OFF)
    {
        _opfphases.fixedflag = 0;
        opfphases  = _opfphases.fixedflag ?  ((void)(1), opfphases) : 1;
        _opfphases.fixedflag = 1;
        setexist(opfphases,PSD_ON);
        pimphscrn = 0; 
    }
    /* ***************************
       Diffussion parameters
       *************************** */
    
    if((exist(opdiffuse)==PSD_ON) || (tensor_flag ==PSD_ON)) {
        if(opdfaxall==0) rhdptype = _rhdptype.fixedflag ? ((void)(0), rhdptype) : 0;
        if((opdfaxall>0) && (opsavedf==1)) rhdptype = _rhdptype.fixedflag ? ((void)(1), rhdptype) : 1;
        if((opdfaxall>0) && (opsavedf==2)) rhdptype = _rhdptype.fixedflag ? ((void)(3), rhdptype) : 3;
        if((opdfaxtetra>0) && (opsavedf==1)) rhdptype = _rhdptype.fixedflag ? ((void)(1), rhdptype) : 1;
        if((opdfaxtetra>0) && (opsavedf==2)) rhdptype = _rhdptype.fixedflag ? ((void)(3), rhdptype) : 3;
        if(tensor_flag>0) rhdptype  = _rhdptype.fixedflag ?  ((void)(0), rhdptype) : 0;

        max_bval  = _max_bval.fixedflag ?  ((void)(0), max_bval) : 0;
        pidifavgnex = 0;
        total_difnex  = _total_difnex.fixedflag ?  ((void)(0), total_difnex) : 0;
        max_nex  = _max_nex.fixedflag ?  ((void)(0), max_nex) : 0;
        total_bval = 0.0;
        
        for (bval_counter = 0; bval_counter < opnumbvals; bval_counter++)
        {
            if (bvalstab[bval_counter] > max_bval) max_bval  = _max_bval.fixedflag ?  ((void)(bvalstab[bval_counter]), max_bval) : bvalstab[bval_counter];
            if (difnextab[bval_counter] > max_nex) max_nex  = _max_nex.fixedflag ?  ((void)((int)difnextab[bval_counter]), max_nex) : (int)difnextab[bval_counter];
            total_difnex  = _total_difnex.fixedflag ?  ((void)((int)difnextab[bval_counter]), total_difnex) : total_difnex+(int)difnextab[bval_counter];
            total_bval += difnextab[bval_counter]*bvalstab[bval_counter];
        }
        max_difnex  = _max_difnex.fixedflag ?  ((void)(max_nex), max_difnex) : max_nex;
        if(opdifnext2 > max_nex) max_nex  = _max_nex.fixedflag ?  ((void)(opdifnext2), max_nex) : opdifnext2;
        pidifavgnex = (total_difnex + opdifnext2*opdifnumt2 + (rpg_in_scan_flag?rpg_in_scan_num:0))/ 
                        ( (float)(rpg_in_scan_flag?rpg_in_scan_num:0) + (float)opdifnumt2 + FMax(2, 1.0, opnumbvals));

        for (bval_counter = 0; bval_counter < opnumbvals; bval_counter++)
        {
            diff_bv_weight[bval_counter] = bvalstab[bval_counter]/max_bval;
        }

        num_dif  = _num_dif.fixedflag ?  ((void)(ONE_AXIS), num_dif) : ONE_AXIS; /*HCSDM00516239*/

        /*MRIhc05854*/
        /*Update opdifnumdirs default value to avoid PSD timeout*/
        if((opdfaxx>PSD_OFF) || (opdfaxy>PSD_OFF) || (opdfaxz>PSD_OFF)) {
            num_dif = _num_dif.fixedflag ? ((void)(ONE_AXIS), num_dif) : ONE_AXIS;
            scale = (float)total_difnex/(opdifnext2+total_difnex*num_dif);
            cvdef(opdifnumdirs,1);
        }
        if(opdfaxall>PSD_OFF) {
            num_dif  = _num_dif.fixedflag ?  ((void)(ALL_AXIS), num_dif) : ALL_AXIS;
            scale = (float)total_difnex/((rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnext2+total_difnex*num_dif);
            if(gradopt_diffall == PSD_ON)
            {
                scale = (float)total_difnex*2/((rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnext2+total_difnex*num_dif);
            }
            cvdef(opdifnumdirs,3);
        }
        if (tensor_flag == PSD_ON) {
            num_dif  = _num_dif.fixedflag ?  ((void)(ALL_AXIS), num_dif) : ALL_AXIS;
            scale = (float)total_difnex/(opdifnext2*opdifnumt2+total_difnex*num_dif);
            cvdef(opdifnumdirs,6);
        }
        if(opdfax3in1>PSD_OFF) {
            num_dif  = _num_dif.fixedflag ?  ((void)(ONE_AXIS), num_dif) : ONE_AXIS;
            scale = (float)total_difnex*num_dif/(opdifnext2+total_difnex*num_dif);
            cvdef(opdifnumdirs,1);
        }
        if(opdfaxtetra>PSD_OFF) {
            num_dif  = _num_dif.fixedflag ?  ((void)(ALL_AXIS_TETRA), num_dif) : ALL_AXIS_TETRA;
            scale = (float)total_difnex*num_dif/(opdifnext2+total_difnex*num_dif);
            cvdef(opdifnumdirs,4);
        }

        scale_dif  = _scale_dif.fixedflag ?  ((void)(scale), scale_dif) : scale; /*MRIhc05854*/
        
        /* MRIhc54476 */
        if ((tensor_flag == PSD_OFF) && (num_dif > 0))
        {
            cvoverride (opdifnumdirs, num_dif, PSD_FIX_ON, PSD_EXIST_ON);
        }

        avg_bval  = _avg_bval.fixedflag ?  ((void)(total_bval/(total_difnex*num_dif+(rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnext2*opdifnumt2)), avg_bval) : total_bval/(total_difnex*num_dif+(rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnext2*opdifnumt2);

        rhnumdifdirs  = _rhnumdifdirs.fixedflag ?  ((void)(exist(opdifnumdirs)), rhnumdifdirs) : exist(opdifnumdirs);

        rhdifnext2  = _rhdifnext2.fixedflag ?  ((void)(opdifnext2), rhdifnext2) : opdifnext2;
        rhnumbvals  = _rhnumbvals.fixedflag ?  ((void)(exist(opnumbvals)), rhnumbvals) : exist(opnumbvals);

        /* BJM: MRIge47630 turn on Diffusion gradients for RMS and heating calcs */
        /* and scale by frequency of occurence */
        /* MRIge57853 added opdfaxall cond. */
        if((opdfaxx != PSD_OFF) || (opdfaxall != PSD_OFF) || (tensor_flag == PSD_ON) || (opdfax3in1 != PSD_OFF) || (opdfaxtetra != PSD_OFF)) {
            gradx[GXDR_SLOT].num = 1;
            gradx[GXDL_SLOT].num = 1;
            gradx[GXDR_SLOT].scale = scale; 
            gradx[GXDL_SLOT].scale = scale; 
            
            /* This is ONLY for SR20 SGD systems */
            if (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25)
            {
                gradx[GXDL_SLOT].scale = 1.0/(1 + 0.8);  /* Per McFarland'd measurement - MRIge48184, */
                gradx[GXDR_SLOT].scale = 1.0/(1 + 0.8);  /* HOUP */
            }

        } else {
            gradx[GXDR_SLOT].num = 0;
            gradx[GXDL_SLOT].num = 0;
        }
        
        if((opdfaxy != PSD_OFF) || (opdfaxall != PSD_OFF) || (tensor_flag == PSD_ON) || (opdfax3in1 != PSD_OFF) || (opdfaxtetra != PSD_OFF) ) {
            grady[GYDR_SLOT].num = 1;
            grady[GYDL_SLOT].num = 1;
            grady[GYDR_SLOT].scale = scale; 
            grady[GYDL_SLOT].scale = scale; 
            
            if (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25)
            {
                grady[GYDL_SLOT].scale = 1.0/(1 + 0.8);
                grady[GYDR_SLOT].scale = 1.0/(1 + 0.8);
            }

        } else {
            grady[GYDR_SLOT].num = 0;
            grady[GYDL_SLOT].num = 0;
        }
        
        if((opdfaxz != PSD_OFF) || (opdfaxall != PSD_OFF) || (tensor_flag == PSD_ON) || (opdfax3in1 != PSD_OFF) || (opdfaxtetra != PSD_OFF)) {
            gradz[GZDR_SLOT].num = 1;
            gradz[GZDL_SLOT].num = 1;
            gradz[GZDR_SLOT].scale = scale; 
            gradz[GZDL_SLOT].scale = scale; 
            
            if (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25)
            {
                gradz[GZDL_SLOT].scale = 1.0/(1 + 0.8);
                gradz[GZDR_SLOT].scale = 1.0/(1 + 0.8);
            }

        } else {
            gradz[GZDR_SLOT].num = 0;
            gradz[GZDL_SLOT].num = 0;
        } /* end opdfax checks */

        incr  = _incr.fixedflag ?  ((void)(PSD_ON), incr) : PSD_ON;
        
        mph_flag = _mph_flag.fixedflag ? ((void)(1), mph_flag) : 1;
        
        /* DTI BJM: pass_reps is used for DW-EPI control */

        if(tensor_flag == PSD_OFF) {
            pass_reps  = _pass_reps.fixedflag ?    ((void)(opdifnumt2+opnumbvals*num_dif), pass_reps) : opdifnumt2+opnumbvals*num_dif;
        } else {
            pass_reps  = _pass_reps.fixedflag ?    ((void)(exist(opdifnumdirs)+exist(opdifnumt2)), pass_reps) : exist(opdifnumdirs)+exist(opdifnumt2);
        }
        
        /* Refless EPI: add in the pass for ref, which is always the first pass */
        pass_reps  = _pass_reps.fixedflag ?    ((void)((ref_in_scan_flag?1:0)), pass_reps) : pass_reps+(ref_in_scan_flag?1:0);

        /* RPG: Add another pass for distortion correction */
        pass_reps  = _pass_reps.fixedflag ?      ((void)((rpg_in_scan_flag?rpg_in_scan_num:0)), pass_reps) : pass_reps+(rpg_in_scan_flag?rpg_in_scan_num:0); 

        reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
        dwi_fphases  = _dwi_fphases.fixedflag ?    ((void)(IMax(2,pass_reps,1)), dwi_fphases) : IMax(2,pass_reps,1);

    }
    else
    {
        incr  = _incr.fixedflag ?  ((void)(PSD_OFF), incr) : PSD_OFF; 
        pass_reps  = _pass_reps.fixedflag ?   ((void)(1), pass_reps) : 1;
        reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;

        dwi_fphases  = _dwi_fphases.fixedflag ?  ((void)(exist(opfphases)), dwi_fphases) : exist(opfphases);
        
        num_dif = _num_dif.fixedflag ? ((void)(0), num_dif) : 0;
        rhdptype = _rhdptype.fixedflag ? ((void)(0), rhdptype) : 0;
    }
    
    /* ***************************
       Multi-Phase parameters
       *************************** */
    
    if((exist(opdiffuse)==PSD_OFF) && (tensor_flag == PSD_OFF))
    { 
        mph_flag  = _mph_flag.fixedflag ?      ((void)((exist(opmph)==PSD_ON?PSD_ON:PSD_OFF)), mph_flag) : (exist(opmph)==PSD_ON?PSD_ON:PSD_OFF);
        
        if ( (exist(opmph)==PSD_ON) && (exist(opacqo)==0) && (exist(opcgate)==PSD_ON) ) 
        { /* multi-rep cardiac gated */
            pass_reps  = _pass_reps.fixedflag ?  ((void)(exist(opfphases)), pass_reps) : exist(opfphases);
            reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
        }
        else 
            if ( (exist(opmph)==PSD_ON) && (exist(opacqo)==0) ) 
            {  /* interleaved multi-phase */
                pass_reps  = _pass_reps.fixedflag ?   ((void)(exist(opfphases)), pass_reps) : exist(opfphases);
                reps  = _reps.fixedflag ?  ((void)(1), reps) : 1;
            }
            else 
                if ( (exist(opmph)==PSD_ON) && (exist(opacqo)==1) ) 
                { /* sequential multi-phase */
                    reps  = _reps.fixedflag ?  ((void)(exist(opfphases)), reps) : exist(opfphases);
                    pass_reps  = _pass_reps.fixedflag ?  ((void)(1), pass_reps) : 1;
                }
                else 
                {  /* default */
                    pass_reps  = _pass_reps.fixedflag ?  ((void)(1), pass_reps) : 1;
                    reps  = _reps.fixedflag ?   ((void)(1), reps) : 1;
                }
        acqmode  = _acqmode.fixedflag ?   ((void)(exist(opacqo)), acqmode) : exist(opacqo); /* acq mode, 0=interleaved, 1=def=sequential */
        rhuser4  = _rhuser4.fixedflag ?  ((void)(acqmode), rhuser4) : acqmode;
        
    }
   
    if (PSD_ON == mux_flag)
    {
        cvmax(rhchannel_combine_method, RHCCM_ASSET_COMBINE);
        rhchannel_combine_method  = _rhchannel_combine_method.fixedflag ?  ((void)(RHCCM_ASSET_COMBINE), rhchannel_combine_method) : RHCCM_ASSET_COMBINE;
        rhcal_options  = _rhcal_options.fixedflag ?      ((void)(CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL+CAL_OPTIONS_CACHE), rhcal_options) : CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL+CAL_OPTIONS_CACHE; /* for multiband, bit4-Cache Calibration, bit1-Ext 2D Cal, bit0-Ext 3D Cal */
    }
    else if (PSD_ON == rfov_flag)
    {
        cvmax(rhchannel_combine_method, RHCCM_C3_RECON_FOR_PHASE_I_Q_IMAGES);
        rhchannel_combine_method  = _rhchannel_combine_method.fixedflag ?  ((void)(RHCCM_C3_RECON_FOR_PHASE_I_Q_IMAGES), rhchannel_combine_method) : RHCCM_C3_RECON_FOR_PHASE_I_Q_IMAGES;
        rhcal_options  = _rhcal_options.fixedflag ?    ((void)(CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL), rhcal_options) : CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL; /* Phase ASSET , bit1-Ext 2D Cal, bit0-Ext 3D Cal*/
    }
    else
    {
        cvmax(rhchannel_combine_method, RHCCM_C3_RECON_FOR_PHASE_I_Q_IMAGES);
        rhchannel_combine_method  = _rhchannel_combine_method.fixedflag ?  ((void)(RHCCM_SUM_OF_SQUARES), rhchannel_combine_method) : RHCCM_SUM_OF_SQUARES;
        rhcal_options  = _rhcal_options.fixedflag ?    ((void)(CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL), rhcal_options) : CAL_OPTIONS_EXT3DCAL+CAL_OPTIONS_EXT2DCAL; /* Phase ASSET , bit1-Ext 2D Cal, bit0-Ext 3D Cal*/
    }


    if (exist(opmph)==PSD_OFF)
        opsldelay  = _opsldelay.fixedflag ?  ((void)(avminsldelay), opsldelay) : avminsldelay;
         
    if (existcv(opsldelay) && (exist(opsldelay) == avminsldelay) && (avminsldelay <= 1  ) ) {

        /* set pass_delay to min. = 1 us which is effectively    */
        /* a delay = 0us between passes since the delay between */
        /* each null pass is also 1 us.                         */
        pass_delay  = _pass_delay.fixedflag ?    ((void)(1), pass_delay) : 1;
        num_passdelay  = _num_passdelay.fixedflag ?  ((void)(1), num_passdelay) : 1;
        
    } else {

        /* Else...set the delay to the prescribed value */
        pass_delay  = _pass_delay.fixedflag ?  ((void)(exist(opsldelay)), pass_delay) : exist(opsldelay);
        if (pass_delay > 15000000) {
            num_passdelay  = _num_passdelay.fixedflag ?  ((void)(pass_delay/15000000+((pass_delay%15000000==0)?0:1)), num_passdelay) : pass_delay/15000000+((pass_delay%15000000==0)?0:1);
        }
        else {
            num_passdelay  = _num_passdelay.fixedflag ?  ((void)(1), num_passdelay) : 1;
        }
        pass_delay  = _pass_delay.fixedflag ?  ((void)(pass_delay/num_passdelay+1), pass_delay) : pass_delay/num_passdelay+1;
    }

    piphases  = _piphases.fixedflag ?  ((void)(exist(opphases)), piphases) : exist(opphases);
    max_phases  = _max_phases.fixedflag ?  ((void)(piphases), max_phases) : piphases;
    
    piadvmin |= (1<<PSD_ADVTI);
    piadvmax |= (1<<PSD_ADVTI);
    
    if (( mph_flag == PSD_ON )&&(opdiffuse==PSD_OFF)&&(tensor_flag == PSD_OFF)) 
    {
        /* screen for MPH option */
        pimphscrn = 1;
        pifphasenub = 6;
        pifphaseval2 = 1;
        pifphaseval3 = 2;
        pifphaseval4 = 5;
        pifphaseval5 = 10;
        pifphaseval6 = 15;
        
        pisldelnub = 6;
        pisldelval3 = 500000;
        pisldelval4 = 1000000;
        pisldelval5 = 2000000;
        pisldelval6 = 5000000;
        
        /* Changed piacqnub from 2 to 3 for Linux-MGD. WGEbg17457 -Venkat*/
        piacqnub = 3; /* acquisition order buttons */
        
    } 
    else 
    {
        pimphscrn = 0; /* do not display the Multi-Phase Parameter screen */
        pifphasenub = 0;
        pisldelnub = 0;
        piacqnub = 0; /* acquisition order buttons */
        
    }
  
    /***** TI UI Button Control *********/
    if( (PSD_ON == exist(opdiffuse)) &&
        ((PSD_ON == exist(opspecir)) || (PSD_ON == exist(opirprep))) )
    {
        pitinub=2;
    }
    else
    {
        pitinub=0;
        cvoverride(opautoti, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
   
    /* UI Fields TR & TI (FLAIR) */
    if (epi_flair == PSD_ON) {
        
        pitinub = 2;
        
        if(cffield==B0_15000) {
            pitival2 = 2200000;
        } else if (cffield==B0_10000) {
            pitival2 = 2000000;
        } else if(cffield==B0_5000) {
            pitival2 = 1800000; 
        }
        else if (cffield == B0_40000) {
            pitival2 = 2200000;
            DEBUG_4_0(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000) {
            pitival2 = 2200000;
            DEBUG_3_0(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000) {
            pitival2 = 1800000; 
            DEBUG_0_7(SD_PSD_EPI2,__FILE__,__LINE__);
        }
        else if (cffield == B0_2000) {
            SDL_PrintFStrengthWarning(SD_PSD_EPI2,cffield,__FILE__,__LINE__);
        }
        else {
            SDL_PrintFStrengthWarning(SD_PSD_EPI2,cffield,__FILE__,__LINE__);
        }

 
        avminti=FLAIR_MIN_TI;
        avmaxti=FLAIR_MAX_TI;
        
        cvmin(opti,FLAIR_MIN_TI);
        cvmax(opti,FLAIR_MAX_TI);
        
        cvdef(opti,1500000);
    } else {

        cvmin(opti,TI_MIN);

        /* irprep_support */
        if(irprep_flag == PSD_ON)
        {
          /* Activate advisory panel checks for TI */
          piadvmin = (piadvmin | (1<<PSD_ADVTI));
          piadvmax = (piadvmax | (1<<PSD_ADVTI));

          pitinub = 5;

          if(cffield == B0_15000)
          {
              pitival2 = 160000;
              pitival3 = 170000;
              pitival4 = 180000;
              pitival5 = 190000;
          }
          else
          {
              pitival2 = 220000;
              pitival3 = 230000;
              pitival4 = 240000;
              pitival5 = 250000;
          }

          if ((PSD_ON == t1flair_flag) || (PSD_ON == ir_prep_manual_tr_mode))
          {
              /* turn on Auto TI for t1flair interleaved STIR */
              piautoti = PSD_ON;
          }
          else
          {
              piautoti = PSD_OFF;
          }

          avmaxti = EPI_STIR_TI_MAX;
          cvmax(opti,EPI_STIR_TI_MAX);
        }
        else if(PSD_ON == exist(opspecir))
        {
          init_ASPIR_TI();
        }
        else 
        {
          /* turn off TI field, flair = 0 */
          pitinub = 0;
          piautoti = PSD_OFF;
          avmaxti = TI_MAX;
          cvmax(opti,TI_MAX);
        }
    }

    /* 0.5T -> turn on fatsat, turn off spsp */
    if (cffield == B0_5000) { 
        cvoverride(opsat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(opfat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        ss_rf1  = _ss_rf1.fixedflag ?  ((void)(0), ss_rf1) : 0;
    }

    if (PSD_OFF == enhanced_fat_suppression)
    {
        if (irprep_flag || aspir_flag || exist(opfat) || (ss_rf1_compatible == PSD_OFF))
        {
            ss_rf1  = _ss_rf1.fixedflag ?  ((void)(0), ss_rf1) : 0;
            eosykiller  = _eosykiller.fixedflag ?  ((void)(0), eosykiller) : 0;
        }
        else
        {
            /* MRIge48532 - turn on eosykiller if ss_rf1 = PSD_ON */
            ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;        
            eosykiller  = _eosykiller.fixedflag ?  ((void)(1), eosykiller) : 1;
        }

        breast_spsp_flag  = _breast_spsp_flag.fixedflag ?  ((void)(0), breast_spsp_flag) : 0;
        d_cf  = _d_cf.fixedflag ?  ((void)(0), d_cf) : 0;
    }
    else
    {
            /* set up enhanced fat suppression */
            if (cffield == B0_30000)
            {
                if (enhanced_fat_suppression == 1)
                {
                    ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
                    eosykiller  = _eosykiller.fixedflag ?  ((void)(1), eosykiller) : 1;
                    breast_spsp_flag  = _breast_spsp_flag.fixedflag ?  ((void)(0), breast_spsp_flag) : 0;
                    d_cf  = _d_cf.fixedflag ?  ((void)(0), d_cf) : 0;
                }
                else if (enhanced_fat_suppression == 2)
                {
                    ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
                    eosykiller  = _eosykiller.fixedflag ?  ((void)(1), eosykiller) : 1;
                    breast_spsp_flag  = _breast_spsp_flag.fixedflag ?  ((void)(1), breast_spsp_flag) : 1; /* broad pass band spsp */
                    d_cf  = _d_cf.fixedflag ?    ((void)((int)(50/TARDIS_FREQ_RES)), d_cf) : (int)(50/TARDIS_FREQ_RES);
                }
                else
                {
                    ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
                    eosykiller  = _eosykiller.fixedflag ?  ((void)(1), eosykiller) : 1;
                    breast_spsp_flag  = _breast_spsp_flag.fixedflag ?  ((void)(2), breast_spsp_flag) : 2; /*Type II broad pass band spsp */
                    d_cf  = _d_cf.fixedflag ?    ((void)((int)(50/TARDIS_FREQ_RES)), d_cf) : (int)(50/TARDIS_FREQ_RES);
                }
                /*RTB0 correction: set d_cf to 0 to prevent spine signal drop off at shoulder*/
                if (rtb0_spsp_flag)
                {
                    d_cf  = _d_cf.fixedflag ?  ((void)(0), d_cf) : 0;
                } 
            }
            else /*1.5T*/
            {
                ss_rf1  = _ss_rf1.fixedflag ?  ((void)(1), ss_rf1) : 1;
                eosykiller  = _eosykiller.fixedflag ?  ((void)(1), eosykiller) : 1;
                breast_spsp_flag  = _breast_spsp_flag.fixedflag ?  ((void)(0), breast_spsp_flag) : 0;
                d_cf  = _d_cf.fixedflag ?  ((void)(0), d_cf) : 0;
            }
    }

    if( (cfgcoiltype == PSD_XRMB_COIL || isRioSystem() || cfgcoiltype == PSD_XRMW_COIL || cfgcoiltype == PSD_VRMW_COIL) ||
        (opweight > 150 && cffield >= B0_30000 && getTxCoilType() == TX_COIL_BODY &&
         cfgcoiltype == PSD_TRM_COIL) )
    {
       if (ss_rf1 == PSD_ON)
       {
           ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), ss_fa_scaling_flag) : PSD_ON;
       }
       else
       {
           ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ss_fa_scaling_flag) : PSD_OFF;
       }

       if (ir_on == PSD_ON && opweight > 150 && cffield >= B0_30000 &&
           getTxCoilType() == TX_COIL_BODY && cfgcoiltype == PSD_TRM_COIL)
       {
           ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_ON), ir_fa_scaling_flag) : PSD_ON;
       }
       else
       {
           ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ir_fa_scaling_flag) : PSD_OFF;
       }
    }
    else
    {
        ss_fa_scaling_flag  = _ss_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ss_fa_scaling_flag) : PSD_OFF;
        ir_fa_scaling_flag  = _ir_fa_scaling_flag.fixedflag ?  ((void)(PSD_OFF), ir_fa_scaling_flag) : PSD_OFF;
    }

    fast_rec  = _fast_rec.fixedflag ?  ((void)(0), fast_rec) : 0;
     
    /* just add cvcheck to trap this and eliminate this code: */
    /* gxdelay and gydelay must lie on 4us boundaries */
    if (gxdelay % GRAD_UPDATE_TIME != 0) {
        cvoverride(gxdelay,RUP_GRD(gxdelay),_gxdelay.fixedflag, _gxdelay.existflag);
    }
    
    if (gydelay % GRAD_UPDATE_TIME != 0) {
        cvoverride(gydelay,RUP_GRD(gydelay),_gydelay.fixedflag, _gydelay.existflag);
    }   
    
    intleaves  = _intleaves.fixedflag ?  ((void)(exist(opnshots)), intleaves) : exist(opnshots);
   
    piphasfovnub = 0;
    /* Variable FOV buttons on or off depending on square pixels */
    if (exist(opsquare) == PSD_ON)
    {
        piphasfovnub2 = 0;
    }
    else 
    {
        if (rfov_flag)
        {
            piphasfovnub2 = 31;
            piphasfovval2 = 1.0;
            piphasfovval3 = 0.75;
            piphasfovval4 = 0.5;
            piphasfovval5 = 0.2;
        }
        else
        {
            piphasfovnub2 = 7;
            piphasfovval2 = 1.0;
            piphasfovval3 = 0.5;
        }

        cvmax(opphasefov,1.0);

        if (rfov_flag)
        {
            min_phasefov  = _min_phasefov.fixedflag ?  ((void)(0.2), min_phasefov) : 0.2;
        }
        else
        {
            min_phasefov  = _min_phasefov.fixedflag ?  ((void)(0.5), min_phasefov) : 0.5;
        }

        cvmin(opphasefov, min_phasefov);
    }
       
    if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77 ) && (EZflag == PSD_ON) )
    {
        piphasfovnub = 1;
        piphasfovval1 = 0.6;
    }
   
    /* Set default frequency encoding direction for head R/L  QT*/
    if (( TX_COIL_LOCAL == getTxCoilType() &&
          (exist(opplane) == PSD_AXIAL || exist(opplane)== PSD_COR) ) ||
        ( TX_COIL_LOCAL == getTxCoilType() &&
          exist(opplane) == PSD_OBL && existcv(opplane) 
          && (exist(opobplane) == PSD_AXIAL || exist(opobplane) == PSD_COR) )) 
    {
        piswapfc = 1;
    }
    else 
    {
        piswapfc = 0;
    }
    
    /****  Asymmetric Fov  ****/
    /* handling for phase (y) resolution and recon scale factor.*/
    setexist(opphasefov,PSD_ON);   /* MRIge51075 - set exist flag so that the value won't be 1. */
    if ( !floatsAlmostEqualEpsilons(exist(opphasefov), 1.0, 2) && existcv(opphasefov) && ((exist(opsquare) != PSD_ON) && existcv(opsquare)) ) 
    {
        rhphasescale  = _rhphasescale.fixedflag ?  ((void)(exist(opphasefov)), rhphasescale) : exist(opphasefov);
        eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opyres)), eg_phaseres) : exist(opyres);
    } else { 
        if ( (exist(opsquare) == PSD_ON) && existcv(opsquare) ) 
        {
            /* MRIge51504 - opyres can't be greater than opxres with square pixel. */
            if ( exist(opyres) > exist(opxres) )
            {
                epic_error( use_ermes, "This YRES cannot be achieved with current prescription", EM_PSD_YRES_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, exist(opxres) );
                avminyres = exist(opxres);
                avmaxyres = exist(opxres);
                return ADVISORY_FAILURE;
            }
            rhphasescale  = _rhphasescale.fixedflag ?  ((void)((float)exist(opyres)/(float)exist(opxres)), rhphasescale) : (float)exist(opyres)/(float)exist(opxres);
            setexist(opphasefov,PSD_ON);
            _opphasefov.fixedflag = 0;
            opphasefov  = _opphasefov.fixedflag ?  ((void)(rhphasescale), opphasefov) : rhphasescale;
            _opphasefov.fixedflag = 1;
            eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opxres)), eg_phaseres) : exist(opxres);
        } 
        else 
        {
            rhphasescale  = _rhphasescale.fixedflag ?  ((void)(1.0), rhphasescale) : 1.0;
            _opphasefov.fixedflag = 0;
            opphasefov  = _opphasefov.fixedflag ?  ((void)(1.0), opphasefov) : 1.0;
            _opphasefov.fixedflag = 1;
            eg_phaseres  = _eg_phaseres.fixedflag ?  ((void)(exist(opyres)), eg_phaseres) : exist(opyres);
        }
    }

    /* t1flair_stir */
    if ( T1flair_setup()  == FAILURE )
    {
        return FAILURE;
    }

    /* MRIge51174 - EZDWI, ramp sampling is ON, PH */
    if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem())) || cfsrmode == PSD_SR77) && (EZflag == PSD_ON) )
        vrgfsamp  = _vrgfsamp.fixedflag ?  ((void)(1), vrgfsamp) : 1;
    
    rhfreqscale  = _rhfreqscale.fixedflag ?  ((void)(1.0), rhfreqscale) : 1.0;
    dfg  = _dfg.fixedflag ?  ((void)(2), dfg) : 2;
    dfscale = 1;
    freq_scale  = _freq_scale.fixedflag ?  ((void)(rhfreqscale), freq_scale) : rhfreqscale;
    
    /**********************************************************************
      Initialize RF System Safety Information.  This must be re-initialized
      in eval section since CV changes may lead to scaling of rfpulse.
    *********************************************************************/
    for (pulse=0; pulse<RF_FREE; pulse++) 
    {
        rfpulseInfo[pulse].change=PSD_OFF;
        rfpulseInfo[pulse].newres=0;
    }
    /* Reinitialize Prescan CV's for cveval. Done so rf system safety check
       can be performed with each OPIO change. */

    /* PURE Mix */
    model_parameters.epi.rfov_flag  = _rfov_flag.fixedflag ?  ((void)(rfov_flag), rfov_flag) : rfov_flag;

    { /* Start of code inlined from vmx.e SysParmEval */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            system_type  = _system_type.fixedflag ?  ((void)(1), system_type) : 1;
            rfupa = cv_rfupa;
        }
        if( (cfgradcoil == GCOIL_HGC)||(cfgradcoil == GCOIL_VECTRA) )
        {
            avmaxfov = FOV_MAX_VMX;
            _opweight.maxval = 150.0;
        }
        if(cffield == 2000)
        {
            avmaxfov = FOV_MAX_PROFILE;
            _opweight.maxval = 180.0;
        }
        if(cffield == 3500)
        {
            avmaxfov = FOV_MAX_PROFILE;
        }

        if( (exist(opimode) != PSD_3D) && (exist(opimode) != PSD_3DM)
           && (exist(oppseq) != PSD_TOF) && (exist(oppseq) != PSD_TOFSP)
           && (cffield <= B0_5000) ) 
        {
            if( exist(opslthick) < MINTHICK_VMX )
            { 
                epic_error(use_ermes, "Increase the slice thickness to %.1f",
                           EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, MINTHICK_VMX);
                return FAILURE;
            }
        }

        /* PURE */
        pipure = coilInfo[0].pureCompatible;

        /* PURE Mix */
        strcpy(model_parameters.psd_name, get_psd_name());
        model_parameters.irmode = exist(opirmode);
        model_parameters.irprep = exist(opirprep);
        model_parameters.fatsat_flag = exist(opfatcl) || exist(opfat) || exist(opspecir) || exist(opssrf);
        model_parameters.flex_flag = exist(opmedal);
        model_parameters.ideal_flag = exist(opdixon);
        model_parameters.pure_support = pipure;
        model_parameters.cffield  = _cffield.fixedflag ?  ((void)(cffield), cffield) : cffield;
        model_parameters.pseq_type = exist(oppseq);
        model_parameters.realtime_flag = exist(oprealtime);
        model_parameters.imode = exist(opimode);
        model_parameters.plane = exist(opplane);

        if (FAILURE == getPUREMixCompatibility(model_parameters, coilInfo, exist(opanatomy), &pipure, &pure_mix))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getPUREMixCompatibility");
            return FAILURE;
        }

        if (B0_30000 == cffield)
        {

            if (PURE2 == exist(oppure) && pure_mix.enable)
            {
                cvmod(opuser40, -100.0, 100.0, 0.0, "PURE compensation", 0, "");
                opuser40  = _opuser40.fixedflag ?  ((void)(_opuser40.defval), opuser40) : _opuser40.defval;
                activate_reserved_usercv(40);

                if ((_opuser40.minval > exist(opuser40)) ||
                    (_opuser40.maxval < exist(opuser40)))
                {
                    cvoverride(opuser40, _opuser40.defval, PSD_FIX_ON, PSD_EXIST_ON);
                    epic_error(use_ermes, "%s is out of range.",
                               EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "PURE compensation");
                    return FAILURE;
                }
            }
            else
            {
                cvmod(opuser40, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 40", 0, "");
                cvoverride(opuser40, _opuser40.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
                deactivate_reserved_usercv(40);
            }
        }

        if (isDVSystem() && (B0_15000 == cffield) &&
            (PSD_PURE_COMPATIBLE_1 & pipure) &&
            (!strncmp("memp_pure", get_psd_name(), 9) || !strncmp("fse_pure", get_psd_name(), 8)))
        {   
            pipure = PSD_PURE_COMPATIBLE_2;
        }
        else if ((isK15TSystem()) &&
                 (PSD_PURE_COMPATIBLE_1 & pipure) && (opfov <= 300) &&
                 (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) ||
                  isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES)))
        {
            pipure = PSD_PURE_COMPATIBLE_2;
        }
        else if ((isSVSystem()) && (PSD_PURE_COMPATIBLE_1 & pipure) &&
                 (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)))
        {
            if((!strncmp("dwi_pure",get_psd_name(),8) || !strncmp("fsemaster_pure",get_psd_name(),14) || 
                !strncmp("t1memp_pure",get_psd_name(),11) || !strncmp("2dfast_pure",get_psd_name(),11) || 
                !strncmp("3dfse_pure",get_psd_name(),10) || !strncmp("3dradial_pure",get_psd_name(),13) ||
                !strncmp("efgre3d_pure",get_psd_name(),12) || !strncmp("csmemp_pure",get_psd_name(),11) || 
                !strncmp("3dtof_pure",get_psd_name(),10) || !strncmp("ssfse_pure",get_psd_name(),10) || 
                !strncmp("epi_pure",get_psd_name(),8) || !strncmp("asl_pure",get_psd_name(),8)) && (exist(oppure) != 0))
            {
                pipure = PSD_PURE_COMPATIBLE_2;

                /* Adding an advanced CV31 for Customer to adjust the Lamda of Pure-mix for the Head Shading issue for above type-in PSD.
                   Because not all the HNA coils have the same shading level, an advanced CV will be more flexible and robust.
                   ZT 06/Mar/2018 */

                piuset2 |= use31;
                opuser31  = _opuser31.fixedflag ?  ((void)(100.0), opuser31) : 100.0;
                cvmod(opuser31, 1.0, 100.0, 100.0, "Head Uniformity Improvement",0," ");
                if (existcv(opuser31) && ((exist(opuser31) < 1) || (exist(opuser31) > 100) || 
                    (!floatsAlmostEqualEpsilons(exist(opuser31),(int)exist(opuser31),2))))
                {
                    epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser31.descr );
                    return FAILURE;
                }
            }
            else
            {
                piuset2 &= ~use31;
                cvmod(opuser31, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 31", 0, "");
                cvoverride(opuser31, _opuser31.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            }

        }

        if ((PSD_SPECTRO == exist(opimode)) ||
            (PSD_3PLANE == exist(opplane)) ||
            (PSD_ON == exist(opassetcal)) || (PSD_ON == exist(oppurecal)) ||
            ((PSD_ON == exist(oprealtime)) && (PSD_OFF == exist(opfluorotrigger))) ||
            (PSD_ON == exist(opmultistation)) ||
            (1 == coilInfo[0].numChannels))
        {
            pipure = 0;
        }

        /* pure is set off for MAVRIC.  */
        if (model_parameters.fse3d.mavric_flag)
        {
            pipure = 0;
        }

        /* pure2 is set off for FIESTA-C.  */
        if (model_parameters.gre3d.pcfiesta_flag)
        {
            pipure &= ~PSD_PURE_COMPATIBLE_2;
        }

        /* SCENIC */
        model_parameters.anatomy = exist(opanatomy);
        model_parameters.pure_support = pipure;
        scenic.sysconfig = cfscenic;
        scenic.opscenic  = _opscenic.fixedflag ?  ((void)(exist(opscenic)), opscenic) : exist(opscenic);
        scenic.opscic  = _opscic.fixedflag ?  ((void)(exist(opscic)), opscic) : exist(opscic);
        scenic.itkn4.allow = ((cfn4_num_levels_max>0) && cfn4_allowed);
        scenic.scic.allow = ((cfscic_focus>0.0) && cfscic_allowed);
        scenic.itkn4.gain_clamp_value = cfn4_gain_clamp_value;
        scenic.itkn4.gain_clamp_mode = cfn4_gain_clamp_mode;

        if((exist(opsilent) || exist(opsilentmr)) && (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)))
        {
            model_parameters.pure_support = 0;
        }
        else
        {
            model_parameters.pure_support = pipure;
        }

        if (FAILURE == getScenicCompatibility(model_parameters, &scenic))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getScenicCompatibility");
            return FAILURE;
        }
        piscenic  = _piscenic.fixedflag ?  ((void)(scenic.piscenic), piscenic) : scenic.piscenic;
        piscic  = _piscic.fixedflag ?  ((void)(scenic.piscic), piscic) : scenic.piscic;

        /*
         * scenic.scenic_type and scenic.itkn4.gain_clamp_value
         * will be set in getScenicType()
         */
        if (FAILURE == getScenicType(model_parameters, &scenic))
        {
            epic_error(use_ermes, "Support routine %s failed.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "getScenicType");
            return FAILURE;
        }
        rhscenic_type  = _rhscenic_type.fixedflag ?  ((void)(scenic.scenic_type), rhscenic_type) : scenic.scenic_type;

        if (SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
            override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;
        }
        else if (PSD_OFF == override_opcalrequired)
        {
            cvoverride(opcalrequired, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        }

        if( psd_board_type == PSDCERD || psd_board_type == PSDDVMR )
        {
            
            if( cftpssize <= 0 )
            {
                if (VALUE_SYSTEM_HDE == value_system_flag) {
                    cftpssize = 133954560;
                }else {
                    cftpssize = 1670381568.0;
                }
            }
        }

        /* MRIhc41001 - maximum attenuation available for PSD
         * (xmtadd) usage is the hardware maximum minus 200 for
         * TG. (ampCal is unused and coil attenuation is included
         * in xmtadd.
         */
        cfdbmax = IMax(2, 0, cfrfMaxAttenuation - 200);

        /* Dynamic Plan */
        if( (exist(opdynaplan) == PSD_ON) && existcv(opdynaplan) ) {
            if(checkOptionKey( SOK_MPHVAR )){
                epic_error( use_ermes,
                            "%s is not available without the option key.",
                            EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1),
                            STRING_ARG, "Multi-Phase (variable delays)" );
                return FAILURE;
            }
            if( (exist(opfmri) == PSD_ON) && existcv(opfmri) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"fMRI");
                return FAILURE;
            }
            if( (exist(opectricks) == PSD_ON) && existcv(opectricks) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"ECTRICKS");
                return FAILURE;
            }
            if( (exist(opmph) == PSD_ON) && existcv(opmph) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Multi Phase");
                return FAILURE;
            }
            if( (exist(opcgate) == PSD_ON) && existcv(opcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Cardiac Gating");
                return FAILURE;
            }
            if( (exist(oprtcgate) == PSD_ON) && existcv(oprtcgate) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Respiratory Triggering");
                return FAILURE;
            }
            if( (exist(oprealtime) == PSD_ON) && existcv(oprealtime) && (exist(opfluorotrigger) == PSD_OFF) && existcv(opfluorotrigger) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Realtime");
                return FAILURE;
            }
            /* MRIhc08845  08/03/2005 YI */
            if( (exist(opcosmic) == PSD_ON) && existcv(opcosmic) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"COSMIC");
                return FAILURE;
            }
            if( (exist(opswift) == PSD_ON) && existcv(opswift) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"SWIFT");
                return FAILURE;
            }
            if( (exist(opmerge) == PSD_ON) && existcv(opmerge) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"MERGE");
                return FAILURE;
            }
            /* MRIhc09973  09/07/2005 YI */
            if( (exist(opplane) == PSD_3PLANE) && existcv(opplane) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"Localizer");
                return FAILURE;
            }
            if( (exist(optensor) > PSD_OFF) && existcv(optensor) ) {
                epic_error(use_ermes,"%s is incompatible with %s.",
                            EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                            STRING_ARG,"TENSOR");
                return FAILURE;
            }
            if(NON_VALUE_SYSTEM == value_system_flag){
                if( (2 == exist(opnecho)) && (PSD_3D != exist(opimode)) && 
                    ((PSD_GE == exist(oppseq)) ||
                     (PSD_SPGR == exist(oppseq))) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"FGRE Dual Echo");
                    return FAILURE;
                }
                /* MRIhc09972  09/06/2005 YI */
                if( ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq))) && (exist(opimode) == PSD_2D) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"Fast TOF");
                    return FAILURE;
                }
                if( (exist(opdiffuse) == PSD_ON) && existcv(opdiffuse) ) {
                    epic_error(use_ermes,"%s is incompatible with %s.",
                                EM_PSD_INCOMPATIBLE,2,STRING_ARG,"Multi-Phase (variable delays)",
                                STRING_ARG,"DWI");
                    return FAILURE;
                }
            }
        } /* End of Dynamic Plan */

        /* HCSDM00323513 */
        if (opslquant*opvquant > SLTAB_MAX)
        {
            avmaxslquant = (int)(SLTAB_MAX/(IMax(2,opvquant,1)));
            epic_error(use_ermes,"Maximum slice quantity is %-d",
                       EM_PSD_SLQUANT_OUT_OF_RANGE, 1, INT_ARG, avmaxslquant);
            return ADVISORY_FAILURE;
        }

        /* Update default values based on the system configuration */
        configSystem();

        /* HCSDM00338330: moved 3DGW enable/disable control from Host.  */
        /* 3DGW is disabled when one of the following conditions is met */
        /* << 2D or Cine imaging mode >>                                */
        /*    - gap / thickness > maxSliceGap2ThickPercent/100          */
        /*    - non-coaxial                                             */
        /*    - multi group                                             */
        /* << 3D imaging mode >>                                        */
        /*    - multi slab                                              */
        if( FALSE == Is3DGWAllowed(0) )
        {
            pi3dgradwarpnub  = _pi3dgradwarpnub.fixedflag ?  ((void)(0), pi3dgradwarpnub) : 0;
            cvdef(pi3dgradwarpnub, 0);
        }

        fov_freq_scale   = _fov_freq_scale.fixedflag ?  ((void)(scan_info[0].opfov_freq_scale), fov_freq_scale) : scan_info[0].opfov_freq_scale;
        fov_phase_scale  = _fov_phase_scale.fixedflag ?  ((void)(scan_info[0].opfov_phase_scale), fov_phase_scale) : scan_info[0].opfov_phase_scale;
        slthick_scale    = _slthick_scale.fixedflag ?  ((void)(scan_info[0].opslthick_scale), slthick_scale) : scan_info[0].opslthick_scale;

    } /* End of code inlined from vmx.e SysParmEval */

    {
        psd_relative_encoded_volume_phase  = _psd_relative_encoded_volume_phase.fixedflag ?  ((void)(opnpwfactor), psd_relative_encoded_volume_phase) : opnpwfactor;

        if (PSD_3D == exist(opimode) ) /* 3D different excitation modes */
        {
            if(FOCUS == exist(opexcitemode))
            {
                psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_phase) : 1.0;
                psd_relative_encoded_volume_phase  = _psd_relative_encoded_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_encoded_volume_phase) : 1.0;

                psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_slice) : 1.0;
            }
            else if(SELECTIVE == exist(opexcitemode))
            {
                psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_phase) : -1.0;
                psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_slice) : 1.0;
            }
            else
            {
                psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_phase) : -1.0;
                psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_slice) : -1.0;
            }
        }
        else if (PSD_2D == exist(opimode) ) /* 2D different excitation modes */
        {
            if(FOCUS == exist(opexcitemode)) /* 2D FOCUS mode */
            {
                psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_phase) : 1.0;
                psd_relative_encoded_volume_phase  = _psd_relative_encoded_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_encoded_volume_phase) : 1.0;
            }
            if(PSD_ON == exist(opradialrx))
            {
                psd_relative_excited_volume_freq  = _psd_relative_excited_volume_freq.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_freq) : -1.0;
                psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_phase) : -1.0;
                psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(-1.0), psd_relative_excited_volume_slice) : -1.0;
            }
        }
        else if (PSD_SPECTRO == exist(opimode)) /* MR Spectroscopy Mode */
        {
            psd_relative_excited_volume_freq  = _psd_relative_excited_volume_freq.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_freq) : 1.0;
            psd_relative_excited_volume_phase  = _psd_relative_excited_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_phase) : 1.0;
            psd_relative_excited_volume_slice  = _psd_relative_excited_volume_slice.fixedflag ?  ((void)(1.0), psd_relative_excited_volume_slice) : 1.0;

            psd_relative_encoded_volume_freq  = _psd_relative_encoded_volume_freq.fixedflag ?  ((void)(1.0), psd_relative_encoded_volume_freq) : 1.0;
            psd_relative_encoded_volume_phase  = _psd_relative_encoded_volume_phase.fixedflag ?  ((void)(1.0), psd_relative_encoded_volume_phase) : 1.0;
            psd_relative_encoded_volume_slice  = _psd_relative_encoded_volume_slice.fixedflag ?  ((void)(1.0), psd_relative_encoded_volume_slice) : 1.0;
        }
    }


    /* reinitialize sat and prescan vars in case loggrd changed */
    if(SpSatInit(vrgsat) == FAILURE) return FAILURE;

    { /* Start of code inlined from ChemSat.e ChemSatInit */
        cyc_rfcssat  = _cyc_rfcssat.fixedflag ?  ((void)(1), cyc_rfcssat) : 1;
        alpha_rfcssat  = _alpha_rfcssat.fixedflag ?  ((void)(0.46), alpha_rfcssat) : 0.46;
	
        /* SVBranch HCSDM00091804: Duo Chemical Saturation */
	if (PSD_ON == duo_cs_flag)
	{
		n_cspulses  = _n_cspulses.fixedflag ?  ((void)(2), n_cspulses) : 2;
	}else
	{
		n_cspulses  = _n_cspulses.fixedflag ?  ((void)(1), n_cspulses) : 1;
	}


        /* vmx 3/13/95 YI */
        if(cfpwrmontyp == PMTYP_VMX) 
        {
            csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
            rfupa = csat_rfupa;
        }
        /* end vmx */

        if (B0_30000 == cffield)
        {
            cs_dda_flip  = _cs_dda_flip.fixedflag ?  ((void)(75), cs_dda_flip) : 75;
        }
        else
        {
            cs_dda_flip  = _cs_dda_flip.fixedflag ?  ((void)(90), cs_dda_flip) : 90;
        }
    } /* End of code inlined from ChemSat.e ChemSatInit */

    { /* Start of code inlined from Prescan.e PScvinit */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScvinit                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cvinit() must be written here.                     *
         *********************************************************************/
        
        cvdef(mpsfov, cfsystemmaxfov);
        cvdef(FTGfov, cfsystemmaxfov);
        
        FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

        pipscshimtgnub = PSD_ON;
        if(PSD_SPECTRO == exist(opimode))
        {
            pipscshimtgnub = PSD_OFF;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));

        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if( (cffield == B0_30000) && 
            (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_SPINE) && strstr(attribute_codeMeaning, "Lumbar spine")) &&
            (PSD_OFF == local_tg) )
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }
        else
        {
            enableMapTg  = _enableMapTg.fixedflag ?  ((void)(PSD_OFF), enableMapTg) : PSD_OFF;
        }

        PScvinit();
        FTGcvinit();
        XTGcvinit();
        AScvinit();
        RGcvinit();
        RScvinit();
        DTGcvinit();
        AutoCoilcvinit();
        ExtCalcvinit();
    } /* End of code inlined from Prescan.e PScvinit */

    { /* Start of code inlined from Inversion_new.e InversionInit */
        /* vmx 3/13/95 YI */
        if( cfpwrmontyp == PMTYP_VMX ) 
        {
            ir_sys_type  = _ir_sys_type.fixedflag ?  ((void)(1), ir_sys_type) : 1;
            rfupa = ir_rfupa;
        }
        /* end vmx */

        /* Initialize rf structure */
        pw_rf0      = _pw_rf0.fixedflag ?  ((void)(PSD_INV_RF0_PW), pw_rf0) : PSD_INV_RF0_PW; 
        cyc_rf0     = _cyc_rf0.fixedflag ?  ((void)(2.0), cyc_rf0) : 2.0;
        pw_gzrf0    = _pw_gzrf0.fixedflag ?  ((void)(pw_rf0), pw_gzrf0) : pw_rf0;
        pw_gzrf0a   = _pw_gzrf0a.fixedflag ?  ((void)(loggrd.zrt), pw_gzrf0a) : loggrd.zrt;
        pw_gzrf0d   = _pw_gzrf0d.fixedflag ?  ((void)(loggrd.zrt), pw_gzrf0d) : loggrd.zrt;
        gscale_rf0  = _gscale_rf0.fixedflag ?  ((void)(0.87*csf_fact), gscale_rf0) : 0.87*csf_fact;	
        res_rf0     = _res_rf0.fixedflag ?  ((void)(RES_SILVER), res_rf0) : RES_SILVER;

        if ( (cffield == B0_30000) && (PSD_OFF == exist(opflair)) )
        {
            if( (PSD_XRMB_COIL == cfgcoiltype) 
                && ( ((TX_POS_XIPHOID == getTxPosition()) || (TX_POS_HEAD_XIPHOID == getTxPosition()) || (TX_POS_BODY == getTxPosition())) 
                     || ((TX_COIL_BODY == getTxCoilType()) && (RX_COIL_BODY == getRxCoilType())) ) )
            {
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(180.0), flip_rf0) : 180.0;
            }
            else
            {
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(220.0), flip_rf0) : 220.0;
            }
        }
        else
        {
            flip_rf0  = _flip_rf0.fixedflag ?  ((void)(180.0), flip_rf0) : 180.0;
        }

        /* set num fields and activity for RF0 based on IR flag */
        if (ir_on == PSD_ON)
        {
            rfpulse[RF0_SLOT].num = 1;
            rfpulse[RF0_SLOT].activity = PSD_SCAN_ON;
           /*  rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF; */ /*MRIge92242 - set in Prescan.e */
            gradz[GZRF0_SLOT].num = 1;   
            grady[GYK0_SLOT].num = 1;   
        }
        else
        { 
            rfpulse[RF0_SLOT].num = 0;
            rfpulse[RF0_SLOT].activity = PSD_PULSE_OFF;
           /*  rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF; */
            gradz[GZRF0_SLOT].num = 0;   
            grady[GYK0_SLOT].num = 0;   
        }

        /* Round to gradient update time*/
        pw_rf0  = _pw_rf0.fixedflag ?  ((void)(RUP_RF((int)rint((double)pw_rf0/(double)res_rf0))*res_rf0), pw_rf0) : RUP_RF((int)rint((double)pw_rf0/(double)res_rf0))*res_rf0;

    } /* End of code inlined from Inversion_new.e InversionInit */


    if (mux_flag == PSD_OFF) {
        if ( (exist(oppseq) == PSD_SE) || (exist(opflip) > 30) )
        {
            pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_SE_RF1_PW), pw_rf1) : PSD_SE_RF1_PW;
            res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_SE_RF1_R), res_rf1) : PSD_SE_RF1_R;
            gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(.90), gscale_rf1) : .90;
            flip_rf1  = _flip_rf1.fixedflag ?  ((void)(90.0), flip_rf1) : 90.0;
            hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_SE_RF1_LEFT), hrf1a) : PSD_SE_RF1_LEFT;
            hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_SE_RF1_RIGHT), hrf1b) : PSD_SE_RF1_RIGHT;
            a_rf1  = _a_rf1.fixedflag ?  ((void)(0.5), a_rf1) : 0.5;
            rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
            sprintf(ssrffile, "/usr/g/bin/rffl901mc.rho");
            sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
        }
        else
        {
            pw_rf1  = _pw_rf1.fixedflag ?  ((void)(PSD_GR_RF1_PW), pw_rf1) : PSD_GR_RF1_PW;
            res_rf1  = _res_rf1.fixedflag ?  ((void)(PSD_GR_RF1_R), res_rf1) : PSD_GR_RF1_R;
            gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(.90), gscale_rf1) : .90;
            flip_rf1  = _flip_rf1.fixedflag ?  ((void)(30.0), flip_rf1) : 30.0;
            hrf1a  = _hrf1a.fixedflag ?  ((void)(PSD_GR_RF1_LEFT), hrf1a) : PSD_GR_RF1_LEFT;
            hrf1b  = _hrf1b.fixedflag ?  ((void)(PSD_GR_RF1_RIGHT), hrf1b) : PSD_GR_RF1_RIGHT;
            a_rf1  = _a_rf1.fixedflag ?  ((void)(0.5), a_rf1) : 0.5;
            rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
            sprintf(ssrffile, "/usr/g/bin/rfgr30l.rho");
            sprintf(ssgzfile, "/usr/g/bin/rfempty1.gz");
        }
        mux_slices_rf1  = _mux_slices_rf1.fixedflag ?  ((void)(1), mux_slices_rf1) : 1;
        mux_slices_rf2  = _mux_slices_rf2.fixedflag ?  ((void)(1), mux_slices_rf2) : 1;
    }
    else {
        gscale_rf1  = _gscale_rf1.fixedflag ?  ((void)(1.0), gscale_rf1) : 1.0;
    }

    /* HCSDM00361682 */
    /* Pulse width of FOCUS RF pulse for 1 acq is longer than for 2 acqs.
       rfov_type is determined in rfov_cveval() depending on acqs.
       But acqs is calculated in cveval1().
       If the condition is under marginally condition between 1acq and 2acqs
       the result of selection of rfov_type and acqs had conflict.
       That caused oscillation of results of cveval(), long UI response, wrong excitation
       and resulted in acquireing noise images.
       Detect oscillation here and set condition to larger acqs and smaller avmaxslquant.
       In predownload() no parameters should be changed, keep the oscillation mode flag
       and call cveval() from predownload() once oscillation is detected.
       Fix for HCSDM00361682 is rather tricky fix so appropriate fix with structual design change
       will be desired in the future. */
    if(rfov_flag)
    {
        focus_eval_oscil = _focus_eval_oscil.fixedflag ?  ((void)(0), focus_eval_oscil) : 0;
        oscil_eval_count  = _oscil_eval_count.fixedflag ?    ((void)(oscil_eval_count+1), oscil_eval_count) : oscil_eval_count+1;
        if( ((exist(optr) != optr_save) || (exist(opslquant) != opslquant_save)) && (0 == isPredownload) )
        {
            reset_oscil_in_eval  = _reset_oscil_in_eval.fixedflag ?  ((void)(1), reset_oscil_in_eval) : 1;
            oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(1), oscil_eval_count) : 1;
        }
        if(MAXINT == oscil_eval_count)
        {
            oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(0), oscil_eval_count) : 0;
        }
        if(keep_focus_eval_oscil)
        {
            focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(keep_focus_eval_oscil), focus_eval_oscil) : keep_focus_eval_oscil;
        }
        else
        {
            if((avmaxslquant_hist[0] == avmaxslquant_hist[2]) && (acqs_hist[0] == acqs_hist[2]) &&
                (avmaxslquant_hist[0] != avmaxslquant_hist[1]) && (acqs_hist[0] != acqs_hist[1]))
            {
                focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(1), focus_eval_oscil) : 1;
            }
            if( (((avmaxslquant_hist[0] == avmaxslquant_hist[1]) && (avmaxslquant_hist[2] == avmaxslquant_hist[3]) && (avmaxslquant_hist[1] != avmaxslquant_hist[2])) ||
                  ((avmaxslquant_hist[0] == avmaxslquant_hist[3]) && (avmaxslquant_hist[1] == avmaxslquant_hist[2]) && (avmaxslquant_hist[0] != avmaxslquant_hist[1]))) &&
                 (((acqs_hist[0] == acqs_hist[1]) && (acqs_hist[2] == acqs_hist[3]) && (acqs_hist[1] != acqs_hist[2])) ||
                  ((acqs_hist[0] == acqs_hist[3]) && (acqs_hist[1] == acqs_hist[2]) && (acqs_hist[0] != acqs_hist[1]))) )
            {
                if(oscil_eval_count > 3)
                {
                    focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(2), focus_eval_oscil) : 2;
                }
            }
        }
        if(focus_eval_oscil)
        {
            focus_eval_oscil_hist  = _focus_eval_oscil_hist.fixedflag ?  ((void)(1), focus_eval_oscil_hist) : 1;
            if(1 == focus_eval_oscil)
            {
                force_acqs  = _force_acqs.fixedflag ?  ((void)(IMax(2,acqs_hist[0],acqs_hist[1])), force_acqs) : IMax(2,acqs_hist[0],acqs_hist[1]);
                force_avmaxslquant  = _force_avmaxslquant.fixedflag ?  ((void)(IMin(2,avmaxslquant_hist[0],avmaxslquant_hist[1])), force_avmaxslquant) : IMin(2,avmaxslquant_hist[0],avmaxslquant_hist[1]);
            }
            else if(2 == focus_eval_oscil)
            {
                force_acqs  = _force_acqs.fixedflag ?  ((void)(IMax(3,acqs_hist[0],acqs_hist[1],acqs_hist[2])), force_acqs) : IMax(3,acqs_hist[0],acqs_hist[1],acqs_hist[2]);
                force_avmaxslquant  = _force_avmaxslquant.fixedflag ?  ((void)(IMin(3,avmaxslquant_hist[0],avmaxslquant_hist[1],avmaxslquant_hist[2])), force_avmaxslquant) : IMin(3,avmaxslquant_hist[0],avmaxslquant_hist[1],avmaxslquant_hist[2]);
            }
            if(1 == reset_oscil_in_eval)
            {
                focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(0), focus_eval_oscil) : 0;
            }
            else
            {
                acqs  = _acqs.fixedflag ?  ((void)(force_acqs), acqs) : force_acqs;
                avmaxslquant = force_avmaxslquant;
            }
            if( (1 == isPredownload) || ((0 == isPredownload) && (0 == reset_oscil_in_eval) && (PSD_OFF == exist(opinrangetr))) )
            {
                keep_focus_eval_oscil  = _keep_focus_eval_oscil.fixedflag ?  ((void)(focus_eval_oscil), keep_focus_eval_oscil) : focus_eval_oscil;
            }
            else
            {
                keep_focus_eval_oscil  = _keep_focus_eval_oscil.fixedflag ?  ((void)(0), keep_focus_eval_oscil) : 0;
            }
            oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(0), oscil_eval_count) : 0;
        }
    }
    else
    {
        focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(0), focus_eval_oscil) : 0;
        keep_focus_eval_oscil  = _keep_focus_eval_oscil.fixedflag ?  ((void)(0), keep_focus_eval_oscil) : 0;
        focus_eval_oscil_hist  = _focus_eval_oscil_hist.fixedflag ?  ((void)(0), focus_eval_oscil_hist) : 0;
        oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(0), oscil_eval_count) : 0;
    }

    /* Initialize RFOV parameters, and set hrf1a & hrf1b, etc. */
    if (FAILURE == rfov_cveval())
    {
        return FAILURE;
    }


    gztype  = _gztype.fixedflag ?  ((void)(PLAY_TRAP), gztype) : PLAY_TRAP;
    thetatype  = _thetatype.fixedflag ?  ((void)(NO_THETA), thetatype) : NO_THETA;
    pw_rf2  = _pw_rf2.fixedflag ?   ((void)(3200), pw_rf2) : 3200; 
    res_rf2  = _res_rf2.fixedflag ?  ((void)(RES_SE1B4_RF2), res_rf2) : RES_SE1B4_RF2;
    gscale_rf2  = _gscale_rf2.fixedflag ?  ((void)(.90), gscale_rf2) : .90;
    flip_rf2  = _flip_rf2.fixedflag ?  ((void)(180.0), flip_rf2) : 180.0;
    hrf2a  = _hrf2a.fixedflag ?  ((void)(pw_rf2/2), hrf2a) : pw_rf2/2;
    hrf2b  = _hrf2b.fixedflag ?  ((void)(pw_rf2/2), hrf2b) : pw_rf2/2;
    a_rf2  = _a_rf2.fixedflag ?  ((void)(1.0), a_rf2) : 1.0;
    alpha_rf2  = _alpha_rf2.fixedflag ?  ((void)(0.46), alpha_rf2) : 0.46;
  
    /* MRIge81510 (HD) spsp pulse for 1.5T */
    /* BJM: change pulse if possible */
    if (cfsrmode >= PSD_SR100 || ((cfsrmode == PSD_SR50) && (isStarterSystem()))) {
        /* turn on 1.5T delay insensitive RF pulse */
        if (cffield ==  B0_15000) {
            ss_override  = _ss_override.fixedflag ?  ((void)(1), ss_override) : 1;
        } else {
	    ss_override  = _ss_override.fixedflag ?  ((void)(0), ss_override) : 0;   /* 3T is already delay insensitive */
        }

    } else {

        ss_override   = _ss_override.fixedflag ?  ((void)(0), ss_override) : 0;

    }
								    
    if (exist(oppseq) == PSD_SE || (exist(opflip)>30) ) 
    { 
        INT num_rf2 = 1.0;
        
        /* DTI BJM: (dsp) count pulses correctly */
        if (PSD_ON == dualspinecho_flag)
        {
            num_rf2 = 2.0;

            if (ssgr_flag && ssgr_bw_update)
            {
                int temp_pw;
                temp_pw = RUP_GRD((int)(NOM_BW_SE1B4 * (float)PSD_NOM_PW_SE1B4/
                                  (rf2_bw_ratio*fat_cs*cffield/B0_15000-2.0*b0_offset)));

                if(temp_pw > pw_rf2)
                {
                    pw_rf2  = _pw_rf2.fixedflag ?  ((void)(temp_pw), pw_rf2) : temp_pw;
                }
            }
        }
        else
        {
            num_rf2 = 1.0;
            if (ssgr_flag && ssgr_bw_update)
            {
                int temp_pw;
                temp_pw = RUP_GRD((int)(NOM_BW_FL901MC_RF1 * (float)PSD_NOM_PW_FL901MC/
                                  (rf1_bw_ratio*fat_cs*cffield/B0_15000-2.0*b0_offset)));
                if(temp_pw > pw_rf1)
                {        
                    pw_rf1  = _pw_rf1.fixedflag ?  ((void)(temp_pw), pw_rf1) : temp_pw; 
                } 
                temp_pw = RUP_GRD((int)(NOM_BW_SE1B4 * (float)PSD_NOM_PW_SE1B4/
                                  (rf2_bw_ratio*fat_cs*cffield/B0_15000-2.0*b0_offset)));
                if(temp_pw > pw_rf2)
                {
                    pw_rf2  = _pw_rf2.fixedflag ?  ((void)(temp_pw), pw_rf2) : temp_pw;
                }
            }
        }

        if (rfov_flag)
        {
            setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp456_pw_rf1=pw_rf1,&_temp456_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp457_a_rf1=a_rf1,&_temp457_a_rf1) : &a_rf1, ex_abswidth, ex_effwidth, ex_area,
                         ex_dtycyc, ex_maxpw, 1, ex_max_b1, ex_max_int_b1_sqr, ex_max_rms_b1,
                         ex_nom_flip, _flip_rf1.fixedflag ? (_temp458_flip_rf1=flip_rf1,&_temp458_flip_rf1) : &flip_rf1, (float) pw_rf1, bw_rf1,
                         PSD_APS2_ON+PSD_MPS2_ON+PSD_SCAN_ON, (char ) 0, hrf1b, 1.0,
                         _res_rf1.fixedflag ? (_temp459_res_rf1=res_rf1,&_temp459_res_rf1) : &res_rf1, 1, _wg_rf1.fixedflag ? (_temp460_wg_rf1=wg_rf1,&_temp460_wg_rf1) : &wg_rf1, 1, rfpulse);
            /*** SVBranch: HCSDM00259122  - FOCUS walk sat ***/         
            if ( (walk_sat_flag) && (rfov_flag) )
            {          
                setuprfpulse(RFWK_SLOT,             /* index into rfpulse structure array */
                             _pw_rfwk.fixedflag ? (_temp461_pw_rfwk=pw_rfwk,&_temp461_pw_rfwk) : &pw_rfwk,              /* pointer to pulse width (us) */
                             _a_rfwk.fixedflag ? (_temp462_a_rfwk=a_rfwk,&_temp462_a_rfwk) : &a_rfwk,               /* pointer to amplitude (relative) */
                             SAR_ABSWIDTH_RFWK,
                             SAR_EFFWIDTH_RFWK,
                             SAR_AREA_RFWK,         
                             SAR_DTYCYC_RFWK,       
                             SAR_MAXPW_RFWK, 
                             1,                       /* quantity of this type of RF pulse */
                             SAR_MAX_B1_RFWK, 
                             SAR_MAX_INT_B1_SQ_RFWK, 
                             SAR_MAX_RMS_B1_RFWK,
                             SAR_NOM_FA_RFWK, 
                             _flip_rfwk.fixedflag ? (_temp463_flip_rfwk=flip_rfwk,&_temp463_flip_rfwk) : &flip_rfwk,             /* pointer to actual flip angle */
                             SAR_NOM_PW_RFWK, 
                             SAR_NOM_BW_RFWK,
                             PSD_APS2_ON+PSD_MPS2_ON+PSD_SCAN_ON,
                             (char) 0,                /* flag for pulse used in TG setting */
                             hrfwkb,                  /* iso-delay */
                             1.0,                     /* duty cycle scale factor */
                             _res_rfwk.fixedflag ? (_temp464_res_rfwk=res_rfwk,&_temp464_res_rfwk) : &res_rfwk,            
                             0,                       /* external grad wave or not */
                             _wg_rfwk.fixedflag ? (_temp465_wg_rfwk=wg_rfwk,&_temp465_wg_rfwk) : &wg_rfwk,                /* pointer to sequencer type */
                             2,                       /* Hadamard Factor */
                             rfpulse);                               
            }                             
            /****************************/                         

            if (focus_B0_robust_mode)
            {
                float bw_rf2_temp = 0.0;

                focus_unwanted_delta_f  = _focus_unwanted_delta_f.fixedflag ?  ((void)(SDL_GetChemicalShift(cffield)), focus_unwanted_delta_f) : SDL_GetChemicalShift(cffield);
                bw_rf2_temp = bw_rf1 * focus_unwanted_delta_f/ (focus_unwanted_delta_f - bw_rf1);
                pw_rf2  = _pw_rf2.fixedflag ?     ((void)(RUP_GRD((int)(rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/bw_rf2_temp))), pw_rf2) : RUP_GRD((int)(rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/bw_rf2_temp));
                hrf2a  = _hrf2a.fixedflag ?  ((void)(pw_rf2/2), hrf2a) : pw_rf2/2;
                hrf2b  = _hrf2b.fixedflag ?  ((void)(pw_rf2/2), hrf2b) : pw_rf2/2;
            }
        }
        else
        {
            if (mux_flag == PSD_OFF) {
                setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp466_pw_rf1=pw_rf1,&_temp466_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp467_a_rf1=a_rf1,&_temp467_a_rf1) : &a_rf1, SAR_ABS_FL901MC, SAR_PFL901MC,
                             SAR_AFL901MC, SAR_DTYCYC_FL901MC, SAR_MAXPW_FL901MC, 1,
                             MAX_B1_FL901MC_90, MAX_INT_B1_SQ_FL901MC_90,
                             MAX_RMS_B1_FL901MC_90, 90.0, _flip_rf1.fixedflag ? (_temp468_flip_rf1=flip_rf1,&_temp468_flip_rf1) : &flip_rf1, (float)PSD_NOM_PW_FL901MC,
                             NOM_BW_FL901MC_RF1, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON,
                             0, hrf1b, 1.0, _res_rf1.fixedflag ? (_temp469_res_rf1=res_rf1,&_temp469_res_rf1) : &res_rf1, 0, _wg_rf1.fixedflag ? (_temp470_wg_rf1=wg_rf1,&_temp470_wg_rf1) : &wg_rf1, 1, rfpulse);
            }
        }
        if (mux_flag == PSD_OFF) {
            setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp471_pw_rf2=pw_rf2,&_temp471_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp472_a_rf2=a_rf2,&_temp472_a_rf2) : &a_rf2, SAR_ABS_SE1B4, SAR_PSE1B4,
                         SAR_ASE1B4, SAR_DTYCYC_SE1B4, SAR_MAXPW_SE1B4, 1,
                         MAX_B1_SE1B4_180, MAX_INT_B1_SQ_SE1B4_180,
                         MAX_RMS_B1_SE1B4_180, 180.0, _flip_rf2.fixedflag ? (_temp473_flip_rf2=flip_rf2,&_temp473_flip_rf2) : &flip_rf2, (float)PSD_NOM_PW_SE1B4,
                         NOM_BW_SE1B4, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                         hrf2b, 1.0, _res_rf2.fixedflag ? (_temp474_res_rf2=res_rf2,&_temp474_res_rf2) : &res_rf2, 0, _wg_rf2.fixedflag ? (_temp475_wg_rf2=wg_rf2,&_temp475_wg_rf2) : &wg_rf2, 1, rfpulse);
            verse_rf2  = _verse_rf2.fixedflag ?  ((void)(0), verse_rf2) : 0;
        } 

        /* DTI BJM: (dsp) set up rf waveform amps */
        if (PSD_ON == dualspinecho_flag)
        {
            a_rf2left  = _a_rf2left.fixedflag ?  ((void)(a_rf2), a_rf2left) : a_rf2;
            a_rf2right  = _a_rf2right.fixedflag ?  ((void)(a_rf2left), a_rf2right) : a_rf2left;
        }

    } 
    else 
    {
        setuprfpulse(RF1_SLOT, _pw_rf1.fixedflag ? (_temp476_pw_rf1=pw_rf1,&_temp476_pw_rf1) : &pw_rf1, _a_rf1.fixedflag ? (_temp477_a_rf1=a_rf1,&_temp477_a_rf1) : &a_rf1, SAR_ABS_GR30L, SAR_PGR30L,
                     SAR_AGR30L, SAR_DTYCYC_GR30L, SAR_MAXPW_GR30L, 1,
                     MAX_B1_GR30L, MAX_INT_B1_SQ_GR30L, MAX_RMS_B1_GR30L,
                     30.0, _flip_rf1.fixedflag ? (_temp478_flip_rf1=flip_rf1,&_temp478_flip_rf1) : &flip_rf1, (float)PSD_NOM_PW_GR30, NOM_BW_GR30L,
                     PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                     hrf1b, 1.0, _res_rf1.fixedflag ? (_temp479_res_rf1=res_rf1,&_temp479_res_rf1) : &res_rf1, 0, _wg_rf1.fixedflag ? (_temp480_wg_rf1=wg_rf1,&_temp480_wg_rf1) : &wg_rf1, 1, rfpulse);

        if (PSD_OFF == mux_flag)
        {
            setuprfpulse(RF2_SLOT, _pw_rf2.fixedflag ? (_temp481_pw_rf2=pw_rf2,&_temp481_pw_rf2) : &pw_rf2, _a_rf2.fixedflag ? (_temp482_a_rf2=a_rf2,&_temp482_a_rf2) : &a_rf2, SAR_ABS_SE1B4, SAR_PSE1B4,
                         SAR_ASE1B4, SAR_DTYCYC_SE1B4, SAR_MAXPW_SE1B4, 1,
                         MAX_B1_SE1B4_180, MAX_INT_B1_SQ_SE1B4_180,
                         MAX_RMS_B1_SE1B4_180, 180.0, _flip_rf2.fixedflag ? (_temp483_flip_rf2=flip_rf2,&_temp483_flip_rf2) : &flip_rf2, (float)PSD_NOM_PW_SE1B4,
                         NOM_BW_SE1B4, PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON, 0,
                         hrf2b, 1.0, _res_rf2.fixedflag ? (_temp484_res_rf2=res_rf2,&_temp484_res_rf2) : &res_rf2, 0, _wg_rf2.fixedflag ? (_temp485_wg_rf2=wg_rf2,&_temp485_wg_rf2) : &wg_rf2, 1, rfpulse);
        }
    }

    /* Initialize Multiband parameters, setup rf1 & rf2 pulses etc. */
    if (FAILURE == Multiband_cveval(ssgr_mux))
    {
        return FAILURE;
    }

    if (ssInit() == FAILURE) return FAILURE;	

    { /* Start of code inlined from Inversion_new.e InversionEval2 */

        /* **************************************************************
           RF0  CVs and bookkeeping
           ************************************************************* */
        rfpulse[RF0_SLOT].abswidth = 0.4634;
        rfpulse[RF0_SLOT].area = 0.4634;
        rfpulse[RF0_SLOT].effwidth = 0.3099;
        rfpulse[RF0_SLOT].dtycyc = 1.00;
        rfpulse[RF0_SLOT].maxpw = 1.00;
        rfpulse[RF0_SLOT].max_b1 = 0.02934;
     
        rfpulse[RF0_SLOT].nom_fa = 43.82; /* flip angle to make a_rf0/a_rf2=0.825*/
        rfpulse[RF0_SLOT].act_fa = _flip_rf0.fixedflag ? (_temp486_flip_rf0=flip_rf0,&_temp486_flip_rf0) : &flip_rf0;
        rfpulse[RF0_SLOT].nom_pw = PSD_INV_RF0_PW;
        rfpulse[RF0_SLOT].max_rms_b1=0.0163276;
        rfpulse[RF0_SLOT].max_int_b1_sq=0.00230333;

        if ( (cffield == B0_30000) && (PSD_OFF == exist(opflair)) )
        {
            if( (PSD_XRMB_COIL == cfgcoiltype) 
                && ( ((TX_POS_XIPHOID == getTxPosition()) || (TX_POS_HEAD_XIPHOID == getTxPosition()) || (TX_POS_BODY == getTxPosition())) 
                     || ((TX_COIL_BODY == getTxCoilType()) && (RX_COIL_BODY == getRxCoilType())) ) )
            {
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(180), flip_rf0) : 180;
            }
            else
            {
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(220), flip_rf0) : 220;
            }
        }
        else
        {
            flip_rf0  = _flip_rf0.fixedflag ?  ((void)(180), flip_rf0) : 180;
        }

        /* limit to DV platform */
        /* Open it up for HDx- HCSDM00175770 */
        if ( (cfgcoiltype == PSD_XRMB_COIL || cfgcoiltype == PSD_XRMW_COIL || cfgcoiltype == PSD_HRMW_COIL || cfgcoiltype == PSD_VRMW_COIL) || 
             (opweight > 150 && cffield >= B0_30000 && getTxCoilType() == TX_COIL_BODY &&
              cfgcoiltype == PSD_TRM_COIL && ir_on == PSD_ON) )
        {
            float fa_scaling_factor;
            fa_scaling_factor = get_fa_scaling_factor_ir(flip_rf0, rfpulse[RF0_SLOT].nom_fa, rfpulse[RF0_SLOT].max_b1);

            if (ir_fa_scaling_flag)
            {
                flip_rf0  = _flip_rf0.fixedflag ?  ((void)(flip_rf0*fa_scaling_factor), flip_rf0) : flip_rf0*fa_scaling_factor;
                rfpulse[RF0_SLOT].extgradfile = PSD_ON; /* MRIhc18659: No Stretching for Inversion Pulse */
            }
            else if (fa_scaling_factor < 1.0)
            {
                rfpulse[RF0_SLOT].extgradfile = PSD_OFF;
            }
            else
            {
                rfpulse[RF0_SLOT].extgradfile = PSD_ON; /* MRIhc18659: No Stretching for Inversion Pulse */
            }

            if (ir_fa_scale_debug == PSD_ON)
            {
                FILE *fp;
                fp = fopen("/usr/g/service/log/fa_scale","ab");
                if (fp!=NULL)
                {
                    fprintf(fp,"\n *********** IR FA scaling ********************");
                    fprintf(fp,"\n fa_scaling_factor  = %f", fa_scaling_factor);
                    fprintf(fp,"\n New FA             = %f", flip_rf0);
                    fprintf(fp,"\n Initial FA         = %f", (flip_rf0/fa_scaling_factor));
                    fclose(fp);
                }
            }
        }
        else
        {
            rfpulse[RF0_SLOT].extgradfile = PSD_ON; /* MRIhc18659: No Stretching for Inversion Pulse */
        }

    } /* End of code inlined from Inversion_new.e InversionEval2 */

    
    /* Check to see if rf pw's need scaling for large patients */
    for (entry=0; entry<MAX_ENTRY_POINTS; entry ++)
        scalerfpulses(opweight,cfgcoiltype,RF_FREE,rfpulse,entry,rfpulseInfo);
        
    /*** SVBranch: HCSDM00259122 - FOCUS walk sat calc ***/
    if ( (walk_sat_flag) && (rfov_flag) )
    {
        if ( FAILURE == walk_sat_cveval() ) return FAILURE;      
    }  
    /*********************************/        
  
    /* DTI BJM: (dsp) dual spin echo */
    if (PSD_ON == dualspinecho_flag)
    {
        pw_rf2left  = _pw_rf2left.fixedflag ?  ((void)(pw_rf2), pw_rf2left) : pw_rf2;
        pw_rf2right  = _pw_rf2right.fixedflag ?  ((void)(pw_rf2left), pw_rf2right) : pw_rf2left;
        
        res_rf2left  = _res_rf2left.fixedflag ?  ((void)(res_rf2), res_rf2left) : res_rf2;
        res_rf2right  = _res_rf2right.fixedflag ?  ((void)(res_rf2left), res_rf2right) : res_rf2left;

        flip_rf2left  = _flip_rf2left.fixedflag ?  ((void)(flip_rf2), flip_rf2left) : flip_rf2;
        flip_rf2right  = _flip_rf2right.fixedflag ?  ((void)(flip_rf2left), flip_rf2right) : flip_rf2left;

        /* MRIge70042 set value back to 0.9 */
        /* gscale_rf2 = 1.1; */
    }
       
  
    /* If pulse width of 90 scaled, then scale off90 accordingly */
    if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
        off90  = _off90.fixedflag ?    ((void)((int)rint(pw_rf1/rfpulse[RF1_SLOT].nom_pw)), off90) : off90*(int)rint(pw_rf1/rfpulse[RF1_SLOT].nom_pw);
    
    /*	iso_delay = pw_rf1/2 + off90; */
    
    /* Inner volume selective pulse */
    pw_gyrf2iv  = _pw_gyrf2iv.fixedflag ?  ((void)(pw_rf2), pw_gyrf2iv) : pw_rf2;
    off90  = _off90.fixedflag ?  ((void)(0), off90) : 0;
   
    pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
    pw_gzrf2  = _pw_gzrf2.fixedflag ?  ((void)(pw_rf2), pw_gzrf2) : pw_rf2;

    /* DTI BJM (dsp) */ 
    pw_gzrf2left  = _pw_gzrf2left.fixedflag ?  ((void)(pw_rf2left), pw_gzrf2left) : pw_rf2left;
    pw_gzrf2right  = _pw_gzrf2right.fixedflag ?  ((void)(pw_rf2right), pw_gzrf2right) : pw_rf2right;

    /* HCSDM00190059 */
    if(rfov_flag == PSD_OFF && mux_flag == PSD_OFF)
    {
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(exist(opflip)), flip_rf1) : exist(opflip);
    }
    
    if (ssEval1() == FAILURE) return FAILURE;  /* Redefine area_gz1, bw_rf1, 
                                                  hrf1a, hrf1b and other parameters for spectral-spatial pulse. */

    /* Make sure the true bandwidths are up to date. */
    bw_rf1  = _bw_rf1.fixedflag ?  ((void)(rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1), bw_rf1) : rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1;
    bw_rf2  = _bw_rf2.fixedflag ?  ((void)(rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/pw_rf2), bw_rf2) : rfpulse[RF2_SLOT].nom_bw*rfpulse[RF2_SLOT].nom_pw/pw_rf2;
    
    /* time from the start of the excitation pulse to the magnetic isocenter */
    t_exa  = _t_exa.fixedflag ?    ((void)(hrf1a-off90), t_exa) : hrf1a-off90;
 
    rfExIso  = _rfExIso.fixedflag ?    ((void)(hrf1b+off90), rfExIso) : hrf1b+off90;
    
    /* auto min te and tr */
    
    if ( exist(opautote) == PSD_MINTE || exist(opautote) == PSD_MINTEFULL )
    {
        setexist(opte,PSD_OFF);
    }
    
    if (exist(opfcomp) == PSD_ON && existcv(opfcomp)) 
    {
        zgmn_type  = _zgmn_type.fixedflag ?  ((void)(CALC_GMN1), zgmn_type) : CALC_GMN1;
        ygmn_type  = _ygmn_type.fixedflag ?  ((void)(CALC_GMN1), ygmn_type) : CALC_GMN1;
    } 
    else 
    {
        zgmn_type  = _zgmn_type.fixedflag ?  ((void)(NO_GMN), zgmn_type) : NO_GMN;
        ygmn_type  = _ygmn_type.fixedflag ?  ((void)(NO_GMN), ygmn_type) : NO_GMN;
    }
    
    pw_gzrf2a  = _pw_gzrf2a.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2a) : RUP_GRD(loggrd.zrt);
    pw_gzrf2d  = _pw_gzrf2d.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2d) : RUP_GRD(loggrd.zrt);
    pw_gzrf2r1a  = _pw_gzrf2r1a.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2r1a) : RUP_GRD(loggrd.zrt); 
    pw_gzrf2r1d  = _pw_gzrf2r1d.fixedflag ?  ((void)(RUP_GRD(loggrd.zrt)), pw_gzrf2r1d) : RUP_GRD(loggrd.zrt);

    /* Seqtype(MPMP, XRR, NCAT,CAT  needed for several routines */
    if (seqtype(_seq_type.fixedflag ? (_temp487_seq_type=seq_type,&_temp487_seq_type) : &seq_type) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "seqtype" );
        return FAILURE;
    }
    
    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
    ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_TOP_DOWN), ky_dir) : PSD_TOP_DOWN;
    
    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
        ep_alt  = _ep_alt.fixedflag ?  ((void)(2), ep_alt) : 2;   /*1st half +, second half - */
    else
        ep_alt  = _ep_alt.fixedflag ?  ((void)(0), ep_alt) : 0;
    
    nexcalc();
    
    /* X readout train */
    
    if (vrgfsamp == 0) 
    {  /* epigradopt will set this properly for vrg */
        rhfrsize  = _rhfrsize.fixedflag ?  ((void)(exist(opxres)), rhfrsize) : exist(opxres);
    }
    rampsamp  = _rampsamp.fixedflag ?  ((void)(vrgfsamp), rampsamp) : vrgfsamp;
    
    if (vrgfsamp == 1 && !vrgf_bwctrl)
    {   /* turn off bandwidth buttons & rbw advisory */
        pircbnub = 0;
        piadvmax = (piadvmax & ~(1<<PSD_ADVRCVBW)); 
        piadvmin = (piadvmin & ~(1<<PSD_ADVRCVBW)); 
        
        _oprbw.existflag = PSD_OFF;  /* BJM MRIge50916 */
    }
    else
    {
        pircbnub = 5;
        piadvmax = (piadvmax | (1<<PSD_ADVRCVBW));
        piadvmin = (piadvmin | (1<<PSD_ADVRCVBW));
    }

    /* MPG and EPI readout gradient needs to be derated for SSSPS lifetime */
    if ( (5550 == cfgradamp) && (!mkgspec_x_gmax_flag && !mkgspec_y_gmax_flag && !mkgspec_z_gmax_flag) )
    {
        int MAX_ITER = 5;             /* number of iteration for MPG pulse width estimation */

        int iter = 0;                 /* iteration index for MPG pulse width estimation */
        float est_epi_duration = 0.0; /* Estimated EPI duration [ms] */
        float est_mpg_duration = 0.0; /* Estimated MPG duration [ms] */
        float temp_gmax = 0.0;        /* Highest gradient amplitude limit [G/cm] */
        float temp_gmin = 0.0;        /* Lowest gradient amplitude limit [G/cm] */
        float temp_glim = 0.0;        /* Temporary gradient amplitude limit [G/cm] */
        float time_thresh = 0.0;      /* Time threshold to start derating [ms] */
        float time_const = 0.0;       /* Time constant in derating equation [ms] */
        float c1 = 0.0;               /* 1st fitting parameter for MPG pulse width */
        float c2 = 0.0;               /* 2nd fitting parameter for MPG pulse width */

        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) || ((opdfaxall > PSD_OFF) && (PSD_ON == gradopt_diffall)))
        {
            if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
            {
                temp_gmax = 3.0;
                temp_gmin = 2.02;
                time_thresh = 25.0;
                time_const = 18.0;

                if (PSD_ON == dualspinecho_flag)
                {
                    c1 = 1692.7;
                    c2 = 0.3498;
                }
                else if (PSD_ON == rfov_flag)
                {
                    c1 = 972.00;
                    c2 = 0.4060;
                }
                else
                {
                    c1 = 543.51;
                    c2 = 0.4598;
                }
            }
            else /* gradopt */
            {
                temp_gmax = 3.0;
                temp_gmin = 2.4;
                time_thresh = 40.0;
                time_const = 18.0;

                if (PSD_ON == dualspinecho_flag)
                {
                    c1 = 1994.9;
                    c2 = 0.3465;
                }
                else if (PSD_ON == rfov_flag)
                {
                    c1 = 1225.0;
                    c2 = 0.3958;
                }
                else
                {
                    c1 = 717.68;
                    c2 = 0.4459;
                }
            }

            adaptive_mpg_glim  = _adaptive_mpg_glim.fixedflag ?  ((void)(temp_gmax), adaptive_mpg_glim) : temp_gmax;

            /* empirical MPG duration under MPG amplitude is temp_gmax */
            est_mpg_duration = 0.001 * 2.0 * c1 * powf(max_bval, c2);

            if (est_mpg_duration > time_thresh)
            {
                for (iter = 0; iter < MAX_ITER; iter++)
                {
                    temp_glim = adaptive_mpg_glim;

                    adaptive_mpg_glim  = _adaptive_mpg_glim.fixedflag ?      
                                           ((void)(temp_gmin+(temp_gmax-temp_gmin)*exp(-(est_mpg_duration-time_thresh)/time_const)), adaptive_mpg_glim) : temp_gmin+(temp_gmax-temp_gmin)*exp(-(est_mpg_duration-time_thresh)/time_const);

                    /* suppose MPG area doesn't change a lot by MPG derating */
                    est_mpg_duration = est_mpg_duration * temp_glim/ adaptive_mpg_glim;
                }
            }

            epi_loggrd_glim  = _epi_loggrd_glim.fixedflag ?  ((void)(3.0), epi_loggrd_glim) : 3.0;
        }
        else
        {
            temp_gmax = 3.3;
            temp_gmin = 2.8;
            time_thresh = 113.5;
            time_const = 30.0;

            adaptive_mpg_glim  = _adaptive_mpg_glim.fixedflag ?  ((void)(temp_gmin), adaptive_mpg_glim) : temp_gmin;

            if (PSD_ON == vrgfsamp)
            {
                /* empirical ESP value times ETL */
                est_epi_duration = 0.001 * (4.3 * exist(opxres) + 480) * (3.9 * powf(get_act_freq_fov()/ 10.0, -0.5))
                    * (num_overscan + (int)(ceilf(exist(opyres) * asset_factor/ rup_factor) * rup_factor)/ 2)/ intleaves;

                if (PSD_ON == dualspinecho_flag)
                {
                    c1 = 2578.4;
                    c2 = 0.3368;
                }
                else if (PSD_ON == rfov_flag)
                {
                    c1 = 1893.3;
                    c2 = 0.3649;
                }
                else
                {
                    c1 = 1488.6;
                    c2 = 0.3852;
                }

                adaptive_mpg_glim  = _adaptive_mpg_glim.fixedflag ?  ((void)(temp_gmax), adaptive_mpg_glim) : temp_gmax;

                /* empirical MPG duration under MPG amplitude is temp_gmax */
                est_mpg_duration = 0.001 * 2.0 * c1 * powf(max_bval, c2);

                if (est_mpg_duration + est_epi_duration > time_thresh)
                {
                    for (iter = 0; iter < MAX_ITER; iter++)
                    {
                        temp_glim = adaptive_mpg_glim;

                        adaptive_mpg_glim  = _adaptive_mpg_glim.fixedflag ?      
                                                 ((void)(temp_gmin+(temp_gmax-temp_gmin)*exp(-(est_mpg_duration+est_epi_duration-time_thresh)/time_const)), adaptive_mpg_glim) : temp_gmin+(temp_gmax-temp_gmin)*exp(-(est_mpg_duration+est_epi_duration-time_thresh)/time_const);

                        /* suppose MPG area doesn't change a lot by MPG derating */
                        est_mpg_duration = est_mpg_duration * temp_glim/ adaptive_mpg_glim;
                    }
                }
            }

            epi_loggrd_glim  = _epi_loggrd_glim.fixedflag ?  ((void)(adaptive_mpg_glim), epi_loggrd_glim) : adaptive_mpg_glim;
        }

        adaptive_mpg_glim_flag  = _adaptive_mpg_glim_flag.fixedflag ?  ((void)(PSD_ON), adaptive_mpg_glim_flag) : PSD_ON;
        epi_loggrd_glim_flag  = _epi_loggrd_glim_flag.fixedflag ?  ((void)(PSD_ON), epi_loggrd_glim_flag) : PSD_ON;
    }
    else
    {
        adaptive_mpg_glim_flag  = _adaptive_mpg_glim_flag.fixedflag ?  ((void)(PSD_OFF), adaptive_mpg_glim_flag) : PSD_OFF;
        epi_loggrd_glim_flag  = _epi_loggrd_glim_flag.fixedflag ?  ((void)(PSD_OFF), epi_loggrd_glim_flag) : PSD_OFF;
    }

    /* Adaptive SR derating of readout gradient for SSSD */
    if( ((5550 == cfgradamp) && (PSD_ON == exist(opdiffuse))) &&
        (!(mkgspec_x_sr_flag & MK_SPEC_SR_CHANGE) && !(mkgspec_y_sr_flag & MK_SPEC_SR_CHANGE) && !(mkgspec_z_sr_flag & MK_SPEC_SR_CHANGE)) )
    {
        int iter = 0;
        int run_cveval1 = PSD_ON;
        float preset_derate = 1.0;
        static float extra_derate = 1.0;
        static float extra_derate_pre = 1.0;
        float delta_derate = 0.0;

        while(PSD_ON == run_cveval1 && iter < SR_DERATING_MAX_ITER)
        {
            iter = iter + 1;

            epi_srderate_factor  = _epi_srderate_factor.fixedflag ?    ((void)(preset_derate*extra_derate), epi_srderate_factor) : preset_derate*extra_derate;
            extra_derate_pre = extra_derate;

            if(epi_srderate_factor < 0.99)
            {
                epiphygrd.xrt = RUP_GRD(cfrmp2xfs/ epi_srderate_factor);
                epiphygrd.yrt = RUP_GRD(cfrmp2yfs/ epi_srderate_factor);
                epiphygrd.zrt = RUP_GRD(cfrmp2zfs/ epi_srderate_factor);
                epiphygrd.xft = RUP_GRD(cffall2x0/ epi_srderate_factor);
                epiphygrd.yft = RUP_GRD(cffall2y0/ epi_srderate_factor);
                epiphygrd.zft = RUP_GRD(cffall2z0/ epi_srderate_factor);
                epiloggrd.xrt = epiloggrd.yrt = epiloggrd.zrt
                    = RUP_GRD(IMax(3, cfrmp2xfs, cfrmp2yfs, cfrmp2zfs)/ epi_srderate_factor);
                epiloggrd.xft = epiloggrd.yft = epiloggrd.zft
                    = RUP_GRD(IMax(3, cffall2x0, cffall2y0, cffall2z0)/ epi_srderate_factor);

                opnewgeo = 1;
            }

            if (cveval1()==FAILURE) {
                /* don't send ermes so that underlying ermes will be displayed */
                return FAILURE;
            }

            if(FALSE == skip_minseqseg)
            {
                /* Return extra_derate to 1.0 when it's less than 1.0 in 1st iteration.
                   extra_derate should be reduced if required voltage is larger than estimated one.
                   In other cases, quit the loop since under voltage won't occur by reducing EPI SR. */

                if(1 == iter && extra_derate_pre < 0.99)
                {
                    extra_derate = 1.0;
                    run_cveval1 = PSD_ON;
                    iter = 0;
                }
                else if(vol_ratio_est_req < 1.0 && iter < SR_DERATING_MAX_ITER)
                {
                    delta_derate = FMax(2, 0.05, 1.0 - vol_ratio_est_req);
                    delta_derate = FMin(2, 0.1, delta_derate);
                    extra_derate = extra_derate_pre - delta_derate/ preset_derate;
                    run_cveval1 = PSD_ON;
                }
                else
                {
                    run_cveval1 = PSD_OFF;
                }
            }
            else
            {
                /* If waveform and rotation matrix are not updated, it's not necesary to repeat cveval1(). */
                run_cveval1 = PSD_OFF;
            }

            if(PSD_ON == run_cveval1 && iter < SR_DERATING_MAX_ITER)
            {
                enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(PSD_ON), enforce_minseqseg) : PSD_ON;
            }
            else
            {
                enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(PSD_OFF), enforce_minseqseg) : PSD_OFF;
            }

            if((fabs(extra_derate_pre - extra_derate) > 0.01) && (vol_ratio_est_req < 1.0))
            {
                FILE *fp;
                fp = fopen("/usr/g/service/log/GradientSafetyResults.log","a");
                fprintf(fp,"EPI SR derating: iter=%d, preset_derate=%4.2f, extra_derate=%4.2f, derate_factor=%4.2f\n",
                        iter, preset_derate, extra_derate, preset_derate * extra_derate);
                fclose(fp);
            }
        }
    }
    else
    {
        if (cveval1()==FAILURE) {
            /* don't send ermes so that underlying ermes will be displayed */
            return FAILURE;
        }
    }

    /* Under voltage prediction for SSSD */
    /* HCSDM00337293 */
    if( (5550 == cfgradamp && vol_ratio_est_req < 1.0) &&
        (!mkgspec_x_gmax_flag && !mkgspec_y_gmax_flag && !mkgspec_z_gmax_flag) )
    {
        if(pircbnub > 0)
        {
            epic_error(use_ermes,
                       "Too much Gradient Power is required.",
                       EM_PSD_GRADPOWER_FOV_B_BW_FREQ_PHASE, EE_ARGS(0));
        }
        else
        {
            epic_error(use_ermes,
                       "Too much Gradient Power is required.",
                       EM_PSD_GRADPOWER_FOV_B_FREQ_PHASE, EE_ARGS(0));
        }

        return FAILURE;
    }


    if( peakAveSars( &ave_sar, &cave_sar, &peak_sar, &b1rms, (int)RF_FREE,
                     rfpulse, L_SCAN, (int)(act_tr/((mux_flag)?mux_slquant:slquant1)) ) == FAILURE )
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                    EE_ARGS(1), STRING_ARG, "peakAveSars" );
        return FAILURE;

    }

    piasar = (float)ave_sar; /* Report to plasma */
    picasar = (float)cave_sar; /* Coil SAR report to plasma */
    pipsar = (float)peak_sar; /* Report to plasma */
    pib1rms = (float)b1rms; /* Report predicted b1rms value on the UI */
    if (FAILURE == Monitor_Eval( rfpulse, (int)RF_FREE, _monave_sar.fixedflag ? (_temp488_monave_sar=monave_sar,&_temp488_monave_sar) : &monave_sar, _moncave_sar.fixedflag ? (_temp489_moncave_sar=moncave_sar,&_temp489_moncave_sar) : &moncave_sar, _monpeak_sar.fixedflag ? (_temp490_monpeak_sar=monpeak_sar,&_temp490_monpeak_sar) : &monpeak_sar ))
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_Eval");
        return FAILURE;
    }

    /* Report the greater of the scan and Navigator SAR values */
    if (PSD_ON == navtrig_flag)
    {
        if (monave_sar > piasar) {
            piasar = monave_sar;
        }
        if (moncave_sar > picasar) {
            picasar = moncave_sar;
        }
        if (monpeak_sar > pipsar) {
            pipsar = monpeak_sar;
        }
    }

    fecho_factor  = _fecho_factor.fixedflag ?    ((void)((float)(rhnframes+rhhnover)/fullk_nframes), fecho_factor) : (float)(rhnframes+rhhnover)/fullk_nframes;
    
    /* SNR monitor */
    _pifractecho.fixedflag = 0;
    pifractecho  = _pifractecho.fixedflag ?  ((void)(fecho_factor), pifractecho) : fecho_factor;
    setexist(pifractecho,_opte.existflag);
    _pifractecho.fixedflag = _opte.fixedflag;

    if (rfov_flag)
    {
        /* HCSDM00150820 - avminslthick based on designed 2DRF pulse */
        av_temp_float = ceil((ex_a_gzs*ex_nom_thkz/loggrd.zfs - exist(opslspace))*10.0)/10.0;
        avminslthick = FMax(3, avminslthick, av_temp_float, ceil(ex_nom_thkz*10.0)/10.0);
    }
    else
    {
        /* MRIge56926 - Calculation of avminslthick - TAA */
        minslicethick(&av_temp_float, bw_rf1, loggrd.tz, gscale_rf1,TYPDEF);
        av_temp_float = ceil(av_temp_float*10.0)/10.0;
        avminslthick = FMax(3,avminslthick,av_temp_float,ss_rf1*ss_min_slthk);
    }
 
    minslicethick(&av_temp_float, bw_rf2, loggrd.tz, gscale_rf2,TYPDEF);
    av_temp_float = ceil(av_temp_float*10.0)/10.0;
    avminslthick = FMax(2,avminslthick,av_temp_float);

    if(mux_flag && verse_rf2)
    {
        avminslthick = FMax(2, avminslthick, mux_min_verserf2_slthk);
    }

    /* MRIge56898 - Calculation of avminnshots and avmaxnshots out of error
       conditions - TAA */

    if (existcv(opnex)!=PSD_OFF) { 
        avmaxnshots = exist(opyres);
    }

    if (nshots_locks == PSD_ON) {
        if ( (cfsrmode==PSD_SR17) || (cfsrmode==PSD_SR20) || (cfsrmode==PSD_SR25) )
            min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
        else if (cfsrmode==PSD_SR77)
            if (exist(opxres)<=128)
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
            else
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
        else if (((cfsrmode == PSD_SR50) && (isStarterSystem())) || (cfsrmode==PSD_SR100) || (cfsrmode==PSD_SR120))
            if (exist(opxres)==512)
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
            else
                min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
        else
            min_nshots  = _min_nshots.fixedflag ?  ((void)(1), min_nshots) : 1;
    }

    if  (exist(opdiffuse) == PSD_ON || tensor_flag == PSD_ON)  {
        avminnshots = min_nshots;
        avmaxnshots = max_nshots;
    }
 
    /* MRIge53114 - popup maximum TI for the selected TR. */
    /* AMR for MRIge62721; Moved the calculation of avmaxti from within the error
       check ( to ensure that TR is 4 times longer than TI ) to cveval( ) */
    if ( epi_flair == PSD_ON )
        avmaxti = exist(optr)/(false_acqs*2);

    if( (exist(opslspace)<0) && (tensor_flag == PSD_ON) )
    {
         epic_error( use_ermes, "Increase the slice spacing to %.1f mm", EM_PSD_SLSPACING_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, 0.0);
         return FAILURE;
    }

    /* Multiband is incompatible with negative spacing*/
    if( (exist(opslspace)<0) && (mux_flag == PSD_ON) )
    {
         epic_error( use_ermes, "Increase the slice spacing to %.1f mm", EM_PSD_SLSPACING_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, 0.0);
         return FAILURE;
    }

    /* irprep_support */ 
    if( (PSD_ON == pi_neg_sp || PSD_ON == pioverlap ) &&
        (exist(opslspace)<0) && existcv(opslthick) &&
        (fabs( exist(opslspace) ) > (exist(opslthick) * 0.8)) )
    {
        epic_error( use_ermes, "Overlap should be less than 80%% of the "
                    "prescribed slice thickness.",
                    EM_PSD_SLICE_OVERLAP_EXCEEDED, EE_ARGS(0) );
        return FAILURE;
    }
    
    if( (PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype) )
    {
        /* MRIhc28734 - 
         * Use weighted diffusion averaging when diffusion lobes are active 
         * for less than 5 minutes on a single axis.
         * If the scan calls for 5 minutes of DWI/DTI scanning on a
         * single axis, turn gradient optimization off 
         * gradient optimization = weighted_avg_grad (1 = on)
         * 5 min = 300000000 us
         */

        /* For SSSD, realtime over current check is introduced to avoid burning.
         * The time constant should be 60sec for the gradient optimization.
         */

        if ((PSD_ON == opdiffuse) || (PSD_ON == tensor_flag))
        {
            if(5550 == cfgradamp)
            {
                if(isK15TSystem())
                {   
                    /* HCSDM00479162: Insure the correct weighted_avg_grad value and keep the same performance as autoTR */
                    core_time  = _core_time.fixedflag ?        ((void)((float)intleaves*max_difnex*tmin_total*opslquant), core_time) : (float)intleaves*max_difnex*tmin_total*opslquant;
                }
                else
                {
                    core_time  = _core_time.fixedflag ?        ((void)((float)intleaves*max_difnex*(float)act_tr*act_acqs), core_time) : (float)intleaves*max_difnex*(float)act_tr*act_acqs;
                }
            }
            else
            {
                if(((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_OFF)) || (tensor_flag == PSD_ON))
                {
                    core_time  = _core_time.fixedflag ?        ((void)((float)intleaves*max_difnex*(float)act_tr*act_acqs), core_time) : (float)intleaves*max_difnex*(float)act_tr*act_acqs;
                }
                else
                {
                    core_time  = _core_time.fixedflag ?          ((void)((float)intleaves*total_difnex*opdifnumdirs*(float)act_tr*act_acqs), core_time) : (float)intleaves*total_difnex*opdifnumdirs*(float)act_tr*act_acqs;
                }
            }

            if(5550 == cfgradamp)
            {
                if((core_time >= 60000000.0) || (exist(opdifnumdirs) > 40))
                {
                    weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_OFF), weighted_avg_grad) : PSD_OFF;
                }
                else
                {
                    weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_ON), weighted_avg_grad) : PSD_ON;
                }
            }
            else
            {
                if (core_time >= 300000000.0)
                {
                    weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_OFF), weighted_avg_grad) : PSD_OFF;
                }
                else
                {
                    weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_ON), weighted_avg_grad) : PSD_ON;
                }
            }
        }
        else
        {
            weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_ON), weighted_avg_grad) : PSD_ON;
        }
    }
    else
    {
        /* MRIhc 34431 - turn weighted_avg_grad off for non XRMB
         * systems */
        weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_OFF), weighted_avg_grad) : PSD_OFF;
    }

    if((mkgspec_x_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_y_sr_flag & MK_SPEC_SR_CHANGE) || (mkgspec_z_sr_flag & MK_SPEC_SR_CHANGE) ||
        mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
    {
        weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_OFF), weighted_avg_grad) : PSD_OFF;
    }

    if ((isRioSystem()) &&(exist(opdiffuse)==PSD_ON))
    {
            weighted_avg_grad  = _weighted_avg_grad.fixedflag ?  ((void)(PSD_ON), weighted_avg_grad) : PSD_ON;
    }

    if (FAILURE == NavigatorEval())
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "NavigatorEval");
        return FAILURE;
    }

    if( (PSD_OFF == pircbnub) && (PSD_OFF == exist(opautorbw)) )
    {
        opautorbw  = _opautorbw.fixedflag ?  ((void)(PSD_ON), opautorbw) : PSD_ON;
    }

    if(FAILURE == DTI_Eval()) {
        return FAILURE;
    } 


    /* HCSDM00455043 Set pidistcorr before setting rpg_flag */
    if (PSD_ON == exist(opdiffuse))
    {
        if ((PSD_ON == distcorr_status) && /* option key and HW check */
            (PSD_OFF == rfov_flag) && ((asset_factor/(float)(opnshots))<=0.5)) /* PSD options check */
        {
            pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(2), pidistcorrnub) : 2; /* Controls show/hide */
        }
        else
        {
            cvoverride(opdistcorr, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
            pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(0), pidistcorrnub) : 0; /* Controls show/hide */
        }
    }
    else
    {
        cvoverride(opdistcorr, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        pidistcorrnub  = _pidistcorrnub.fixedflag ?  ((void)(0), pidistcorrnub) : 0;
    }
 
    /* Distortion correction using RPG based on pepolar. */
    if (PSD_ON == exist(opdistcorr))
    {
        rpg_flag  = _rpg_flag.fixedflag ?        ((void)((PSD_ON==pepolar)?RPG_FWD_THEN_REV:RPG_REV_THEN_FWD), rpg_flag) : (PSD_ON==pepolar)?RPG_FWD_THEN_REV:RPG_REV_THEN_FWD; /* Init according to bulk of scan */
    }
    else
    {
        rpg_flag  = _rpg_flag.fixedflag ?  ((void)(0), rpg_flag) : 0;   
    }
    
    /* Distortion Correction - set number of hidden T2 passes */
    rpg_in_scan_flag  = _rpg_in_scan_flag.fixedflag ?        ((void)((rpg_flag>0)?1:0), rpg_in_scan_flag) : (rpg_flag>0)?1:0;
    if ((PSD_ON == rpg_in_scan_flag) && (PSD_ON == exist(opdiffuse)))
    {
        rpg_in_scan_num  = _rpg_in_scan_num.fixedflag ?       ((void)((0==exist(opdifnumt2))?2:1), rpg_in_scan_num) : (0==exist(opdifnumt2))?2:1;
    }
    else
    {
        rpg_in_scan_num  = _rpg_in_scan_num.fixedflag ?  ((void)(0), rpg_in_scan_num) : 0;
    }


    /* Turn off >1 prescription group with rfov or HOECC */
    if (rfov_flag || hoecc_flag != PSD_OFF || mux_flag || rpg_flag || muse_flag )
        pimultigroup = PSD_OFF;
    else
        pimultigroup = PSD_ON;

    /* MRIhc27551 Pititle was set according to piuset */
    pititle  = _pititle.fixedflag ?    ((void)((piuset!=0)), pititle) : (piuset!=0);

    /* HCSDM00129469 */
    TGenh  = _TGenh.fixedflag ?  ((void)(0.0), TGenh) : 0.0;

    if ( PSD_OFF == mux_flag)
    {
    if ((opdiffuse == PSD_ON) && (cffield == B0_30000) &&
            ((cfgcoiltype == PSD_XRMB_COIL) || (cfgcoiltype == PSD_XRMW_COIL) || 
             (isRioSystem()) || (cfgcoiltype == PSD_VRMW_COIL)) &&
            ((TX_COIL_BODY == getTxCoilType()) && (isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD))))
    {
        if (!strcmp(get_psd_name(), "epi2cl"))
        {
            if (opentry == 1) /* Head first */
            {
                TGenh  = _TGenh.fixedflag ?  ((void)(-9.0), TGenh) : -9.0;
            }
        }
        else
        {
            if (cfgcoiltype == PSD_VRMW_COIL)
            {
                TGenh  = _TGenh.fixedflag ?  ((void)(-8.0), TGenh) : -8.0;
            }
            else
            {
                TGenh  = _TGenh.fixedflag ?  ((void)(-5.5), TGenh) : -5.5; /* default */
            }
        }
    }
    }
    else
    {
        TGenh  = _TGenh.fixedflag ?  ((void)(0.0), TGenh) : 0.0; /* multiband */
    }

    if( (PSD_ON == exist(oprtcgate)) || (PSD_ON == exist(opnav)) )
    {
        piautovoice = 0;
    }
    else
    {
        piautovoice = 1;
    }

    info_fields_display(&piinplaneres,&pirbwperpix,&piesp,&ihinplanexres,
                        &ihinplaneyres,&ihrbwperpix,&ihesp,
                        DISP_INPLANERES|DISP_RBWPERPIX|DISP_ESP,
                        esp,
                        SCALE_INPLANEYRES_SQP);

    if(PSD_ON == vrgfsamp)
    {
       pirbwperpix = 0;
       ihrbwperpix = 0;
    }

    /* HCSDM00361682 */
    if(rfov_flag)
    {
        int i;
        for(i=MAX_FOCUS_EVAL_WATCH-1; i>0; i--)
        {
            avmaxslquant_hist[i] = avmaxslquant_hist[i-1];
            acqs_hist[i] = acqs_hist[i-1];
            tmin_hist[i] = tmin_hist[i-1];
        }
        avmaxslquant_hist[0] = avmaxslquant;
        acqs_hist[0] = acqs;
        tmin_hist[0] = tmin;
        if( ((tmin != tmin_hist[1])&&(tmin != tmin_hist[2])&&(tmin != tmin_hist[3])) && (0 == isPredownload) )
        {
            reset_oscil_in_eval  = _reset_oscil_in_eval.fixedflag ?  ((void)(1), reset_oscil_in_eval) : 1;
            oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(0), oscil_eval_count) : 0;
        }
        else
        {
            reset_oscil_in_eval  = _reset_oscil_in_eval.fixedflag ?  ((void)(0), reset_oscil_in_eval) : 0;
        }
        optr_save  = _optr_save.fixedflag ?  ((void)(exist(optr)), optr_save) : exist(optr);
        opslquant_save  = _opslquant_save.fixedflag ?  ((void)(exist(opslquant)), opslquant_save) : exist(opslquant);
    }
    else
    {
        int i;
        for(i=0; i<MAX_FOCUS_EVAL_WATCH; i++)
        {
            avmaxslquant_hist[i] = 0;
            acqs_hist[i] = 0;
            tmin_hist[i] = 0;
        }
        reset_oscil_in_eval  = _reset_oscil_in_eval.fixedflag ?  ((void)(0), reset_oscil_in_eval) : 0;
    }
    
    return SUCCESS;

}   /* end cveval() */

#include <sys/time.h>

/* ARCsetup inlined from ARC.e*/
/* Inlined from ARC.e ARCsetup - MRIhc46119 
 * This function setups ARC variables, checks for integer acceleration
 * and also sets the min and max variables, default values for drop down
 * phase and slice combos, default step sizes for increment/decrement
 * functionality
 * */

STATUS init_arc_variables(void)
{
    float temp_maxaccel_ph;
    float temp_maxaccel_sl;
    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);
    int cardiac_scan = (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                        && (!strcmp(attribute_codeMeaning, "Heart") || !strcmp(attribute_codeMeaning, "Aorta")
                            || !strcmp(attribute_codeMeaning, "Aortic arch")));


    if (PSD_ON == exist(oparc)) 
    {
        cvmax( arc_flag, PSD_ON );
        cvoverride(arc_flag, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);
    } 
    else  /* RBA for resetting arc_flag for MRIhc46954 */
    {
        cvmax( arc_flag, PSD_OFF );
        cvoverride(arc_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_OFF);
    }
    avmaxaccel_ph_stride = (arc_research_flag) ? MAX_ACCEL : cfaccel_ph_maxstride;
    arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(avmaxaccel_ph_stride), arc_ph_maxstride) : avmaxaccel_ph_stride;
    avminaccel_ph_stride = 1.0;
    avminaccel_sl_stride = 1.0;

    if (PSD_2D == exist(opimode)) 
    {
        avmaxaccel_sl_stride = 1.0;
        arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(1.0), arc_sl_maxstride) : 1.0;
        piaccel_slnub = 0;
    } 
    else if (PSD_3D == exist(opimode)) 
    {
        avmaxaccel_sl_stride = (arc_research_flag) ? MAX_ACCEL : cfaccel_sl_maxstride;
        arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(avmaxaccel_sl_stride), arc_sl_maxstride) : avmaxaccel_sl_stride;
    } 
    else 
    {
        avmaxaccel_ph_stride = 1.0;
        avmaxaccel_sl_stride = 1.0;
        arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(1.0), arc_ph_maxstride) : 1.0;
        arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(1.0), arc_sl_maxstride) : 1.0;
        piaccel_slnub = 0;
        piaccel_phnub = 0;
    }

    if(arc_flag) 
    {
        piaccelscrn = PSD_ON;

        /* MRIhc46119 - Changes for PI UI
         * Integer Acceleration needs to round up the outer acceleration
         * ceil to nearest integer. The user can choose 1.5 Ph and 1.25 Sl.
         * 
         * 1. We would need to compute the net acceleration considering the
         * outer acceleration of 1.5 Ph and 1.25 Sl. This is the target
         * Acceleration we need to achieve. 
         *
         * 2. Now compute net acceleration with the outer acceleration
         * of the ceil'ed strides. Keep increasing cal size till this
         * net acceleration is equal to target acceleration.
         * The arc_ph_intaccel and arc_sl_intaccel indicate that the PSD
         * does not support floating pt outer acceleration.
         * */

        if (arc_ph_intaccel) 
        {
            arc_ph_stride  = _arc_ph_stride.fixedflag ?   ((void)((int)ceil(exist(opaccel_ph_stride))), arc_ph_stride) : (int)ceil(exist(opaccel_ph_stride));
            arc_ph_userstride  = _arc_ph_userstride.fixedflag ?   ((void)(exist(opaccel_ph_stride)), arc_ph_userstride) : exist(opaccel_ph_stride);
        } 
        else 
        {
            arc_ph_stride  = _arc_ph_stride.fixedflag ?   ((void)(exist(opaccel_ph_stride)), arc_ph_stride) : exist(opaccel_ph_stride);
        }

        if (arc_sl_intaccel) 
        {
            arc_sl_stride  = _arc_sl_stride.fixedflag ?    ((void)((int)ceil(exist(opaccel_sl_stride))), arc_sl_stride) : (int)ceil(exist(opaccel_sl_stride));
            arc_sl_userstride  = _arc_sl_userstride.fixedflag ?  ((void)(exist(opaccel_sl_stride)), arc_sl_userstride) : exist(opaccel_sl_stride);
        } 
        else 
        {
            arc_sl_stride  = _arc_sl_stride.fixedflag ?  ((void)(exist(opaccel_sl_stride)), arc_sl_stride) : exist(opaccel_sl_stride);
        }

        /* If the Phase Accel is not more than 2 and Slice acceleration
         * is available, let the default acceleration be 1x2, else
         * stay at 2x1. 
         * */

        if (avmaxaccel_ph_stride > 1.0)
        {
            accel_sl_defstride = 1.0;
        }
        else 
        {
            accel_sl_defstride = FMin(2, 2.0, avmaxaccel_sl_stride);
        }


        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of default and the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride,
                                     avmaxaccel_ph_stride);
        }

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of default and the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride,
                                     avmaxaccel_sl_stride);
        }
         
        /* default step size being set, actual step size would be set by
         * setAccePulldown(). Start with 0 step size, set it in
         * accelsupport.c, for arc_research_flag or efgre3darc, the
         * avmaxaccel_ph_stride would be MAX_ACCEL = 20 and dropdowns
         * would be created accordingly.
         * */

        if(PSD_ON == cardiac_scan)  /* pulldown to show max factor up to 3 for cardiac scans */
        {
            temp_maxaccel_ph = FMin(2, 3.0, avmaxaccel_ph_stride);
            temp_maxaccel_sl = FMin(2, 3.0, avmaxaccel_sl_stride);
        }
        else
        {
            temp_maxaccel_ph = avmaxaccel_ph_stride;
            temp_maxaccel_sl = avmaxaccel_sl_stride;
        }

        setAccelPulldown ( temp_maxaccel_ph, temp_maxaccel_sl, 
                      &piaccel_phval2, &piaccel_phval3,
                      &piaccel_phval4, &piaccel_phval5,
                      &piaccel_phval6, &piaccel_phnub,
                      &piaccel_phedit, &piaccel_slval2,
                      &piaccel_slval3, &piaccel_slval4,
                      &piaccel_slval5, &piaccel_slval6,
                      &piaccel_slnub, &piaccel_sledit,
                      &piaccel_ph_step, &piaccel_sl_step); /* MRIhc47196 */
#ifdef PIDEBUG
        print_arc_params();
#endif
    } 
    else 
    {
        reset_accel_variables ();
    }
    return SUCCESS;
} 


/*  This function independently evaluates for ARC and Asset, turns off
 *  their variables. MRIhc46119 - Changes for PIUI. This is used for
 *  Asset and ARC across PSDs
 *  */
STATUS reset_accel_variables (void)
{
    if( (PSD_ON == exist(opassetscan)) && (PSD_OFF == exist(oparc)) )
    {
        cvmax( arc_flag, PSD_OFF );
        cvoverride(arc_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
        arc_ph_userstride  = _arc_ph_userstride.fixedflag ?  ((void)(1.0), arc_ph_userstride) : 1.0;
        arc_sl_userstride  = _arc_sl_userstride.fixedflag ?  ((void)(1.0), arc_sl_userstride) : 1.0;
        arc_sl_stride  = _arc_sl_stride.fixedflag ?  ((void)(1.0), arc_sl_stride) : 1.0;
        arc_ph_stride  = _arc_ph_stride.fixedflag ?  ((void)(1.0), arc_ph_stride) : 1.0;
        arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(1.0), arc_ph_maxstride) : 1.0;
        arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(1.0), arc_sl_maxstride) : 1.0;
    }
    if( (PSD_OFF == exist(opassetscan)) && (PSD_ON == exist(oparc)) )
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    }
    if( (PSD_OFF == exist(opassetscan)) && (PSD_OFF == exist(oparc)) )
    {
        cvmax( arc_flag, PSD_OFF );
        cvoverride(arc_flag, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
        rhasset  = _rhasset.fixedflag ?  ((void)(exist(opasset)), rhasset) : exist(opasset);
        piaccelscrn = PSD_OFF;
        piaccel_phnub = 0;
        piaccel_slnub = 0;
        piaccel_ph_step = 0.0;  /* Reset these so that they become ZERO when ARC/Asset is turned OFF */
        piaccel_sl_step = 0.0;
        avmaxaccel_ph_stride = 1.0;
        avmaxaccel_sl_stride = 1.0;
        arc_ph_maxstride  = _arc_ph_maxstride.fixedflag ?  ((void)(1.0), arc_ph_maxstride) : 1.0;
        arc_sl_maxstride  = _arc_sl_maxstride.fixedflag ?  ((void)(1.0), arc_sl_maxstride) : 1.0;
        arc_ph_userstride  = _arc_ph_userstride.fixedflag ?  ((void)(1.0), arc_ph_userstride) : 1.0;
        arc_sl_userstride  = _arc_sl_userstride.fixedflag ?  ((void)(1.0), arc_sl_userstride) : 1.0;
        arc_sl_stride  = _arc_sl_stride.fixedflag ?  ((void)(1.0), arc_sl_stride) : 1.0;
        arc_ph_stride  = _arc_ph_stride.fixedflag ?  ((void)(1.0), arc_ph_stride) : 1.0;
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    }
    return SUCCESS;
}

/* This function prints arc parameters for debugging purposes
 * MRIhc46119 - Changes for PIUI
 * */
STATUS print_arc_params (void)
{
    printf ("\n========================================START===================================\n");
    printf("arc_flag = %d\n",arc_flag);
    printf("cfaccel_ph_maxstride = %f\n",cfaccel_ph_maxstride);
    printf("cfaccel_sl_maxstride = %f\n",cfaccel_sl_maxstride);
    printf("piaccel_phnub = %d\n",piaccel_phnub);
    printf("piaccel_slnub = %d\n",piaccel_slnub);
    printf("arc_ph_maxstride = %f\n",arc_ph_maxstride);
    printf("arc_sl_maxstride = %f\n",arc_sl_maxstride);
    printf("opaccel_ph_stride = %f\n", exist(opaccel_ph_stride));
    printf("oparc = %d\n", exist(oparc));
    printf("opaccel_sl_stride = %f\n", exist(opaccel_sl_stride));
    printf("avmaxaccel_ph_stride = %f\n",avmaxaccel_ph_stride);
    printf("avmaxaccel_sl_stride = %f\n",avmaxaccel_sl_stride);
    printf("accel_ph_defstride = %f\n",accel_ph_defstride);
    printf("accel_sl_defstride = %f\n",accel_sl_defstride);
    printf("piaccel_ph_step = %f\n",piaccel_ph_step);
    printf("piaccel_sl_step = %f\n",piaccel_sl_step);
    printf("piaccel_ph_stride = %f\n",piaccel_ph_stride);
    printf("piaccel_sl_stride = %f\n",piaccel_sl_stride);
    printf("exist(opasset) = %d, existcv(opasset) = %d\n",exist(opasset), existcv(opasset));
    printf("exist(opassetscan) = %d\n", exist(opassetscan));
    printf ("\n========================================END===================================\n");
    fflush(stdout);
    return SUCCESS;

}


/* This function is useful in setting up dropdowns for PSDs that support
 * ARC and Asset. The function is self sufficient, checks for arc, asset
 * variables, sets up the variables, dropdowns and resets other
 * variables
 * */
STATUS initialize_arc_asset_variables (void)
{
    if( arc_flag )
    {
        /* We dont need to override if research flag is ON, init woudl
         *  have initialized it, research mode will override
         * avmax values to be used for coil development -
         * MRIhc42465 for PIUI
         ** */
         init_arc_variables();
    }
    else if ( existcv(opasset) && (exist(opassetscan) == PSD_ON) )
    {
/* AssetEval inlined from Asset.e  */
{
    /* New flags, originally used in efgre3d , being expanded */
    assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
    assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;

    /* Pick up default step size computed from avmaxaccel_ph_stride
     * and avmaxaccel_sl_stride
     * */

    avmaxaccel_sl_stride = 1.0;
    avmaxaccel_ph_stride = 1.0;
    avminaccel_sl_stride = 1.0;
    avminaccel_ph_stride = 1.0;
    piaccel_sl_stride = 1.0;
    piaccel_ph_stride = 1.0;

    assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_sl_maxstride > 1.0) && 
        (ASSET_SUPPORT_SLICE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support slice ASSET */

        /* Enable slice ASSET (host no longer sets slices ASSET) */
        cvoverride(opasset, ASSET_SCAN_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_ON), assetsl_flag) : PSD_ON;
        avmaxaccel_sl_stride = cfaccel_sl_maxstride;

        if( existcv(opaccel_sl_stride) )
        {
            /* If user specified value, display it */
            piaccel_sl_stride = opaccel_sl_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 or the coil capability */
            piaccel_sl_stride = FMin(2, accel_sl_defstride, avmaxaccel_sl_stride);
        }

        if (exist(opaccel_sl_stride) > 1.0) {
            assetsl_factor  = _assetsl_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_sl_stride))), assetsl_factor) : FMin(2,1.0,1.0/exist(opaccel_sl_stride));
        } else {
            assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        }
    }

    asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
    if( existcv(opasset) && (1 == exist(opassetscan)) &&
        (cfaccel_ph_maxstride > 1.0) && 
        (ASSET_SUPPORT_PHASE == asset_supported_direction) )
    {
        /* ASSET selected, App & Coil support phase ASSET */

        /* Reset to phase ASSET (host no longer sets slice ASSET ) */
        cvoverride(opasset, ASSET_SCAN_PHASE, PSD_FIX_ON, PSD_EXIST_ON);

        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_ON), assetph_flag) : PSD_ON;
        avmaxaccel_ph_stride = cfaccel_ph_maxstride;

        if( existcv(opaccel_ph_stride) )
        {
            /* If user specified value, display it */
            piaccel_ph_stride = opaccel_ph_stride;
        }
        else
        {
            /* Otherwise default to min of 2.0 and the coil capability */
            piaccel_ph_stride = FMin(2, accel_ph_defstride, avmaxaccel_ph_stride);
        }

        if (exist(opaccel_ph_stride) > 1.0) {
            asset_factor  = _asset_factor.fixedflag ?    ((void)(FMin(2,1.0,1.0/exist(opaccel_ph_stride))), asset_factor) : FMin(2,1.0,1.0/exist(opaccel_ph_stride));
        } else {
            asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        }
    }

    /* Set asset_factor */
    /* MRIge92386 */
    if( existcv(opasset) &&  exist(opassetscan) == PSD_ON )
    {
        float temp_maxaccel_ph;
        float temp_maxaccel_sl;
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);
        int cardiac_scan = (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                            && (!strcmp(attribute_codeMeaning, "Heart") || !strcmp(attribute_codeMeaning, "Aorta")
                                || !strcmp(attribute_codeMeaning, "Aortic arch")));

        piaccelscrn = PSD_ON;

        /* Set up the PI pulldown */
        if(PSD_ON == cardiac_scan)  /* pulldown to show up to factor of 3 for cardiac scans */
        {
            temp_maxaccel_ph = FMin(2, 3.0, avmaxaccel_ph_stride);
            temp_maxaccel_sl = FMin(2, 3.0, avmaxaccel_sl_stride);
        }
        else
        {
            temp_maxaccel_ph = avmaxaccel_ph_stride;
            temp_maxaccel_sl = avmaxaccel_sl_stride;
        }

        setAccelPulldown (temp_maxaccel_ph, temp_maxaccel_sl, 
                          &piaccel_phval2, &piaccel_phval3,
                          &piaccel_phval4, &piaccel_phval5,
                          &piaccel_phval6, &piaccel_phnub,
                          &piaccel_phedit, &piaccel_slval2,
                          &piaccel_slval3, &piaccel_slval4,
                          &piaccel_slval5, &piaccel_slval6,
                          &piaccel_slnub, &piaccel_sledit,
                          &piaccel_ph_step, &piaccel_sl_step);

    } 
    else
    {
        asset_factor  = _asset_factor.fixedflag ?  ((void)(1.0), asset_factor) : 1.0;
        assetsl_factor  = _assetsl_factor.fixedflag ?  ((void)(1.0), assetsl_factor) : 1.0;
        assetph_flag  = _assetph_flag.fixedflag ?  ((void)(PSD_OFF), assetph_flag) : PSD_OFF;
        assetsl_flag  = _assetsl_flag.fixedflag ?  ((void)(PSD_OFF), assetsl_flag) : PSD_OFF;
        if(PSD_OFF == exist(oparc))
        {
            piaccel_slnub = 0.0;
            piaccel_phnub = 0.0;
            piaccelscrn = PSD_OFF;
        }        
    }
} 

/* AssetEval inlined from Asset.e  */
    }
    else
    {
        reset_accel_variables();
    }
    return SUCCESS;
}


/* ARCsetup inlined from ARC.e*/

void
init_ASPIR_TI( void )
{
    /* Activate advisory panel checks for TI */
    piadvmin = (piadvmin | (1<<PSD_ADVTI));
    piadvmax = (piadvmax | (1<<PSD_ADVTI));

    /* Set TI annotation */
    pititype = PSD_LABEL_TE_PREP;

    /* Only show Auto TI */
    pitinub = 2;
    piautoti = PSD_ON;  /* show Auto as an option */
    avmaxti = ASPIR_DWI_MAX_TI;
    cvmax(opti,ASPIR_DWI_MAX_TI);
    avminti = IMax(2, ASPIR_DWI_MIN_TI, aspir_minti);
    cvmin(opti,avminti);
    cvdef(opti, ASPIR_DWI_MIN_TI);
    pitidefval = ASPIR_DWI_MIN_TI;
    if(cffield == B0_15000)
    {
        T1eff  = _T1eff.fixedflag ?  ((void)(ASPIR_DWI_T1EFF_1HT), T1eff) : ASPIR_DWI_T1EFF_1HT;
        bcoeff  = _bcoeff.fixedflag ?  ((void)(ASPIR_DWI_BCOEFF_1HT), bcoeff) : ASPIR_DWI_BCOEFF_1HT;
    }
    else
    {
        /* use 3T values for all other cffield */
        T1eff  = _T1eff.fixedflag ?  ((void)(ASPIR_DWI_T1EFF_3T), T1eff) : ASPIR_DWI_T1EFF_3T;
        bcoeff  = _bcoeff.fixedflag ?  ((void)(ASPIR_DWI_BCOEFF_3T), bcoeff) : ASPIR_DWI_BCOEFF_3T;
    }

    /* Set Auto TI model for ASPIR. */
    /* ASPIR Auto TI for GAT/RTG/Navi uses fixed value. */
    if (exist(opcgate) || exist(oprtcgate) || navtrig_flag)
    {
        aspir_auto_ti_model  = _aspir_auto_ti_model.fixedflag ?  ((void)(ASPIR_AUTO_TI_FIXED), aspir_auto_ti_model) : ASPIR_AUTO_TI_FIXED;
    }
    else
    {
        /* Auto TI caluculation will be performed by calc_ASPIR_TI() */
        aspir_auto_ti_model  = _aspir_auto_ti_model.fixedflag ?  ((void)(ASPIR_AUTO_TI_ADAPTIVE), aspir_auto_ti_model) : ASPIR_AUTO_TI_ADAPTIVE;
    }
}

/**
 * @brief Computes fat nulling TI value for ASPIR.
 *
 * The function calculates null TI of ASPIR. This function refers #aspir_auto_ti_model 
 * to determine whether null TI uses predefined value or adaptive value with #act_tr.
 *
 * @param[in] num_slices    Total number of slices that are scanned per pass.
 * @return   Null TI for ASPIR with current discription.
 * 
 */
INT
calc_ASPIR_TI( int num_slices )
{
    int aspir_null_ti = 0;

    if (ASPIR_AUTO_TI_FIXED == aspir_auto_ti_model)
    {
        if (cffield == B0_15000)
        {
            aspir_null_ti =  ASPIR_DWI_1HT_TI;
        }
        else
        {
            /* use 3T value (110ms) for all other cffield for now */
            aspir_null_ti =  ASPIR_DWI_3T_TI;
        }
    }
    else
    {
        /* Adaptive Auto TI */
        aspir_null_ti = (int)(T1eff*log(2.0/(1.0+exp(-bcoeff*act_tr/num_slices/T1eff))));
        aspir_null_ti = aspir_null_ti/1000*1000; /*rounded to ms*/
    }

    return aspir_null_ti;
}

/**
 * @brief Sets TI value to pull down menu
 *
 * This function set input aspir TI value to pull down menu (#pitival2).
 * And if Auto TI is used (#opautoti), then overwrites #act_ti and #opti 
 * with the input ASPIR TI.
 * 
 * @param[in]    TI value that would be set.
 * @return    Void.
 *
 */
void
set_ASPIR_TI(int aspir_ti)
{
    /* display auto TI in pitival2 */
    pitival2 = aspir_ti;

    if (exist(opautoti))
    {
        act_ti  = _act_ti.fixedflag ?  ((void)(aspir_ti), act_ti) : aspir_ti;
        cvoverride(opti, act_ti, PSD_FIX_OFF, PSD_EXIST_ON);
    }
}

/*
 * Set diffusion cyling related flags, called by cvinit and cveval()
 * */
static void SetCyclingCVs(void)
{
    if ((isRioSystem()) && (exist(opdiffuse)==PSD_ON))
    {
        dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELRECT), dbdt_model) : DBDTMODELRECT;
        if ( (exist(opdfaxall) >= PSD_ON) || (exist(optensor) >= PSD_ON) || (exist(opdfaxtetra) >= PSD_ON) )
        {
            diff_order_flag  = _diff_order_flag.fixedflag ?  ((void)(1), diff_order_flag) : 1;
        }
    }
    else
    {
        diff_order_flag  = _diff_order_flag.fixedflag ?  ((void)(0), diff_order_flag) : 0;
        dbdt_model  = _dbdt_model.fixedflag ?  ((void)(DBDTMODELRECT), dbdt_model) : DBDTMODELRECT;
    }

    if (diff_order_flag > 0)
    {
        hsdab  = _hsdab.fixedflag ?  ((void)(2), hsdab) : 2;
    }
    else
    {
        hsdab  = _hsdab.fixedflag ?  ((void)(1), hsdab) : 1;
    }

    num_iters  = _num_iters.fixedflag ?  ((void)(0), num_iters) : 0;

    if (diff_order_flag == 1)
    {
        if ((exist(opdfaxtetra) >= PSD_ON) || (exist(optensor) >= PSD_ON) || (exist(opdfaxall) >= PSD_ON) )
        {
            num_iters  = _num_iters.fixedflag ?    ((void)(IMin(2,exist(opdifnumdirs),MAX_NUM_ITERS)), num_iters) : IMin(2,exist(opdifnumdirs),MAX_NUM_ITERS);
        }
    }
    else if (diff_order_flag == 2)
    {
        if ( (exist(opdfaxtetra) >= PSD_ON) || (exist(optensor) >= PSD_ON) || (exist(opdfaxall) >= PSD_ON) )
        {
            if ( exist(opdifnumt2) > 0)
            {
                num_iters  = _num_iters.fixedflag ?      ((void)(IMin(2,exist(opdifnumdirs)+1,MAX_NUM_ITERS)), num_iters) : IMin(2,exist(opdifnumdirs)+1,MAX_NUM_ITERS);
            }
            else
            {
                num_iters  = _num_iters.fixedflag ?    ((void)(IMin(2,exist(opdifnumdirs),MAX_NUM_ITERS)), num_iters) : IMin(2,exist(opdifnumdirs),MAX_NUM_ITERS);
            }
        }
    }

    /* Obl 3in1 opt */
    if( ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF) ||
         ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON))) &&
        (exist(opplane) == PSD_OBL) && (exist(opcoax) != PSD_OFF) )
    {
        /*Turn off obl_3in1_opt on Rio due to spherical gradient model enforced*/
        if (isRioSystem())
            obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_OFF), obl_3in1_opt) : PSD_OFF;
        else
            obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_ON), obl_3in1_opt) : PSD_ON;
    }
    else
    {
        obl_3in1_opt  = _obl_3in1_opt.fixedflag ?  ((void)(PSD_OFF), obl_3in1_opt) : PSD_OFF;
    }
}


STATUS 
#ifdef __STDC__
setEpiEsp( void )
#else
    setEpiEsp()
#endif
{
    /* Minimum time between the endof one frame and beginning */
    /* of next is 50us in MGD DRF. */

    /* modify pw_gxwl,r1 to satisfy esp constraints */
    pw_gxwl1  = _pw_gxwl1.fixedflag ?  ((void)(0), pw_gxwl1) : 0;
    pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(0), pw_gxwr1) : 0;
    pw_gxwl2  = _pw_gxwl2.fixedflag ?  ((void)(0), pw_gxwl2) : 0;
    pw_gxwr2  = _pw_gxwr2.fixedflag ?  ((void)(0), pw_gxwr2) : 0;
    pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
    pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;

    esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;

    if (esp < minesp) {  /* is esp long enough? - if not, adjust pw_gxwl1,r2 */
        pw_gxwl1  = _pw_gxwl1.fixedflag ?    ((void)((minesp-esp)/2), pw_gxwl1) : (minesp-esp)/2;
        pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(pw_gxwl1), pw_gxwr1) : pw_gxwl1;
        pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
        pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
        esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
    }

    if (vrgfsamp != PSD_ON) 
    {
        if ( (2*pw_gxwad + pw_gxwl1 + pw_gxwr1) < (pw_gyba + pw_gyb + pw_gybd) ) 
        {
            pw_gxwl1  = _pw_gxwl1.fixedflag ?        ((void)(pw_gxwl1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad)), pw_gxwl1) : pw_gxwl1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad);
            pw_gxwr1  = _pw_gxwr1.fixedflag ?        ((void)(pw_gxwr1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad)), pw_gxwr1) : pw_gxwr1+RUP_GRD(pw_gyb/2+pw_gyba-pw_gxwad);
            pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
            pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
            esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
        }

        {  
            /* make sure esp/intleaves is a multiple of (hardware period)*intleaves by adjusting pw_gxwl1,r1 */
            int tmp, esp_new;

            esp_new = esp;
            tmp = intleaves * hrdwr_period;
            if( (esp % tmp) != 0) esp_new = (esp/tmp + 1) * tmp;
            esp_new = IMax(2, esp_new, minesp);

            if( esp_new > esp ) {
                pw_gxwl1  = _pw_gxwl1.fixedflag ?      ((void)(pw_gxwl1+(esp_new-esp)/2), pw_gxwl1) : pw_gxwl1+(esp_new-esp)/2;
                pw_gxwr1  = _pw_gxwr1.fixedflag ?  ((void)(pw_gxwl1), pw_gxwr1) : pw_gxwl1;
                pw_gxwl  = _pw_gxwl.fixedflag ?  ((void)(pw_gxwl1), pw_gxwl) : pw_gxwl1;
                pw_gxwr  = _pw_gxwr.fixedflag ?  ((void)(pw_gxwr1), pw_gxwr) : pw_gxwr1;
                esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;
            }
        }
    } /* end if vrgfsamp != PSD_ON */

    /* Last check: Make sure the echo-spacing */
    /* does not violate the minimum time from the end */
    /* of one data frame to the beginning of the next */
    if( (esp - rhfrsize*tsp) <  MinFram2FramTime) {      
        pw_gxgap   = _pw_gxgap.fixedflag ?    ((void)(RUP_GRD((int)(MinFram2FramTime-(esp-rhfrsize*tsp)))), pw_gxgap) : RUP_GRD((int)(MinFram2FramTime-(esp-rhfrsize*tsp)));

        /* Make sure added pw_gxgap/2 is on 4 us boundary */
        if ((pw_gxgap % pwmin_gap) != 0)
            pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;    
    } 

    /* Do the following in case pw_gxwl2 was modified by modify cvs */
    pw_gxwr2  = _pw_gxwr2.fixedflag ?  ((void)(pw_gxwl2), pw_gxwr2) : pw_gxwl2;
    pw_gxwl  = _pw_gxwl.fixedflag ?    ((void)(pw_gxwl1+pw_gxwl2), pw_gxwl) : pw_gxwl1+pw_gxwl2;
    pw_gxwr  = _pw_gxwr.fixedflag ?    ((void)(pw_gxwr1+pw_gxwr2), pw_gxwr) : pw_gxwr1+pw_gxwr2;
    esp   = _esp.fixedflag ?          ((void)(pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap), esp) : pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr+pw_gxgap;

    /* total readout flat-top */
    pw_gxw_total  = _pw_gxw_total.fixedflag ?      ((void)(pw_gxwl+pw_gxw+pw_gxwr), pw_gxw_total) : pw_gxwl+pw_gxw+pw_gxwr;  

    return SUCCESS;
}

STATUS
cveval1( void )
{
    const CHAR funcName[] = "cveval1";
    int icount;
    float xtarg_org = 0.0;

    if (exist(opslquant) == 3 && b0calmode == 1) {
        setb0rotmats();

        save_newgeo = opnewgeo;

        if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                            PSD_OBL, 0, 1, obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cveval()" ); 
            return FAILURE;
        }
        
        /* BJM: MRIge47073 derate non readout waveforms */
        dbdtderate(&loggrd, 0);  
        
        /* call for epiloggrd */
        opnewgeo = save_newgeo;
        if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                            PSD_OBL, 0, 1, obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cveval()" );
            return FAILURE;
        }    
        
    } else {
        
        save_newgeo = opnewgeo;
        if (obloptimize_epi(&loggrd, &phygrd, scan_info, exist(opslquant),
                            exist(opplane), exist(opcoax), obl_method,
                            obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cveval()" );
            return FAILURE; 
        }

        /* Obl 3in1 opt */
        if (obl_3in1_opt)
        {
            opnewgeo = save_newgeo;
            if (obloptimize_epi(&orthloggrd, &orthphygrd, orth_info, 1,
                                PSD_AXIAL, 1, obl_method,
                                obl_debug, &opnewgeo, cfsrmode)==FAILURE) { 
                epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cveval()" );
                return FAILURE;
            }
        }

        /* BJM: MRIge47073 derate non readout waveforms */
        dbdtderate(&loggrd, 0);

        /* Obl 3in1 opt */
        if (obl_3in1_opt)
        {
            dbdtderate(&orthloggrd, 0);
        }

        opnewgeo = save_newgeo;
        if (obloptimize_epi(&epiloggrd, &epiphygrd, scan_info, exist(opslquant),
                            exist(opplane), exist(opcoax), obl_method,
                            obl_debug, &opnewgeo, cfsrmode)==FAILURE) {
            psd_dump_scan_info();
            epic_error( use_ermes, "%s failed in %s.", EM_PSD_FUNCTION_FAILURE, EE_ARGS(2), STRING_ARG, "obloptimize_epi()", STRING_ARG, "cveval()" );
            return FAILURE; 
        }

    } /* end if (exist(opslquant) == 3 && b0calmode == 1) */

    /* Fill in the epigradopt input structure */
    if (autogap == 1) 
    {
        xtarg  = _xtarg.fixedflag ?  ((void)(epiloggrd.tx), xtarg) : epiloggrd.tx;
        ytarg  = _ytarg.fixedflag ?  ((void)(epiloggrd.ty), ytarg) : epiloggrd.ty;
        ztarg  = _ztarg.fixedflag ?  ((void)(epiloggrd.tz), ztarg) : epiloggrd.tz;
    } 
    else 
    {
        xtarg  = _xtarg.fixedflag ?  ((void)(epiloggrd.tx_xyz), xtarg) : epiloggrd.tx_xyz;
        ytarg  = _ytarg.fixedflag ?  ((void)(epiloggrd.ty_xyz), ytarg) : epiloggrd.ty_xyz;
        ztarg  = _ztarg.fixedflag ?  ((void)(epiloggrd.tz_xyz), ztarg) : epiloggrd.tz_xyz;
    }

    if(arc_extCal && oparc){
        asset_factor  = _asset_factor.fixedflag ?  ((void)(arc_ph_factor), asset_factor) : arc_ph_factor;
    }

    xtarg_org = xtarg;

    if (PSD_ON == epi_loggrd_glim_flag)
    {
        xtarg  = _xtarg.fixedflag ?    ((void)(FMin(2,xtarg,epi_loggrd_glim)), xtarg) : FMin(2,xtarg,epi_loggrd_glim);
    }

    /* Local block for calcualting tsp */
    {
        /* HALF_KHZ_USEC is from filter.h - need to change from cfcerdbw1 when */
        /* config name changes */
        float tsp_min = (HALF_KHZ_USEC/RBW_MAX);
        float act_rbw;
        float decimation;
        float max_rbw;
        int vrgf_rescale = 0; 
        float vrgf_ratio = 1.0; 
        float xtarg_temp = 0; 
 
        if (vrgfsamp == PSD_ON) 
        {
            
            rbw  = _rbw.fixedflag ?  ((void)(0.0), rbw) : 0.0;  /* calculate this for the vrgf case */
            
            /* Do this so rhfrsize remains low enough for current recon limitations */
            if (exist(opxres) <= 128) {
                vrgf_targ  = _vrgf_targ.fixedflag ?  ((void)(2.0), vrgf_targ) : 2.0;
            } else {
                vrgf_targ  = _vrgf_targ.fixedflag ?  ((void)(1.6), vrgf_targ) : 1.6;
            }

            /* 4x oversampling ratio desired */
            tsp  = _tsp.fixedflag ?          ((void)(1.0/(GAM*xtarg*get_act_freq_fov()/10.0)/(vrgf_targ/1.0e6)), tsp) : 1.0/(GAM*xtarg*get_act_freq_fov()/10.0)/(vrgf_targ/1.0e6); /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by CV minimum value setting" */
                       
            /* Cant go lower than hardware sample period */
            if (tsp < tsp_min) 
            {
                tsp  = _tsp.fixedflag ?  ((void)(tsp_min), tsp) : tsp_min;
            }  

            /* Calculate desired RBW in kHz. */
            /* Note: this might not be valid if the */
            /* decimation required is not supported by */
            /* MGD.  Thus, we will check this calculation */
            /* below with calcvalidrbw() */
            /* Hz to kHz */
            rbw  = _rbw.fixedflag ?      ((void)((1.0/(2.0*(tsp/1000000)))/1000.0), rbw) : (1.0/(2.0*(tsp/1000000)))/1000.0; /* parasoft-suppress BD-PB-ZERO  "divide by zero avoided by CV minimum value setting" */

            /* Check for a valid RBW */
            /* Calculate the rbw, decimation based on the */
            /* the supported MGD configuration */
            /* This function will return act_rbw with the nearest */
            /* valid value and also overwrite the value of oprbw  */

            if (vrgf_bwctrl)
            {
                rbw  = _rbw.fixedflag ?  ((void)(exist(oprbw)), rbw) : exist(oprbw);
            }

            if (SUCCESS != calcvalidrbw(rbw, &act_rbw, &max_rbw, 
                                        &decimation, OVERWRITE_OPRBW, vrgfsamp))
            {
                return FAILURE;
            }
            
            /* Recalculate tsp now that we have a valid RBW */
            tsp  = _tsp.fixedflag ?  ((void)(1000000*(1.0/(2.0*(1000.0*act_rbw)))), tsp) : 1000000*(1.0/(2.0*(1000.0*act_rbw)));
            /* MRIhc27257, MRIhc27350 : adjust vrgf oversampling factor according to the new tsp */
                
            vrgf_targ  = _vrgf_targ.fixedflag ?           ((void)(1/(tsp*GAM*xtarg*get_act_freq_fov()/10.0)*1.0e6), vrgf_targ) : 1/(tsp*GAM*xtarg*get_act_freq_fov()/10.0)*1.0e6;
            if (vrgf_targ < 1.0)
            {
                vrgf_targ  = _vrgf_targ.fixedflag ?  ((void)(1.0), vrgf_targ) : 1.0;
                xtarg_temp = xtarg;

                /* MRIhc27257, MRIhc27350: this process can compete with the
                 * taratio logic below by lowering the target amplitude. 
                 * However, taratio logic always
                 * reduces the target amplitude. Therefore, taratio 
                 * does not have
                 * impact on the frequency direction aliasing.   - SWL
                 */
                xtarg  = _xtarg.fixedflag ?          ((void)(1.0/(GAM*tsp*get_act_freq_fov()/10.0)/(vrgf_targ/1.0e6)), xtarg) : 1.0/(GAM*tsp*get_act_freq_fov()/10.0)/(vrgf_targ/1.0e6);
                if ( (xtarg <= cfxfs) && (xtarg >=0 ) )
                {
                    vrgf_ratio = xtarg/ xtarg_temp;
                    vrgf_rescale = 1;
                }
                else
                {
                    return FAILURE;
                }
            }

            /* reset rbw */
            rbw  = _rbw.fixedflag ?  ((void)(act_rbw), rbw) : act_rbw;

        }   /* end if(vrgfsamp == PSD_ON) */ 
        else 
        {   /* non VRGF */ 
            
            /* first, check for a valid RBW */
            /* calculate the rbw, decimation based on the */
            if (SUCCESS != calcvalidrbw(exist(oprbw), &act_rbw, &max_rbw, 
                                        &decimation, OVERWRITE_OPRBW, vrgfsamp)) {
                return FAILURE;
            }

            /* tsp = echo1_filt.tsp;*/
            rbw  = _rbw.fixedflag ?  ((void)(exist(oprbw)), rbw) : exist(oprbw); 

            /* Need to calculate tsp for epigradopt */
            tsp  = _tsp.fixedflag ?  ((void)(1000000*(1.0/(2.0*(1000.0*rbw)))), tsp) : 1000000*(1.0/(2.0*(1000.0*rbw)));
            
        } 
    
        /* Round tsp (removes any small RO error) */
        tsp  = _tsp.fixedflag ?     ((void)((float)((floor)((tsp*10.0)+0.5)/10.0)), tsp) : (float)((floor)((tsp*10.0)+0.5)/10.0);

        gradin.xfs = xtarg;
        gradin.yfs = ytarg;
        gradin.zfs = ztarg;
        gradin.xrt = ceil((float)epiloggrd.xrt*epiloggrd.scale_3axis_risetime * xtarg/ xtarg_org);
        gradin.yrt = ceil((float)epiloggrd.yrt*epiloggrd.scale_3axis_risetime); /* HCSDM00339202 */
        gradin.zrt = ceil((float)epiloggrd.zrt*epiloggrd.scale_3axis_risetime);
        gradin.xbeta = epiloggrd.xbeta;
        gradin.ybeta = epiloggrd.ybeta;
        gradin.zbeta = epiloggrd.zbeta;
        gradin.xfov = rhfreqscale*exist(opfov)/10.0;   /* convert to cm */
        gradin.yfov = exist(opphasefov)*exist(opfov)*asset_factor/10.0; /* convert to cm */
    } /* end local block */
 
    if (vrgfsamp == PSD_OFF)
    {
        gradin.xres = rhfrsize;
    }
    else
    {
        gradin.xres = exist(opxres);
    }
    gradin.yres = (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor);
    
    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
    {
        gradin.ileaves = intleaves/2;
    }
    else
    {
        gradin.ileaves = intleaves;
    }
    gradin.xdis = cfdbdtdx;
    gradin.ydis = cfdbdtdy;
    gradin.zdis = cfdbdtdz;
    gradin.tsp  = _tsp.fixedflag ?  ((void)(tsp), tsp) : tsp;
    gradin.osamps = osamp;
    gradin.fbhw  = _fbhw.fixedflag ?  ((void)(fbhw), fbhw) : fbhw;
    gradin.vvp = hrdwr_period;
    pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
 

    /* SXZ::MRIge72411: find taratio value for the current prescription */
    /* max k value */
    totarea  = _totarea.fixedflag ?          ((void)(1.0e6*gradin.xres/(rhfreqscale*get_act_freq_fov()/10.0*(FLOAT)GAM)), totarea) : 1.0e6*gradin.xres/(rhfreqscale*get_act_freq_fov()/10.0*(FLOAT)GAM);
    if( vrgfsamp == PSD_ON && rampopt == 1 ){
        int indx;
        for(indx = 0; indx < NODESIZE; indx++){
            if(totarea <= totarea_arr[indx]){
                if( indx == 0 ){
                    taratio  = _taratio.fixedflag ?  ((void)(taratio_arr[indx]), taratio) : taratio_arr[indx];
                }else{ 
                    taratio  = _taratio.fixedflag ?   
                         

                        ((void)(taratio_arr[indx-1]+(totarea-totarea_arr[indx-1])/(totarea_arr[indx]-totarea_arr[indx-1])*(taratio_arr[indx]-taratio_arr[indx-1])), taratio) : taratio_arr[indx-1]+(totarea-totarea_arr[indx-1])/(totarea_arr[indx]-totarea_arr[indx-1])*(taratio_arr[indx]-taratio_arr[indx-1]);
                }

                break;

            } else if(indx==NODESIZE-1) {

                taratio  = _taratio.fixedflag ?  ((void)(taratio_arr[indx]), taratio) : taratio_arr[indx];
            }
        }
        if(isStarterSystem() && (isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_ABDOMEN))) 
        {
            taratio  = _taratio.fixedflag ?  ((void)(0.4), taratio) : 0.4;
        }
    }
    else{

        taratio  = _taratio.fixedflag ?  ((void)(0), taratio) : 0;
    }

    gradin.taratio  = _taratio.fixedflag ?  ((void)(taratio), taratio) : taratio;

    if ((use_slice_fov_shift_blips) && (mux_flag == PSD_ON) && (mux_slices_rf1 > 1)) {
        slice_fov_shift_cycles  = _slice_fov_shift_cycles.fixedflag ?    ((void)((slice_fov_shift-1)/((float)slice_fov_shift)), slice_fov_shift_cycles) : (slice_fov_shift-1)/((float)slice_fov_shift);
        slice_fov_shift_area  = _slice_fov_shift_area.fixedflag ?        ((void)(1.0e6*slice_fov_shift_cycles/(GAM*mux_slice_shift_mm_rf1/10.0)), slice_fov_shift_area) : 1.0e6*slice_fov_shift_cycles/(GAM*mux_slice_shift_mm_rf1/10.0);
        gradin.zarea = slice_fov_shift_area;
    }
    else
    {
        slice_fov_shift_area  = _slice_fov_shift_area.fixedflag ?  ((void)(0.0), slice_fov_shift_area) : 0.0;
        gradin.zarea = 0.0;
    }

    each_gradopt_count = 0;

    if((cffield >= B0_30000) && (PSD_HRMW_COIL == cfgcoiltype))
    {
        esprange_check  = _esprange_check.fixedflag ?  ((void)(1), esprange_check) : 1;
        espamp_check  = _espamp_check.fixedflag ?  ((void)(1), espamp_check) : 1;
    }
    else
    {
        esprange_check  = _esprange_check.fixedflag ?  ((void)(0), esprange_check) : 0;
        espamp_check  = _espamp_check.fixedflag ?  ((void)(0), espamp_check) : 0;
    }

    if(esprange_check == 1)
    {
        if(FAILURE == readEspRange())
        {
            return FAILURE;
        }
    }

    if((dbdt_model == DBDTMODELCONV) && isdbdtper())
    {
        if(optGradAndEsp_conv() == FAILURE)
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
    }
    else if(esprange_check && isdbdtper())
    {
        if(optGradAndEsp_rect() == FAILURE)
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
    }
    else
    {
        pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
        dbdtper_new  = _dbdtper_new.fixedflag ?  ((void)(cfdbdtper), dbdtper_new) : cfdbdtper;
        if(epigradopt_rect(dbdtper_new, 0) == FAILURE)
        {
            reopt_flag = PSD_ON;
            return FAILURE;
        }
        if(epigradopt_debug) printEpigradoptLog();
    }

    rhfrsize  = _rhfrsize.fixedflag ?  ((void)(temprhfrsize), rhfrsize) : temprhfrsize;
    pidbdtper = FMax(2, pidbdtper, rfov_dbdtper); /* HCSDM00150820 */

    /* SXZ::MRIge72411: calc actual ratio */
    if(vrgfsamp == 1 && rampopt == 1){
        int tempvar;
        /* ramp area */
        tempvar = ((float)a_gxw*pw_gxwad-a_gxw*(pw_gyba+pw_gyb/2)*(pw_gyba+pw_gyb/2)/pw_gxwad);
        /* top area */
        tempvar = totarea - tempvar;

        actratio  = _actratio.fixedflag ?  ((void)(tempvar/totarea), actratio) : tempvar/totarea;

    } else {

        actratio  = _actratio.fixedflag ?  ((void)(1), actratio) : 1;

    }

    /* MGD: call calcfilter() */
    if( FAILURE == (calcfilter(&echo1_filt, oprbw, rhfrsize, OVERWRITE_OPRBW)) ) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calcfilter" );
        return FAILURE;
    }

    getminesp(echo1_filt, xtr_offset, intleaves, hrdwr_period, vrgfsamp, _minesp.fixedflag ? (_temp491_minesp=minesp,&_temp491_minesp) : &minesp);

    /* There is a bug in epigradopt for non-vrg.  Bump up pw_gxwad */
    pw_gxwad  = _pw_gxwad.fixedflag ?  ((void)(RUP_GRD(pw_gxwad)), pw_gxwad) : RUP_GRD(pw_gxwad);

    /* Also, epigradopt does not make pw_gxgap a mult. of 2*GRAD_UPDATE_TIME,
       so do it here (MRIge23911) */
    if ((pw_gxgap % pwmin_gap) != 0)
        pw_gxgap  = _pw_gxgap.fixedflag ?     ((void)((int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap), pw_gxgap) : (int)ceil((double)pw_gxgap/(double)pwmin_gap)*pwmin_gap;

    /* Need to set the decay of the blip to = the attack found in epgradopt() */
    pw_gybd  = _pw_gybd.fixedflag ?  ((void)(pw_gyba), pw_gybd) : pw_gyba;

    /* Call to calculate the echo-sapcing (esp) */
    if( FAILURE == setEpiEsp() ) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setEpiEsp" );
        return FAILURE;
    }
    msamp  = _msamp.fixedflag ?  ((void)(0.0), msamp) : 0.0;
    dsamp  = _dsamp.fixedflag ?  ((void)(0.0), dsamp) : 0.0;                             /* Delta echo shift (tuning) */
    
    /* PW_GXW delta for GW1 calc */ 
    delpw  = _delpw.fixedflag ?  ((void)((msamp+dsamp)*tsp), delpw) : (msamp+dsamp)*tsp;
  
    /* Position of dephaser pulses: pre- or post- 180 */
    /* For GRE - the positions are post-180 to get the proper sign */  
    if (exist(oppseq) != PSD_SE) {              
        /* set the gx1 and gy1 position flags */
        cvoverride(gx1pos, PSD_POST_180,_gx1pos.fixedflag,_gx1pos.existflag);
        cvoverride(gy1pos, PSD_POST_180,_gy1pos.fixedflag,_gy1pos.existflag);
    }
    
    /* X dephaser pulse */
    
    gx1_area  = _gx1_area.fixedflag ?       
                          ((void)(a_gxw*((float)pw_gxwad/2.0+(float)pw_gxwl+(float)pw_gxw/2.0+delpw)), gx1_area) : a_gxw*((float)pw_gxwad/2.0+(float)pw_gxwl+(float)pw_gxw/2.0+delpw);
    
    /* The GRAM circuit may require shaped attack and decay ramps to
       facilitate a smooth transition between the ramp transition and
       adjacent pulse seqments.  A mechanism is provided in 5.5 to shape
       the waveform such that it begins as a parabola, transitions smoothly
       into a linear segment covering the center portion of the transition,
       and transitions smoothly into a parabolic segment (a mirror of the
       first parabolic component) to terminate the transition.  This
       composite waveform and its first deriviative are continuous from
       start to end.   A parameter called "beta," ranging form 0 to 1,
       specifies the portion of the ramp that is linear.  If beta is 1,
       the ramp is completely linear; if zero, the ramp is completely
       parabolic.  As a greater portion of the waveform becomes parabolic,
       the slope of the linear segment increases.  The absolute area under
       the "ramp" transition remains constant for any value of beta over
       its range [0..1].
       
       Please refer to the 5.5 General PSD Enhancements SRS.
       
       The wave shaping is performed at the low level ramp generation
       routine (w_ramp funciton in wg_linear.c, PGEN_WAVE project).
       
       In the readout echo planar pulse train, the first attack and last
       decay ramp will have different shapes than the other ramps.
       For VRG sampling, this results in an assymmetry in the first and
       last view of the train.  To circumvent this, the dephaser pulse
       can be moved up against the readout train, and the dephaser's
       decay and be combined with the first readout attack ramp.
       
       The following code make this determination.  */
    
    /* If epiloggrd.xrt == loggrd.xrt then dB/dt is not an issue and
       a single ramp is legal. */
    if (( gx1_area >= a_gxw*(float)pw_gxwad) && gx1pos == PSD_POST_180 &&
        epiloggrd.xrt == loggrd.xrt && hoecc_flag == PSD_OFF && (iref_etl == 0))
        single_ramp_gx1d  = _single_ramp_gx1d.fixedflag ?  ((void)(1), single_ramp_gx1d) : 1;
    else
        single_ramp_gx1d  = _single_ramp_gx1d.fixedflag ?  ((void)(0), single_ramp_gx1d) : 0;
    
    if (single_ramp_gx1d == PSD_ON) 
    {
        pw_gx1a  = _pw_gx1a.fixedflag ?  ((void)(pw_gxwad), pw_gx1a) : pw_gxwad;
        pw_gx1d  = _pw_gx1d.fixedflag ?  ((void)(pw_gxwad), pw_gx1d) : pw_gxwad;
        /* pw_gx1 must >= MIN_PLATEAU_TIME */
        pw_gx1  = _pw_gx1.fixedflag ?      ((void)(IMax(2,RUP_GRD((int)(gx1_area/a_gxw-(float)pw_gx1a)),MIN_PLATEAU_TIME)), pw_gx1) : IMax(2,RUP_GRD((int)(gx1_area/a_gxw-(float)pw_gx1a)),MIN_PLATEAU_TIME);
        a_gx1  = _a_gx1.fixedflag ?    ((void)(-gx1_area/(float)(pw_gx1a+pw_gx1)), a_gx1) : -gx1_area/(float)(pw_gx1a+pw_gx1);
    } 
    else 
    {
        if (gx1pos == PSD_POST_180)
            gx1_area  = _gx1_area.fixedflag ?  ((void)(-1), gx1_area) : gx1_area*-1;
        start_amp  = _start_amp.fixedflag ?  ((void)(0.0), start_amp) : 0.0;
        end_amp  = _end_amp.fixedflag ?  ((void)(0.0), end_amp) : 0.0;
        if (amppwgradmethod(&gradx[GX1_SLOT], gx1_area, loggrd.tx_xyz, start_amp,
                            end_amp, loggrd.xrt*loggrd.scale_3axis_risetime, MIN_PLATEAU_TIME) == FAILURE) 
	{
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gx1" );
            return FAILURE;
	}
    }
    
    pw_gx1_tot  = _pw_gx1_tot.fixedflag ?      ((void)(pw_gx1a+pw_gx1+pw_gx1d), pw_gx1_tot) : pw_gx1a+pw_gx1+pw_gx1d;
    
    if(iref_etl > 0)
    {
        if (amppwgradmethod(&gradx[GXDPC1_SLOT], gx1_area, loggrd.tx_xz, 0.0,
                    0.0, loggrd.xrt*loggrd.scale_2axis_risetime, MIN_PLATEAU_TIME) == FAILURE)
        {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gxiref1" );
            return FAILURE;
        }
        if (amppwgradmethod(&gradx[GXDPCR_SLOT], gx1_area, loggrd.tx, 0.0,
                    0.0, loggrd.xrt, MIN_PLATEAU_TIME) == FAILURE)
        {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gxirefr" );
            return FAILURE;
        }
        pw_gxiref1_tot  = _pw_gxiref1_tot.fixedflag ?      ((void)(pw_gxiref1a+pw_gxiref1+pw_gxiref1d), pw_gxiref1_tot) : pw_gxiref1a+pw_gxiref1+pw_gxiref1d;
        pw_gxiref_tot  = _pw_gxiref_tot.fixedflag ?  ((void)(esp*iref_etl), pw_gxiref_tot) : esp*iref_etl;
        pw_gxirefr_tot  = _pw_gxirefr_tot.fixedflag ?      ((void)(pw_gxirefra+pw_gxirefr+pw_gxirefrd), pw_gxirefr_tot) : pw_gxirefra+pw_gxirefr+pw_gxirefrd;
    }
    else
    {
        pw_gxiref1_tot  = _pw_gxiref1_tot.fixedflag ?  ((void)(0), pw_gxiref1_tot) : 0;
        pw_gxiref_tot  = _pw_gxiref_tot.fixedflag ?  ((void)(0), pw_gxiref_tot) : 0;
        pw_gxirefr_tot  = _pw_gxirefr_tot.fixedflag ?  ((void)(0), pw_gxirefr_tot) : 0;
    }
    
    /* At this point, we know the timing for the basic parameters for
       the echo planar gradient train: amplitudes and pulse widths of
       readout and phase encoding trapezoids, excluding the y axis
       dephaser.
       
       To compute the advisory panel minimum TE, first calculate the
       other timing elements, such as slice select axis timing, killer
       pulses, diffusion, etc.  Then proceed with advisory calculations,
       finishing up with calculation of the phase encoding dephaser,
       ky_offset, rhhnover, etc. */
    
    
    /***** Slice select timing ****************************************/

    if (ssgr_mux && (a_gzrf1 > 0.0)) 
    {
        a_gzrf1  = _a_gzrf1.fixedflag ?  ((void)(-a_gzrf1), a_gzrf1) : -a_gzrf1;
    }

    if ((PSD_OFF == rfov_flag) && (PSD_OFF == mux_flag))
    {
        if (ampslice(_a_gzrf1.fixedflag ? (_temp492_a_gzrf1=a_gzrf1,&_temp492_a_gzrf1) : &a_gzrf1, bw_rf1, exist(opslthick), gscale_rf1, TYPDEF)
            == FAILURE)
        {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice" );
            return FAILURE;
        }
        /* optimize attack and decay ramps */
        if (optramp(_pw_gzrf1d.fixedflag ? (_temp493_pw_gzrf1d=pw_gzrf1d,&_temp493_pw_gzrf1d) : &pw_gzrf1d, a_gzrf1, loggrd.tz_xyz, loggrd.zrt*loggrd.scale_3axis_risetime, TYPDEF) == FAILURE)
        {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gzrf1d" );
            return FAILURE;
        }
        if (pw_gzrf1d < 300)
            pw_gzrf1a  = _pw_gzrf1a.fixedflag ?  ((void)(RUP_GRD(300)), pw_gzrf1a) : RUP_GRD(300);
        else
            pw_gzrf1a  = _pw_gzrf1a.fixedflag ?  ((void)(pw_gzrf1d), pw_gzrf1a) : pw_gzrf1d;
    }

    /* For RFOV, we change the RF2 thickness to balance between the slice aliasing and SNR. */
    if (rfov_flag && (exist(opslspace) > 0))
    {
        temp_slthick  = _temp_slthick.fixedflag ?          ((void)(exist(opslthick)+(exist(opslspace)>1.0?1.0:exist(opslspace))), temp_slthick) : exist(opslthick)+(exist(opslspace)>1.0?1.0:exist(opslspace));
    }
    else
    {
        temp_slthick  = _temp_slthick.fixedflag ?  ((void)(exist(opslthick)), temp_slthick) : exist(opslthick);
    }

    if (ampslice(_a_gzrf2.fixedflag ? (_temp494_a_gzrf2=a_gzrf2,&_temp494_a_gzrf2) : &a_gzrf2, bw_rf2, temp_slthick, gscale_rf2, TYPDEF)== FAILURE)
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice:a_gzrf2" );
        return FAILURE;
    }

    /* DTI BJM: (dsp) set gradient amps for refocusing */
    if (PSD_ON == dualspinecho_flag)
    {
        a_gzrf2left  = _a_gzrf2left.fixedflag ?  ((void)(a_gzrf2), a_gzrf2left) : a_gzrf2;
        a_gzrf2right  = _a_gzrf2right.fixedflag ?  ((void)(a_gzrf2), a_gzrf2right) : a_gzrf2;
    }

    ivslthick  = _ivslthick.fixedflag ?  ((void)(get_act_phase_fov()), ivslthick) : get_act_phase_fov();
    if (ampslice(_a_gyrf2iv.fixedflag ? (_temp495_a_gyrf2iv=a_gyrf2iv,&_temp495_a_gyrf2iv) : &a_gyrf2iv, bw_rf2, ivslthick, gscale_rf2, TYPDEF) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice:a_gyrf2iv" );
        return FAILURE;
    }
    
    gradz[GZRF1_SLOT].num = 1;
    gradz[GZK_SLOT].num = 1;
    
    if (exist(oppseq) == PSD_SE) 
    {
        if (innerVol == PSD_ON) 
	{  /* refocus pulse on logical Y */
            gradz[GZRF2_SLOT].num = 0;
            grady[GYRF2IV_SLOT].num = 1;
            if (optramp(_pw_gyrf2iva.fixedflag ? (_temp496_pw_gyrf2iva=pw_gyrf2iva,&_temp496_pw_gyrf2iva) : &pw_gyrf2iva, loggrd.ty_xyz, loggrd.ty, loggrd.yrt*loggrd.scale_3axis_risetime, TYPDEF)
                == FAILURE) 
	    {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gyrf2iva" );
                return FAILURE;
	    }
            pw_gyrf2ivd  = _pw_gyrf2ivd.fixedflag ?  ((void)(pw_gyrf2iva), pw_gyrf2ivd) : pw_gyrf2iva;
	} 
        else 
	{  /* refocus pulse on logical Z */
            gradz[GZRF2_SLOT].num = 1;
            grady[GYRF2IV_SLOT].num = 0;
	}
        gradz[GZRF2L1_SLOT].num = 1;
        gradz[GZRF2R1_SLOT].num = 1;
        gradz[GZRF2_SLOT].num = 1;

        /* DTI need to accout for extra RF2 pulse */
        if (PSD_ON == dualspinecho_flag)
        {
            rfpulse[RF2_SLOT].num = 2;
        }
        else
        {
            rfpulse[RF2_SLOT].num = 1;
        }
    } 
    else 
    {
        gradz[GZRF2_SLOT].num = 0;
        grady[GYRF2IV_SLOT].num = 0;
        gradz[GZRF2L1_SLOT].num = 0;
        gradz[GZRF2R1_SLOT].num = 0;
        gradz[GZRF2_SLOT].num = 0;
        rfpulse[RF2_SLOT].num = 0;
    }
    
    rfpulse[RF1_SLOT].num = 1;
	
    if (optramp(_pw_gzrf2l1a.fixedflag ? (_temp497_pw_gzrf2l1a=pw_gzrf2l1a,&_temp497_pw_gzrf2l1a) : &pw_gzrf2l1a, loggrd.tz_xyz, loggrd.tz, loggrd.zrt*loggrd.scale_3axis_risetime, TYPDEF) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gzrf2l1a" );
        return FAILURE;
    }
    
    if (optramp(_pw_gzrf2l1d.fixedflag ? (_temp498_pw_gzrf2l1d=pw_gzrf2l1d,&_temp498_pw_gzrf2l1d) : &pw_gzrf2l1d, fabs(a_gzrf2l1-a_gzrf2), loggrd.tz_xyz*loggrd.scale_3axis_risetime,
                loggrd.zrt*loggrd.scale_3axis_risetime, TYPDEF) == FAILURE)
        return FAILURE;
    
    crusher_type = PSD_TYPCMEMP;
    if (crusherutil(crusher_scale, crusher_type) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "crusherutil" );
        return FAILURE;
    }
    
    /* The CVs c1_scale, c2_scale, ... are maintained for bay testing. */
    c1_scale  = _c1_scale.fixedflag ?    ((void)(FMax(2,crusher_scale[0],3.0)), c1_scale) : FMax(2,crusher_scale[0],3.0);
    area_std  = _area_std.fixedflag ?  ((void)(pw_gzrf2*a_gzrf2/2), area_std) : pw_gzrf2*a_gzrf2/2;   
    /* c1_scale = (crusher_cycles*1e7)/(area_std*GAM*opslthick); */
    
    if(exist(oppseq)==PSD_SE)  /* call only is spin echo sequence  */
    {
        if(((PSD_OFF == dualspinecho_flag) && (xygradCrusherFlag == PSD_ON)) ||
           ((PSD_ON == dualspinecho_flag) && ((xygradLeftCrusherFlag == PSD_ON) || (xygradRightCrusherFlag == PSD_ON))))
        {
            if ((amppwcrush(&gradz[GZRF2R1_SLOT], &gradz[GZRF2L1_SLOT],
                            (int)1, c1_scale, FMin(3, loggrd.tx_xyz, loggrd.ty_xyz, loggrd.tz_xyz), 
                            a_gzrf2, area_std, MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime) == FAILURE))
            {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwcrush" );
                return FAILURE;
            }
        }
        else
        {
            if ((amppwcrush(&gradz[GZRF2R1_SLOT], &gradz[GZRF2L1_SLOT],
                            (int)1, c1_scale, loggrd.tz_xyz, a_gzrf2, area_std,
                            MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime) == FAILURE)) 
            {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwcrush" );
                return FAILURE;
            }
        }
    }

    /* Include gz1 and gzmn in gradient duty cycle calc. MRIge37148 YP Du */
    gradz[GZ1_SLOT].num = 1;
    
    if ( existcv(opfcomp) && exist(opfcomp) == PSD_ON)
        gradz[GZMN_SLOT].num = 1;
    
    /* *******************************************************
       Left Crusher for 1st 180 (handles 90 pulse rephasing)
       Calc area needed for z rephaser for amppwlcrsh routine.
    *******************************************************/

    if (rfov_flag)
    {
        area_gz1  = _area_gz1.fixedflag ?        ((void)(a_gzrf1*(ex_pw_constantz+ex_pw_rampz)*ex_refocus_ratioz), area_gz1) : a_gzrf1*(ex_pw_constantz+ex_pw_rampz)*ex_refocus_ratioz;
    }
    else
    {   
        /* spsp area needed for rephaser */
        avail_pwgz1  = _avail_pwgz1.fixedflag ?  ((void)(TR_MAX), avail_pwgz1) : TR_MAX;
        area_gz1  = _area_gz1.fixedflag ?    ((void)(((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1), area_gz1) : ((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1;
        if(PSD_OFF == mux_flag)
        {
            if (ssEval1() == FAILURE) return FAILURE;  /* redefine area_gz1 for spectral-spatial pulse */

            if(ss_rf1 == PSD_OFF)
                area_gz1  = _area_gz1.fixedflag ?    ((void)(((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1), area_gz1) : ((float)rfExIso+(float)pw_gzrf1d/2.0)*a_gzrf1;
        }
    }
    
    /* Find modification needed for gz1 to take into account need to incorporate first Gz blip */
    if ((use_slice_fov_shift_blips) && (mux_flag == PSD_ON) && (mux_slices_rf1 > 1)) {
        /* Modification of Gz blip area for user CV FOV shift control */
        slice_fov_shift_cycles  = _slice_fov_shift_cycles.fixedflag ?    ((void)((slice_fov_shift-1)/((float)slice_fov_shift)), slice_fov_shift_cycles) : (slice_fov_shift-1)/((float)slice_fov_shift);
        slice_fov_shift_area  = _slice_fov_shift_area.fixedflag ?        ((void)(1.0e6*slice_fov_shift_cycles/(GAM*mux_slice_shift_mm_rf1/10.0)), slice_fov_shift_area) : 1.0e6*slice_fov_shift_cycles/(GAM*mux_slice_shift_mm_rf1/10.0);


        if (floatsAlmostEqualEpsilons(area_gz1, 0.0, 2) || floatsAlmostEqualEpsilons(slice_fov_shift_area, 0.0, 2) )
        {
            factor_gz1  = _factor_gz1.fixedflag ?  ((void)(0.0), factor_gz1) : 0.0;
        }
        else
        {
            factor_gz1  = _factor_gz1.fixedflag ?  ((void)(1.0), factor_gz1) : 1.0;
        }
    }
    else
    {
        factor_gz1  = _factor_gz1.fixedflag ?  ((void)(1.0), factor_gz1) : 1.0;
    }
 
    if (zgmn_type == CALC_GMN1) 
    {
        /* Set time origin for moment calculation at end of gzrf1d decay ramp.
           Therefore the gzrf1 pulse is time reversed. */
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        
        if (ss_rf1 == PSD_ON) 
        {
            zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(gz1_zero_moment), zeromomentsum) : gz1_zero_moment;
            firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(gz1_first_moment), firstmomentsum) : gz1_first_moment;
        }
        else 
        {
            rampmoments(0.0, a_gzrf1, pw_gzrf1d, invertphase, _pulsepos.fixedflag ? (_temp499_pulsepos=pulsepos,&_temp499_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp500_zeromoment=zeromoment,&_temp500_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp501_firstmoment=firstmoment,&_temp501_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp502_zeromomentsum=zeromomentsum,&_temp502_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp503_firstmomentsum=firstmomentsum,&_temp503_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf1, a_gzrf1, rfExIso, invertphase, _pulsepos.fixedflag ? (_temp504_pulsepos=pulsepos,&_temp504_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp505_zeromoment=zeromoment,&_temp505_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp506_firstmoment=firstmoment,&_temp506_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp507_zeromomentsum=zeromomentsum,&_temp507_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp508_firstmomentsum=firstmomentsum,&_temp508_firstmomentsum) : &firstmomentsum);
        }

        if (exist(oppseq) == PSD_SE) 
        {
            /* Make left and right crushers mirror images of each other */
            a_gzrf2l1  = _a_gzrf2l1.fixedflag ?  ((void)(a_gzrf2r1), a_gzrf2l1) : a_gzrf2r1;
            pw_gzrf2l1d  = _pw_gzrf2l1d.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2l1d) : pw_gzrf2r1a;
            pw_gzrf2l1  = _pw_gzrf2l1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2l1) : pw_gzrf2r1;
            pw_gzrf2l1a  = _pw_gzrf2l1a.fixedflag ?  ((void)(pw_gzrf2r1d), pw_gzrf2l1a) : pw_gzrf2r1d;
            pulsepos  = _pulsepos.fixedflag ?       
                      ((void)(-(rfExIso+pw_gzrf1d)+exist(opte)-(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2)), pulsepos) : -(rfExIso+pw_gzrf1d)+exist(opte)-(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2);
            rampmoments(0.0, a_gzrf2l1, pw_gzrf2l1a, invertphase, _pulsepos.fixedflag ? (_temp509_pulsepos=pulsepos,&_temp509_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp510_zeromoment=zeromoment,&_temp510_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp511_firstmoment=firstmoment,&_temp511_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp512_zeromomentsum=zeromomentsum,&_temp512_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp513_firstmomentsum=firstmomentsum,&_temp513_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2l1, a_gzrf2l1, pw_gzrf2l1, invertphase, _pulsepos.fixedflag ? (_temp514_pulsepos=pulsepos,&_temp514_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp515_zeromoment=zeromoment,&_temp515_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp516_firstmoment=firstmoment,&_temp516_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp517_zeromomentsum=zeromomentsum,&_temp517_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp518_firstmomentsum=firstmomentsum,&_temp518_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2l1, a_gzrf2, pw_gzrf2l1d, invertphase, _pulsepos.fixedflag ? (_temp519_pulsepos=pulsepos,&_temp519_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp520_zeromoment=zeromoment,&_temp520_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp521_firstmoment=firstmoment,&_temp521_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp522_zeromomentsum=zeromomentsum,&_temp522_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp523_firstmomentsum=firstmomentsum,&_temp523_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2, a_gzrf2, pw_gzrf2/2, invertphase, _pulsepos.fixedflag ? (_temp524_pulsepos=pulsepos,&_temp524_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp525_zeromoment=zeromoment,&_temp525_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp526_firstmoment=firstmoment,&_temp526_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp527_zeromomentsum=zeromomentsum,&_temp527_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp528_firstmomentsum=firstmomentsum,&_temp528_firstmomentsum) : &firstmomentsum);
            invertphase  = _invertphase.fixedflag ?  ((void)(1), invertphase) : 1;
            rampmoments(a_gzrf2, a_gzrf2, pw_gzrf2/2, invertphase, _pulsepos.fixedflag ? (_temp529_pulsepos=pulsepos,&_temp529_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp530_zeromoment=zeromoment,&_temp530_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp531_firstmoment=firstmoment,&_temp531_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp532_zeromomentsum=zeromomentsum,&_temp532_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp533_firstmomentsum=firstmomentsum,&_temp533_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2, a_gzrf2r1, pw_gzrf2r1a, invertphase, _pulsepos.fixedflag ? (_temp534_pulsepos=pulsepos,&_temp534_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp535_zeromoment=zeromoment,&_temp535_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp536_firstmoment=firstmoment,&_temp536_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp537_zeromomentsum=zeromomentsum,&_temp537_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp538_firstmomentsum=firstmomentsum,&_temp538_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2r1, a_gzrf2r1, pw_gzrf2r1, invertphase, _pulsepos.fixedflag ? (_temp539_pulsepos=pulsepos,&_temp539_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp540_zeromoment=zeromoment,&_temp540_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp541_firstmoment=firstmoment,&_temp541_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp542_zeromomentsum=zeromomentsum,&_temp542_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp543_firstmomentsum=firstmomentsum,&_temp543_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gzrf2r1, 0.0, pw_gzrf2r1d, invertphase, _pulsepos.fixedflag ? (_temp544_pulsepos=pulsepos,&_temp544_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp545_zeromoment=zeromoment,&_temp545_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp546_firstmoment=firstmoment,&_temp546_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp547_zeromomentsum=zeromomentsum,&_temp547_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp548_firstmomentsum=firstmomentsum,&_temp548_firstmomentsum) : &firstmomentsum);
            avail_zflow_time  = _avail_zflow_time.fixedflag ?         
                   
                ((void)(exist(opte)-(rfExIso+pw_gzrf1d+pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2)), avail_zflow_time) : exist(opte)-(rfExIso+pw_gzrf1d+pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2/2);
            firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(-1.0), firstmomentsum) : firstmomentsum*-1.0;
        }
        else 
        {  /* gradient recalled echo */
            avail_zflow_time  = _avail_zflow_time.fixedflag ?      ((void)(exist(opte)-(rfExIso+pw_gzrf1d)), avail_zflow_time) : exist(opte)-(rfExIso+pw_gzrf1d);
        }

        /* Calculate the z moment nulling pulses: gz1, gzmn */
        if (amppwgmn(zeromomentsum, firstmomentsum, 0.0, 0.0, avail_zflow_time,
                     loggrd.zbeta, loggrd.tz_xyz, loggrd.zrt*loggrd.scale_3axis_risetime, MIN_PLATEAU_TIME,
                     _a_gz1.fixedflag ? (_temp549_a_gz1=a_gz1,&_temp549_a_gz1) : &a_gz1, _pw_gz1a.fixedflag ? (_temp550_pw_gz1a=pw_gz1a,&_temp550_pw_gz1a) : &pw_gz1a, _pw_gz1.fixedflag ? (_temp551_pw_gz1=pw_gz1,&_temp551_pw_gz1) : &pw_gz1, _pw_gz1d.fixedflag ? (_temp552_pw_gz1d=pw_gz1d,&_temp552_pw_gz1d) : &pw_gz1d, _a_gzmn.fixedflag ? (_temp553_a_gzmn=a_gzmn,&_temp553_a_gzmn) : &a_gzmn, _pw_gzmna.fixedflag ? (_temp554_pw_gzmna=pw_gzmna,&_temp554_pw_gzmna) : &pw_gzmna,
                     _pw_gzmn.fixedflag ? (_temp555_pw_gzmn=pw_gzmn,&_temp555_pw_gzmn) : &pw_gzmn, _pw_gzmnd.fixedflag ? (_temp556_pw_gzmnd=pw_gzmnd,&_temp556_pw_gzmnd) : &pw_gzmnd) == FAILURE) {
            /* don't trap the failure here; this will drive minimum te */
        }
        a_gz1  = _a_gz1.fixedflag ?  ((void)(-1.0), a_gz1) : a_gz1*-1.0;  /* Invert gz1 pulse */
    } 
    else 
    {        /* zgmn_type != CALC_GMN1 */
        pw_gzmna  = _pw_gzmna.fixedflag ?  ((void)(0), pw_gzmna) : 0;
        pw_gzmn  = _pw_gzmn.fixedflag ?  ((void)(0), pw_gzmn) : 0;
        pw_gzmnd  = _pw_gzmnd.fixedflag ?  ((void)(0), pw_gzmnd) : 0;

        if (exist(oppseq) != PSD_SE) 
        {
            if (amppwgz1(_a_gz1.fixedflag ? (_temp557_a_gz1=a_gz1,&_temp557_a_gz1) : &a_gz1, _pw_gz1.fixedflag ? (_temp558_pw_gz1=pw_gz1,&_temp558_pw_gz1) : &pw_gz1, _pw_gz1a.fixedflag ? (_temp559_pw_gz1a=pw_gz1a,&_temp559_pw_gz1a) : &pw_gz1a, _pw_gz1d.fixedflag ? (_temp560_pw_gz1d=pw_gz1d,&_temp560_pw_gz1d) : &pw_gz1d, area_gz1,
                         avail_pwgz1, MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime,
                         loggrd.tz_xyz) == FAILURE) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgz1" );
                return FAILURE;
            }
        }
        else 
        {
            if ((use_slice_fov_shift_blips) && (mux_flag == PSD_ON) && (mux_slices_rf1 > 1) && (slice_fov_shift_area > 0.0)) {
                if(dpc_flag)
                {
                    if (amppwgz1(_a_gz1.fixedflag ? (_temp561_a_gz1=a_gz1,&_temp561_a_gz1) : &a_gz1, _pw_gz1.fixedflag ? (_temp562_pw_gz1=pw_gz1,&_temp562_pw_gz1) : &pw_gz1, _pw_gz1a.fixedflag ? (_temp563_pw_gz1a=pw_gz1a,&_temp563_pw_gz1a) : &pw_gz1a, _pw_gz1d.fixedflag ? (_temp564_pw_gz1d=pw_gz1d,&_temp564_pw_gz1d) : &pw_gz1d, fabs(slice_fov_shift_area/2) + fabs(area_gz1),
                                avail_pwgz1, MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime,
                                loggrd.tz_xyz) == FAILURE)
                    {
                        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgz1" );
                        return FAILURE;
                    }
                }
                else
                {
                    if (amppwgz1(_a_gz1.fixedflag ? (_temp565_a_gz1=a_gz1,&_temp565_a_gz1) : &a_gz1, _pw_gz1.fixedflag ? (_temp566_pw_gz1=pw_gz1,&_temp566_pw_gz1) : &pw_gz1, _pw_gz1a.fixedflag ? (_temp567_pw_gz1a=pw_gz1a,&_temp567_pw_gz1a) : &pw_gz1a, _pw_gz1d.fixedflag ? (_temp568_pw_gz1d=pw_gz1d,&_temp568_pw_gz1d) : &pw_gz1d, slice_fov_shift_area/2,
                                avail_pwgz1, MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime,
                                loggrd.tz_xyz) == FAILURE) {
                        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgz1" );
                        return FAILURE;
                    }
                }
            }
            else if(rtb0_flag || dpc_flag)
            {
                if (amppwgz1(_a_gz1.fixedflag ? (_temp569_a_gz1=a_gz1,&_temp569_a_gz1) : &a_gz1, _pw_gz1.fixedflag ? (_temp570_pw_gz1=pw_gz1,&_temp570_pw_gz1) : &pw_gz1, _pw_gz1a.fixedflag ? (_temp571_pw_gz1a=pw_gz1a,&_temp571_pw_gz1a) : &pw_gz1a, _pw_gz1d.fixedflag ? (_temp572_pw_gz1d=pw_gz1d,&_temp572_pw_gz1d) : &pw_gz1d, area_gz1,
                             avail_pwgz1, MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime,
                             loggrd.tz_xyz) == FAILURE) {
                    epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgz1" );
                    return FAILURE;
                }
            }
            else
            {
                a_gz1  = _a_gz1.fixedflag ?  ((void)(0.0), a_gz1) : 0.0;
                pw_gz1a  = _pw_gz1a.fixedflag ?  ((void)(0), pw_gz1a) : 0;
                pw_gz1  = _pw_gz1.fixedflag ?  ((void)(0), pw_gz1) : 0;
                pw_gz1d  = _pw_gz1d.fixedflag ?  ((void)(0), pw_gz1d) : 0;
            }

            if(!dpc_flag)
            {
                if(((PSD_OFF == dualspinecho_flag) && (xygradCrusherFlag == PSD_ON)) ||
                        ((PSD_ON == dualspinecho_flag) && ((xygradLeftCrusherFlag == PSD_ON) || (xygradRightCrusherFlag == PSD_ON))))
                {
                    if (amppwlcrsh(&gradz[GZRF2L1_SLOT], &gradz[GZRF2R1_SLOT],
                                area_gz1*((ssgr_flag && (!dualspinecho_flag)) ? -1 : 1), 
                                a_gzrf2, FMin(3, loggrd.tx_xyz, loggrd.ty_xyz, loggrd.tz_xyz),
                                MIN_PLATEAU_TIME, loggrd.zrt*loggrd.scale_3axis_risetime, _pw_gzrf2a.fixedflag ? (_temp573_pw_gzrf2a=pw_gzrf2a,&_temp573_pw_gzrf2a) : &pw_gzrf2a) == FAILURE)
                    {
                        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwlcrush" );
                        return FAILURE;
                    }
                }
                else
                {
                    if (amppwlcrsh(&gradz[GZRF2L1_SLOT], &gradz[GZRF2R1_SLOT],
                                area_gz1*((ssgr_flag && (!dualspinecho_flag)) ? -1 : 1), 
                                a_gzrf2, loggrd.tz_xyz, MIN_PLATEAU_TIME,
                                loggrd.zrt*loggrd.scale_3axis_risetime, _pw_gzrf2a.fixedflag ? (_temp574_pw_gzrf2a=pw_gzrf2a,&_temp574_pw_gzrf2a) : &pw_gzrf2a) == FAILURE) 
                    {
                        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwlcrush" );
                        return FAILURE;
                    }
                }
            }
        }
    }  /* 	if (zgmn_type == CALC_GMN1) */

    pw_gz1_tot  = _pw_gz1_tot.fixedflag ?            ((void)(pw_gz1a+pw_gz1+pw_gz1d+pw_gzmna+pw_gzmn+pw_gzmnd), pw_gz1_tot) : pw_gz1a+pw_gz1+pw_gz1d+pw_gzmna+pw_gzmn+pw_gzmnd;
    
    if (!rfov_flag && !mux_flag)
    {
        if (ssEval2() == FAILURE) return FAILURE;
    }

    /* DTI */
    if (PSD_OFF == dualspinecho_flag)
    {
        /* MRIhc05259 Insure that X, Y Crushers are off for non DSE case */
        xygradLeftCrusherFlag  = _xygradLeftCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradLeftCrusherFlag) : PSD_OFF;
        xygradRightCrusherFlag  = _xygradRightCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradRightCrusherFlag) : PSD_OFF;
        xygradCrusherFlag  = _xygradCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradCrusherFlag) : PSD_OFF;
        if(opslthick < 3.0) {
            xygradCrusherFlag  = _xygradCrusherFlag.fixedflag ?  ((void)(PSD_ON), xygradCrusherFlag) : PSD_ON;
        } else {
            xygradCrusherFlag  = _xygradCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradCrusherFlag) : PSD_OFF;
        }
        LeftCrusherRSlop = _LeftCrusherRSlop.fixedflag ? ((void)(0), LeftCrusherRSlop) : 0;
        LeftCrusherLSlop = _LeftCrusherLSlop.fixedflag ? ((void)(0), LeftCrusherLSlop) : 0;
        RightCrusherLSlop = _RightCrusherLSlop.fixedflag ? ((void)(0), RightCrusherLSlop) : 0;
        RightCrusherRSlop = _RightCrusherRSlop.fixedflag ? ((void)(0), RightCrusherRSlop) : 0;

        if( PSD_OFF == xygradCrusherFlag ) {
            a_xgradCrusherL  = _a_xgradCrusherL.fixedflag ?  ((void)(0), a_xgradCrusherL) : 0;
            a_xgradCrusherR  = _a_xgradCrusherR.fixedflag ?  ((void)(0), a_xgradCrusherR) : 0;
            a_ygradCrusherL  = _a_ygradCrusherL.fixedflag ?  ((void)(0), a_ygradCrusherL) : 0;
            a_ygradCrusherR  = _a_ygradCrusherR.fixedflag ?  ((void)(0), a_ygradCrusherR) : 0;
        } else {
            a_xgradCrusherL  = _a_xgradCrusherL.fixedflag ?  ((void)(a_gzrf2r1), a_xgradCrusherL) : a_gzrf2r1;
            a_xgradCrusherR  = _a_xgradCrusherR.fixedflag ?  ((void)(a_gzrf2r1), a_xgradCrusherR) : a_gzrf2r1;
            a_ygradCrusherL  = _a_ygradCrusherL.fixedflag ?  ((void)(a_gzrf2r1), a_ygradCrusherL) : a_gzrf2r1;
            a_ygradCrusherR  = _a_ygradCrusherR.fixedflag ?  ((void)(a_gzrf2r1), a_ygradCrusherR) : a_gzrf2r1;
        }

        if( PSD_ON == xygradCrusherFlag ) {
            CrusherLSlop = _CrusherLSlop.fixedflag ? ((void)(0), CrusherLSlop) : 0;
            CrusherRSlop = _CrusherRSlop.fixedflag ? ((void)(0), CrusherRSlop) : 0;
            pw_xgradCrusherL  = _pw_xgradCrusherL.fixedflag ?   ((void)(IMax(2,pw_gzrf2r1,pw_gzrf2l1)), pw_xgradCrusherL) : IMax(2,pw_gzrf2r1,pw_gzrf2l1);
            pw_xgradCrusherR  = _pw_xgradCrusherR.fixedflag ?   ((void)(IMax(2,pw_gzrf2r1,pw_gzrf2l1)), pw_xgradCrusherR) : IMax(2,pw_gzrf2r1,pw_gzrf2l1);
            pw_xgradCrusherLa  = _pw_xgradCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2r1a,pw_gzrf2r1d)), pw_xgradCrusherLa) : IMax(2,pw_gzrf2r1a,pw_gzrf2r1d);
            pw_xgradCrusherRa  = _pw_xgradCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2r1a,pw_gzrf2r1d)), pw_xgradCrusherRa) : IMax(2,pw_gzrf2r1a,pw_gzrf2r1d);
            pw_xgradCrusherLd  = _pw_xgradCrusherLd.fixedflag ?  ((void)(pw_xgradCrusherLa), pw_xgradCrusherLd) : pw_xgradCrusherLa;
            pw_xgradCrusherRd  = _pw_xgradCrusherRd.fixedflag ?  ((void)(pw_xgradCrusherRa), pw_xgradCrusherRd) : pw_xgradCrusherRa;
            pw_ygradCrusherL  = _pw_ygradCrusherL.fixedflag ?   ((void)(IMax(2,pw_gzrf2r1,pw_gzrf2l1)), pw_ygradCrusherL) : IMax(2,pw_gzrf2r1,pw_gzrf2l1);
            pw_ygradCrusherR  = _pw_ygradCrusherR.fixedflag ?   ((void)(IMax(2,pw_gzrf2r1,pw_gzrf2l1)), pw_ygradCrusherR) : IMax(2,pw_gzrf2r1,pw_gzrf2l1);
            pw_ygradCrusherLa  = _pw_ygradCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2r1a,pw_gzrf2r1d)), pw_ygradCrusherLa) : IMax(2,pw_gzrf2r1a,pw_gzrf2r1d);
            pw_ygradCrusherRa  = _pw_ygradCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2r1a,pw_gzrf2r1d)), pw_ygradCrusherRa) : IMax(2,pw_gzrf2r1a,pw_gzrf2r1d);
            pw_ygradCrusherLd  = _pw_ygradCrusherLd.fixedflag ?  ((void)(pw_ygradCrusherLa), pw_ygradCrusherLd) : pw_ygradCrusherLa;
            pw_ygradCrusherRd  = _pw_ygradCrusherRd.fixedflag ?  ((void)(pw_ygradCrusherRa), pw_ygradCrusherRd) : pw_ygradCrusherRa;
            if(pw_xgradCrusherL-pw_gzrf2l1 > 0) {
                 CrusherLSlop  = _CrusherLSlop.fixedflag ?  ((void)((pw_xgradCrusherL-pw_gzrf2l1)), CrusherLSlop) : CrusherLSlop+(pw_xgradCrusherL-pw_gzrf2l1);
            }
            if(pw_xgradCrusherR-pw_gzrf2r1 > 0) {
                 CrusherRSlop  = _CrusherRSlop.fixedflag ?  ((void)((pw_xgradCrusherR-pw_gzrf2r1)), CrusherRSlop) : CrusherRSlop+(pw_xgradCrusherR-pw_gzrf2r1);
            }
            if(pw_xgradCrusherLa-pw_gzrf2l1a > 0) {
                 CrusherLSlop  = _CrusherLSlop.fixedflag ?  ((void)((pw_xgradCrusherLa-pw_gzrf2l1a)), CrusherLSlop) : CrusherLSlop+(pw_xgradCrusherLa-pw_gzrf2l1a);
            }
            if(pw_xgradCrusherRa-pw_gzrf2r1a > 0) {
                 CrusherRSlop  = _CrusherRSlop.fixedflag ?  ((void)((pw_xgradCrusherRa-pw_gzrf2r1a)), CrusherRSlop) : CrusherRSlop+(pw_xgradCrusherRa-pw_gzrf2r1a);
            }
            if(pw_xgradCrusherLd-pw_gzrf2l1d > 0) {
                 CrusherLSlop  = _CrusherLSlop.fixedflag ?  ((void)((pw_xgradCrusherLd-pw_gzrf2l1d)), CrusherLSlop) : CrusherLSlop+(pw_xgradCrusherLd-pw_gzrf2l1d);
            }
            if(pw_xgradCrusherRd-pw_gzrf2r1d > 0) {
                 CrusherRSlop  = _CrusherRSlop.fixedflag ?  ((void)((pw_xgradCrusherRd-pw_gzrf2r1d)), CrusherRSlop) : CrusherRSlop+(pw_xgradCrusherRd-pw_gzrf2r1d);
            }
        } else {
            CrusherLSlop = _CrusherLSlop.fixedflag ? ((void)(0), CrusherLSlop) : 0;
            CrusherRSlop = _CrusherRSlop.fixedflag ? ((void)(0), CrusherRSlop) : 0;
            pw_xgradCrusherL  = _pw_xgradCrusherL.fixedflag ?  ((void)(0), pw_xgradCrusherL) : 0;
            pw_xgradCrusherR  = _pw_xgradCrusherR.fixedflag ?  ((void)(0), pw_xgradCrusherR) : 0;
            pw_xgradCrusherLa  = _pw_xgradCrusherLa.fixedflag ?  ((void)(0), pw_xgradCrusherLa) : 0;
            pw_xgradCrusherRa  = _pw_xgradCrusherRa.fixedflag ?  ((void)(0), pw_xgradCrusherRa) : 0;
            pw_xgradCrusherLd  = _pw_xgradCrusherLd.fixedflag ?  ((void)(0), pw_xgradCrusherLd) : 0;
            pw_xgradCrusherRd  = _pw_xgradCrusherRd.fixedflag ?  ((void)(0), pw_xgradCrusherRd) : 0;
            pw_ygradCrusherL  = _pw_ygradCrusherL.fixedflag ?  ((void)(0), pw_ygradCrusherL) : 0;
            pw_ygradCrusherR  = _pw_ygradCrusherR.fixedflag ?  ((void)(0), pw_ygradCrusherR) : 0;
            pw_ygradCrusherLa  = _pw_ygradCrusherLa.fixedflag ?  ((void)(0), pw_ygradCrusherLa) : 0;
            pw_ygradCrusherRa  = _pw_ygradCrusherRa.fixedflag ?  ((void)(0), pw_ygradCrusherRa) : 0;
            pw_ygradCrusherLd  = _pw_ygradCrusherLd.fixedflag ?  ((void)(0), pw_ygradCrusherLd) : 0;
            pw_ygradCrusherRd  = _pw_ygradCrusherRd.fixedflag ?  ((void)(0), pw_ygradCrusherRd) : 0;
        }

        pw_gzrf2a  = _pw_gzrf2a.fixedflag ?  ((void)(pw_gzrf2l1d), pw_gzrf2a) : pw_gzrf2l1d;
        pw_gzrf2d  = _pw_gzrf2d.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2d) : pw_gzrf2r1a;
        pw_gzrf2l1_tot  = _pw_gzrf2l1_tot.fixedflag ?        ((void)(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+CrusherLSlop), pw_gzrf2l1_tot) : pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+CrusherLSlop;
        pw_gzrf2r1_tot  = _pw_gzrf2r1_tot.fixedflag ?        ((void)(pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d+CrusherRSlop), pw_gzrf2r1_tot) : pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d+CrusherRSlop;

        pw_gzrf2l1_tot_bval  = _pw_gzrf2l1_tot_bval.fixedflag ?        ((void)(pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+CrusherLSlop), pw_gzrf2l1_tot_bval) : pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+CrusherLSlop;
        pw_gzrf2r1_tot_bval  = _pw_gzrf2r1_tot_bval.fixedflag ?        ((void)(pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d+CrusherRSlop), pw_gzrf2r1_tot_bval) : pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d+CrusherRSlop;

    } else {
        /* MRIhc05259 Require Left side crusher only if opslthick < 4.0 */
        xygradLeftCrusherFlag  = _xygradLeftCrusherFlag.fixedflag ?  ((void)(PSD_ON), xygradLeftCrusherFlag) : PSD_ON;
        xygradRightCrusherFlag  = _xygradRightCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradRightCrusherFlag) : PSD_OFF;
        xygradCrusherFlag  = _xygradCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradCrusherFlag) : PSD_OFF;

        CrusherLSlop = _CrusherLSlop.fixedflag ? ((void)(0), CrusherLSlop) : 0;
        CrusherRSlop = _CrusherRSlop.fixedflag ? ((void)(0), CrusherRSlop) : 0;

        /* MRIhc05259 Require Right side crusher only if opslthick < 2.1 mm */
        if(opslthick < 2.1) {
        xygradRightCrusherFlag  = _xygradRightCrusherFlag.fixedflag ?  ((void)(PSD_ON), xygradRightCrusherFlag) : PSD_ON;
        }
        else {
        xygradRightCrusherFlag  = _xygradRightCrusherFlag.fixedflag ?  ((void)(PSD_OFF), xygradRightCrusherFlag) : PSD_OFF;
        }

        /* BJM: this section sets the pulse widths and amps for */
        /* the 180 refocusing pulses. Since the code already sets these up */
        /* for normal spin-echo epi, I use those results.  The "left" gzrf2 */
        /* pulse is closest to the 90 while the "right" gzrf2 pulse is closest to */
        /* the readout.  While I realize this is not the most intuitive naming convention */
        /* at least it is consistent with previous non-intutivie epic naming conventions */
        /* Note: the gz1 area is combined with the "l1" crusher under */
        /* normal conditions.  The same is done here except it is only done for the */
        /* "l1" cursher associated witht the "left" gzrf2 pulse */

        /* amps of non-symmetric left pulse - account for area_gz1 */
        a_gzrf2leftl1  = _a_gzrf2leftl1.fixedflag ?  ((void)(a_gzrf2l1), a_gzrf2leftl1) : a_gzrf2l1;
        a_gzrf2leftr1  = _a_gzrf2leftr1.fixedflag ?  ((void)(a_gzrf2r1), a_gzrf2leftr1) : a_gzrf2r1;

        /* amps of symmetric right pulse */
        a_gzrf2rightl1  = _a_gzrf2rightl1.fixedflag ?  ((void)(a_gzrf2r1), a_gzrf2rightl1) : a_gzrf2r1;
        a_gzrf2rightr1  = _a_gzrf2rightr1.fixedflag ?  ((void)(a_gzrf2r1), a_gzrf2rightr1) : a_gzrf2r1;


        /* MRIhc05227 */
        /* Duplicate amps of Z right 180 right-side crusher for X and Y to  */
        /* avoid unequal amplitude associated with including area_gz1 on */
        /* left 180 left-side crusher */

        if( PSD_OFF == xygradRightCrusherFlag ) {
            a_xgradRightCrusherL  = _a_xgradRightCrusherL.fixedflag ?  ((void)(0), a_xgradRightCrusherL) : 0;
            a_xgradRightCrusherR  = _a_xgradRightCrusherR.fixedflag ?  ((void)(0), a_xgradRightCrusherR) : 0;
            a_ygradRightCrusherL  = _a_ygradRightCrusherL.fixedflag ?  ((void)(0), a_ygradRightCrusherL) : 0;
            a_ygradRightCrusherR  = _a_ygradRightCrusherR.fixedflag ?  ((void)(0), a_ygradRightCrusherR) : 0; 
        } else {
            a_xgradRightCrusherL  = _a_xgradRightCrusherL.fixedflag ?  ((void)(a_gzrf2rightr1), a_xgradRightCrusherL) : a_gzrf2rightr1;
            a_xgradRightCrusherR  = _a_xgradRightCrusherR.fixedflag ?  ((void)(a_gzrf2rightr1), a_xgradRightCrusherR) : a_gzrf2rightr1;
            a_ygradRightCrusherL  = _a_ygradRightCrusherL.fixedflag ?  ((void)(a_gzrf2rightr1), a_ygradRightCrusherL) : a_gzrf2rightr1;
            a_ygradRightCrusherR  = _a_ygradRightCrusherR.fixedflag ?  ((void)(a_gzrf2rightr1), a_ygradRightCrusherR) : a_gzrf2rightr1;
        }
        if( PSD_OFF == xygradLeftCrusherFlag ) {
            a_xgradLeftCrusherL  = _a_xgradLeftCrusherL.fixedflag ?  ((void)(0), a_xgradLeftCrusherL) : 0;
            a_xgradLeftCrusherR  = _a_xgradLeftCrusherR.fixedflag ?  ((void)(0), a_xgradLeftCrusherR) : 0;
            a_ygradLeftCrusherL  = _a_ygradLeftCrusherL.fixedflag ?  ((void)(0), a_ygradLeftCrusherL) : 0;
            a_ygradLeftCrusherR  = _a_ygradLeftCrusherR.fixedflag ?  ((void)(0), a_ygradLeftCrusherR) : 0;
        } else {
            a_xgradLeftCrusherL  = _a_xgradLeftCrusherL.fixedflag ?  ((void)(a_gzrf2leftr1), a_xgradLeftCrusherL) : a_gzrf2leftr1;
            a_xgradLeftCrusherR  = _a_xgradLeftCrusherR.fixedflag ?  ((void)(a_gzrf2leftr1), a_xgradLeftCrusherR) : a_gzrf2leftr1;
            a_ygradLeftCrusherL  = _a_ygradLeftCrusherL.fixedflag ?  ((void)(a_gzrf2leftr1), a_ygradLeftCrusherL) : a_gzrf2leftr1;
            a_ygradLeftCrusherR  = _a_ygradLeftCrusherR.fixedflag ?  ((void)(a_gzrf2leftr1), a_ygradLeftCrusherR) : a_gzrf2leftr1;
        } 


        /* pw_gzrf2leftl1 = pw_gzrf2l1 since gz1 pulse combine with crusher */
        /* left crusher on "left" pulse */
        pw_gzrf2leftl1a  = _pw_gzrf2leftl1a.fixedflag ?  ((void)(pw_gzrf2l1a), pw_gzrf2leftl1a) : pw_gzrf2l1a;   /* r1d */
        pw_gzrf2leftl1d  = _pw_gzrf2leftl1d.fixedflag ?  ((void)(pw_gzrf2l1d), pw_gzrf2leftl1d) : pw_gzrf2l1d;   /* r1a */

        {

            /* Area of crusher */  
            float AreaLeftl1 = a_gzrf2l1*(pw_gzrf2l1+(pw_gzrf2l1a+pw_gzrf2l1d)/2);           

            /* Added ability to double the area */
            if(unbalanceCrusher == PSD_OFF) {
               
                pw_gzrf2leftl1  = _pw_gzrf2leftl1.fixedflag ?  ((void)(pw_gzrf2l1), pw_gzrf2leftl1) : pw_gzrf2l1;
               
            } else {
               
                /* Recalc flattop */                
                pw_gzrf2leftl1  = _pw_gzrf2leftl1.fixedflag ?    ((void)(RUP_GRD((crusherFactorLeft*AreaLeftl1)/a_gzrf2l1-(pw_gzrf2l1a+pw_gzrf2l1d)/2)), pw_gzrf2leftl1) : RUP_GRD((crusherFactorLeft*AreaLeftl1)/a_gzrf2l1-(pw_gzrf2l1a+pw_gzrf2l1d)/2);
                if(pw_gzrf2leftl1 < GRAD_UPDATE_TIME) pw_gzrf2leftl1  = _pw_gzrf2leftl1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzrf2leftl1) : GRAD_UPDATE_TIME; 
               
            }
           
            /* right crusher on "left" pulse */
            pw_gzrf2leftr1a  = _pw_gzrf2leftr1a.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2leftr1a) : pw_gzrf2r1a;
            pw_gzrf2leftr1d  = _pw_gzrf2leftr1d.fixedflag ?  ((void)(pw_gzrf2r1d), pw_gzrf2leftr1d) : pw_gzrf2r1d;
            pw_gzrf2leftr1  = _pw_gzrf2leftr1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2leftr1) : pw_gzrf2r1;
           
            /* Added ability to double the area */
            if(unbalanceCrusher == PSD_OFF) {
               
                pw_gzrf2leftr1  = _pw_gzrf2leftr1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2leftr1) : pw_gzrf2r1;
               
            } else {
                         
                /* Calculate original area of r1 crusher & add any additional area from l1 */
                float origAreaLeftr1 = a_gzrf2r1*(pw_gzrf2r1+(pw_gzrf2r1a+pw_gzrf2r1d)/2);
                float area2Add = (crusherFactorLeft-1)*AreaLeftl1;

                pw_gzrf2leftr1  = _pw_gzrf2leftr1.fixedflag ?    ((void)(RUP_GRD((origAreaLeftr1+area2Add)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2)), pw_gzrf2leftr1) : RUP_GRD((origAreaLeftr1+area2Add)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2);
                if(pw_gzrf2leftr1 < GRAD_UPDATE_TIME) pw_gzrf2leftr1  = _pw_gzrf2leftr1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzrf2leftr1) : GRAD_UPDATE_TIME; 
               
            }
           
        }

        pw_gzrf2lefta  = _pw_gzrf2lefta.fixedflag ?  ((void)(pw_gzrf2leftl1d), pw_gzrf2lefta) : pw_gzrf2leftl1d;
        pw_gzrf2leftd  = _pw_gzrf2leftd.fixedflag ?  ((void)(pw_gzrf2leftr1a), pw_gzrf2leftd) : pw_gzrf2leftr1a;

        /* left crusher on "right" pulse */
        pw_gzrf2rightl1a  = _pw_gzrf2rightl1a.fixedflag ?  ((void)(pw_gzrf2r1d), pw_gzrf2rightl1a) : pw_gzrf2r1d;
        pw_gzrf2rightl1d  = _pw_gzrf2rightl1d.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2rightl1d) : pw_gzrf2r1a;

        /* Added ability to double the area */
        if(unbalanceCrusher == PSD_OFF) {

            pw_gzrf2rightl1  = _pw_gzrf2rightl1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2rightl1) : pw_gzrf2r1;

        } else {
            
            float origAreaRightl1 =  a_gzrf2r1*(pw_gzrf2r1+(pw_gzrf2r1a+pw_gzrf2r1d)/2);         
            pw_gzrf2rightl1  = _pw_gzrf2rightl1.fixedflag ?  ((void)(RUP_GRD((crusherFactorRight*origAreaRightl1)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2)), pw_gzrf2rightl1) : RUP_GRD((crusherFactorRight*origAreaRightl1)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2);
            if(pw_gzrf2rightl1 < GRAD_UPDATE_TIME) pw_gzrf2rightl1  = _pw_gzrf2rightl1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzrf2rightl1) : GRAD_UPDATE_TIME; 

        }

        /* right crusher on "right" pulse */
        pw_gzrf2rightr1a  = _pw_gzrf2rightr1a.fixedflag ?  ((void)(pw_gzrf2r1a), pw_gzrf2rightr1a) : pw_gzrf2r1a;
        pw_gzrf2rightr1d  = _pw_gzrf2rightr1d.fixedflag ?  ((void)(pw_gzrf2r1d), pw_gzrf2rightr1d) : pw_gzrf2r1d;

        /* Added ability to double the area */
        if(unbalanceCrusher == PSD_OFF) {

            pw_gzrf2rightr1  = _pw_gzrf2rightr1.fixedflag ?  ((void)(pw_gzrf2r1), pw_gzrf2rightr1) : pw_gzrf2r1;

	} else {
       
            float origAreaRightr1 =  a_gzrf2r1*(pw_gzrf2r1+(pw_gzrf2r1a+pw_gzrf2r1d)/2);         
            pw_gzrf2rightr1  = _pw_gzrf2rightr1.fixedflag ?  ((void)(RUP_GRD((crusherFactorRight*origAreaRightr1)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2)), pw_gzrf2rightr1) : RUP_GRD((crusherFactorRight*origAreaRightr1)/a_gzrf2r1-(pw_gzrf2r1a+pw_gzrf2r1d)/2);
            if(pw_gzrf2rightr1 < GRAD_UPDATE_TIME) pw_gzrf2rightr1  = _pw_gzrf2rightr1.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_gzrf2rightr1) : GRAD_UPDATE_TIME; 

	}			
  
        pw_gzrf2righta  = _pw_gzrf2righta.fixedflag ?  ((void)(pw_gzrf2rightl1d), pw_gzrf2righta) : pw_gzrf2rightl1d;
        pw_gzrf2rightd  = _pw_gzrf2rightd.fixedflag ?  ((void)(pw_gzrf2rightr1a), pw_gzrf2rightd) : pw_gzrf2rightr1a;
        pw_gzrf2l1_tot  = _pw_gzrf2l1_tot.fixedflag ?        
                ((void)((pw_gzrf2leftl1a+pw_gzrf2leftl1+pw_gzrf2leftl1d)+(pw_gzrf2leftr1a+pw_gzrf2leftr1+pw_gzrf2leftr1d)), pw_gzrf2l1_tot) : (pw_gzrf2leftl1a+pw_gzrf2leftl1+pw_gzrf2leftl1d)+(pw_gzrf2leftr1a+pw_gzrf2leftr1+pw_gzrf2leftr1d);
        pw_gzrf2r1_tot  = _pw_gzrf2r1_tot.fixedflag ?        
                ((void)((pw_gzrf2rightl1a+pw_gzrf2rightl1+pw_gzrf2rightl1d)+(pw_gzrf2rightr1a+pw_gzrf2rightr1+pw_gzrf2rightr1d)), pw_gzrf2r1_tot) : (pw_gzrf2rightl1a+pw_gzrf2rightl1+pw_gzrf2rightl1d)+(pw_gzrf2rightr1a+pw_gzrf2rightr1+pw_gzrf2rightr1d);
      
        /* MRIhc05227 */
        /* Duplicate pulse widths of Z crushers for X and Y crushers */
        /* Use longer attack/decay pulse width to avoid gradient faults */
        /* for very thin slices.  Calculate add'l time and add to Slop */
        if( PSD_ON == xygradRightCrusherFlag ) {
            RightCrusherLSlop = _RightCrusherLSlop.fixedflag ? ((void)(0), RightCrusherLSlop) : 0;
            RightCrusherRSlop = _RightCrusherRSlop.fixedflag ? ((void)(0), RightCrusherRSlop) : 0;
            pw_xgradRightCrusherL  = _pw_xgradRightCrusherL.fixedflag ?   ((void)(IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1)), pw_xgradRightCrusherL) : IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1);
            pw_xgradRightCrusherR  = _pw_xgradRightCrusherR.fixedflag ?   ((void)(IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1)), pw_xgradRightCrusherR) : IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1);
            pw_xgradRightCrusherLa  = _pw_xgradRightCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d)), pw_xgradRightCrusherLa) : IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d);
            pw_xgradRightCrusherRa  = _pw_xgradRightCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d)), pw_xgradRightCrusherRa) : IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d);
            pw_xgradRightCrusherLd  = _pw_xgradRightCrusherLd.fixedflag ?  ((void)(pw_xgradRightCrusherLa), pw_xgradRightCrusherLd) : pw_xgradRightCrusherLa;
            pw_xgradRightCrusherRd  = _pw_xgradRightCrusherRd.fixedflag ?  ((void)(pw_xgradRightCrusherRa), pw_xgradRightCrusherRd) : pw_xgradRightCrusherRa;
            pw_ygradRightCrusherL  = _pw_ygradRightCrusherL.fixedflag ?   ((void)(IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1)), pw_ygradRightCrusherL) : IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1);
            pw_ygradRightCrusherR  = _pw_ygradRightCrusherR.fixedflag ?   ((void)(IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1)), pw_ygradRightCrusherR) : IMax(2,pw_gzrf2rightr1,pw_gzrf2rightl1);
            pw_ygradRightCrusherLa  = _pw_ygradRightCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d)), pw_ygradRightCrusherLa) : IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d);
            pw_ygradRightCrusherRa  = _pw_ygradRightCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d)), pw_ygradRightCrusherRa) : IMax(2,pw_gzrf2rightr1a,pw_gzrf2rightr1d);
            pw_ygradRightCrusherLd  = _pw_ygradRightCrusherLd.fixedflag ?  ((void)(pw_ygradRightCrusherLa), pw_ygradRightCrusherLd) : pw_ygradRightCrusherLa;
            pw_ygradRightCrusherRd  = _pw_ygradRightCrusherRd.fixedflag ?  ((void)(pw_ygradRightCrusherRa), pw_ygradRightCrusherRd) : pw_ygradRightCrusherRa;
            if(pw_xgradRightCrusherL-pw_gzrf2rightl1 > 0) {
                 RightCrusherLSlop  = _RightCrusherLSlop.fixedflag ?  ((void)((pw_xgradRightCrusherL-pw_gzrf2rightl1)), RightCrusherLSlop) : RightCrusherLSlop+(pw_xgradRightCrusherL-pw_gzrf2rightl1);
            }
            if(pw_xgradRightCrusherR-pw_gzrf2rightr1 > 0) {
                 RightCrusherRSlop  = _RightCrusherRSlop.fixedflag ?  ((void)((pw_xgradRightCrusherR-pw_gzrf2rightr1)), RightCrusherRSlop) : RightCrusherRSlop+(pw_xgradRightCrusherR-pw_gzrf2rightr1);
            }
            if(pw_xgradRightCrusherLa-pw_gzrf2rightl1a > 0) {
                 RightCrusherLSlop  = _RightCrusherLSlop.fixedflag ?  ((void)((pw_xgradRightCrusherLa-pw_gzrf2rightl1a)), RightCrusherLSlop) : RightCrusherLSlop+(pw_xgradRightCrusherLa-pw_gzrf2rightl1a);
            }
            if(pw_xgradRightCrusherRa-pw_gzrf2rightr1a > 0) {
                 RightCrusherRSlop  = _RightCrusherRSlop.fixedflag ?  ((void)((pw_xgradRightCrusherRa-pw_gzrf2rightr1a)), RightCrusherRSlop) : RightCrusherRSlop+(pw_xgradRightCrusherRa-pw_gzrf2rightr1a);
            }
            if(pw_xgradRightCrusherLd-pw_gzrf2rightl1d > 0) {
                 RightCrusherLSlop  = _RightCrusherLSlop.fixedflag ?  ((void)((pw_xgradRightCrusherLd-pw_gzrf2rightl1d)), RightCrusherLSlop) : RightCrusherLSlop+(pw_xgradRightCrusherLd-pw_gzrf2rightl1d);
            }
            if(pw_xgradRightCrusherRd-pw_gzrf2rightr1d > 0) {
                 RightCrusherRSlop  = _RightCrusherRSlop.fixedflag ?  ((void)((pw_xgradRightCrusherRd-pw_gzrf2rightr1d)), RightCrusherRSlop) : RightCrusherRSlop+(pw_xgradRightCrusherRd-pw_gzrf2rightr1d);
            }
        } else {
            RightCrusherLSlop = _RightCrusherLSlop.fixedflag ? ((void)(0), RightCrusherLSlop) : 0;
            RightCrusherRSlop = _RightCrusherRSlop.fixedflag ? ((void)(0), RightCrusherRSlop) : 0;
            pw_xgradRightCrusherL  = _pw_xgradRightCrusherL.fixedflag ?  ((void)(0), pw_xgradRightCrusherL) : 0;
            pw_xgradRightCrusherR  = _pw_xgradRightCrusherR.fixedflag ?  ((void)(0), pw_xgradRightCrusherR) : 0;
            pw_xgradRightCrusherLa  = _pw_xgradRightCrusherLa.fixedflag ?  ((void)(0), pw_xgradRightCrusherLa) : 0;
            pw_xgradRightCrusherRa  = _pw_xgradRightCrusherRa.fixedflag ?  ((void)(0), pw_xgradRightCrusherRa) : 0;
            pw_xgradRightCrusherLd  = _pw_xgradRightCrusherLd.fixedflag ?  ((void)(0), pw_xgradRightCrusherLd) : 0;
            pw_xgradRightCrusherRd  = _pw_xgradRightCrusherRd.fixedflag ?  ((void)(0), pw_xgradRightCrusherRd) : 0;
            pw_ygradRightCrusherL  = _pw_ygradRightCrusherL.fixedflag ?  ((void)(0), pw_ygradRightCrusherL) : 0;
            pw_ygradRightCrusherR  = _pw_ygradRightCrusherR.fixedflag ?  ((void)(0), pw_ygradRightCrusherR) : 0;
            pw_ygradRightCrusherLa  = _pw_ygradRightCrusherLa.fixedflag ?  ((void)(0), pw_ygradRightCrusherLa) : 0;
            pw_ygradRightCrusherRa  = _pw_ygradRightCrusherRa.fixedflag ?  ((void)(0), pw_ygradRightCrusherRa) : 0;
            pw_ygradRightCrusherLd  = _pw_ygradRightCrusherLd.fixedflag ?  ((void)(0), pw_ygradRightCrusherLd) : 0;
            pw_ygradRightCrusherRd  = _pw_ygradRightCrusherRd.fixedflag ?  ((void)(0), pw_ygradRightCrusherRd) : 0;
        }
        if( PSD_ON == xygradLeftCrusherFlag ) {
            LeftCrusherLSlop = _LeftCrusherLSlop.fixedflag ? ((void)(0), LeftCrusherLSlop) : 0;
            LeftCrusherRSlop = _LeftCrusherRSlop.fixedflag ? ((void)(0), LeftCrusherRSlop) : 0;
            pw_xgradLeftCrusherL  = _pw_xgradLeftCrusherL.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1)), pw_xgradLeftCrusherL) : IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1);
            pw_xgradLeftCrusherR  = _pw_xgradLeftCrusherR.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1)), pw_xgradLeftCrusherR) : IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1);
            pw_xgradLeftCrusherLa  = _pw_xgradLeftCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d)), pw_xgradLeftCrusherLa) : IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d);
            pw_xgradLeftCrusherRa  = _pw_xgradLeftCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d)), pw_xgradLeftCrusherRa) : IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d);
            pw_xgradLeftCrusherLd  = _pw_xgradLeftCrusherLd.fixedflag ?  ((void)(pw_xgradLeftCrusherLa), pw_xgradLeftCrusherLd) : pw_xgradLeftCrusherLa;
            pw_xgradLeftCrusherRd  = _pw_xgradLeftCrusherRd.fixedflag ?  ((void)(pw_xgradLeftCrusherRa), pw_xgradLeftCrusherRd) : pw_xgradLeftCrusherRa;
            pw_ygradLeftCrusherL  = _pw_ygradLeftCrusherL.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1)), pw_ygradLeftCrusherL) : IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1);
            pw_ygradLeftCrusherR  = _pw_ygradLeftCrusherR.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1)), pw_ygradLeftCrusherR) : IMax(2,pw_gzrf2leftl1,pw_gzrf2leftr1);
            pw_ygradLeftCrusherLa  = _pw_ygradLeftCrusherLa.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d)), pw_ygradLeftCrusherLa) : IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d);
            pw_ygradLeftCrusherRa  = _pw_ygradLeftCrusherRa.fixedflag ?  ((void)(IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d)), pw_ygradLeftCrusherRa) : IMax(2,pw_gzrf2leftr1a,pw_gzrf2leftr1d);
            pw_ygradLeftCrusherLd  = _pw_ygradLeftCrusherLd.fixedflag ?  ((void)(pw_ygradLeftCrusherLa), pw_ygradLeftCrusherLd) : pw_ygradLeftCrusherLa;
            pw_ygradLeftCrusherRd  = _pw_ygradLeftCrusherRd.fixedflag ?  ((void)(pw_ygradLeftCrusherRa), pw_ygradLeftCrusherRd) : pw_ygradLeftCrusherRa;
            if(pw_xgradLeftCrusherL-pw_gzrf2leftl1 > 0) {
                 LeftCrusherLSlop  = _LeftCrusherLSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherL-pw_gzrf2leftl1)), LeftCrusherLSlop) : LeftCrusherLSlop+(pw_xgradLeftCrusherL-pw_gzrf2leftl1);
            }
            if(pw_xgradLeftCrusherR-pw_gzrf2leftr1 > 0) {
                 LeftCrusherRSlop  = _LeftCrusherRSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherR-pw_gzrf2leftr1)), LeftCrusherRSlop) : LeftCrusherRSlop+(pw_xgradLeftCrusherR-pw_gzrf2leftr1);
            }
            if(pw_xgradLeftCrusherLa-pw_gzrf2leftl1a > 0) {
                 LeftCrusherLSlop  = _LeftCrusherLSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherLa-pw_gzrf2leftl1a)), LeftCrusherLSlop) : LeftCrusherLSlop+(pw_xgradLeftCrusherLa-pw_gzrf2leftl1a);
            }
            if(pw_xgradLeftCrusherRa-pw_gzrf2leftr1a > 0) {
                 LeftCrusherRSlop  = _LeftCrusherRSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherRa-pw_gzrf2leftr1a)), LeftCrusherRSlop) : LeftCrusherRSlop+(pw_xgradLeftCrusherRa-pw_gzrf2leftr1a);
            }
            if(pw_xgradLeftCrusherLd-pw_gzrf2leftl1d > 0) {
                 LeftCrusherLSlop  = _LeftCrusherLSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherLd-pw_gzrf2leftl1d)), LeftCrusherLSlop) : LeftCrusherLSlop+(pw_xgradLeftCrusherLd-pw_gzrf2leftl1d);
            }
            if(pw_xgradLeftCrusherRd-pw_gzrf2leftr1d > 0) {
                 LeftCrusherRSlop  = _LeftCrusherRSlop.fixedflag ?  ((void)((pw_xgradLeftCrusherRd-pw_gzrf2leftr1d)), LeftCrusherRSlop) : LeftCrusherRSlop+(pw_xgradLeftCrusherRd-pw_gzrf2leftr1d);
            }

        } else {
            LeftCrusherLSlop = _LeftCrusherLSlop.fixedflag ? ((void)(0), LeftCrusherLSlop) : 0;
            LeftCrusherRSlop = _LeftCrusherRSlop.fixedflag ? ((void)(0), LeftCrusherRSlop) : 0;
            pw_xgradLeftCrusherL  = _pw_xgradLeftCrusherL.fixedflag ?  ((void)(0), pw_xgradLeftCrusherL) : 0;
            pw_xgradLeftCrusherR  = _pw_xgradLeftCrusherR.fixedflag ?  ((void)(0), pw_xgradLeftCrusherR) : 0;
            pw_xgradLeftCrusherLa  = _pw_xgradLeftCrusherLa.fixedflag ?  ((void)(0), pw_xgradLeftCrusherLa) : 0;
            pw_xgradLeftCrusherRa  = _pw_xgradLeftCrusherRa.fixedflag ?  ((void)(0), pw_xgradLeftCrusherRa) : 0;
            pw_xgradLeftCrusherLd  = _pw_xgradLeftCrusherLd.fixedflag ?  ((void)(0), pw_xgradLeftCrusherLd) : 0;
            pw_xgradLeftCrusherRd  = _pw_xgradLeftCrusherRd.fixedflag ?  ((void)(0), pw_xgradLeftCrusherRd) : 0;
            pw_ygradLeftCrusherL  = _pw_ygradLeftCrusherL.fixedflag ?  ((void)(0), pw_ygradLeftCrusherL) : 0;
            pw_ygradLeftCrusherR  = _pw_ygradLeftCrusherR.fixedflag ?  ((void)(0), pw_ygradLeftCrusherR) : 0;
            pw_ygradLeftCrusherLa  = _pw_ygradLeftCrusherLa.fixedflag ?  ((void)(0), pw_ygradLeftCrusherLa) : 0;
            pw_ygradLeftCrusherRa  = _pw_ygradLeftCrusherRa.fixedflag ?  ((void)(0), pw_ygradLeftCrusherRa) : 0;
            pw_ygradLeftCrusherLd  = _pw_ygradLeftCrusherLd.fixedflag ?  ((void)(0), pw_ygradLeftCrusherLd) : 0;
            pw_ygradLeftCrusherRd  = _pw_ygradLeftCrusherRd.fixedflag ?  ((void)(0), pw_ygradLeftCrusherRd) : 0;
        }
        /* MRIhc05259 bval calc is based on time between start of 1st diff lobe
           and start of second.  Hence, l1_tot_bval and r1_tot_bval alone
           contribute to bval.  The LeftCrusherSlop is the amount of 
           additional time that is added to the sequence to add the x, y
           crushers on the left 180.  This time will increase the Delta_Time
           of the bval calculation.  The _tot_bval values are also used for 
           avminte calc.  Adding l2_tot_bval accounts for the fact that the
           pulse widths between the leftr1 and rightl1 crushers may be different
           at thin slices.  This should allow proper calculation of TE. 
        */
        pw_gzrf2l1_tot_bval  = _pw_gzrf2l1_tot_bval.fixedflag ?     
                                 ((void)((pw_gzrf2leftl1a+pw_gzrf2leftl1+pw_gzrf2leftl1d+LeftCrusherLSlop)), pw_gzrf2l1_tot_bval) : (pw_gzrf2leftl1a+pw_gzrf2leftl1+pw_gzrf2leftl1d+LeftCrusherLSlop);
        pw_gzrf2l2_tot_bval  = _pw_gzrf2l2_tot_bval.fixedflag ?     
                                 ((void)((pw_gzrf2rightl1a+pw_gzrf2rightl1+pw_gzrf2rightl1d+RightCrusherLSlop)), pw_gzrf2l2_tot_bval) : (pw_gzrf2rightl1a+pw_gzrf2rightl1+pw_gzrf2rightl1d+RightCrusherLSlop);
        pw_gzrf2r1_tot_bval  = _pw_gzrf2r1_tot_bval.fixedflag ?     
                                 ((void)((pw_gzrf2leftr1a+pw_gzrf2leftr1+pw_gzrf2leftr1d+LeftCrusherRSlop)), pw_gzrf2r1_tot_bval) : (pw_gzrf2leftr1a+pw_gzrf2leftr1+pw_gzrf2leftr1d+LeftCrusherRSlop);
        pw_gzrf2r2_tot_bval  = _pw_gzrf2r2_tot_bval.fixedflag ?     
                                 ((void)((pw_gzrf2rightr1a+pw_gzrf2rightr1+pw_gzrf2rightr1d+RightCrusherRSlop)), pw_gzrf2r2_tot_bval) : (pw_gzrf2rightr1a+pw_gzrf2rightr1+pw_gzrf2rightr1d+RightCrusherRSlop);
    }    
   
    /* Calculate z blip gradient parameters */
    /* Always use max blip area in accelerated time points(slice_fov_shift_area) to set up gzb amplitude and width, because calibration time points never use gzb */
    if ((use_slice_fov_shift_blips) && (mux_flag) && (mux_slices_rf1 > 1) && (slice_fov_shift_area > 0.0)) {

      /* Store blip amplitude */
      gzb_amp  = _gzb_amp.fixedflag ?  ((void)(a_gzb), gzb_amp) : a_gzb;
      pw_gzbd  = _pw_gzbd.fixedflag ?  ((void)(pw_gzba), pw_gzbd) : pw_gzba;

      /* Recalculate pw_gxgap for Slice FOV Shift. */
      /* NOTE - This happens after call to epigradopt_rect, and
         optGradAndEsp_rect -- each which call setEpiEsp -- so esp should
         not be calculated again */
      if(slice_fov_shift_extra_gap_flag)
      {
          slice_fov_shift_extra_gap  = _slice_fov_shift_extra_gap.fixedflag ?            ((void)(pw_gzba+pw_gzbd+pw_gzb-(pw_gyba+pw_gybd+pw_gyb)), slice_fov_shift_extra_gap) : pw_gzba+pw_gzbd+pw_gzb-(pw_gyba+pw_gybd+pw_gyb);
          if(slice_fov_shift_extra_gap > 0)
          {
              pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(slice_fov_shift_extra_gap), pw_gxgap) : pw_gxgap+slice_fov_shift_extra_gap;
              if(slice_fov_shift_calc_new_esp)
              {
                  esp  = _esp.fixedflag ?  ((void)(pw_gxgap), esp) : esp+pw_gxgap;
              }
          }
      }

      /* Calculate slice_fov_shift_blip_start so that we start with Kz ~= 0 for encoding */
      slice_fov_shift_blip_start  = _slice_fov_shift_blip_start.fixedflag ?   ((void)(FLOOR_DIV(slice_fov_shift,2)), slice_fov_shift_blip_start) : FLOOR_DIV(slice_fov_shift,2);

      /* Set slice_fov_shift_blip_inc equal to the arc factor */
      slice_fov_shift_blip_inc  = _slice_fov_shift_blip_inc.fixedflag ?  ((void)((INT)exist(opaccel_ph_stride)), slice_fov_shift_blip_inc) : (INT)exist(opaccel_ph_stride);

    } else {
      /* Make sure Z blips are not created */
      pw_gzba  = _pw_gzba.fixedflag ?  ((void)(0), pw_gzba) : 0;
      pw_gzb  = _pw_gzb.fixedflag ?  ((void)(0), pw_gzb) : 0;
      pw_gzbd  = _pw_gzbd.fixedflag ?  ((void)(0), pw_gzbd) : 0;
      a_gzb  = _a_gzb.fixedflag ?  ((void)(0.0), a_gzb) : 0.0;
    }
 
    /***** End of sequences (eos) killer pulses *****************/

    if (eoskillers == PSD_ON) 
    {
        target_area  = _target_area.fixedflag ?    ((void)(a_gxw*(float)(pw_gxwad+pw_gxw/2)), target_area) : a_gxw*(float)(pw_gxwad+pw_gxw/2);
        if (eosxkiller == PSD_ON) 
	{   /* X killer pulse */
            if (amppwgradmethod(&gradx[GXK_SLOT], target_area, loggrd.tx_xyz,
                                start_amp, end_amp,
                                loggrd.xrt*loggrd.scale_3axis_risetime, MIN_PLATEAU_TIME)==FAILURE) 
	    {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gxk" );
                return FAILURE;
	    }
	}
        if (eosykiller == PSD_ON) 
	{   /* Y killer pulse */
            if (amppwgradmethod(&grady[GYK_SLOT], target_area, loggrd.ty_xyz,
                                start_amp, end_amp,
                                loggrd.yrt*loggrd.scale_3axis_risetime, MIN_PLATEAU_TIME)==FAILURE) 
	    {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gyk" );
                return FAILURE;
	    }
	}
        if (eoszkiller == PSD_ON) 
	{   /* Z killer pulse */
            if (amppwgradmethod(&gradz[GZK_SLOT], target_area, loggrd.tz_xyz,
                                start_amp, end_amp,
                                loggrd.zrt*loggrd.scale_3axis_risetime, MIN_PLATEAU_TIME)==FAILURE) 
	    {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwgradmethod:gzk" );
                return FAILURE;
	    }
	}
        
        gxktime  = _gxktime.fixedflag ?      ((void)(pw_gxk+pw_gxka+pw_gxkd), gxktime) : pw_gxk+pw_gxka+pw_gxkd;
        gyktime  = _gyktime.fixedflag ?      ((void)(pw_gyk+pw_gyka+pw_gykd), gyktime) : pw_gyk+pw_gyka+pw_gykd;
        gzktime  = _gzktime.fixedflag ?      ((void)(pw_gzk+pw_gzka+pw_gzkd), gzktime) : pw_gzk+pw_gzka+pw_gzkd;
    } 
    else 
    {
        gxktime  = _gxktime.fixedflag ?  ((void)(0), gxktime) : 0;
        gyktime  = _gyktime.fixedflag ?  ((void)(0), gyktime) : 0;
        gzktime  = _gzktime.fixedflag ?  ((void)(0), gzktime) : 0;
    }
	  
    gktime   = _gktime.fixedflag ?    ((void)(IMax(3,gxktime,gyktime,gzktime)), gktime) : IMax(3,gxktime,gyktime,gzktime);
    
    /***** Cardiac and advisory panel control *********************************/

    if (aspir_flag)
    {
        if (ASPIR_AUTO_TI_FIXED == aspir_auto_ti_model)
        {
            /* ASPIR Auto TI for fixed TI model */
            int null_ti_temp = 0;

            null_ti_temp = calc_ASPIR_TI(INT_INPUT_NOT_USED);

            set_ASPIR_TI(null_ti_temp);
        }
        else
        {
            /* For ASPIR adaptive TI model cases where Auto TI value depends on TR value,
               calculation of TI would be performed later. 
               But some initialization is necessary so set avminti here by set_ASPIR_TI().*/
            set_ASPIR_TI(avminti);
        }
    }

    if (ChemSatEval(_cs_sattime.fixedflag ? (_temp575_cs_sattime=cs_sattime,&_temp575_cs_sattime) : &cs_sattime) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ChemSatEval" );
        return FAILURE;
    }
    
    switch (sp_sattype) {
        case 1:
            flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(105), flip_rfse1) : 105;
            flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(105), flip_rfse2) : 105;
            flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(105), flip_rfse3) : 105;
            flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(105), flip_rfse4) : 105;
            flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(105), flip_rfse5) : 105;
            flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(105), flip_rfse6) : 105;
            break;
        case 2:
            if (cffield == B0_30000)
            {
                flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(130), flip_rfse1) : 130;
                flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(130), flip_rfse2) : 130;
                flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(130), flip_rfse3) : 130;
                flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(130), flip_rfse4) : 130;
                flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(130), flip_rfse5) : 130;
                flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(130), flip_rfse6) : 130;
            }
            else
            {
                flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(120), flip_rfse1) : 120;
                flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(120), flip_rfse2) : 120;
                flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(120), flip_rfse3) : 120;
                flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(120), flip_rfse4) : 120;
                flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(120), flip_rfse5) : 120;
                flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(120), flip_rfse6) : 120;
            }
            break;
        default:
            flip_rfse1  = _flip_rfse1.fixedflag ?  ((void)(90), flip_rfse1) : 90;
            flip_rfse2  = _flip_rfse2.fixedflag ?  ((void)(90), flip_rfse2) : 90;
            flip_rfse3  = _flip_rfse3.fixedflag ?  ((void)(90), flip_rfse3) : 90;
            flip_rfse4  = _flip_rfse4.fixedflag ?  ((void)(90), flip_rfse4) : 90;
            flip_rfse5  = _flip_rfse5.fixedflag ?  ((void)(90), flip_rfse5) : 90;
            flip_rfse6  = _flip_rfse6.fixedflag ?  ((void)(90), flip_rfse6) : 90;
            break;
    }
    
    if (SpSatEval(_sp_sattime.fixedflag ? (_temp576_sp_sattime=sp_sattime,&_temp576_sp_sattime) : &sp_sattime) == FAILURE) 
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "SpSatEval" );
        return FAILURE;
    }

    SetCyclingCVs();

    /* Obl 3in1 opt */
    if (obl_3in1_opt)
    {
        float abs_gx_log,abs_gy_log,abs_gz_log;
        float target_mpg_x,target_mpg_y,target_mpg_z;
        float target_mpg_inv_min;
        int i,j;

        if (orderslice(seq_type, 1, 1, gating) == FAILURE)
        {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "orderslice" );
            return FAILURE;
        }

        for (j=0; j<9; j++)
        {
            rsprot_unscaled[0][j] = rsprot[0][j];
        }

        if (obl_3in1_opt_debug)
        {
            printf("Obl3in1:  \n");
            printf("Obl3in1: loggrd.tx= %f phygrd.xfull= %d phygrd.xfs= %f\n", loggrd.tx, phygrd.xfull, phygrd.xfs);
            printf("Obl3in1: loggrd.ty= %f phygrd.yfull= %d phygrd.yfs= %f\n", loggrd.ty, phygrd.yfull, phygrd.yfs);
            printf("Obl3in1: loggrd.tz= %f phygrd.zfull= %d phygrd.zfs= %f\n", loggrd.tz, phygrd.zfull, phygrd.zfs);
            printf("Obl3in1: orthloggrd.tx= %f orthloggrd.ty= %f orthloggrd.tz= %f\n", orthloggrd.tx, orthloggrd.ty, orthloggrd.tz);
        }

        if (inversRspRot(inversRR, rsprot_unscaled[0]) == FAILURE)
        {
            epic_error(use_ermes,"inversRspRot failed",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," inversRspRot");
            return FAILURE;
        }

        target_mpg_inv_min = FMax(3, orthloggrd.tx, orthloggrd.ty, orthloggrd.tz);

        for (i=0; i<num_dif; i++)
        {
            gx_log = orthloggrd.tx;
            gy_log = orthloggrd.ty;
            gz_log = orthloggrd.tz;

            rotateToLogical(&gx_log, &gy_log, &gz_log, i);

            abs_gx_log = fabs(gx_log);
            abs_gy_log = fabs(gy_log);
            abs_gz_log = fabs(gz_log);

            target_mpg_x = orthloggrd.tx * loggrd.tx/ abs_gx_log;
            target_mpg_y = orthloggrd.ty * loggrd.ty/ abs_gy_log;
            target_mpg_z = orthloggrd.tz * loggrd.tz/ abs_gz_log;

            target_mpg_inv  = _target_mpg_inv.fixedflag ?     ((void)(FMin(3,target_mpg_x,target_mpg_y,target_mpg_z)), target_mpg_inv) : FMin(3,target_mpg_x,target_mpg_y,target_mpg_z);
            target_mpg_inv  = _target_mpg_inv.fixedflag ?    ((void)((float)((int)(target_mpg_inv*1000))/1000.0), target_mpg_inv) : (float)((int)(target_mpg_inv*1000))/1000.0;
            target_mpg_inv_min = FMin(2, target_mpg_inv, target_mpg_inv_min);

            if (obl_3in1_opt_debug)
            {
                /* g<x,y,z>_log       : Logical amplitude inverse rotation matrix is applied.
                   target_mpg_<x,y,z> : Logical target scaled by absolute target_mpg_<x,y,z>
                                        to avoid amplitude overflow in pulsegen().
                   target_mpg_inv     : Final logical target which is used in get_diffusion_time(). 
                                        target_mpg_inv is obtained after checking all diffusion directions. */
                printf("Obl3in1:  \n");
                printf("Obl3in1: Dir= %d\n",i);
                printf("Obl3in1: Calculated logical MPG amplitude\n");
                printf("Obl3in1: gx_log= %f gy_log= %f gz_log= %f\n", gx_log, gy_log, gz_log);
                printf("Obl3in1: abs_gx_log= %f abs_gy_log= %f abs_gz_log= %f\n", abs_gx_log, abs_gy_log, abs_gz_log);
                printf("Obl3in1: target_mpg_x= %f target_mpg_y= %f target_mpg_z= %f\n", target_mpg_x, target_mpg_y, target_mpg_z);
            }
        }

        target_mpg_inv  = _target_mpg_inv.fixedflag ?  ((void)(target_mpg_inv_min), target_mpg_inv) : target_mpg_inv_min;

        if (obl_3in1_opt_debug)
        {
            printf("Obl3in1: Final Max traget amp for inverse MPG\n");
            printf("Obl3in1: target_mpg_inv= %f\n", target_mpg_inv);
        }
    }

    if (FAILURE == Monitor_CvevalInit(rfpulse))
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_CvevalInit");
        return FAILURE;
    }

    if (FAILURE == NavigatorCvevalInit())
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "NavigatorCvevalInit");
        return FAILURE;
    }

    /* Multiband is incompatible with negative spacing*/
    if( (exist(opslspace)<0) && (mux_flag == PSD_ON) )
    {
         epic_error( use_ermes, "Increase the slice spacing to %.1f mm", EM_PSD_SLSPACING_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, 0.0);
         return FAILURE;
    }
        tlead  = _tlead.fixedflag ?    ((void)(RUP_GRD(24)), tlead) : RUP_GRD(24);

    /*RTB0 correction*/
    if(rtb0_flag) tlead  = _tlead.fixedflag ?  ((void)(pw_dynr1+GRAD_UPDATE_TIME), tlead) : tlead+pw_dynr1+GRAD_UPDATE_TIME;
    tlead  = _tlead.fixedflag ?  ((void)(RUP_GRD(tlead)), tlead) : RUP_GRD(tlead);

    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
if(fixed_acqs_debug == DEBUG_DEV) {
    printf("\n AUTOMINTR: Entry cveval1() optracqs = %d,exist = %d,fixed ="
            "%d\n",exist(optracq),_optracq.existflag,_optracq.fixedflag);
    fflush(stdout);
}

    psd_card_hdwr_delay  = _psd_card_hdwr_delay.fixedflag ?  ((void)(10000), psd_card_hdwr_delay) : 10000;  
    if ((exist(opcgate) == PSD_ON) && existcv(opcgate)) 
    {
        avmintdel1 = psd_card_hdwr_delay + tlead + t_exa + GRAD_UPDATE_TIME;
        avmintdel1 = avmintdel1 + ir_time_total;
        if (ir_on == PSD_ON)
        {
            pitdel1 = avmintdel1;
        }
        else
        {
            pitdel1 = avmintdel1 + sp_sattime + cs_sattime + satdelay;
        }
        advroundup(&avmintdel1); /* round up to ms */
        advroundup(&pitdel1); /* round up to ms */
 
        /* Override Trigger Delay value if user prescribes Minimum or Recommended */
        if( existcv(opautotdel1) ) 
        { 
            if( PSD_TDEL1_MINIMUM == exist(opautotdel1) ) 
            { 
                cvdef(optdel1, avmintdel1); 
                cvoverride(optdel1, _optdel1.defval, PSD_FIX_ON, PSD_EXIST_ON); 
            } 
            else if( PSD_TDEL1_RECOMMENDED == exist(opautotdel1) ) 
            { 
                cvdef(optdel1, pitdel1); 
                cvoverride(optdel1, _optdel1.defval, PSD_FIX_ON, PSD_EXIST_ON); 
            } 
        }

        if (optdel1 < pitdel1)
            td0  = _td0.fixedflag ?     
                                                     ((void)(RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa)))), td0) : RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa)));
        else
            td0  = _td0.fixedflag ?       
                                                           ((void)(RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa+sp_sattime+cs_sattime+ir_time+satdelay)))), td0) : RUP_GRD((int)(exist(optdel1)-(psd_card_hdwr_delay+tlead+t_exa+sp_sattime+cs_sattime+ir_time+satdelay)));

        gating  = _gating.fixedflag ?  ((void)(TRIG_ECG), gating) : TRIG_ECG;
        piadvmin = (piadvmin & ~(1<<PSD_ADVTR));
        piadvmax = (piadvmax & ~(1<<PSD_ADVTR));
        pitrnub = 0;
    }
    else if (((exist(oprtcgate) == PSD_ON) && existcv(oprtcgate)) || /* RTG */
             (navtrig_flag == PSD_ON) ) 
    {
        _opphases.fixedflag = 0;
        opphases  = _opphases.fixedflag ?  ((void)(1), opphases) : 1;
        avmintdel1 = 0;
        td0  = _td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0) : GRAD_UPDATE_TIME;
        if (navtrig_flag == PSD_OFF)
        {
            /* ALP ECG and RESP have separate hardware lines in MGD */
            gating  = _gating.fixedflag ?  ((void)(TRIG_RESP), gating) : TRIG_RESP;
        } else {
            gating  = _gating.fixedflag ?  ((void)(TRIG_INTERN), gating) : TRIG_INTERN;
        }
        piadvmin = (piadvmin & ~(1<<PSD_ADVTR));
        piadvmax = (piadvmax & ~(1<<PSD_ADVTR));
        pitrnub = 0;
    }  
    else 
    {
        _opphases.fixedflag = 0;
        opphases  = _opphases.fixedflag ?  ((void)(1), opphases) : 1;
        avmintdel1 = 0;
        td0  = _td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0) : GRAD_UPDATE_TIME;
        piadvmin = (piadvmin | (1<<PSD_ADVTR));
        piadvmax = (piadvmax | (1<<PSD_ADVTR));
        gating  = _gating.fixedflag ?  ((void)(TRIG_INTERN), gating) : TRIG_INTERN;
    }

    /* find the avail time for freq dephaser */

    /* need fix here for trapezoidal phase encoding */

    if (exist(oppseq) == PSD_SE)
        avail_pwgx1  = _avail_pwgx1.fixedflag ?       
                             ((void)((int)(exist(opte)/2-rfExIso-pw_rf2/2-RUP_GRD(rfupd))), avail_pwgx1) : (int)(exist(opte)/2-rfExIso-pw_rf2/2-RUP_GRD(rfupd));
    else
        avail_pwgx1  = _avail_pwgx1.fixedflag ?     
                                ((void)((int)(exist(opte)-rfExIso-(pw_gxwad+pw_gxw/2)-RUP_GRD(rfupd))), avail_pwgx1) : (int)(exist(opte)-rfExIso-(pw_gxwad+pw_gxw/2)-RUP_GRD(rfupd));

    /* Calculate minimum FOV ********************************/

    avminfovx  = _avminfovx.fixedflag ?  ((void)(1.0/(GAM*xtarg*tsp*1.0e-6)), avminfovx) : 1.0/(GAM*xtarg*tsp*1.0e-6);
    avminfovx  = _avminfovx.fixedflag ?        ((void)((vrgfsamp==PSD_ON)?4:avminfovx), avminfovx) : (vrgfsamp==PSD_ON)?4:avminfovx;

    avminfovy  = _avminfovy.fixedflag ?  ((void)(0.0), avminfovy) : 0.0;

    avminfov = (avminfovx > avminfovy) ? avminfovx : avminfovy; 
    avminfov = ceil(avminfov)*10.0;

    /* This is the best scan can do on the advisory panel.  The psd supports
       a larger fov than 99cm, but the advisory panel won't reflect it. */
    avmaxfov = 600;

    if ( (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25 ) || ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (EZflag == PSD_ON)) )
    {
        avminfov = 360;
        avmaxfov = 360;
    }
    else if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON)) 
    {
        avminfov = 240;
        if(cfsrmode == PSD_SR77)
        {
            avmaxfov = 600;
        }
        else
        {
            avmaxfov = 400;
        }
    }

    if (rfov_flag)
    {
        avminfov = FMax(2, avminfov, MIN_RFOV/exist(opphasefov));
    }

    fullk_nframes  = _fullk_nframes.fixedflag ?  ((void)((int)(ceilf(opyres*asset_factor/rup_factor)*rup_factor)), fullk_nframes) : (int)(ceilf(opyres*asset_factor/rup_factor)*rup_factor);

    /* Begin Minimum TE *****************************************************/  
    area_gyb  = _area_gyb.fixedflag ?    ((void)((float)(pw_gyba+pw_gyb)*a_gyb), area_gyb) : (float)(pw_gyba+pw_gyb)*a_gyb;  /* G usec / cm */

    /* Compute minimum te with full ky coverage first *************************/
    etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
    num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;

    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(0), fract_ky) : 0;
    ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;

    /* BJM: setup ky_offset, dont allow mods below if single etl */
    if ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor) == exist(opnshots)) {
        cvoverride(ky_offset, 0, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(delt, 0, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        cvoverride(ky_offset, 0, PSD_FIX_OFF, PSD_EXIST_ON);
        cvoverride(delt, 0, PSD_FIX_OFF, PSD_EXIST_ON);
    }

    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    } 
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));
	    	if (muse_flag) {
				ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
			} 
			else 
			{
            if (etl % 2 == 0) 
            {
                if ((etl/2) % 2 == 0)
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(-(double)intleaves/2.0))), ky_offset) : (float)(ceil(-(double)intleaves/2.0));
                else
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
            } 
            else 
            {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves))), ky_offset) : (float)(ceil((double)-intleaves));
            }
			}
            pw_wgx  = _pw_wgx.fixedflag ?    ((void)((intleaves-1)*delt/2+GRAD_UPDATE_TIME), pw_wgx) : (intleaves-1)*delt/2+GRAD_UPDATE_TIME;
        } 
        else 	
        {    /* full ky CENTER-OUT */
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves*2)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves*2)));
            ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
            pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
        }

    blips2cent  = _blips2cent.fixedflag ?    ((void)(etl/2+ky_offset/intleaves), blips2cent) : etl/2+ky_offset/intleaves;

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;   /* ufi2_ypd */


    tdaqhxa  = _tdaqhxa.fixedflag ?    ((void)(((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp), tdaqhxa) : ((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp;
    area_gy1  = _area_gy1.fixedflag ?      ((void)(area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves), area_gy1) : area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves;
    /* DTI BJM: dsp change */
    if(FAILURE == get_diffusion_time()) {
        return FAILURE;
    }

    avmintecalc();

    /* round up to 0.1 ms, ufi2_ypd */
    avmintefull  = _avmintefull.fixedflag ?  ((void)((int)(100.0*ceil((double)avmintetemp/100.0))), avmintefull) : (int)(100.0*ceil((double)avmintetemp/100.0));

    /* Compute minimum te with fractional ky coverage or full ky with center/out
       coverage next ******************/

    /* Set the fract_ CVs */
    fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FRACT_KY), fract_ky) : PSD_FRACT_KY;
    ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;

    /* New rhhnover calculation - use minimum number of overscans (based
       on opnshots and fract_ky).  Leave old algorithm in, but use it to
       calc. rhhnover_max, which is not currently used, but may be in the
       future to maximize s/n. */
    if ( (exist(oppseq) == PSD_GE) )
        rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(MIN_HNOVER_GRE), rhhnover_min) : MIN_HNOVER_GRE;
    else
        rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(MIN_HNOVER_DEF), rhhnover_min) : MIN_HNOVER_DEF;

    if( ((opdiffuse==PSD_ON)&&(oppseq==PSD_SE)) || ((tensor_flag == PSD_ON)&&(oppseq==PSD_SE)) )
    {
        if (rfov_flag)
        {
            rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(MIN_HNOVER_RFOV), rhhnover_min) : MIN_HNOVER_RFOV;
        }
        else
        {
            rhhnover_min  = _rhhnover_min.fixedflag ?  ((void)(MIN_HNOVER_DWI), rhhnover_min) : MIN_HNOVER_DWI;
        }
    }

    if( (intleaves < (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)) && (PSD_OFF == epi2spec_mode) ) {
        for (icount=0; icount<=rhhnover_min; icount++) {
            if (icount*intleaves>=rhhnover_min) {
                num_overscan  = _num_overscan.fixedflag ?  ((void)((icount*intleaves)), num_overscan) : (icount*intleaves);
                break;
            }
        }
        if (muse_flag && (num_overscan < rhhnover_min_per_ilv*intleaves)) 
		{
            num_overscan  = _num_overscan.fixedflag ?  ((void)(rhhnover_min_per_ilv*intleaves), num_overscan) : rhhnover_min_per_ilv*intleaves;
        }
    } else if ( epi2spec_mode ) {
        
        num_overscan  = _num_overscan.fixedflag ?  ((void)(2), num_overscan) : 2;

    } else {

        num_overscan  = _num_overscan.fixedflag ?  ((void)(rhhnover_min), num_overscan) : rhhnover_min;

    } 

    if( (value_system_flag == VALUE_SYSTEM_HDE) && (tensor_flag == PSD_OFF) )
    {
        /* asset = 2 for scans, 1 for calibration */
        if(exist(opasset) == 2)
        {
            /* reduce the overscans by the asset_factor */
            num_overscan  = _num_overscan.fixedflag ?  ((void)(num_overscan*asset_factor), num_overscan) : num_overscan*asset_factor;

            /* limit the overscan reduction */
            if(num_overscan < MIN_HNOVER_DWI*asset_factor)
                num_overscan  = _num_overscan.fixedflag ?   ((void)(MIN_HNOVER_DWI*asset_factor), num_overscan) : MIN_HNOVER_DWI*asset_factor;
        }
    }

    etl  = _etl.fixedflag ?    ((void)(((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2+num_overscan)/intleaves), etl) : ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2+num_overscan)/intleaves;

    /* Determine ky offsets */
    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
        tdaqhxa  = _tdaqhxa.fixedflag ?  ((void)((float)num_overscan*(float)esp), tdaqhxa) : (float)num_overscan*(float)esp;
        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    } 
    else 
    {
        delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));

		if (muse_flag) 
		{
			ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
		} 
		else 
		{
        if ((num_overscan/intleaves) % 2 == 0)
            ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
        else
            ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
		}

        if (fullk_nframes == exist(opnshots))
            ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;

        /* BJM: MRIge60610 */ 
        if(num_overscan > 0) {
            /* BJM: the true number of overscans */
            rhhnover  = _rhhnover.fixedflag ?    ((void)(num_overscan+ky_offset), rhhnover) : num_overscan+ky_offset;

            /* MRIge61204 & MRIge61702 */
            /* Here's da deal: we are trying to put the echo peak */
            /* at the center of the group of flow comped echoes.   */
            /* It's desirable to place the peak early instead of late */
            /* to minimize TE.  However, if we can't, then place the */
            /* echo peak "late" instead for min TE */
            if(fabs(ky_offset) > 0) {
                if (exist(oppseq) == PSD_GE && rhhnover < MIN_HNOVER_GRE) {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                    rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_GRE+ky_offset), rhhnover) : MIN_HNOVER_GRE+ky_offset;
                } else if (rhhnover < MIN_HNOVER_DEF) {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                    rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_DEF+ky_offset), rhhnover) : MIN_HNOVER_DEF+ky_offset;
                }
            } /* end fabs(ky_offset) > 0 */
        }

        tdaqhxa  = _tdaqhxa.fixedflag ?    ((void)(((float)num_overscan+ky_offset)*(float)esp/(float)intleaves), tdaqhxa) : ((float)num_overscan+ky_offset)*(float)esp/(float)intleaves;

        etl  = _etl.fixedflag ?      ((void)(((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves)/2+IMax(2,num_overscan/intleaves,1)), etl) : ((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves)/2+IMax(2,num_overscan/intleaves,1);

        if (ky_dir==PSD_BOTTOM_UP)
        {
            pw_wgx  = _pw_wgx.fixedflag ?    ((void)((intleaves-1)*delt/2+GRAD_UPDATE_TIME), pw_wgx) : (intleaves-1)*delt/2+GRAD_UPDATE_TIME;
        }
        else    /* full ky CENTER-OUT */
        {
            pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
        }
    }

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;   /* ufi2_ypd */

    area_gy1  = _area_gy1.fixedflag ?       ((void)(area_gyb*((float)num_overscan-0.5)/(float)intleaves), area_gy1) : area_gyb*((float)num_overscan-0.5)/(float)intleaves;

    /* DTI BJM: dsp change */
    if(FAILURE == get_diffusion_time()) {
        return FAILURE;
    }

    avmintecalc();

    /* round up to 0.1ms, ufi2_ypd */
    if (exist(opautote) == PSD_MINTEFULL)
    {
        avminte = avmintefull;
    }
    else
    {
        avminte = (int)(100.0*ceil((double)avmintetemp/100.0));
    }

    if (exist(opautote) == PSD_MINTE || exist(opautote) == PSD_MINTEFULL) 
    {
        setexist(opte,PSD_ON);
        _opte.fixedflag = 0;
        opte  = _opte.fixedflag ?  ((void)(ceil((float)avminte/100.0)*100), opte) : ceil((float)avminte/100.0)*100;
        _opte.fixedflag = 1;
    }
    else if ((existcv(opte) == PSD_ON) && smart_numoverscan)
    {
        if ((exist(opte) > avminte) && (exist(opte) < avmintefull))
        {
            int extra_os_time;
            if (exist(opdiffuse) == PSD_ON)
            {
                if (PSD_OFF == dualspinecho_flag)
                {
                    extra_os_time = (exist(opte) - avminte)/2;
                }
                else
                {
                    extra_os_time = (exist(opte) - avminte)/4;
                }
            }
            else
            {
                if(oppseq == PSD_GE)
                {
                    extra_os_time = exist(opte) - avminte;
                }
                else
                {
                    extra_os_time = (exist(opte) -avminte)/2;
                }
            }
            num_overscan  = _num_overscan.fixedflag ?  ((void)((extra_os_time/esp/2)*2), num_overscan) : num_overscan+(extra_os_time/esp/2)*2;
            etl  = _etl.fixedflag ?    ((void)((num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves), etl) : (num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves;
        }
    }
    /* End Minimum TE *******************************************************/

    /* Now recompute everything based on operator selected parameters *******/

    ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;
    if (exist(opte) >= avmintefull) 
    {
        fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FULL_KY), fract_ky) : PSD_FULL_KY;
    } 
    else 
    {
        fract_ky  = _fract_ky.fixedflag ?  ((void)(PSD_FRACT_KY), fract_ky) : PSD_FRACT_KY;
    }

    nexcalc();

    if (intleaves == 1) 
    {
        delt  = _delt.fixedflag ?  ((void)(0), delt) : 0;
    } 
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves)));
        } 
        else 	
        {
            delt  = _delt.fixedflag ?  ((void)(RUP_HRD((int)((float)esp/(float)(intleaves*2)))), delt) : RUP_HRD((int)((float)esp/(float)(intleaves*2)));
        }

    /* Wait pulses */
    if (intleaves == 1)
        pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;
    else 
        if ( ky_dir==PSD_BOTTOM_UP ) 
            pw_wgx  = _pw_wgx.fixedflag ?    ((void)((intleaves-1)*delt/2+GRAD_UPDATE_TIME), pw_wgx) : (intleaves-1)*delt/2+GRAD_UPDATE_TIME;
        else    /* full ky CENTER-OUT */
            pw_wgx  = _pw_wgx.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_wgx) : GRAD_UPDATE_TIME;

    pw_wgx  = _pw_wgx.fixedflag ?  ((void)(RUP_GRD(pw_wgx)), pw_wgx) : RUP_GRD(pw_wgx);
    pw_wgy  = _pw_wgy.fixedflag ?  ((void)(pw_wgx), pw_wgy) : pw_wgx;
    pw_wgz  = _pw_wgz.fixedflag ?  ((void)(pw_wgx), pw_wgz) : pw_wgx;
    pw_wssp  = _pw_wssp.fixedflag ?  ((void)(pw_wgx), pw_wssp) : pw_wgx;
    pw_womega  = _pw_womega.fixedflag ?  ((void)(pw_wgx), pw_womega) : pw_wgx;   /* ufi2_ypd */


    if ((intleaves > 1))		
    {
        if ( ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY ) 
        {
            if (muse_flag == PSD_ON)
                ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
            else if (etl % 2 == 0)
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
            else
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
        } 
        else 
            if ( (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FULL_KY) ||
                 ky_dir == PSD_TOP_DOWN ) 
            {
                etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
                if (muse_flag == PSD_ON)
                {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
                }
                else if (etl % 2 == 0)
                {
                    if ((etl/2) % 2 == 0)
                        ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
                    else
                        ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)intleaves/2.0))), ky_offset) : (float)(ceil((double)intleaves/2.0));
                } 
                else 
                {
                    ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil((double)-intleaves/2.0))), ky_offset) : (float)(ceil((double)-intleaves/2.0));
                }
            } 
            else 
                if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
                    ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
    } 
    else 
    {             /* single interleave */
        ky_offset  = _ky_offset.fixedflag ?  ((void)(0.0), ky_offset) : 0.0;
    }

    if (fract_ky == PSD_FULL_KY) 
    {
        rhhnover  = _rhhnover.fixedflag ?  ((void)(0), rhhnover) : 0;
        num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;
        etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;
    } 
    else
    {
        if (exist(oppseq) == PSD_SE) 
        {
            avail_tdaqhxa  = _avail_tdaqhxa.fixedflag ?         
                                             
                                                  
                                                     
                                                    
                                                    ((void)(exist(opte)/2-(pw_rf2/2+xdiff_time2+pw_wgx+IMax(3,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot+ydiff_time2,pw_gzrf2r1_tot+zdiff_time2))), avail_tdaqhxa) : exist(opte)/2-(pw_rf2/2+xdiff_time2+pw_wgx+IMax(3,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot+ydiff_time2,pw_gzrf2r1_tot+zdiff_time2));
        } 
        else 
        {
            avail_tdaqhxa  = _avail_tdaqhxa.fixedflag ?   
                        
                                               ((void)(exist(opte)-(rfExIso+pw_wgx+IMax(3,pw_gzrf1d+pw_gz1_tot,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot+pw_gyex1_tot))), avail_tdaqhxa) : exist(opte)-(rfExIso+pw_wgx+IMax(3,pw_gzrf1d+pw_gz1_tot,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot+pw_gyex1_tot));
        }

        /* number of views that will fit in the available time slot.
           2nd term accounts for time shifting of echo train,
           3rd term accounts for ky_offset.  Assume nviews is odd initially. */

        nviews  = _nviews.fixedflag ?     
                  ((void)((avail_tdaqhxa-delt*(intleaves-1)/2-ky_offset*esp/intleaves)/esp), nviews) : (avail_tdaqhxa-delt*(intleaves-1)/2-ky_offset*esp/intleaves)/esp;

        etl  = _etl.fixedflag ?    ((void)((num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves), etl) : (num_overscan+(int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/2)/intleaves;

        if (num_overscan >= fullk_nframes/2) 
        {
            rhhnover  = _rhhnover.fixedflag ?  ((void)(0), rhhnover) : 0;
            num_overscan  = _num_overscan.fixedflag ?  ((void)(0), num_overscan) : 0;
            fract_ky  = _fract_ky.fixedflag ?  ((void)(0), fract_ky) : 0;
            ky_dir  = _ky_dir.fixedflag ?  ((void)(PSD_BOTTOM_UP), ky_dir) : PSD_BOTTOM_UP;
            etl  = _etl.fixedflag ?  ((void)((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves), etl) : (int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)/intleaves;

            /* MRIge41484 BJM: modify ky_offset and set fn = 1.0 to prevent */
            /*                 download failure of Min TE, multi-shot, */
            /*                 spin-echo epi */
            ky_offset  = _ky_offset.fixedflag ?  ((void)(-1), ky_offset) : ky_offset*-1;
            fn  = _fn.fixedflag ?  ((void)(1.0), fn) : 1.0;         /* reset fractional nex value */

        }
    } /* partial ky */

    /* since opetl is written into the header */
    opetl  = _opetl.fixedflag ?  ((void)(etl), opetl) : etl;
    tot_etl  = _tot_etl.fixedflag ?    ((void)(etl+iref_etl), tot_etl) : etl+iref_etl;

    /* BJM: MRIge60610 */ 
    if(num_overscan > 0) {
        /* BJM: the true number of overscans */
        rhhnover  = _rhhnover.fixedflag ?    ((void)(num_overscan+ky_offset), rhhnover) : num_overscan+ky_offset;   

        /* MRIge61204 & MRIge61702 */
        if(fabs(ky_offset) > 0) {
            if (exist(oppseq) == PSD_GE && rhhnover < MIN_HNOVER_GRE) {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_GRE+ky_offset), rhhnover) : MIN_HNOVER_GRE+ky_offset;
            } else if (rhhnover < MIN_HNOVER_DEF) {
                ky_offset  = _ky_offset.fixedflag ?  ((void)((float)(ceil(3.0*(double)intleaves/2.0))), ky_offset) : (float)(ceil(3.0*(double)intleaves/2.0));
                rhhnover  = _rhhnover.fixedflag ?    ((void)(MIN_HNOVER_DEF+ky_offset), rhhnover) : MIN_HNOVER_DEF+ky_offset;
            }
        } /* end fabs(ky_offset) > 0 */
    }

    nblips  = _nblips.fixedflag ?    ((void)(etl-1), nblips) : etl-1;

    /* Y phase encode prephaser */

    if (etl == 1) {
        area_gy1  = _area_gy1.fixedflag ?  ((void)(area_gyb/2.0), area_gy1) : area_gyb/2.0;
        blips2cent  = _blips2cent.fixedflag ?  ((void)(0), blips2cent) : 0;
    } else {
        if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {
            area_gy1  = _area_gy1.fixedflag ?       ((void)(area_gyb*((float)num_overscan-0.5)/(float)intleaves), area_gy1) : area_gyb*((float)num_overscan-0.5)/(float)intleaves;
            blips2cent  = _blips2cent.fixedflag ?     ((void)((num_overscan+ky_offset)/intleaves), blips2cent) : (num_overscan+ky_offset)/intleaves;
        } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
            area_gy1  = _area_gy1.fixedflag ?      ((void)(area_gyb*((float)intleaves/2.0-0.5)), area_gy1) : area_gyb*((float)intleaves/2.0-0.5);
            blips2cent  = _blips2cent.fixedflag ?  ((void)(0), blips2cent) : 0;
        } else if ( (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FULL_KY) ||
                    (ky_dir == PSD_TOP_DOWN && fract_ky == PSD_FULL_KY) ) {
            area_gy1  = _area_gy1.fixedflag ?      
                ((void)(area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves), area_gy1) : area_gyb*(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor/2.0-0.5)/(float)intleaves;
            blips2cent  = _blips2cent.fixedflag ?    ((void)(etl/2+ky_offset/intleaves), blips2cent) : etl/2+ky_offset/intleaves;
        }
    }

    if ((fract_ky == PSD_FULL_KY) && ((PSD_ON == dualspinecho_flag) || 
         ((PSD_OFF == dualspinecho_flag) && (PSD_ON == sse_enh))))
    {
        /* set diffusion timing for full ky and dual spin echo*/
        tdaqhxa  = _tdaqhxa.fixedflag ?    ((void)(((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp), tdaqhxa) : ((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp;
        if(FAILURE == get_diffusion_time()) {
            return FAILURE;
        }
    }

    /*update SSE diffusion manual TE timing after avminte is fully determinted*/
    if ( isRioSystem() && (PSD_ON == sse_manualte_derating)
        && ((exist(opdiffuse) == PSD_ON)|| (tensor_flag == PSD_ON))
        && (dualspinecho_flag == PSD_OFF) && (exist(opautote) == 0) )
    {
        if(FAILURE == update_sse_diffusion_time()) {
            return FAILURE;
        }
    }

    gy1_offset  = _gy1_offset.fixedflag ?  ((void)(ky_offset*fabs(area_gyb)/intleaves), gy1_offset) : ky_offset*fabs(area_gyb)/intleaves;

    /* Shift ky=0 point to center of x flow comp'd echoes */
    if (etl > 1)
        area_gy1  = _area_gy1.fixedflag ?  ((void)(gy1_offset), area_gy1) : area_gy1+gy1_offset;

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */

    if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {
        if (intleaves <= 1)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else {
            if (num_overscan >= 2)
                endview_iamp  = _endview_iamp.fixedflag ?   
                       
                    ((void)((int)((int)(2*max_pg_wamp/(num_overscan-1+2*ky_offset))/2)*2*(num_overscan-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/(num_overscan-1+2*ky_offset))/2)*2*(num_overscan-1+2*ky_offset)/2;
            else
                endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        }
    } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
        if (intleaves <= 2)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else
            endview_iamp  = _endview_iamp.fixedflag ?  
                  
                  ((void)((int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2;
    } else if ((ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP) &&
        fract_ky == PSD_FULL_KY) {
        if (intleaves <= 1)
            endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
        else
            endview_iamp  = _endview_iamp.fixedflag ?  
                  
                  ((void)((int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2), endview_iamp) : (int)((int)(2*max_pg_wamp/((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset))/2)*2*((int)(ceilf(exist(opyres)*asset_factor/rup_factor)*rup_factor)-1+2*ky_offset)/2;
    }

    endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;

    /* Find the amplitudes and pulse widths of the trapezoidal
       phase encoding pulse. */

    if (amppwtpe(_a_gy1a.fixedflag ? (_temp577_a_gy1a=a_gy1a,&_temp577_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp578_a_gy1b=a_gy1b,&_temp578_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp579_pw_gy1=pw_gy1,&_temp579_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp580_pw_gy1a=pw_gy1a,&_temp580_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp581_pw_gy1d=pw_gy1d,&_temp581_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt*loggrd.scale_3axis_risetime,
                 area_gy1) == FAILURE)
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwtpe" );
        return FAILURE;
    } 

    pw_gy1_tot  = _pw_gy1_tot.fixedflag ?      ((void)(pw_gy1a+pw_gy1+pw_gy1d), pw_gy1_tot) : pw_gy1a+pw_gy1+pw_gy1d;
    a_gy1a  = _a_gy1a.fixedflag ?         
                ((void)(((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1a:-a_gy1a)), a_gy1a) : ((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1a:-a_gy1a);
    a_gy1b  = _a_gy1b.fixedflag ?         
                ((void)(((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1b:-a_gy1b)), a_gy1b) : ((exist(oppseq)==PSD_SE&&gy1pos==PSD_PRE_180)?a_gy1b:-a_gy1b);

    get_flowcomp_time();

    /* internref: pw_iref_gxwait is defined in EP_TRAIN() */
    pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;

    /* Actual inter echo time */
    if (etl == 1)
        esp  = _esp.fixedflag ?  ((void)(0), esp) : 0;  /* can't define an echo spacing with an etl of 1! */

    if (esp % GRAD_UPDATE_TIME != 0) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "esp not an integral multiple of grad hardware period." );
        return FAILURE;
    }

    if (etl == 1) {
        tdaqhxa  = _tdaqhxa.fixedflag ?        ((void)((pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr)/2), tdaqhxa) : (pw_gxw+2*pw_gxwad+pw_gxwl+pw_gxwr)/2;
        tdaqhxb  = _tdaqhxb.fixedflag ?  ((void)(tdaqhxa), tdaqhxb) : tdaqhxa;
        pw_gxgap  = _pw_gxgap.fixedflag ?  ((void)(0), pw_gxgap) : 0;
    } else {
        if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
            fract_ky == PSD_FULL_KY) {
            tdaqhxa  = _tdaqhxa.fixedflag ?    ((void)(((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp), tdaqhxa) : ((float)etl/2.0+ky_offset/(float)intleaves)*(float)esp;
            tdaqhxb  = _tdaqhxb.fixedflag ?    ((void)(((float)etl/2.0-ky_offset/(float)intleaves)*(float)esp), tdaqhxb) : ((float)etl/2.0-ky_offset/(float)intleaves)*(float)esp;
        } else if (ky_dir == PSD_BOTTOM_UP && fract_ky == PSD_FRACT_KY) {
            /* Do overscans first */
            tdaqhxa  = _tdaqhxa.fixedflag ?    ((void)(((float)num_overscan-ky_offset)*(float)esp/(float)intleaves), tdaqhxa) : ((float)num_overscan-ky_offset)*(float)esp/(float)intleaves;
            tdaqhxb  = _tdaqhxb.fixedflag ?  
                ((void)(((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp), tdaqhxb) : ((float)etl-(((float)num_overscan+ky_offset)/(float)intleaves))*(float)esp;
        } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
            /* Put the middle of the first echo at the nominal TE */
            tdaqhxa  = _tdaqhxa.fixedflag ?      ((void)(pw_gxwad+pw_gxwl+(pw_gxw/2)), tdaqhxa) : pw_gxwad+pw_gxwl+(pw_gxw/2);
            tdaqhxb  = _tdaqhxb.fixedflag ?          ((void)(etl*esp+pw_gxgap+pw_gxwad+pw_gxwl+(pw_gxw/2)), tdaqhxb) : etl*esp+pw_gxgap+pw_gxwad+pw_gxwl+(pw_gxw/2);
        } 
    }

    if (etl % 2 == 0)       /* odd number of views, so negate killer ampl. */
        a_gxk  = _a_gxk.fixedflag ?  ((void)(-a_gxk), a_gxk) : -a_gxk;

    if (etl >= 256) 
    {
        if (PSDDVMR == psd_board_type)
        {
			time_ssi  = _time_ssi.fixedflag ?    ((void)(muse_flag?5000:4000), time_ssi) : muse_flag?5000:4000;
        }
        else
        {
            time_ssi  = _time_ssi.fixedflag ?  ((void)(2000), time_ssi) : 2000;
        }
    }
    else 
    {
        if (PSDDVMR == psd_board_type)
        {
            if ((hoecc_flag == PSD_OFF) && (mux_flag == PSD_OFF))
            {
                if (etl <= 192) 
                {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(1200), time_ssi) : 1200;
                }
                else 
                {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(2000), time_ssi) : 2000;
                }
            }
            else
            {
                if (etl <= 128) 
                {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(1700), time_ssi) : 1700;
                }
                else if (etl <= 192)
                {
                    time_ssi  = _time_ssi.fixedflag ?  ((void)(2500), time_ssi) : 2500;
                }
                else 
                {
					time_ssi  = _time_ssi.fixedflag ?   ((void)(muse_flag?5000:3300), time_ssi) : muse_flag?5000:3300;
                }
            }
        }
        else
        {
            time_ssi  = _time_ssi.fixedflag ?  ((void)(1000), time_ssi) : 1000;
        }
    }

    te_time  = _te_time.fixedflag ?  ((void)(exist(opte)), te_time) : exist(opte);
    gkdelay  = _gkdelay.fixedflag ?  ((void)(RUP_GRD(gkdelay)), gkdelay) : RUP_GRD(gkdelay);

    /* BJM MRIge57693 - need to calculate it first */
    pos_start  = _pos_start.fixedflag ?    ((void)(RUP_GRD((int)tlead+GRAD_UPDATE_TIME)), pos_start) : RUP_GRD((int)tlead+GRAD_UPDATE_TIME);
    if ((pos_start + pw_gzrf1a) < -rfupa) {
        pos_start  = _pos_start.fixedflag ?      ((void)(RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME))), pos_start) : RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME));
    }

    non_tetime  = _non_tetime.fixedflag ?             
                 
          ((void)(pos_start+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift), non_tetime) : pos_start+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift;

    { /* Start of code inlined from Inversion_new.e InversionEval */
        hrf0  = _hrf0.fixedflag ?  ((void)((pw_rf0)/2), hrf0) : (pw_rf0)/2;  
        pw_gzrf0  = _pw_gzrf0.fixedflag ?  ((void)(pw_rf0), pw_gzrf0) : pw_rf0;

        /* determine the bandwidth of IR pulse */
        bw_rf0  = _bw_rf0.fixedflag ?  ((void)(5.12*cyc_rf0/((FLOAT)pw_rf0/(FLOAT)1000000)), bw_rf0) : 5.12*cyc_rf0/((FLOAT)pw_rf0/(FLOAT)1000000);

        if(ir_on==PSD_ON)
        {
            /* determine the amplitude of IR pulse */
            if (ampslice(_a_gzrf0.fixedflag ? (_temp582_a_gzrf0=a_gzrf0,&_temp582_a_gzrf0) : &a_gzrf0, bw_rf0, 
                         ((exist(opimode) == PSD_3D) ? exist(opvthick) : invthick),
                         gscale_rf0,TYPDEF)
                == FAILURE)
            {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                           1,STRING_ARG,"ampslice");
            }

            /* Y Killer CVs */
            if (amppwgrad(yk0_killer_area, loggrd.ty_yz, 0.0, 0.0, loggrd.yrt,
                          MIN_PLATEAU_TIME, _a_gyk0.fixedflag ? (_temp583_a_gyk0=a_gyk0,&_temp583_a_gyk0) : &a_gyk0, _pw_gyk0a.fixedflag ? (_temp584_pw_gyk0a=pw_gyk0a,&_temp584_pw_gyk0a) : &pw_gyk0a,
                          _pw_gyk0.fixedflag ? (_temp585_pw_gyk0=pw_gyk0,&_temp585_pw_gyk0) : &pw_gyk0, _pw_gyk0d.fixedflag ? (_temp586_pw_gyk0d=pw_gyk0d,&_temp586_pw_gyk0d) : &pw_gyk0d) == FAILURE) {
                epic_error(use_ermes, "%s failed in InversionEval.",
                           EM_PSD_SUPPORT_FAILURE,1,STRING_ARG,"amppwgrad:gyk0"); 
                return FAILURE;
            }
        }

        a_gyk0  = _a_gyk0.fixedflag ?    ((void)(a_gyk0*(ir_on)), a_gyk0) : a_gyk0*(ir_on);

        ir_grad_time   = _ir_grad_time.fixedflag ?       
                                            
                                             ((void)(RUP_GRD((ir_on)*(pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d))), ir_grad_time) : RUP_GRD((ir_on)*(pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d));

        /* irprep_support */
        pos_ir_start  = _pos_ir_start.fixedflag ?    ((void)(RUP_GRD(GRAD_UPDATE_TIME+(int)tlead)), pos_ir_start) : RUP_GRD(GRAD_UPDATE_TIME+(int)tlead);  

        if (exist(opirprep) == PSD_ON) /* same as Inversion.e */
           ir_start  = _ir_start.fixedflag ?      
                                  ((void)(RUP_GRD(GRAD_UPDATE_TIME+tlead+IMax(2,(48+pw_gzrf0a),minimumPreRfSspTime()-psd_rf_wait))), ir_start) : RUP_GRD(GRAD_UPDATE_TIME+tlead+IMax(2,(48+pw_gzrf0a),minimumPreRfSspTime()-psd_rf_wait));
        else
           ir_start  = _ir_start.fixedflag ?      ((void)(RUP_GRD(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a)), ir_start) : RUP_GRD(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a);

        irk_start  = _irk_start.fixedflag ?      ((void)(RUP_GRD(ir_start+pw_rf0+pw_gyk0a)), irk_start) : RUP_GRD(ir_start+pw_rf0+pw_gyk0a);
        ir_time   = _ir_time.fixedflag ?                 ((void)(RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-cs_sattime-sp_sattime-satdelay-(hrf1a+IMax(2,pw_gzrf1a,DAB_length[bd_index]+minimumPreRfSspTime()))))), ir_time) : RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-cs_sattime-sp_sattime-satdelay-(hrf1a+IMax(2,pw_gzrf1a,DAB_length[bd_index]+minimumPreRfSspTime()))));
        ir_time_total  = _ir_time_total.fixedflag ?          ((void)(RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-t_exa))), ir_time_total) : RUP_GRD((ir_on)*(opti+pw_gzrf0a+hrf0-t_exa));

        if(exist(opflair) == PSD_ON)  /*recalculate ir_time*/
        { 
            ir_time  = _ir_time.fixedflag ?  ((void)(0), ir_time) : 0;
            ir_time_total  = _ir_time_total.fixedflag ?  ((void)(ir_time), ir_time_total) : ir_time; 
        }
      
        /* t1flair_stir */
        if( t1flair_flag == PSD_ON )
        {
            ir_time  = _ir_time.fixedflag ?          
                                             ((void)(RUP_GRD((ir_on)*(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d))), ir_time) : RUP_GRD((ir_on)*(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a+pw_rf0+IMax(2,pw_gzrf0d,pw_gyk0a)+pw_gyk0+pw_gyk0d));
        }

    } /* End of code inlined from Inversion_new.e InversionEval */


    non_tetime  = _non_tetime.fixedflag ?      ((void)(non_tetime+ir_time+satdelay), non_tetime) : non_tetime+ir_time+satdelay;

    pos_start_rf0  = _pos_start_rf0.fixedflag ?      ((void)(RUP_GRD(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a)), pos_start_rf0) : RUP_GRD(GRAD_UPDATE_TIME+(int)tlead+pw_gzrf0a);

    /****Changing the beg_nontetime calculation to use pos_start instead of */
    /* pos_start_rf0 - MRIge42119 - RJF/JAP ********/ 
    beg_nontetime  = _beg_nontetime.fixedflag ?      ((void)(hrf1a+pw_gzrf1a+pos_start), beg_nontetime) : hrf1a+pw_gzrf1a+pos_start;
    
    /***SVBranch: HCSDM00259122 - FOCUS walk sat ***/
    if ((walk_sat_flag) && (rfov_flag))
    {
        non_tetime  = _non_tetime.fixedflag ?    ((void)(non_tetime+pw_wksat_tot), non_tetime) : non_tetime+pw_wksat_tot;
        beg_nontetime  = _beg_nontetime.fixedflag ?    ((void)(beg_nontetime+pw_wksat_tot), beg_nontetime) : beg_nontetime+pw_wksat_tot;
    }
    /****************************/    

    /* Removed pw_gzrf0a from beg_nontitime calculation - pos_start_rf0 
       is the time at which the flat portion of the slice select trapezoid starts.*/

    beg_nontitime  = _beg_nontitime.fixedflag ?    ((void)(pw_rf0/2+pos_start_rf0), beg_nontitime) : pw_rf0/2+pos_start_rf0;
    full_irtime  = _full_irtime.fixedflag ?            ((void)(exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;

    tmin  = _tmin.fixedflag ?    ((void)(te_time+non_tetime), tmin) : te_time+non_tetime;

    /* Imgtimutil calculates actual tr for 
       normal scans, available portion of R-R
       interval for imaging for cardiac scans.
       First parameter is only used if the scan
       is cardiac gated. */

    premid_rf90  = _premid_rf90.fixedflag ?       ((void)(optdel1-psd_card_hdwr_delay-td0), premid_rf90) : optdel1-psd_card_hdwr_delay-td0;
    if (imgtimutil(premid_rf90, seq_type, gating, 
                   _avail_image_time.fixedflag ? (_temp587_avail_image_time=avail_image_time,&_temp587_avail_image_time) : &avail_image_time)==FAILURE)
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "imgtimutil" );
    else
        act_tr  = _act_tr.fixedflag ?  ((void)(avail_image_time), act_tr) : avail_image_time;

    /* Image time util returns the time available for slices.
       If cardiac, imgtimutil subtracts off the cardiac trigger delay.
    */

    if (existcv(opcgate) && (opcgate == PSD_ON)) {
        /* act_tr is used in powermon routines */
        act_tr  = _act_tr.fixedflag ?  
                                 ((void)(RUP_GRD((int)((float)(exist(ophrep))*(60.0/exist(ophrate))*1e6))), act_tr) : RUP_GRD((int)((float)(exist(ophrep))*(60.0/exist(ophrate))*1e6));
        cvoverride(optr, act_tr, _optr.fixedflag, PSD_EXIST_ON);
    }

    /* RTG */
    if ((existcv(oprtcgate) && (oprtcgate == PSD_ON)) || (navtrig_flag == PSD_ON))
    {
        /* act_tr is used in powermon routines */
        act_tr  = _act_tr.fixedflag ?  
                                 ((void)(RUP_GRD((int)((float)(exist(oprtrep))*(60.0/exist(oprtrate))*1e6))), act_tr) : RUP_GRD((int)((float)(exist(oprtrep))*(60.0/exist(oprtrate))*1e6));
        cvoverride(optr, act_tr, _optr.fixedflag, PSD_EXIST_ON);
    }

    act_tr  = _act_tr.fixedflag ?  ((void)(RUP_HRD(act_tr)), act_tr) : RUP_HRD(act_tr);
    avail_image_time  = _avail_image_time.fixedflag ?  ((void)(RUP_HRD(avail_image_time)), avail_image_time) : RUP_HRD(avail_image_time);

    rhptsize  = _rhptsize.fixedflag ?  ((void)(exist(opptsize)), rhptsize) : exist(opptsize);

    /* BJM: MRIge60610 */
    if(num_overscan > 0) {
        rhnframes  = _rhnframes.fixedflag ?    ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop-ky_offset)), rhnframes) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop-ky_offset);
    } else {
        rhnframes  = _rhnframes.fixedflag ?  ((void)((short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop)), rhnframes) : (short)(ceilf((float)exist(opyres)*asset_factor/rup_factor)*rup_factor*fn*nop);
    }

    /* internref: iref_frames */
    iref_frames  = _iref_frames.fixedflag ?    ((void)(iref_etl*intleaves), iref_frames) : iref_etl*intleaves;

    if (rawdata) {
        slice_size  = _slice_size.fixedflag ?  
            ((void)((1+baseline+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*nex*exist(opnecho)), slice_size) : (1+baseline+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*nex*exist(opnecho);
    } else {
        slice_size  = _slice_size.fixedflag ?  
            ((void)((1+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*exist(opnecho)), slice_size) : (1+rhnframes+rhhnover+iref_frames)*2*rhptsize*rhfrsize*exist(opnecho);
    }

    rhdayres  = _rhdayres.fixedflag ?        ((void)(rhnframes+rhhnover+iref_frames+1), rhdayres) : rhnframes+rhhnover+iref_frames+1;
    if (exist(opxres) > 256 && exist(opxres) <= 512)
        rhimsize  = _rhimsize.fixedflag ?  ((void)(512), rhimsize) : 512;
    else
        rhimsize  = _rhimsize.fixedflag ?  ((void)(256), rhimsize) : 256;

    /* internref: rhcv calculations */
    if(iref_etl > 0)
    {
        if( ky_dir == PSD_BOTTOM_UP ){
            rhextra_frames_top  = _rhextra_frames_top.fixedflag ?  ((void)(0), rhextra_frames_top) : 0;
            rhextra_frames_bot  = _rhextra_frames_bot.fixedflag ?  ((void)(iref_frames), rhextra_frames_bot) : iref_frames;
            rhpc_ref_start  = _rhpc_ref_start.fixedflag ?    ((void)(rhdayres-1), rhpc_ref_start) : rhdayres-1;
            rhpc_ref_stop  = _rhpc_ref_stop.fixedflag ?    ((void)(rhdayres-iref_frames), rhpc_ref_stop) : rhdayres-iref_frames;
        }else if( ky_dir == PSD_TOP_DOWN ){
            rhextra_frames_top  = _rhextra_frames_top.fixedflag ?  ((void)(iref_frames), rhextra_frames_top) : iref_frames;
            rhextra_frames_bot  = _rhextra_frames_bot.fixedflag ?  ((void)(0), rhextra_frames_bot) : 0;
            rhpc_ref_start  = _rhpc_ref_start.fixedflag ?  ((void)(1), rhpc_ref_start) : 1;
            rhpc_ref_stop  = _rhpc_ref_stop.fixedflag ?  ((void)(iref_frames), rhpc_ref_stop) : iref_frames;
        }
    }
    else
    {
        rhextra_frames_top  = _rhextra_frames_top.fixedflag ?  ((void)(0), rhextra_frames_top) : 0;
        rhextra_frames_bot  = _rhextra_frames_bot.fixedflag ?  ((void)(0), rhextra_frames_bot) : 0;
    }

    /* prepare for maxslquanttps calculation */
    opslquant_old  = _opslquant_old.fixedflag ?  ((void)(opslquant), opslquant_old) : opslquant;
    if ( PSD_ON == mph_flag ) {
        if (acqmode == 0)
            opslquant  = _opslquant.fixedflag ?  ((void)(opslquant_old), opslquant) : opslquant_old;
        else if (acqmode == 1)
            opslquant  = _opslquant.fixedflag ?  ((void)(dwi_fphases), opslquant) : dwi_fphases;
    }

    if (maxslquanttps(_max_bamslice.fixedflag ? (_temp588_max_bamslice=max_bamslice,&_temp588_max_bamslice) : &max_bamslice, (int)rhimsize, slice_size, 1, NULL) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslquanttps" );
        return FAILURE;
    }

    /* return opslquant to its original value */
    opslquant  = _opslquant.fixedflag ?  ((void)(opslquant_old), opslquant) : opslquant_old;

    ta_gxwn  = _ta_gxwn.fixedflag ?  ((void)((-1.0)*a_gxw), ta_gxwn) : (-1.0)*a_gxw;
    gradx[GXWP_SLOT].num = etl/2+(iref_etl/2+iref_etl%2);
    gradx[GXWN_SLOT].num = (etl+1)/2+iref_etl/2;
    gradx[GXWN_SLOT].amp = _ta_gxwn.fixedflag ? (_temp589_ta_gxwn=ta_gxwn,&_temp589_ta_gxwn) : &ta_gxwn;
    grady[GY1_SLOT].num = 1;
    grady[GY_BLIP_SLOT].num = etl - 1;

    if (eoskillers == PSD_ON) {
        gradx[GXK_SLOT].num = ((eosxkiller==1) ? 1 : 0);
        grady[GYK_SLOT].num = ((eosykiller==1) ? 1 : 0);
        gradz[GZK_SLOT].num = ((eoszkiller==1) ? 1 : 0);
    } else {
        gradx[GXK_SLOT].num = 0;
        grady[GYK_SLOT].num = 0;
        gradz[GZK_SLOT].num = 0;
    }

    grady[GY1_SLOT].ptype = G_TRAP;
    grady[GY1_SLOT].attack = _pw_gy1a.fixedflag ? (_temp590_pw_gy1a=pw_gy1a,&_temp590_pw_gy1a) : &pw_gy1a;
    grady[GY1_SLOT].decay = _pw_gy1d.fixedflag ? (_temp591_pw_gy1d=pw_gy1d,&_temp591_pw_gy1d) : &pw_gy1d;
    grady[GY1_SLOT].pw = _pw_gy1.fixedflag ? (_temp592_pw_gy1=pw_gy1,&_temp592_pw_gy1) : &pw_gy1;

    /* MRIge51455 - initalize invthick before Inversion_new. */
    if ( floatsAlmostEqualEpsilons(invthick, 0.0, 2) )
    {
        invthick  = _invthick.fixedflag ?  ((void)(1.0), invthick) : 1.0;
    }

    /* Fix up grad structure for number of Z blips */
    if ((use_slice_fov_shift_blips) && (mux_flag) && (mux_slices_rf1 > 1)) {
      gradz[GZ_BLIP_SLOT].num = etl - 1;
    } else {
      gradz[GZ_BLIP_SLOT].num = 0;
    }

    /* To avoid error from prescan signal being too small */
    if (rfov_flag)
    {
        temp_slthick  = _temp_slthick.fixedflag ?  ((void)(opslthick), temp_slthick) : opslthick;
        cvoverride(opslthick, FMax(2, psminslthick, opslthick), PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(cfh_fov, FMax(2, psminfov/10.0, opfov/10.0), PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvunlock(cfh_fov);
    }

    { /* Start of code inlined from Prescan.e PScveval */
        /*********************************************************************
         *                     PRESCAN.E HOST SECTION                        *
         *                           PScveval                                *
         *                                                                   *
         * Write here the code unique to the Host PSD process. All code to   *
         * be executed in cveval() must be written here.                     *
         *********************************************************************/

        /* MRIhc49539: check current nucleus against coil DB: */
        n32 psd_nucleus = specnuc;

        if(psd_nucleus != coilInfo[0].rxNucleus)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD", STRING_ARG, "the selected coil");
            return FAILURE; 
        }
         
        TGspf  = _TGspf.fixedflag ?        ((void)(((0==getAps1Mod())&&opspf)), TGspf) : ((0==getAps1Mod())&&opspf);
    	read_axis = TGspf ? YGRAD : XGRAD;
        if(read_axis == XGRAD)
        {
            killer_axis = YGRAD;
        }
        else
        {
            killer_axis = XGRAD;
        }

        local_tg  = _local_tg.fixedflag ?      ((void)((exist(oppscshimtg)&&(exist(oppscvquant)>0))), local_tg) : (exist(oppscshimtg)&&(exist(oppscvquant)>0));
                
        /* set up axis for XTG */
        if(local_tg && oppscvquant > 0)
        {
            tg_read_axis = XGRAD;
            tg_killer_axis = YGRAD;
        }
        else
        {
            tg_read_axis = read_axis;
            tg_killer_axis = killer_axis;
        }

        /* Set flag for minimizing time between XTG Y Killers */
        if ( ( getAps1Mod() == 2 ) && (local_tg == PSD_OFF) )
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_ON), XTG_minimizeYKillerGap) : PSD_ON;
        }
        else
        {
            XTG_minimizeYKillerGap  = _XTG_minimizeYKillerGap.fixedflag ?  ((void)(PSD_OFF), XTG_minimizeYKillerGap) : PSD_OFF;
        }

        /* Set min_ssp */
        min_ssp = IMax( 2, RF_MIN_BLANK, RUP_GRD(-rfupa + rfupd + RFUNBLANK_LENGTH + RFFREQ_LENGTH) );

        TGopslthick  = _TGopslthick.fixedflag ?  ((void)(10.0), TGopslthick) : 10.0;

        if((PSD_ON == local_tg) && (oppscvquant >0)) /* use shim vol for TG */
        {
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(psc_info[0].oppsclenx), TGopslthickx) : psc_info[0].oppsclenx;
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(psc_info[0].oppscleny), TGopslthicky) : psc_info[0].oppscleny;
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(psc_info[0].oppsclenz), TGopslthick) : psc_info[0].oppsclenz;


            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMin(2,TGopslthickx,cfsystemmaxfov)), TGopslthickx) : FMin(2,TGopslthickx,cfsystemmaxfov);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMin(2,TGopslthicky,cfsystemmaxfov)), TGopslthicky) : FMin(2,TGopslthicky,cfsystemmaxfov);
            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMin(2,TGopslthick,cfsystemmaxfov)), TGopslthick) : FMin(2,TGopslthick,cfsystemmaxfov);

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,MINFOV_TG)), TGopslthick) : FMax(2,TGopslthick,MINFOV_TG);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }
        else if(PSD_ON == local_tg)
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.8), fov_scaling) : 0.8;
            if(PSD_ON == opfus)
            {
                fov_scaling  = _fov_scaling.fixedflag ?  ((void)(0.5), fov_scaling) : 0.5;
            }
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(opslthick*opslquant*fov_scaling), TGopslthick) : opslthick*opslquant*fov_scaling;
            TGopslthickx  = _TGopslthickx.fixedflag ?  ((void)(get_act_freq_fov()*fov_scaling), TGopslthickx) : get_act_freq_fov()*fov_scaling;  /* use scan Rx */
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(get_act_phase_fov()*fov_scaling), TGopslthicky) : get_act_phase_fov()*fov_scaling;  /* use scan Rx */

            TGopslthick   = _TGopslthick.fixedflag ?     ((void)(FMax(2,TGopslthick,20.0)), TGopslthick) : FMax(2,TGopslthick,20.0);
            TGopslthickx  = _TGopslthickx.fixedflag ?    ((void)(FMax(2,TGopslthickx,MINFOV_TG)), TGopslthickx) : FMax(2,TGopslthickx,MINFOV_TG);
            TGopslthicky  = _TGopslthicky.fixedflag ?    ((void)(FMax(2,TGopslthicky,MINFOV_TG)), TGopslthicky) : FMax(2,TGopslthicky,MINFOV_TG);
        }

        cal_btw_rf_rba_ssp  = _cal_btw_rf_rba_ssp.fixedflag ?       ((void)(IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk)), cal_btw_rf_rba_ssp) : IMax(3,DABSETUP,4+attenlen+tns_len+XTR_length[bd_index]+DAB_length[bd_index]+fast_xtr,cfrfminunblk);
        cal_grd_rf_delays  = _cal_grd_rf_delays.fixedflag ?      ((void)(IMax(2,0,psd_rf_wait-psd_grd_wait)), cal_grd_rf_delays) : IMax(2,0,psd_rf_wait-psd_grd_wait);

        if (psddebugcode)
        {
            psd_dump_coil_info();
        }

        if (FAILURE==PScveval())
        {
            return FAILURE;
        }
        if (FAILURE==FTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==XTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AScveval())
        {
            return FAILURE;
        }
        if (FAILURE==RGcveval())
        {
            return FAILURE;
        }

        if (FAILURE==RScveval())
        {
            return FAILURE;
        }
        if (FAILURE==DTGcveval())
        {
            return FAILURE;
        }
        if (FAILURE==AutoCoilcveval())
        {
            return FAILURE;
        }
        if (FAILURE==ExtCalcveval())
        {
            return FAILURE;
        }

    } /* End of code inlined from Prescan.e PScveval */



    if (rfov_flag)
    {
        cvoverride(opslthick, temp_slthick, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* Gradient driver and coil heating calculations */
    if (exist(opplane) != PSD_OBL) {
        gradx[GX1_SLOT].powscale = 1.0;
        gradx[GXDPC1_SLOT].powscale = 1.0;
        gradx[GXDPCR_SLOT].powscale = 1.0;
        gradx[GXWP_SLOT].powscale = 1.0;
        gradx[GXWN_SLOT].powscale = 1.0;
        gradx[GXK_SLOT].powscale = 1.0;
        gradx[GXDR_SLOT].powscale = 1.0;
        gradx[GXDL_SLOT].powscale = 1.0; 
        grady[GY1_SLOT].powscale = 1.0;
        grady[GY_BLIP_SLOT].powscale = 1.0;
        grady[GYK_SLOT].powscale = 1.0;
        grady[GYKCS_SLOT].powscale = 1.0;
        grady[GYRF2IV_SLOT].powscale = 1.0;
        grady[GYK0_SLOT].powscale = 1.0;
        grady[GYDR_SLOT].powscale = 1.0;
        grady[GYDL_SLOT].powscale = 1.0;
        gradz[GZRF1_SLOT].powscale = 1.0;
        gradz[GZRF2L1_SLOT].powscale = 1.0;
        gradz[GZRF2R1_SLOT].powscale = 1.0;
        gradz[GZRF2_SLOT].powscale = 1.0;
        gradz[GZRF0_SLOT].powscale = 1.0;
        gradz[GZK_SLOT].powscale = 1.0;
        gradz[GZ1_SLOT].powscale = 1.0;
        gradz[GZMN_SLOT].powscale = 1.0;
        gradz[GZDL_SLOT].powscale = 1.0;
        gradz[GZDR_SLOT].powscale = 1.0;
        gradz[GZ_BLIP_SLOT].powscale = 1.0;
    } else {
        gradx[GX1_SLOT].powscale     = loggrd.xfs/loggrd.tx_xyz;
        gradx[GXDPC1_SLOT].powscale  = loggrd.xfs/loggrd.tx_xz;
        gradx[GXDPCR_SLOT].powscale  = loggrd.xfs/loggrd.tx;
        gradx[GXWP_SLOT].powscale    = loggrd.xfs/loggrd.tx_xy;
        gradx[GXWN_SLOT].powscale    = loggrd.xfs/loggrd.tx_xy;
        gradx[GXK_SLOT].powscale     = loggrd.xfs/loggrd.tx_xyz;
        gradx[GXDL_SLOT].powscale     = loggrd.xfs/loggrd.tx_xyz;
        gradx[GXDR_SLOT].powscale     = loggrd.xfs/loggrd.tx_xyz;

        grady[GY1_SLOT].powscale     = loggrd.yfs/loggrd.ty_xyz;
        grady[GY_BLIP_SLOT].powscale = loggrd.yfs/loggrd.ty_xy;
        grady[GYK_SLOT].powscale     = loggrd.yfs/loggrd.ty_xyz;
        grady[GYK0_SLOT].powscale    = loggrd.yfs/loggrd.ty_xyz;
        grady[GYKCS_SLOT].powscale   = loggrd.yfs/loggrd.ty_xyz;
        grady[GYRF2IV_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
        grady[GYDL_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;
        grady[GYDR_SLOT].powscale = loggrd.yfs/loggrd.ty_xyz;

        if (rfov_flag)
        {
            gradz[GZRF1_SLOT].powscale   = loggrd.zfs/loggrd.tz_yz;
        }
        else
        {
            gradz[GZRF1_SLOT].powscale   = loggrd.zfs/loggrd.tz;
        }

        gradz[GZRF2L1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZRF2R1_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZRF2_SLOT].powscale   = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZRF0_SLOT].powscale   = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZK_SLOT].powscale     = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZ1_SLOT].powscale     = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZMN_SLOT].powscale    = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZDL_SLOT].powscale    = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZDR_SLOT].powscale    = loggrd.zfs/loggrd.tz_xyz;
        gradz[GZ_BLIP_SLOT].powscale = loggrd.zfs/loggrd.tz_xyz;
    }

    if(iref_etl > 0)
    {
        gradx[GXDPC1_SLOT].num = 1;
        gradx[GXDPCR_SLOT].num = 1;
    }
    else
    {
        gradx[GXDPC1_SLOT].num = 0;
        gradx[GXDPCR_SLOT].num = 0;
    }

    /* RF Pulse Scaling (to peak B1)  ************************/
    /* First, find the peak B1 for the whole sequence. */

    if (findMaxB1Seq(&maxB1Seq, maxB1, MAX_ENTRY_POINTS, rfpulse, RF_FREE) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"findMaxB1Seq");
        return FAILURE;
    }

    /* Throw in an extra scale factor to account for xmtadd. */
    if (setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN],
                 maxB1[L_SCAN]/maxB1Seq) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setScale" );
        return FAILURE;
    }

    /* if FLAIR, available imaging time updated */
    if (epi_flair==PSD_ON)
    {
        maxslq_titime = _maxslq_titime.fixedflag ?          
                 ((void)(exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime-(pw_rf0+2*pw_gzrf0a+pos_start_rf0)), maxslq_titime) : exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime-(pw_rf0+2*pw_gzrf0a+pos_start_rf0);
        maxslq_ilir  = _maxslq_ilir.fixedflag ?        ((void)(maxslq_titime/(tmin+pw_rf0+2*pw_gzrf0a+pos_start_rf0)), maxslq_ilir) : maxslq_titime/(tmin+pw_rf0+2*pw_gzrf0a+pos_start_rf0);
        avail_se_time  = _avail_se_time.fixedflag ?  ((void)(maxslq_titime), avail_se_time) : maxslq_titime;
    }
    else
    {
        avail_se_time  = _avail_se_time.fixedflag ?  ((void)(avail_image_time), avail_se_time) : avail_image_time;
    }

    minseqcoil_esp  = _minseqcoil_esp.fixedflag ?  ((void)(esp), minseqcoil_esp) : esp;     /* MRIhc16090 */

    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
/* *********************************************************** 
*  Set default values of gradHeatMethod =1, gradCoilMethod =3 and
*  gradHeatFile=0 - Start of Code inlined from AutoAdjustTR.e 
***************************************************************/
#ifdef PGEN_UTIL
      pititle = _pititle.fixedflag ? ((void)(1), pititle) : 1;
      piuset|= use18;
      opuser18  = _opuser18.fixedflag ?  ((void)(1), opuser18) : 1; 
      cvmod (opuser18,0,1,1,"Value of gradHeatMethod: ", 1, "gradHeatMethod");
      cvdesc(pititle, "gradHeatMethod");
     
      gradHeatMethod  = _gradHeatMethod.fixedflag ?   ((void)((int)exist(opuser18)), gradHeatMethod) : (int)exist(opuser18);
      
      cvdesc(pititle,"gradCoilMethod");
      piuset |=use19;
      opuser19  = _opuser19.fixedflag ?  ((void)(3), opuser19) : 3;
      cvmod (opuser19,0,5,3,"Value of gradCoilMethod: ", 3, "gradCoilMethod");
      gradCoilMethod  = _gradCoilMethod.fixedflag ?   ((void)((int)exist(opuser19)), gradCoilMethod) : (int)exist(opuser19);
	
      cvdesc(pititle,"gradHeatFile");
      piuset |= use21;
      opuser21 = _opuser21.fixedflag ? ((void)(0), opuser21) : 0;
      cvmod (opuser21,0,2,0,"Value of gradHeatFile: ", 0, "gradHeatFile");
      gradHeatFile  = _gradHeatFile.fixedflag ?   ((void)((int)exist(opuser21)), gradHeatFile) : (int)exist(opuser21);
      /* MRIhc17231 */	
/*      printf("\ng.HeatMethod= %d,g.CoilMethod=%d,g.HeatFile=%d\n",(int)exist(opuser18),(int)exist(opuser19),(int)exist(opuser21));
      fflush(stdout);
*/ 
#endif
/* End of code inlined from AutoAdjustTR.e */

    if( opdiffuse == PSD_ON &&
        ((old_weighted_avg_grad != weighted_avg_grad) ||
         (!floatsAlmostEqualEpsilons(old_avg_bval, avg_bval, 2) && weighted_avg_grad == PSD_ON)) )
    {
        old_weighted_avg_grad = weighted_avg_grad;
        old_avg_bval = avg_bval;
        /* set_cvs_changed_flag(TRUE); */
        enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(PSD_ON), enforce_minseqseg) : PSD_ON;
    }

    if( PSD_ON == weighted_avg_grad &&
        ((opdiffuse == PSD_ON && tensor_flag == PSD_OFF) ||
         (tensor_flag == PSD_ON && num_tensor >= MIN_DTI_DIRECTIONS && 
          ((num_tensor <= act_numdir_clinical) || 
          ((PSD_ON == exist(opresearch)) && (rhtensor_file_number > 0) && (num_tensor <= MAX_DIRECTIONS))))))
    {
        if( FAILURE == set_tensor_orientations() )
        {
            return FAILURE;
        }
    }

    /* Rio diffusion cyclcing, need to check # of dirs, #of T2s, ... to recalculate timing*/
    /* It's necessary to trigger minseq() when switching to 3in1*/
    if( ((opdiffuse == PSD_ON) && (isRioSystem())) &&
        ((old_num_dirs != opdifnumdirs) || (old_opdifnumt2!=opdifnumt2) || (old_dualspinecho_flag !=dualspinecho_flag)
            || (old_diff_order_flag != diff_order_flag) || (old_opdfax3in1 != opdfax3in1)) )
    {
        old_num_dirs = opdifnumdirs;
        old_opdifnumt2 = opdifnumt2;
        old_dualspinecho_flag = dualspinecho_flag;
        old_diff_order_flag = diff_order_flag;
        old_opdfax3in1 = opdfax3in1;

        enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(PSD_ON), enforce_minseqseg) : PSD_ON;
    }

    INT seq_entry_index = 0;  /* core sequence = 0 */

    /* Perform gradient safety checks for main sequence */  

    if(PSD_OFF == oploadprotocol)
    {
        time_profiler_start_timer("EPI2:minseq()");

        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp593_min_seqgrad=min_seqgrad,&_temp593_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seq_entry_index, tsamp,
                                avail_image_time,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, supfailfmt,
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "minseq" );
            return FAILURE;
        }

        time_profiler_stop_timer("EPI2:minseq()");
    }

    if (diff_order_debug == PSD_ON)
    {
        FILE *fp= NULL;
#ifdef PSD_HW
        const char *dir_log = "/usr/g/service/log";
#else
        const char *dir_log = ".";
#endif
        char fname_tensor_host[255];
        int ii, kk;

        sprintf(fname_tensor_host, "%s/diff_order_tensor_host.txt", dir_log);

        if (NULL != (fp = fopen(fname_tensor_host, "w")))
        {
            if(optensor >= PSD_ON)
            {
                fprintf(fp,"%d\n",opdifnumdirs+opdifnumt2);
                for( kk=0; kk< (opdifnumdirs + opdifnumt2); kk++)
                {
                    fprintf(fp,"%f %f %f\n", TENSOR_HOST[0][kk],TENSOR_HOST[1][kk],TENSOR_HOST[2][kk]);
                }
            }
            else
            {
                fprintf(fp,"%d\n",opdifnumt2 + opdifnumdirs * opnumbvals);

                for( kk=0; kk<opdifnumt2; kk++)
                {
                    fprintf(fp,"%f %f %f\n", TENSOR_HOST[0][kk],TENSOR_HOST[1][kk],TENSOR_HOST[2][kk]);
                }
                for( kk=0; kk<opnumbvals; kk++)
                {
                    for(ii = 0; ii<opdifnumdirs; ii++)
                    {
                        fprintf(fp,"%f %f %f\n",
                                TENSOR_HOST[0][ii+opdifnumt2]* sqrt(diff_bv_weight[kk]),
                                TENSOR_HOST[1][ii+opdifnumt2]* sqrt(diff_bv_weight[kk]),
                                TENSOR_HOST[2][ii+opdifnumt2]* sqrt(diff_bv_weight[kk]) );
                    }
                }
            }

            fprintf(fp, "%d,%d\n", opnumbvals, opdifnumt2);
            for (kk=0; kk<opnumbvals; kk++)
            {
                fprintf(fp, "%d ", (int)difnextab[kk]);
            }

            fclose(fp);
        }
    }


    /* Set the amps back that are scaled within calcPulseParams function */
    if((PSD_ON == gradHeatMethod) && (PSD_ON == derate_amp)) 
    {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            ia_gxdl  = _ia_gxdl.fixedflag ?     ((void)((int)(a_gxdl*(float)max_pg_iamp/loggrd.tx)), ia_gxdl) : (int)(a_gxdl*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr  = _ia_gxdr.fixedflag ?     ((void)((int)(a_gxdr*(float)max_pg_iamp/loggrd.tx)), ia_gxdr) : (int)(a_gxdr*(float)max_pg_iamp/loggrd.tx);
            
            ia_gydl  = _ia_gydl.fixedflag ?     ((void)((int)(a_gydl*(float)max_pg_iamp/loggrd.ty)), ia_gydl) : (int)(a_gydl*(float)max_pg_iamp/loggrd.ty);
            ia_gydr  = _ia_gydr.fixedflag ?     ((void)((int)(a_gydr*(float)max_pg_iamp/loggrd.ty)), ia_gydr) : (int)(a_gydr*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl  = _ia_gzdl.fixedflag ?     ((void)((int)(a_gzdl*(float)max_pg_iamp/loggrd.tz)), ia_gzdl) : (int)(a_gzdl*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr  = _ia_gzdr.fixedflag ?     ((void)((int)(a_gzdr*(float)max_pg_iamp/loggrd.tz)), ia_gzdr) : (int)(a_gzdr*(float)max_pg_iamp/loggrd.tz);
        } 
        else 
        {
            ia_gxdl1  = _ia_gxdl1.fixedflag ?     ((void)((int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx)), ia_gxdl1) : (int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr1  = _ia_gxdr1.fixedflag ?     ((void)((int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx)), ia_gxdr1) : (int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx);
        
            ia_gxdl2  = _ia_gxdl2.fixedflag ?     ((void)((int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx)), ia_gxdl2) : (int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr2  = _ia_gxdr2.fixedflag ?     ((void)((int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx)), ia_gxdr2) : (int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx);

            ia_gydl1  = _ia_gydl1.fixedflag ?     ((void)((int)(a_gydl1*(float)max_pg_iamp/loggrd.ty)), ia_gydl1) : (int)(a_gydl1*(float)max_pg_iamp/loggrd.ty);
            ia_gydr1  = _ia_gydr1.fixedflag ?     ((void)((int)(a_gydr1*(float)max_pg_iamp/loggrd.ty)), ia_gydr1) : (int)(a_gydr1*(float)max_pg_iamp/loggrd.ty);
            
            ia_gydl2  = _ia_gydl2.fixedflag ?     ((void)((int)(a_gydl2*(float)max_pg_iamp/loggrd.ty)), ia_gydl2) : (int)(a_gydl2*(float)max_pg_iamp/loggrd.ty);
            ia_gydr2  = _ia_gydr2.fixedflag ?     ((void)((int)(a_gydr2*(float)max_pg_iamp/loggrd.ty)), ia_gydr2) : (int)(a_gydr2*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl1  = _ia_gzdl1.fixedflag ?     ((void)((int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz)), ia_gzdl1) : (int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr1  = _ia_gzdr1.fixedflag ?     ((void)((int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz)), ia_gzdr1) : (int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz);
            
            ia_gzdl2  = _ia_gzdl2.fixedflag ?     ((void)((int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz)), ia_gzdl2) : (int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr2  = _ia_gzdr2.fixedflag ?     ((void)((int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz)), ia_gzdr2) : (int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz);  
        }
    }

    if (debug_mux_rf)
    {
        printf("MB: before minseqrfamp opaccel_mb_stride = %d, mux_slices_rf2 =%d\n", opaccel_mb_stride, mux_slices_rf2);
    }

    /* RF amp, SAR, and system limitations on seq time */
    if (minseqrfamp(_min_seqrfamp.fixedflag ? (_temp594_min_seqrfamp=min_seqrfamp,&_temp594_min_seqrfamp) : &min_seqrfamp,(int)RF_FREE,rfpulse, 
                    L_SCAN) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "minseqrfamp" );
        return FAILURE;
    }

    if (maxseqsar(_max_seqsar.fixedflag ? (_temp595_max_seqsar=max_seqsar,&_temp595_max_seqsar) : &max_seqsar, (int)RF_FREE, rfpulse, L_SCAN) == FAILURE)
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxseqsar" );
        return FAILURE;
    }

    /* Note: this routine still uses the old coefficients */
    if (maxslicesar(_max_slicesar.fixedflag ? (_temp596_max_slicesar=max_slicesar,&_temp596_max_slicesar) : &max_slicesar, (int)RF_FREE,rfpulse, 
                    L_SCAN) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslicesar" );
        return FAILURE;
    }

    /* calculate maximum number of slices to fit in interleaved total IR time */
    if(epi_flair==PSD_ON)
    {
        other_slice_limit  = _other_slice_limit.fixedflag ?    ((void)(IMin(3,max_slicesar,max_bamslice,maxslq_ilir)), other_slice_limit) : IMin(3,max_slicesar,max_bamslice,maxslq_ilir);
    }
    else
    {
        if(opdiffuse == PSD_OFF)
        {
            other_slice_limit  = _other_slice_limit.fixedflag ?    ((void)(IMin(2,max_slicesar,max_bamslice)), other_slice_limit) : IMin(2,max_slicesar,max_bamslice);
        }
        else
        {
            other_slice_limit  = _other_slice_limit.fixedflag ?     ((void)(IMin(3,max_slicesar,max_bamslice,(int)(MAX_SLICES_DTI/dwi_fphases))), other_slice_limit) : IMin(3,max_slicesar,max_bamslice,(int)(MAX_SLICES_DTI/dwi_fphases));
            if(mux_flag){
                other_slice_limit  = _other_slice_limit.fixedflag ?     ((void)(IMin(3,max_slicesar*mux_slices_rf1,max_bamslice,(int)(MAX_SLICES_DTI/dwi_fphases))), other_slice_limit) : IMin(3,max_slicesar*mux_slices_rf1,max_bamslice,(int)(MAX_SLICES_DTI/dwi_fphases));
            }
        }
    }

    if (rfov_flag)
    {
        if ((rfov_maxnslices >= DEFAULT_MAXNSLICES_RFOV) && (exist(optr) >= FOCUS_ONE_ACQ_MIN_TR))   /* HCSDM00397660 */
        {
            rfov_maxnslices  = _rfov_maxnslices.fixedflag ?  ((void)(other_slice_limit), rfov_maxnslices) : other_slice_limit;
        }
        else
        {
            rfov_maxnslices  = _rfov_maxnslices.fixedflag ?  ((void)(DEFAULT_MAXNSLICES_RFOV), rfov_maxnslices) : DEFAULT_MAXNSLICES_RFOV;
        }
        other_slice_limit  = _other_slice_limit.fixedflag ?    ((void)(IMin(2,other_slice_limit,rfov_maxnslices)), other_slice_limit) : IMin(2,other_slice_limit,rfov_maxnslices);
    }

    /* Here, calculate #acqs, Auto TI value, avmaxslquant for ASPIR,
       because adaptive Auto TI value depends on slice/acqs.
       This ASPIR rutine is not needed for fixed TI model. */
    if ((PSD_ON == aspir_flag) && (ASPIR_AUTO_TI_ADAPTIVE == aspir_auto_ti_model))
    {
        int null_ti_temp = 0;
            
        if(mux_flag)
        {
            int tmin_temp = 0;
            int tmin_total_temp = 0;

            null_ti_temp = calc_ASPIR_TI(mux_slquant);
            focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(0), focus_eval_oscil) : 0;
            tmin_temp = tmin + (null_ti_temp - exist(opti));
            tmin_total_temp = IMax(4, min_seqgrad, min_seqrfamp, tmin_temp, max_seqsar);

            if ((PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype))
            {
                if ((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF )|| ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                {
                    tmin_total_temp += edwi_extra_time;
                }
            }

            /* MRIge52734 - increase tmin_total for long etl scan to prevent EOS error. PH */
            if (( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON))
            {
                if ((opyres == 256) && (tmin_total_temp < 500000))
                {
                    tmin_total_temp = 500000;
                }
            }

            /* Calculate avmaxslquant */
            if (maxslquant(&av_temp_int, avail_se_time, other_slice_limit,
                           seq_type, tmin_total_temp) == FAILURE)
            {
                epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslquant");
                return FAILURE;
            }

            avmaxslquant = ( (av_temp_int%2)?av_temp_int:(av_temp_int-1) ) * mux_slices_rf1;
            if (avmaxslquant > other_slice_limit)
            {
                int temp_count = other_slice_limit/ mux_slices_rf1;
                avmaxslquant = ( (temp_count%2)?temp_count:(temp_count-1) ) * mux_slices_rf1;
            }

        }
        else
        {
            /* HCSDM00361682 */
            if(focus_eval_oscil)
            {
                int slicein1_temp = 0;
                acqs  = _acqs.fixedflag ?  ((void)(force_acqs), acqs) : force_acqs;
                avmaxslquant = force_avmaxslquant;
                slicein1(&slicein1_temp, acqs, seq_type);
                null_ti_temp = calc_ASPIR_TI(slicein1_temp);
                if(!keep_focus_eval_oscil)
                {
                    focus_eval_oscil  = _focus_eval_oscil.fixedflag ?  ((void)(0), focus_eval_oscil) : 0;
                }
            }
            else
            {
                int acqs_index = 1;

                while (acqs_index <= exist(opslquant))
                {
                    int slicein1_temp = 0;
                    int tmin_temp = 0;
                    int tmin_total_temp = 0;
                    int acqs_temp = 0;

                    slicein1(&slicein1_temp, acqs_index, seq_type);
                    null_ti_temp = calc_ASPIR_TI(slicein1_temp);
                    tmin_temp = tmin + (null_ti_temp - exist(opti));
                    tmin_total_temp = IMax(4, min_seqgrad, min_seqrfamp, tmin_temp, max_seqsar);

                    if ((PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype))
                    {
                        if ((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF )|| ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                        {
                            tmin_total_temp += edwi_extra_time;
                        }
                    }

                    /* MRIge52734 - increase tmin_total for long etl scan to prevent EOS error. PH */
                    if (( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON))
                    {
                        if ((opyres == 256) && (tmin_total_temp < 500000))
                        {
                            tmin_total_temp = 500000;
                        }
                    }

                    /* Calculate avmaxslquant */
                    if (maxslquant(&av_temp_int, avail_se_time, other_slice_limit,
                                seq_type, tmin_total_temp) == FAILURE)
                    {
                        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslquant");
                        return FAILURE;
                    }


                    /* Calculate # of acqs with new avmaxslquant */
                    if (maxpass(&acqs_temp, seq_type, (int)exist(opslquant), avmaxslquant) == FAILURE)
                    {
                        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxpass");
                        return FAILURE;
                    }

                    if ((acqs_index < acqs_temp) && (PSD_OFF == mux_flag))
                    {
                        acqs_index++;
                    }
                    else
                    {
                        int start_max_slquant = 0;
                        int loop_counter = 0;
                        int MAX_LOOP_COUNT = 20;

                        /* To reduce # of iterations for slice looping, */
                        /* set avmaxslaunt if acqs_index == acqs_temp.  */
                        if (acqs_index > acqs_temp)
                        {
                            slicein1(&slicein1_temp, acqs_temp, seq_type);
                            null_ti_temp = calc_ASPIR_TI(slicein1_temp);
                            start_max_slquant = slicein1_temp;
                        }
                        else
                        {
                            start_max_slquant = avmaxslquant;
                        }

                        /* Find maxslquant for this acqs */
                        /* This calculation is only applied for Auto TI cases.   */
                        /* For Manual TI, avmaxslquant will be calculated lator. */
                        if (PSD_ON == exist(opautoti))
                        {
                            while (loop_counter < MAX_LOOP_COUNT)
                            {
                                int new_auto_ti = 0;
                                int new_tmin = 0;

                                new_auto_ti = calc_ASPIR_TI(start_max_slquant);
                                new_tmin = tmin + (new_auto_ti - exist(opti));
                                tmin_total_temp = IMax(4, min_seqgrad, min_seqrfamp, new_tmin, max_seqsar);

                                if ((PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype))
                                {
                                    if ((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF )|| ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                                    {
                                        tmin_total_temp += edwi_extra_time;
                                    }
                                }

                                /* MRIge52734 - increase tmin_total for long etl scan to prevent EOS error. PH */
                                if (( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON))
                                {
                                    if ((opyres == 256) && (tmin_total_temp < 500000))
                                    {
                                        tmin_total_temp = 500000;
                                    }
                                }

                                /* Calculate avmaxslquant by maxslquant() */
                                if (maxslquant(&av_temp_int, avail_se_time, other_slice_limit,
                                            seq_type, tmin_total_temp) == FAILURE)
                                {
                                    epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslquant");
                                    return FAILURE;
                                }

                                /*multiband max number of slices*/
                                if (mux_flag)
                                {
                                    avmaxslquant = ( (av_temp_int%2)?av_temp_int:(av_temp_int-1) ) * mux_slices_rf1;
                                    if (avmaxslquant > other_slice_limit)
                                    {
                                        int temp_count = other_slice_limit/ mux_slices_rf1;
                                        avmaxslquant = ( (temp_count%2)?temp_count:(temp_count-1) ) * mux_slices_rf1;
                                    }
                                }

                                if (start_max_slquant < avmaxslquant)
                                {
                                    start_max_slquant = avmaxslquant;
                                    loop_counter++;
                                }
                                else
                                {
                                    break;
                                }

                            } /* End of while loop */
                        }
                        break;
                    }
                } /* acqs_index loop */
            }
        }

        set_ASPIR_TI(null_ti_temp);

        /* Calculate cs_sattime, non_tetime and tmin with new opti */
        if (ChemSatEval(_cs_sattime.fixedflag ? (_temp597_cs_sattime=cs_sattime,&_temp597_cs_sattime) : &cs_sattime) == FAILURE)
        {
            epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ChemSatEval");
            return FAILURE;
        }

        /* HCSDM00361682  pos_start is changed in calcPulseParams() */
        pos_start_init  = _pos_start_init.fixedflag ?    ((void)(RUP_GRD((int)tlead+GRAD_UPDATE_TIME)), pos_start_init) : RUP_GRD((int)tlead+GRAD_UPDATE_TIME);
        if ((pos_start_init + pw_gzrf1a) < -rfupa) {
            pos_start_init  = _pos_start_init.fixedflag ?      ((void)(RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME))), pos_start_init) : RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME));
        }
 
        non_tetime  = _non_tetime.fixedflag ?             
                     
              ((void)(pos_start_init+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift), non_tetime) : pos_start_init+cs_sattime+sp_sattime+pw_gzrf1a+t_exa+tdaqhxb+gktime+gkdelay+time_ssi+GRAD_UPDATE_TIME+delt*(intleaves-1)+psd_rf_wait+pw_sspshift;

        non_tetime  = _non_tetime.fixedflag ?      ((void)(non_tetime+ir_time+satdelay), non_tetime) : non_tetime+ir_time+satdelay;

        tmin  = _tmin.fixedflag ?    ((void)(te_time+non_tetime), tmin) : te_time+non_tetime;
    }

    /* BJM PGEN_HOST */
    /* Calculate minimum sequence time based on coil, gradient driver,
       pulse width modulation, RF amplifier, and playout */
    tmin_total  = _tmin_total.fixedflag ?        ((void)(IMax(4,min_seqgrad,min_seqrfamp,tmin,max_seqsar)), tmin_total) : IMax(4,min_seqgrad,min_seqrfamp,tmin,max_seqsar);

    if ((PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype))
    {
        if ((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF )|| ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
        {
            tmin_total  = _tmin_total.fixedflag ?  ((void)(edwi_extra_time), tmin_total) : tmin_total+edwi_extra_time;
        }
    }

    if (navtrig_flag)
    {
        /* In Navigator Triggering, imaging scan interval can be reduced
           by adjusting navtrig_waittime after imaging scan. */
        if (isKizunaSystem())
        {
            nav_image_interval  = _nav_image_interval.fixedflag ?     ((void)(IMax(3,tmin,minseqgrddrv_t,minseqgpm_maxpow_t)), nav_image_interval) : IMax(3,tmin,minseqgrddrv_t,minseqgpm_maxpow_t);

            if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) || ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
            {
                nav_image_interval  = _nav_image_interval.fixedflag ?  ((void)(edwi_extra_time), nav_image_interval) : nav_image_interval+edwi_extra_time;
            }
        }
        else
        {
            nav_image_interval  = _nav_image_interval.fixedflag ?  ((void)(tmin_total), nav_image_interval) : tmin_total;
        }

        navtrig_waittime  = _navtrig_waittime.fixedflag ?          ((void)(IMax(2,500000,(tmin_total-nav_image_interval)*slquant_per_trig-navtrig_wait_before_imaging)), navtrig_waittime) : IMax(2,500000,(tmin_total-nav_image_interval)*slquant_per_trig-navtrig_wait_before_imaging);
    }

    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqcoil_t = %d\n", minseqcoil_t );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqgrddrv_t = %d\n", minseqgrddrv_t );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "minseqgpm_t = %d\n", minseqgpm_t );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "min_seqrfamp = %d\n", min_seqrfamp );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin = %d\n", tmin );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, funcName, "tmin_total = %d\n", tmin_total );

    /* MRIge52734 - increase tmin_total for long etl scan to prevent EOS error. PH */
    if ( ( ( (cfsrmode == PSD_SR50) && !(isStarterSystem()) ) || cfsrmode == PSD_SR77) && (vrgfsamp == PSD_ON)) 
    {
        if ( (opyres >= 256) && (tmin_total < 500000) )
            tmin_total  = _tmin_total.fixedflag ?  ((void)(500000), tmin_total) : 500000;
    }

    /* t1flair_stir */
    if (PSD_ON == t1flair_flag)
    {
        tmin_total_ir  = _tmin_total_ir.fixedflag ?  ((void)(ir_time), tmin_total_ir) : ir_time;
        tmin_total_acq_seq  = _tmin_total_acq_seq.fixedflag ?    ((void)(tmin_total-ir_time), tmin_total_acq_seq) : tmin_total-ir_time;
    }

    /* Used for cardiac intersequence time.  Round up to integer number of ms
     * but report to scan in us. */
    avmintseq = tmin_total;
    advroundup(&avmintseq);
    if ((exist(opcgate) == PSD_ON) && existcv(opcgate)) {
        advroundup(_tmin_total.fixedflag ? (_temp598_tmin_total=tmin_total,&_temp598_tmin_total) : &tmin_total); /* this is the min seq time cardiac
                                    can run at.
                                    Needed for adv. panel validity until all 
                                    cardiac buttons exist. */
        if (existcv(opcardseq)) {
            switch (exist(opcardseq)) {
            case PSD_CARD_INTER_MIN:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avmintseq), psd_tseq) : avmintseq;
                tmin_total  = _tmin_total.fixedflag ?  ((void)(avmintseq), tmin_total) : avmintseq;
                break;
            case PSD_CARD_INTER_OTHER:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(optseq), psd_tseq) : optseq;
                if (optseq > tmin_total)
                    tmin_total  = _tmin_total.fixedflag ?  ((void)(optseq), tmin_total) : optseq;
                break;
            case PSD_CARD_INTER_EVEN:
                /* Roundup tmin_total for the routines ahead. */
                advroundup(_tmin_total.fixedflag ? (_temp599_tmin_total=tmin_total,&_temp599_tmin_total) : &tmin_total);
                break;
            }
        }	else {
            psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avmintseq), psd_tseq) : avmintseq;
        }
    }

    /* RTG */
    avminrttseq = tmin_total;
    advroundup(&avminrttseq);

    if (((exist(oprtcgate) == PSD_ON) && existcv(oprtcgate)) ||
        (navtrig_flag == PSD_ON))
    {
        advroundup(_tmin_total.fixedflag ? (_temp600_tmin_total=tmin_total,&_temp600_tmin_total) : &tmin_total);

        if (existcv(oprtcardseq)) {
            switch (exist(oprtcardseq)) {
            case PSD_CARD_INTER_MIN:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avminrttseq), psd_tseq) : avminrttseq;
                tmin_total  = _tmin_total.fixedflag ?  ((void)(avminrttseq), tmin_total) : avminrttseq;
                break;
            case PSD_CARD_INTER_OTHER:
                psd_tseq  = _psd_tseq.fixedflag ?  ((void)(oprttseq), psd_tseq) : oprttseq;
                if (oprttseq > tmin_total) {
                    tmin_total  = _tmin_total.fixedflag ?  ((void)(oprttseq), tmin_total) : oprttseq;
                }
                break;
            case PSD_CARD_INTER_EVEN:
                /* Roundup tmin_total for the routines ahead. */
                advroundup(_tmin_total.fixedflag ? (_temp601_tmin_total=tmin_total,&_temp601_tmin_total) : &tmin_total);
                break;
            }
        }
        else {
            psd_tseq  = _psd_tseq.fixedflag ?  ((void)(avminrttseq), psd_tseq) : avminrttseq;
        }
    } /* end RTG */  

    if (maxphases(&av_temp_int, tmin_total, seq_type,
                  other_slice_limit) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxphases" );
        return FAILURE;
    }

    /* For epi_flair, avmaxslquant calculation will performed later. */
    /* For other cases, calculate avmaxlquant here. */
    if (epi_flair==PSD_OFF)
    {
        /* HCSDM00361682 */
        if (!((PSD_ON == aspir_flag) && (ASPIR_AUTO_TI_ADAPTIVE == aspir_auto_ti_model) && (PSD_ON == exist(opautoti))))
        {
            if(focus_eval_oscil)
            {
                acqs  = _acqs.fixedflag ?  ((void)(force_acqs), acqs) : force_acqs;
                avmaxslquant = force_avmaxslquant;
            }
            else if (maxslquant(&av_temp_int, avail_se_time, other_slice_limit,
                           seq_type, tmin_total) == FAILURE) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxslquant" );
                return FAILURE;
            }

            /*multiband max number of slices*/
            if (mux_flag)
            {
                avmaxslquant = ( (av_temp_int%2)?av_temp_int:(av_temp_int-1) ) * mux_slices_rf1;
                if (avmaxslquant > other_slice_limit)
                {
                    int temp_count = other_slice_limit/ mux_slices_rf1;
                    avmaxslquant = ( (temp_count%2)?temp_count:(temp_count-1) ) * mux_slices_rf1;
                }
            }
        }
    }

    /* Max slice per pass = 1 for sequential */
    if (exist(opirmode) == PSD_SEQMODE_ON)
        avmaxslquant = 1;
    else {
        if (opautotr == PSD_ON)
        {
            avmaxslquant = SLTAB_MAX;
        }
    } /* end if(opirmode) */

    /* find maximum number of passes allowed */  
    if ((PSD_OFF==epi_flair) && (PSD_OFF==t1flair_flag)) 
    {
        if (maxpass(_acqs.fixedflag ? (_temp602_acqs=acqs,&_temp602_acqs) : &acqs,seq_type,(int)exist(opslquant), avmaxslquant) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxpass" );
            return FAILURE;
        }

        /* Set minimum acqs for non t1flair IR cases */
        if ((PSD_ON == ir_prep_manual_tr_mode) && (acqs < (int)exist(opuser8)))
        {
            acqs  = _acqs.fixedflag ?  ((void)((int)exist(opuser8)), acqs) : (int)exist(opuser8);
            avmaxacqs = acqs;
        }
    }

    act_acqs  = _act_acqs.fixedflag ?  ((void)(acqs), act_acqs) : acqs;

    tmp_deadlast = _tmp_deadlast.fixedflag ? ((void)(0), tmp_deadlast) : 0;

    /* Calculate max slice quant, etc. based on flair params */
    if (epi_flair==PSD_ON) {

        /*  maxslices in one false_acqs  */
        /*  For flair account for the dead time in the IR portion of the scan */

        if((exist(opdiffuse)==PSD_OFF) && (tensor_flag == PSD_OFF))
        {
            tmin_flair = _tmin_flair.fixedflag ? ((void)(IMax(2,tmin,tmin_total/2)), tmin_flair) : IMax(2,tmin,tmin_total/2);
            if(tmin_total/2 < tmin) tmin_flair = _tmin_flair.fixedflag ? ((void)(tmin_total), tmin_flair) : tmin_total;
			
            /* SVBranch: GEHmr04247 */
            if(isSVSystem())
            {
                tmin_flair  = _tmin_flair.fixedflag ?  ((void)(tmin_total), tmin_flair) : tmin_total;
            }			
        }
        if((exist(opdiffuse)==PSD_ON) || (tensor_flag == PSD_ON))
        {
            tmin_flair = _tmin_flair.fixedflag ? ((void)(tmin_total), tmin_flair) : tmin_total;
        }

        maxslquant(_max_slice_ti.fixedflag ? (_temp603_max_slice_ti=max_slice_ti,&_temp603_max_slice_ti) : &max_slice_ti, avail_se_time, other_slice_limit,
                   seq_type, tmin_flair);

        /* ***************************************************************************
           force false_acqs = 2 for flair
           ****************************** */
        false_acqs  = _false_acqs.fixedflag ? ((void)(2), false_acqs) : 2;

        /* acqs = number false_acqs for opslquant    */
        maxpass(_acqs.fixedflag ? (_temp604_acqs=acqs,&_temp604_acqs) : &acqs,seq_type,(int)exist(opslquant), max_slice_ti);

        if((acqs % false_acqs) == 0)
            act_acqs  = _act_acqs.fixedflag ?  ((void)((int)((float)acqs/(float)false_acqs)), act_acqs) : (int)((float)acqs/(float)false_acqs);
        if((acqs % false_acqs) != 0) {
            act_acqs  = _act_acqs.fixedflag ?  ((void)((int)((float)acqs/(float)false_acqs)+1), act_acqs) : (int)((float)acqs/(float)false_acqs)+1;
        }

        acqs = _acqs.fixedflag ? ((void)(act_acqs), acqs) : act_acqs;

        /* number of slices in each false_acqs      */
        slicein1(_false_slquant1.fixedflag ? (_temp605_false_slquant1=false_slquant1,&_temp605_false_slquant1) : &false_slquant1, act_acqs*false_acqs, seq_type);

        avmaxacqs = act_acqs;
        avmaxslquant=max_slice_ti*false_acqs;

        if (rfov_flag)
        {
            avmaxslquant = IMin(2, avmaxslquant, rfov_maxnslices);
        }

        dda_packb  = _dda_packb.fixedflag ?  ((void)(false_acqs-1), dda_packb) : false_acqs-1;
        dda_pack   = _dda_pack.fixedflag ?  ((void)(false_acqs), dda_pack) : false_acqs;

        /*****************************************************************************************
          Fixed deadlast calculation. Use avail_se_time for calculation of 
          sequence times  for all but the last sequence. The dead time for the last sequence,
          deadlast, must be increased so the total sequence time adds up to the TR time  
          Time per sequence is avail_se_time/false_slquant1. 
          - MRIge42119  RJF/ JAP.
        ******************************************************************************************/
        deadlast  = _deadlast.fixedflag ?    
                                ((void)(RUP_GRD((act_tr/false_acqs)-(full_irtime+avail_se_time)+(avail_se_time/false_slquant1-tmin-time_ssi))), deadlast) : RUP_GRD((act_tr/false_acqs)-(full_irtime+avail_se_time)+(avail_se_time/false_slquant1-tmin-time_ssi));

#ifdef UNDEF
        /** Keeping the old calculation here, for future reference - RJF/JAP, MRIge42119 **/
        deadlast  = _deadlast.fixedflag ?    ((void)(RUP_GRD((act_tr/false_acqs)-(full_irtime+tmin_flair*false_slquant1))), deadlast) : RUP_GRD((act_tr/false_acqs)-(full_irtime+tmin_flair*false_slquant1));
#endif

        tmp_deadlast = _tmp_deadlast.fixedflag ? ((void)(deadlast), tmp_deadlast) : deadlast;
        /*  set at least 1s of dead time between false_acq  */
        if(deadlast < 100000)deadlast = _deadlast.fixedflag ? ((void)(100000), deadlast) : 100000;
        /* tmp_deadlast is to be added to scan time  */
        if(deadlast > tmp_deadlast)tmp_deadlast = _tmp_deadlast.fixedflag ? ((void)(deadlast-tmp_deadlast), tmp_deadlast) : deadlast-tmp_deadlast;
        else tmp_deadlast = _tmp_deadlast.fixedflag ? ((void)(0), tmp_deadlast) : 0;
    }

    /* t1flair_stir */
    dummyslices  = _dummyslices.fixedflag ?  ((void)(0), dummyslices) : 0;
    act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), act_edge_slice_enh_flag) : PSD_OFF;

    if ((PSD_ON == epi_flair) || (PSD_ON == irprep_flag)) /* irprep_support */
    {
        /* check slquant1 is non zero */
        if (0 == avmaxslquant)
        {
            epic_error(use_ermes, "TI is too short, increase TI.", EM_PSD_TI_OUT_OF_RANGE1, EE_ARGS(0));
            return FAILURE;
        }

        if (PSD_ON == epi_flair)
        {
            invseqtime  = _invseqtime.fixedflag ?    ((void)(RUP_GRD(full_irtime-time_ssi)), invseqtime) : RUP_GRD(full_irtime-time_ssi);
            invthick  = _invthick.fixedflag ?      ((void)((float)act_acqs*(opslthick+opslspace)), invthick) : (float)act_acqs*(opslthick+opslspace);
        } 
        else if (PSD_ON == irprep_flag)
        {
            invthick  = _invthick.fixedflag ?  ((void)(exist(opslthick)), invthick) : exist(opslthick);
        }
    }

    if (PSD_ON == t1flair_flag)
    {
        /* display auto TI in pitival2 */
        if (exist(opautoti) == PSD_OFF)
        {
            int keep_opti1;
            int keep_optifixedflag;
            int keep_optiexistflag;

            keep_opti1 = exist(opti);
            keep_optifixedflag = _opti.fixedflag;
            keep_optiexistflag = _opti.existflag;
            cvoverride(opautoti, PSD_ON, PSD_FIX_OFF, PSD_EXIST_ON);

            if (FAILURE == T1flair_analytical_seqtime())
            {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1),STRING_ARG,"T1flair_analytical_seqtime");
                return FAILURE;
            }

            pitival2 = exist(opti);
            cvoverride(opautoti, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
            cvoverride(opti, keep_opti1, keep_optifixedflag, keep_optiexistflag);
        }

        if (FAILURE == T1flair_analytical_seqtime())
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1),STRING_ARG,"T1flair_analytical_seqtime");
            return FAILURE;
        }

        /* display auto TI in pitival2 */
        if (opautoti == PSD_ON) pitival2 = exist(opti);

        if (existcv(optracq) && (exist(optracq) > 0))
        {
            act_acqs  = _act_acqs.fixedflag ?  ((void)(acqs), act_acqs) : acqs;
        }

        /* BJM - this needed here so false_slquant1 is */
        /* correct for gated scans... */
        if ((seq_type == TYPXRR) || (seq_type == TYPRTG) || (seq_type == TYPNCATRTG) || (seq_type == TYPCATRTG))
        {
            slquant1  = _slquant1.fixedflag ?           ((void)(opslquant/act_acqs+((opslquant%act_acqs)?1:0)), slquant1) : opslquant/act_acqs+((opslquant%act_acqs)?1:0);
        }
        else
        {
            slquant1  = _slquant1.fixedflag ?  ((void)(slquant_per_trig), slquant1) : slquant_per_trig;
        } 

    { /* Start of code inlined from Inversion_new.e InversionEval1 */

        /* t1flair_stir */
        if( t1flair_flag == PSD_ON )
        {
            ir_time   = _ir_time.fixedflag ?    ((void)(RUP_GRD(ir_grad_time+inner_spacing)), ir_time) : RUP_GRD(ir_grad_time+inner_spacing);
        }

    } /* End of code inlined from Inversion_new.e InversionEval1 */

    }
    else
    {
        /* Now calculate slquant_per_trig */
        slicein1(_slquant_per_trig.fixedflag ? (_temp606_slquant_per_trig=slquant_per_trig,&_temp606_slquant_per_trig) : &slquant_per_trig, act_acqs, seq_type);
        slquant1  = _slquant1.fixedflag ?           ((void)(opslquant/act_acqs+((opslquant%act_acqs)?1:0)), slquant1) : opslquant/act_acqs+((opslquant%act_acqs)?1:0);

        if (PSD_ON == ir_prep_manual_tr_mode)
        {
            float currentNullTI = getNullTI(exist(optr),
                                            INT_INPUT_NOT_USED,
                                            act_acqs * (exist(opslthick) + exist(opslspace)),
                                            exist(opslthick)/ gscale_rf1,
                                            invthick/ gscale_rf0);
            
            /* Display auto TI in pitival2 */
            pitival2 = currentNullTI;
            
            if (PSD_ON == exist(opautoti))
            {
                act_ti  = _act_ti.fixedflag ?  ((void)(currentNullTI), act_ti) : currentNullTI;
                cvoverride(opti, act_ti, PSD_FIX_ON, PSD_EXIST_ON);
            }       
        }
    }

    if ((PSD_ON == epi_flair) || (PSD_ON == irprep_flag))
    {
        ihti  = _ihti.fixedflag ?  ((void)(exist(opti)), ihti) : exist(opti);
    }

    /* BJM - this needed here so false_slquant1 is */
    /* correct for gated scans... */
    if ((seq_type == TYPXRR) || (seq_type == TYPRTG) || (seq_type == TYPNCATRTG) || (seq_type == TYPCATRTG))
        slquant1  = _slquant1.fixedflag ?           ((void)(opslquant/act_acqs+((opslquant%act_acqs)?1:0)), slquant1) : opslquant/act_acqs+((opslquant%act_acqs)?1:0);
    else
        slquant1  = _slquant1.fixedflag ?  ((void)(slquant_per_trig), slquant1) : slquant_per_trig;

    /* YMSmr06515: # of slice locations expansion */
    if ( (act_acqs > MAX_PASSES) && (existcv(opslquant)) )
    {
        epic_error(use_ermes,
                   "Maximum of %d acqs exceeded.  Increase locations/acq or decrease number of slices.",
                   EM_PSD_MAX_ACQS, 1, INT_ARG, MAX_PASSES);
        return FAILURE;
    }

    if ( (slquant1 > MAX_SLICES_PER_PASS) && (existcv(opslquant)) )
    {
        epic_error(use_ermes,
                   "The no. of locations/acquisition cannot exceed the max no. of per acq = %d.",
                   EM_PSD_LOC_PER_ACQS_EXCEEDED_MAX_SL_PER_ACQ, 1, INT_ARG, MAX_SLICES_PER_PASS);
        return FAILURE;
    }

    if (epi_flair == PSD_OFF) {
        false_slquant1  = _false_slquant1.fixedflag ?  ((void)(slquant1), false_slquant1) : slquant1;
        false_acqs  = _false_acqs.fixedflag ?  ((void)(1), false_acqs) : 1;
        dda_packb  = _dda_packb.fixedflag ?  ((void)(0), dda_packb) : 0;

        /***Changing dda_pack to 1, to have one disdaq for each slice.
            Note that this should be equal to the disdaq_shots used in the 
            host scantime calculation - RJF, MRIge42119 **/

        dda_pack   = _dda_pack.fixedflag ?  ((void)(1), dda_pack) : 1;
    }

    if ( (mph_flag==PSD_ON) && (acqmode == 1) ) /* sequential multiphase */
    {
        slquant_per_trig  = _slquant_per_trig.fixedflag ?  ((void)(1), slquant_per_trig) : 1;
        false_slquant1  = _false_slquant1.fixedflag ?  ((void)(1), false_slquant1) : 1;
    }

    if (slquant_per_trig == 0) {
        epic_error( use_ermes, "slquant_per_trig is 0", EM_PSD_SLQUANT_ZERO, EE_ARGS(0) );
        return FAILURE;
    }

    if (T1flair_options() == FAILURE)
    {
        return FAILURE;
    }

    /* ****************************
       Calculate extra sat time
       ************************** */
    SatCatRelaxtime(act_acqs,(act_tr/(mux_flag?mux_slquant:slquant1)),seq_type);

    /* Calculate inter-sequence delay time for 
       even spacing. */
    if ((exist(opcardseq) == PSD_CARD_INTER_EVEN) && existcv(opcardseq)) {
        psd_tseq  = _psd_tseq.fixedflag ?  ((void)(piait/slquant_per_trig), psd_tseq) : piait/slquant_per_trig;
        advrounddown(_psd_tseq.fixedflag ? (_temp607_psd_tseq=psd_tseq,&_temp607_psd_tseq) : &psd_tseq);
    }
    pitseq = avmintseq; /* Value scan displays in min inter-sequence
                           display button */

    /* RTG */
    if ((exist(oprtcardseq) == PSD_CARD_INTER_EVEN) && existcv(oprtcardseq)) {
        psd_tseq  = _psd_tseq.fixedflag ?  ((void)(pirtait/slquant_per_trig), psd_tseq) : pirtait/slquant_per_trig;
        advrounddown(_psd_tseq.fixedflag ? (_temp608_psd_tseq=psd_tseq,&_temp608_psd_tseq) : &psd_tseq);
    }

    /* Set optseq to inter-seq delay value for adv. panel routines. */
    _optseq.fixedflag = 0;
    optseq  = _optseq.fixedflag ?  ((void)(psd_tseq), optseq) : psd_tseq;
    /* Have existence of optseq follow opcardseq. */
    _optseq.existflag = _opcardseq.existflag;

    if (seqtime(_max_seqtime.fixedflag ? (_temp609_max_seqtime=max_seqtime,&_temp609_max_seqtime) : &max_seqtime, avail_image_time, mux_flag?mux_slquant:slquant_per_trig, seq_type) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "seqtime" );
        return FAILURE;
    }

    if (maxte1(&av_temp_int,max_seqtime, TYPNVEMP, non_tetime, 0) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "maxte1" );
        return FAILURE;
    }

    avround  = _avround.fixedflag ?  ((void)(1), avround) : 1;
    if (mintr(&av_temp_int, seq_type, tmin_total, mux_flag?mux_slquant:slquant_per_trig,
              gating) == FAILURE) 
    {
        /* for starter product, add error information for gradient safety model power supply peak power over limit */
        if(1000000000 == min_seqgrad && 5551 == cfgradamp)
        {
            epic_error(use_ermes, "", EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG,
                       "please decrease b-value ");
            return FAILURE;
        }
        else
        {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "mintr" );
        return FAILURE;
    }
    }

    /* hardcode min tr times based on ipg sequence update time measurements */
    if (fract_ky == PSD_FRACT_KY) {
        if ( (exist(opyres) <= 512) && (exist(opyres) > 128) && (avmintr <= 280000) )
            avmintr = 280000;
        if ( (exist(opyres) <= 128) && (exist(opyres) > 64) && (avmintr <= 120000) )
            avmintr = 120000;
        if ( (exist(opyres) <= 64) && (avmintr <= 60000) )
            avmintr = 60000;
    }
    if (fract_ky == PSD_FULL_KY) {
        if ( (exist(opyres) <= 512) && (exist(opyres) > 128) && (avmintr <= 600000) )
            avmintr = 600000;
        if ( (exist(opyres) <= 128) && (exist(opyres) > 64) && (avmintr <= 260000) )
            avmintr = 260000;
        if ( (exist(opyres) <= 64) && (avmintr <= 100000) )
            avmintr = 100000;
    }


    /* MRIge57853 (and HiB Diffusion): set lower limit for optr with flair	*/
    if(epi_flair==PSD_ON) {
        avmintr=FLAIR_MIN_TR;
    } else {
        avmintr = HIB_MIN_TR;
    }

    if( tmin_total > avmintr )
    {
        avmintr = tmin_total;
        advroundup(&avmintr);
    }
    
    /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */

    /* Auto TR mode is determined in T1flair_analytical_seqtime for t1flair */
    if (t1flair_flag == PSD_OFF)
    {
        automintr_compatibility_checks();
    }

    if ((exist(opflair) == PSD_ON) || ((PSD_ON == aspir_flag) && (PSD_ON == exist(opautoti))))
    {
        piautotrmode = PSD_AUTO_TR_MODE_MANUAL_TR;    /* disable autoTR for flair and ASPIR*/  
    }

    if (t1flair_flag == PSD_OFF)
    {
        if (automintr_set_display_acqs() == FAILURE)
        {
            return FAILURE;
        }

        /* HCSDM00398231 */
        if ( (existcv(optracq) && (exist(optracq) > 0)) && rfov_flag && (exist(optr) < FOCUS_ONE_ACQ_MIN_TR) && (sl_acq > DEFAULT_MAXNSLICES_RFOV))
        {
            save_avmintr  = _save_avmintr.fixedflag ?  ((void)(avmintr), save_avmintr) : avmintr;
            save_pitracqval4  = _save_pitracqval4.fixedflag ?  ((void)(pitracqval4), save_pitracqval4) : pitracqval4;
            avmintr = FOCUS_ONE_ACQ_MIN_TR;
            if (automintr_set_display_acqs() == FAILURE)
            {
                return FAILURE;
            }
            avmintr = save_avmintr;
            pitracqval4 = save_pitracqval4;
        }

        /* HCSDM00202538 */
        if (existcv(optracq) && (exist(optracq) > 0))
        {
            act_acqs  = _act_acqs.fixedflag ?  ((void)(acqs), act_acqs) : acqs;
            /* HCSDM00363791 */
            if(PSD_OFF == epi_flair)
            {
                slicein1(_slquant_per_trig.fixedflag ? (_temp610_slquant_per_trig=slquant_per_trig,&_temp610_slquant_per_trig) : &slquant_per_trig, act_acqs, seq_type);
                slquant1  = _slquant1.fixedflag ?  ((void)(slquant_per_trig), slquant1) : slquant_per_trig;
                false_slquant1  = _false_slquant1.fixedflag ?  ((void)(slquant_per_trig), false_slquant1) : slquant_per_trig;
                avail_se_time  = _avail_se_time.fixedflag ?  ((void)(avail_image_time), avail_se_time) : avail_image_time;
            }
        }
    }
    
    /* HCSDM00155514 */
    if (rfov_flag)
    {
        avmaxslquant = IMin(2, avmaxslquant, rfov_maxnslices);
    }

    if ( (mph_flag==PSD_ON) && (acqmode == 1) ) { /* sequential multiphase */
        acqs  = _acqs.fixedflag ?  ((void)(exist(opslquant)), acqs) : exist(opslquant);
        act_acqs = _act_acqs.fixedflag ? ((void)(acqs), act_acqs) : acqs;
        avmaxacqs = acqs;
        avmaxslquant = 1;
    }


    if (rtb0_flag == PSD_ON)
    {
        int tmp_kernel = 1;

        rtb0_dda  = _rtb0_dda.fixedflag ?  ((void)(1), rtb0_dda) : 1;

        /*B0 correction: turn on smoothing if polynomial filter is not used*/
        if ((cf_interpolation == 0) || (cf_interpolation == 4))
            rtb0_smooth_cf_flag = _rtb0_smooth_cf_flag.fixedflag ? ((void)(PSD_ON), rtb0_smooth_cf_flag) : PSD_ON;
        else
            rtb0_smooth_cf_flag = _rtb0_smooth_cf_flag.fixedflag ? ((void)(PSD_OFF), rtb0_smooth_cf_flag) : PSD_OFF;

        if (rtb0_smooth_cf_flag==PSD_ON)
        {
            /* Choose kernel size based on acqs (distance between data pts depends on acqs).
             * Also, make sure kernel size is odd. */
            tmp_kernel = (acqs%2 ==0)?(acqs*3-1):(acqs*3);
            if (tmp_kernel< _rtb0_smooth_kernel_size.maxval)
                rtb0_smooth_kernel_size  = _rtb0_smooth_kernel_size.fixedflag ?  ((void)(tmp_kernel), rtb0_smooth_kernel_size) : tmp_kernel;
            else
                rtb0_smooth_kernel_size  = _rtb0_smooth_kernel_size.fixedflag ?  ((void)(_rtb0_smooth_kernel_size.maxval), rtb0_smooth_kernel_size) : _rtb0_smooth_kernel_size.maxval;
        }

        if (rtb0_debug)
        {
            rtb0DebugFlag  = _rtb0DebugFlag.fixedflag ?  ((void)(PSD_ON), rtb0DebugFlag) : PSD_ON; /*turn on kspace saving also*/
        }

        /*For breast/prone, use standard spsp setting (ie d_cf = 50Hz), otherwise, use d_cf = 0Hz to reduce upper t-spine signal loss at the shoulder level*/
        if (existcv(oppos) && (exist(oppos) == 2))
        {
            rtb0_spsp_flag  = _rtb0_spsp_flag.fixedflag ?  ((void)(0), rtb0_spsp_flag) : 0;
        }
        else
        {
            rtb0_spsp_flag  = _rtb0_spsp_flag.fixedflag ?  ((void)(1), rtb0_spsp_flag) : 1;
        }

    	/*MF*/
    	if ((rtb0_coil_combine == 1) && (rtb0_phase_method == 1))
        {
            rtb0resultwaittime  = _rtb0resultwaittime.fixedflag ?  ((void)(1500), rtb0resultwaittime) : 1500;
        } 
        else 
        {
            rtb0resultwaittime  = _rtb0resultwaittime.fixedflag ?  ((void)(1000), rtb0resultwaittime) : 1000;
        }

        if (opdiffuse == PSD_ON)
            rtb0_acq_delay  = _rtb0_acq_delay.fixedflag ?  ((void)(2000), rtb0_acq_delay) : 2000; /*2ms*/
        else
            rtb0_acq_delay  = _rtb0_acq_delay.fixedflag ?  ((void)(0), rtb0_acq_delay) : 0;
    }
    else
    {
        rtb0_dda  = _rtb0_dda.fixedflag ?  ((void)(0), rtb0_dda) : 0;
        rtb0_spsp_flag  = _rtb0_spsp_flag.fixedflag ?  ((void)(0), rtb0_spsp_flag) : 0;
        rtb0_acq_delay  = _rtb0_acq_delay.fixedflag ?  ((void)(0), rtb0_acq_delay) : 0;
        rtb0DebugFlag  = _rtb0DebugFlag.fixedflag ?  ((void)(PSD_OFF), rtb0DebugFlag) : PSD_OFF;
    }

   
    /* t1flair_stir */
    T1flairPredownload();
    avround  = _avround.fixedflag ?  ((void)(1), avround) : 1;

    /* need a more elaborate algorithm here for disdaq determination */
    if ((intleaves != 1) || (PSD_ON == epi_flair) || (PSD_ON == opdiffuse) || (PSD_ON == tensor_flag))
        dda  = _dda.fixedflag ?  ((void)(1), dda) : 1;
    else
        dda  = _dda.fixedflag ?  ((void)(0), dda) : 0;
    
    /* t1flair_stir */
    if (PSD_ON == t1flair_flag)
    {
        dda  = _dda.fixedflag ?  ((void)(dda_t1flair), dda) : dda+dda_t1flair;
    }

    ref_dda  = _ref_dda.fixedflag ?  ((void)(dda), ref_dda) : dda;

    /* Refless EPI: keep dda with DW-EPI Flair and acqs > 1 */
    if ((ref_in_scan_flag == PSD_ON) && !((epi_flair == PSD_ON) && (act_acqs > 1)))
    {
        scan_dda  = _scan_dda.fixedflag ?    ((void)(dda-1), scan_dda) : dda-1;
    }
    else
    {
        scan_dda  = _scan_dda.fixedflag ?  ((void)(dda), scan_dda) : dda;
    }

    /*KVA 91_merge */
    /*multiband and MUSE support single acq only*/
     if ( PSD_ON == tensor_flag || PSD_ON == mux_flag || PSD_ON == muse_flag ) {
        acqs  = _acqs.fixedflag ?  ((void)(1), acqs) : 1;
        act_acqs  = _act_acqs.fixedflag ?  ((void)(1), act_acqs) : 1;
        avmaxacqs = 1;
    }

    /* HCSDM00393185: overwrite seq_type */
    if (act_acqs > 1)
    {
        if ((PSD_ON == exist(oprtcgate)) || (PSD_ON == navtrig_flag))
        {
            seq_type  = _seq_type.fixedflag ?  ((void)(TYPNCATRTG), seq_type) : TYPNCATRTG;
        }
        else if ((PSD_OFF == exist(opcgate)) && !rfov_flag)
        {
            seq_type  = _seq_type.fixedflag ?  ((void)(TYPNCATFLAIR), seq_type) : TYPNCATFLAIR;
        }
    }

    /* MRIhc05228 */
    if ( PSD_OFF == epi_flair ) {
        dda_pack  = _dda_pack.fixedflag ?  ((void)(dda), dda_pack) : dda;
    }

    /* Looping structure in rsp:

    pass_reps
    ---------
    |
    | pass
    | --------
    | |  baseline           |
    | |  ---------          |
    | |  | reps             |
    | |  | ------           | baseline time (first pass only)
    | |  | | slices         |
    | |  | --------         |
    | |  |--------
    | |
    | |  disdaqs:           |
    | |  ileaves            |
    | |  ----------         | disdaq_shots
    | |  | slices           |
    | |  | ----------       |
    | |
    | |  core_reps          |
    | |  -----------        |
    | |  |                  |
    | |  | ileaves          |
    | |  | ----------       |
    | |  | |                |
    | |  | | nex            |
    | |  | | ----------     | core_shots
    | |  | | |              |
    | |  | | | slices       |
    | |  | | | ---------    |
    | |  | | ----------     |
    | |  | ---------        |
    | |  ----------         |
    | |
    | | pass packet
    | --------
    |
    |--------
    burst mode (not supported in MGD)

    */

    passr_shots  = _passr_shots.fixedflag ?  ((void)(pass_reps), passr_shots) : pass_reps;
    pass_shots  = _pass_shots.fixedflag ?  ((void)(act_acqs), pass_shots) : act_acqs;
    disdaq_shots  = _disdaq_shots.fixedflag ?  ((void)(scan_dda), disdaq_shots) : scan_dda;
    core_shots  = _core_shots.fixedflag ?  ((void)(intleaves), core_shots) : intleaves; /* core_reps */

    /* ******************************************************************
       scan time has to be corrected for lack of disdaqs for diffuse
       data when flair is on. Given disdaqs for T2 images only
       ****************************************************************** */
    if(epi_flair==PSD_ON)
    {
        dda_fact = _dda_fact.fixedflag ? ((void)(0.5), dda_fact) : 0.5;
    } else {
        dda_fact = _dda_fact.fixedflag ? ((void)(1.0), dda_fact) : 1.0; 
    }

    /* Add more time for the last TR of the baseline scan to fix MRIge29749. */
    if(vrgfsamp == PSD_ON && opyres >= 256) bl_acq_tr2  = _bl_acq_tr2.fixedflag ?  ((void)(1000000), bl_acq_tr2) : 1000000;

    if (baseline > 0)
        bline_time  = _bline_time.fixedflag ?    ((void)((baseline-1)*bl_acq_tr1+bl_acq_tr2), bline_time) : (baseline-1)*bl_acq_tr1+bl_acq_tr2;
    else
        bline_time  = _bline_time.fixedflag ?  ((void)(0), bline_time) : 0;

    pass_time  = _pass_time.fixedflag ?  ((void)(pass_delay*num_passdelay), pass_time) : pass_delay*num_passdelay;


    /* DCZ: For MRIge57701, add bline_time to the clock */
    /* ALP MRIge67616  Disdaqs should only be included once for diffusion
       because they are played only for the T2 images acquisition */
    /*MRIhc09116 - no pass_delay after last acquisition */
    if ( exist(opdiffuse) == PSD_OFF ) {
        if (exist(opcgate) == PSD_ON) {
            scan_time   = _scan_time.fixedflag ?      
                  
                       
                       ((void)(bline_time*pass_shots+(float)passr_shots*(float)pass_shots*((float)(act_tr)*((float)(disdaq_shots*dda_fact*(1.0/(float)passr_shots))+nex*(float)core_shots*reps)+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time), scan_time) : bline_time*pass_shots+(float)passr_shots*(float)pass_shots*((float)(act_tr)*((float)(disdaq_shots*dda_fact*(1.0/(float)passr_shots))+nex*(float)core_shots*reps)+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time;
        } else {
            scan_time   = _scan_time.fixedflag ?      
                  
                       
                     ((void)(bline_time*pass_shots+(float)passr_shots*(float)pass_shots*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*((float)(disdaq_shots*dda_fact*(1.0/(float)passr_shots))+nex*(float)core_shots*reps)+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time), scan_time) : bline_time*pass_shots+(float)passr_shots*(float)pass_shots*((float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*((float)(disdaq_shots*dda_fact*(1.0/(float)passr_shots))+nex*(float)core_shots*reps)+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time;
        }
        nreps  = _nreps.fixedflag ?      ((void)(act_acqs*(scan_dda+pass_reps*(nex+dex)*intleaves*reps)), nreps) : act_acqs*(scan_dda+pass_reps*(nex+dex)*intleaves*reps);

    } else {
        if(tensor_flag == 0)
        {
            /* Refless EPI: in ref-in-scan mode, there is an additional ref scan before the T2 scan, which always uses 1 NEX */
            float sum_difnextab = (ref_in_scan_flag ? 1:0) + (rpg_in_scan_flag ? rpg_in_scan_num:0) + opdifnext2;

            int bval_counter;
            for (bval_counter = 0; bval_counter<opnumbvals ; bval_counter++)
            {
                sum_difnextab += difnextab[bval_counter]*num_dif;
            }
            if ((exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON) || (navtrig_flag == PSD_ON)) {
                scan_time   = _scan_time.fixedflag ?     
                     
                     
                                         ((void)(bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr)*(float)pass_shots+(float)pass_shots*(float)(act_tr)*sum_difnextab*(float)core_shots*reps+(float)passr_shots*((float)ccs_relaxtime+(float)pass_time)-(float)pass_time), scan_time) : bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr)*(float)pass_shots+(float)pass_shots*(float)(act_tr)*sum_difnextab*(float)core_shots*reps+(float)passr_shots*((float)ccs_relaxtime+(float)pass_time)-(float)pass_time;
            } else {
                if (t1flair_flag) {
                    t1flair_disdaq_time  = _t1flair_disdaq_time.fixedflag ?  ((void)((float)(dda_t1flair*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots), t1flair_disdaq_time) : (float)(dda_t1flair*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots;
                } else {
                    t1flair_disdaq_time  = _t1flair_disdaq_time.fixedflag ?  ((void)(0), t1flair_disdaq_time) : 0;
                }
                scan_time   = _scan_time.fixedflag ?     
                     
                     
                                              
                                         ((void)(bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots+(float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*sum_difnextab*(float)core_shots*reps+(float)passr_shots*((float)ccs_relaxtime+(float)pass_time)-(float)pass_time-(float)t1flair_disdaq_time), scan_time) : bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots+(float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*sum_difnextab*(float)core_shots*reps+(float)passr_shots*((float)ccs_relaxtime+(float)pass_time)-(float)pass_time-(float)t1flair_disdaq_time;
            }
            nreps  = _nreps.fixedflag ?    ((void)(act_acqs*(scan_dda+sum_difnextab*intleaves*reps)), nreps) : act_acqs*(scan_dda+sum_difnextab*intleaves*reps);
        }
        else
        {
            if ((exist(opcgate) == PSD_ON) || (exist(oprtcgate) == PSD_ON) || (navtrig_flag == PSD_ON)) {
                scan_time   = _scan_time.fixedflag ?     
                     
                     
                                          
                                             ((void)(bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr)*(float)pass_shots+(float)passr_shots*((float)pass_shots*(float)(act_tr)*nex*(float)core_shots*reps+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time), scan_time) : bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr)*(float)pass_shots+(float)passr_shots*((float)pass_shots*(float)(act_tr)*nex*(float)core_shots*reps+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time;

                if (ref_in_scan_flag == PSD_ON)
                {
                    /* Refless EPI: first pass is ref with 1 NEX */
                    scan_time  = _scan_time.fixedflag ?  ((void)(((float)pass_shots*(float)(act_tr)*(nex-1)*(float)core_shots*reps)), scan_time) : scan_time-((float)pass_shots*(float)(act_tr)*(nex-1)*(float)core_shots*reps);
                }
                if (rpg_in_scan_flag == PSD_ON)
                {
                    /* Reverse pass is with 1 NEX */
                    scan_time  = _scan_time.fixedflag ?  ((void)(((float)rpg_in_scan_num*(float)pass_shots*(float)(act_tr)*(nex-1)*(float)core_shots*reps)), scan_time) : scan_time-((float)rpg_in_scan_num*(float)pass_shots*(float)(act_tr)*(nex-1)*(float)core_shots*reps);
                }
            } else {
                scan_time   = _scan_time.fixedflag ?     
                     
                     
                                          
                                             ((void)(bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots+(float)passr_shots*((float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*nex*(float)core_shots*reps+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time), scan_time) : bline_time*pass_shots+(float)(disdaq_shots*dda_fact)*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(float)pass_shots+(float)passr_shots*((float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*nex*(float)core_shots*reps+(float)ccs_relaxtime+(float)pass_time)-(float)pass_time;

                if (ref_in_scan_flag == PSD_ON)
                {
                    /* Refless EPI: first pass is ref with 1 NEX */
                    scan_time  = _scan_time.fixedflag ?  ((void)(((float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(nex-1)*(float)core_shots*reps)), scan_time) : scan_time-((float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(nex-1)*(float)core_shots*reps);
                }
                if (rpg_in_scan_flag == PSD_ON)
                {
                    /* Reverse pass is with 1 NEX */
                    scan_time  = _scan_time.fixedflag ?  ((void)(((float)rpg_in_scan_num*(float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(nex-1)*(float)core_shots*reps)), scan_time) : scan_time-((float)rpg_in_scan_num*(float)pass_shots*(float)(act_tr+((TRIG_LINE==gating)?TR_SLOP:0)+tmp_deadlast*2)*(nex-1)*(float)core_shots*reps);
                }
            }
            nreps  = _nreps.fixedflag ?      ((void)(act_acqs*(scan_dda+pass_reps*(nex+dex)*intleaves*reps)), nreps) : act_acqs*(scan_dda+pass_reps*(nex+dex)*intleaves*reps);
        }

        /* Refless EPI: IR is not played out in REF loop with DW-EPI Flair and acqs > 1 */
        if ((ref_in_scan_flag == PSD_ON) && (epi_flair == PSD_ON) && (act_acqs > 1))
        {
            scan_time  = _scan_time.fixedflag ?      ((void)(invseqtime*act_acqs*false_acqs), scan_time) : scan_time-invseqtime*act_acqs*false_acqs;
        }
    }

    avmintscan  = _avmintscan.fixedflag ?  ((void)(scan_time), avmintscan) : scan_time;

    pitscan  = _pitscan.fixedflag ?  ((void)(avmintscan), pitscan) : avmintscan; /* This value shown in clock */
    pisctim1 = pitscan; 

    /* APx activation */
    if(PSD_ON == apx_status)
    {
        float temp_tscan = pitscan;
        int anatomy_apx_bh_enable = PSD_OFF;

#ifndef SIM
        anatomy_apx_bh_enable = isApplicationAllowedForAnatomy(opanatomy, ATTRIBUTE_APX_BH);
#else
        anatomy_apx_bh_enable = PSD_ON;
#endif

        if(PSD_ON == exist(opmph))
        {
            temp_tscan = (temp_tscan - passtime)/ (float)exist(opfphases);
        }

        if( (1 == exist(opnumgroups)) && (0 != exist(opcoax)) &&
            (PSD_OFF == exist(oprtcgate)) && (PSD_OFF == exist(opnav)) && (PSD_OFF == exist(opcgate)) &&
            (PSD_OFF == epi_flair) && (PSD_OFF == tensor_flag) &&
            (PSD_ON == anatomy_apx_bh_enable) &&
            (APX_T_MIN_BH < temp_tscan + 500000) && (temp_tscan - 500000 < APX_T_MAX_BH) )
        {
            piapx = PSD_ON;
        }
        else
        {
            piapx = PSD_OFF;
        }

        /* APx preference window setting */
        piapxprfstepnub = 2;
        piapxprfres = PSD_ON;
        piapxprfacc = PSD_OFF; /* don't support auto acceleration in DWI */
    }
    else
    {
        piapx = PSD_OFF;

        piapxprfstepnub = 0;
        piapxprfres = PSD_OFF;
        piapxprfacc = PSD_OFF;
    }

    nreps  = _nreps.fixedflag ?            ((void)(((rawdata==PSD_ON&&rhref==1)?2:1)), nreps) : nreps*((rawdata==PSD_ON&&rhref==1)?2:1);

    /* set effective Ky samp freq in KHz */
    if (esp > 0) {
        if ((fract_ky == PSD_FULL_KY) && (ky_dir==PSD_CENTER_OUT)) {
            frqy  = _frqy.fixedflag ?  ((void)(1000.0*(float)(intleaves/2)/(float)esp), frqy) : 1000.0*(float)(intleaves/2)/(float)esp;
            eesp  = _eesp.fixedflag ?  ((void)(rint((float)esp/(float)(intleaves/2))), eesp) : rint((float)esp/(float)(intleaves/2));
        } else {
            frqy  = _frqy.fixedflag ?  ((void)(1000.0*(float)(intleaves)/(float)esp), frqy) : 1000.0*(float)(intleaves)/(float)esp;
            eesp  = _eesp.fixedflag ?  ((void)(rint((float)esp/(float)intleaves)), eesp) : rint((float)esp/(float)intleaves);
        }
    } else {
        frqy  = _frqy.fixedflag ?  ((void)(0), frqy) : 0;
        eesp  = _eesp.fixedflag ?  ((void)(0), eesp) : 0;
    }

    frqx  = _frqx.fixedflag ?  ((void)(1000.0/tsp), frqx) : 1000.0/tsp;

    return SUCCESS;
}   /* end cveval1() */

STATUS ssEval1(void) 
{
    float fieldStrength = (float)cffield;

    if (ss_rf1 == PSD_ON)  /* rfpulse selection for spsp */
    {
        fat_delta  = _fat_delta.fixedflag ?    ((void)(-230.0*(fieldStrength/B0_15000)), fat_delta) : -230.0*(fieldStrength/B0_15000);  /*YH*/
        /* allow for manual selection of spsp pulse through ss_override cv */
        fat_offset  = _fat_offset.fixedflag ?  ((void)((int)(fat_delta/(float)TARDIS_FREQ_RES)), fat_offset) : (int)(fat_delta/(float)TARDIS_FREQ_RES);
        a_rf1  = _a_rf1.fixedflag ?  ((void)(1.0), a_rf1) : 1.0;
        pw_gzrf1  = _pw_gzrf1.fixedflag ?  ((void)(pw_rf1), pw_gzrf1) : pw_rf1;
#if defined(IPG_TGT) || defined(MGD_TGT)
        pw_gzrf1d  = _pw_gzrf1d.fixedflag ?  ((void)(0), pw_gzrf1d) : 0;
        pw_gzrf1a  = _pw_gzrf1a.fixedflag ?  ((void)(0), pw_gzrf1a) : 0;
#endif
        res_gzrf1  = _res_gzrf1.fixedflag ?  ((void)(res_rf1), res_gzrf1) : res_rf1;
        pw_thetarf1  = _pw_thetarf1.fixedflag ?  ((void)(pw_gzrf1), pw_thetarf1) : pw_gzrf1;
        res_thetarf1  = _res_thetarf1.fixedflag ?  ((void)(res_rf1), res_thetarf1) : res_rf1;
        rftype  = _rftype.fixedflag ?  ((void)(PLAY_RFFILE), rftype) : PLAY_RFFILE;
        gztype  = _gztype.fixedflag ?  ((void)(PLAY_GFILE), gztype) : PLAY_GFILE;
        thetatype  = _thetatype.fixedflag ?  ((void)(PLAY_THETA), thetatype) : PLAY_THETA;
        bw_rf1  = _bw_rf1.fixedflag ?  ((void)(rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1), bw_rf1) : rfpulse[RF1_SLOT].nom_bw*rfpulse[RF1_SLOT].nom_pw/pw_rf1;
        flip_rf1  = _flip_rf1.fixedflag ?  ((void)(exist(opflip)), flip_rf1) : exist(opflip);

        /* prevent SPSP 90 degree pulse from violation of RF power limit */
        /* only for 450W, 450, and 750 now*/
        /* need to test for other platforms */

        /* limit to DV platform */
        /* Opened it up for HDx for 160Kg Fix */
        if (ss_fa_scaling_flag)
        {
            float fa_scaling_factor;
            fa_scaling_factor = get_fa_scaling_factor_ss(_max_ss_fa.fixedflag ? (_temp611_max_ss_fa=max_ss_fa,&_temp611_max_ss_fa) : &max_ss_fa, flip_rf1, rfpulse[RF1_SLOT].nom_fa, rfpulse[RF1_SLOT].max_b1);
            flip_rf1  = _flip_rf1.fixedflag ?  ((void)(floor(flip_rf1*fa_scaling_factor)), flip_rf1) : floor(flip_rf1*fa_scaling_factor);

            if (ss_fa_scale_debug == PSD_ON)
            {
                FILE *fp;
                fp = fopen("/usr/g/service/log/fa_scale","ab");
                if (fp!=NULL)
                {
                    fprintf(fp,"\n *********** SPSP FA scaling ********************");
                    fprintf(fp,"\n fa_scaling_factor  = %f", fa_scaling_factor);
                    fprintf(fp,"\n New FA             = %f", flip_rf1);
                    fprintf(fp,"\n Initial FA         = %f", (flip_rf1/fa_scaling_factor));
                    fclose(fp);
                }
            }
        }

        if (PSD_ON == oprealtime)
        {
            if (ampslice(_a_gzrf1.fixedflag ? (_temp612_a_gzrf1=a_gzrf1,&_temp612_a_gzrf1) : &a_gzrf1, bw_rf1, (PSD_3D == (exist(opimode))?exist(opvthick):ss_psd_slthick),
                         gscale_rf1, TYPDEF) == FAILURE)
            {
                epic_error(use_ermes, "%s failure for gzrf1",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "ampslice");
                return FAILURE;
            }
        }
        else
        {
            if (ampslice(_a_gzrf1.fixedflag ? (_temp613_a_gzrf1=a_gzrf1,&_temp613_a_gzrf1) : &a_gzrf1, bw_rf1, (PSD_3D == (exist(opimode))?exist(opvthick):exist(opslthick)),
                         gscale_rf1, TYPDEF) == FAILURE)
            {
                epic_error(use_ermes, "%s failure for gzrf1",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "ampslice");
                return FAILURE;
            }
        }

        pw_constant  = _pw_constant.fixedflag ?      ((void)(pw_gzrf1lobe-2*pw_ss_rampz), pw_constant) : pw_gzrf1lobe-2*pw_ss_rampz;
        area_gz1  = _area_gz1.fixedflag ?       ((void)(((float)pw_constant+(float)pw_ss_rampz+(float)off90minor)*a_gzrf1/2), area_gz1) : ((float)pw_constant+(float)pw_ss_rampz+(float)off90minor)*a_gzrf1/2;
        a_thetarf1  = _a_thetarf1.fixedflag ?  ((void)(a_gzrf1), a_thetarf1) : a_gzrf1;


        /* Do not do this for Y. Zur's pulses (NDG) */        
        if (!((cffield == B0_30000) || (whichss == 1544022) || (whichss == 1534433) || (whichss == 15496248))) {
            if ( (oppseq == PSD_SE) && (num_rf1lobe % 2 == 1) )
                area_gz1  = _area_gz1.fixedflag ?   ((void)(-(area_gz1)), area_gz1) : -(area_gz1);
        }

        if (zgmn_type == CALC_GMN1) {
            float zerommt, firstmmt;
            gz1_zero_moment  = _gz1_zero_moment.fixedflag ?  ((void)(0.0), gz1_zero_moment) : 0.0;
            gz1_first_moment  = _gz1_first_moment.fixedflag ?  ((void)(0.0), gz1_first_moment) : 0.0;
            pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;
            invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
            rampmoments(0.0, a_gzrf1, pw_ss_rampz, invertphase, _pulsepos.fixedflag ? (_temp614_pulsepos=pulsepos,&_temp614_pulsepos) : &pulsepos,
                        &zerommt, &firstmmt, _gz1_zero_moment.fixedflag ? (_temp615_gz1_zero_moment=gz1_zero_moment,&_temp615_gz1_zero_moment) : &gz1_zero_moment, _gz1_first_moment.fixedflag ? (_temp616_gz1_first_moment=gz1_first_moment,&_temp616_gz1_first_moment) : &gz1_first_moment);
            rampmoments(a_gzrf1, a_gzrf1, pw_constant/2, invertphase, _pulsepos.fixedflag ? (_temp617_pulsepos=pulsepos,&_temp617_pulsepos) : &pulsepos,
                        &zerommt, &firstmmt, _gz1_zero_moment.fixedflag ? (_temp618_gz1_zero_moment=gz1_zero_moment,&_temp618_gz1_zero_moment) : &gz1_zero_moment, _gz1_first_moment.fixedflag ? (_temp619_gz1_first_moment=gz1_first_moment,&_temp619_gz1_first_moment) : &gz1_first_moment);
            pos_moment_start  = _pos_moment_start.fixedflag ?        ((void)(pos_start+t_exa+(num_rf1lobe/2)*pw_gzrf1lobe-pw_constant/2), pos_moment_start) : pos_start+t_exa+(num_rf1lobe/2)*pw_gzrf1lobe-pw_constant/2;
        }

    }

    return (SUCCESS);

} /* ssEval1 */

STATUS ssEval2(void) 
{
    /* SVBranch: HCSDM00193936: 
       below variables are moved to ssCheck():
       float ss_minslthk1_rup;
       float max_optloc;
       float a_gzrf1_ss_max;*/      
                            
    float dbdt_slthk;    /* MRIge64190 */
    float sr_slthk;

    if( (isValueSystem()) ||
        (0 != breast_spsp_flag) )
    { 
        ss_convolution_flag  = _ss_convolution_flag.fixedflag ?  ((void)(PSD_ON), ss_convolution_flag) : PSD_ON;
    }
    else
    {
        ss_convolution_flag  = _ss_convolution_flag.fixedflag ?  ((void)(PSD_OFF), ss_convolution_flag) : PSD_OFF;
    }

    /* Do not do this for Y. Zur's pulses (NDG) */
    if (!((cffield == B0_30000) || (whichss == 1544022) || (whichss == 1534433) || (whichss == 15496248))) {
        if ( (oppseq != PSD_SE) && (num_rf1lobe % 2 == 1) )
            a_gz1  = _a_gz1.fixedflag ?   ((void)(-(a_gz1)), a_gz1) : -(a_gz1);
    }
    
    if (ss_rf1 == 0) {
        gradz[GZRF1_SLOT].ptype = G_TRAP;

        gradz[GZRF1_SLOT].attack = _pw_gzrf1a.fixedflag ? (_temp620_pw_gzrf1a=pw_gzrf1a,&_temp620_pw_gzrf1a) : &pw_gzrf1a;
        gradz[GZRF1_SLOT].decay = _pw_gzrf1d.fixedflag ? (_temp621_pw_gzrf1d=pw_gzrf1d,&_temp621_pw_gzrf1d) : &pw_gzrf1d;
        gradz[GZRF1_SLOT].pw = _pw_gzrf1.fixedflag ? (_temp622_pw_gzrf1=pw_gzrf1,&_temp622_pw_gzrf1) : &pw_gzrf1;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = 1;

    } else {
        gradz[GZRF1_SLOT].ptype = G_USER;

        gradz[GZRF1_SLOT].attack = _pw_ss_rampz.fixedflag ? (_temp623_pw_ss_rampz=pw_ss_rampz,&_temp623_pw_ss_rampz) : &pw_ss_rampz;
        gradz[GZRF1_SLOT].decay = _pw_ss_rampz.fixedflag ? (_temp624_pw_ss_rampz=pw_ss_rampz,&_temp624_pw_ss_rampz) : &pw_ss_rampz;
        gradz[GZRF1_SLOT].pw = _pw_constant.fixedflag ? (_temp625_pw_constant=pw_constant,&_temp625_pw_constant) : &pw_constant;
        gradz[GZRF1_SLOT].scale = 1.0;
        gradz[GZRF1_SLOT].num = num_rf1lobe;

        {
            float slope;
            double tmppower;
            double gcmfs2amps2;  /* frequently used (Gauss/cm)^2 to Amperes^2
                                    scale factor */
            double gcmfs2amps;   /* frequently used (Gauss/cm) to Amperes
                                    scale factor */

            /* [Amperes/Gauss/cm]^2 */
            gcmfs2amps2 = pow((double)loggrd.zipeak/(double)loggrd.zfs,2.0);
            /* [Amperes/Gauss/cm] */
            gcmfs2amps = (double)loggrd.zipeak/(double)loggrd.zfs;

            /* attack ****************************************************/
            slope = *gradz[GZRF1_SLOT].amp/ *gradz[GZRF1_SLOT].attack;
            tmppower = gcmfs2amps2 * pow((double)slope, 2.0) *
                pow((double)*gradz[GZRF1_SLOT].attack, 3.0)/ 3.0;

            gradz[GZRF1_SLOT].power = tmppower;

            /* Since the spectral spatial gradient waveform is bipolar, split
               power between the positive and negative power summations */
            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos = tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg = tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg = tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos = tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs = fabs(gcmfs2amps * (double)slope *
                                            pow((double)*gradz[GZRF1_SLOT].attack,
                                                2.0)/ 2.0);

            gradz[GZRF1_SLOT].amptran = fabs(*gradz[GZRF1_SLOT].amp) *
                loggrd.zipeak/ loggrd.zfs;

            gradz[GZRF1_SLOT].pwm = *gradz[GZRF1_SLOT].attack;

            /* constant *************************************************/
            tmppower = (*gradz[GZRF1_SLOT].pw) *
                pow((double)*gradz[GZRF1_SLOT].amp, 2.0) * gcmfs2amps2;  

            gradz[GZRF1_SLOT].power += tmppower;

            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg += tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos += tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs += fabs(gcmfs2amps *
                                             (double)(*gradz[GZRF1_SLOT].pw) *
                                             (double)(*gradz[GZRF1_SLOT].amp));

            /* decay ***************************************************/

            slope = - *gradz[GZRF1_SLOT].amp/ *gradz[GZRF1_SLOT].decay;
            tmppower = gcmfs2amps2 * pow((double)slope, 2.0) *
                pow((double)*gradz[GZRF1_SLOT].decay, 3.0)/ 3.0;

            gradz[GZRF1_SLOT].power += tmppower;

            if (*gradz[GZRF1_SLOT].amp >= 0) {
                gradz[GZRF1_SLOT].powpos += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powneg += tmppower/2.0;
            } else {
                gradz[GZRF1_SLOT].powneg += tmppower*
                    (float)((num_rf1lobe+1)/2)/(float)(num_rf1lobe);
                gradz[GZRF1_SLOT].powpos += tmppower/2.0;
            }

            gradz[GZRF1_SLOT].powabs += fabs(gcmfs2amps * (double)slope *
                                             pow((double)*gradz[GZRF1_SLOT].decay,
                                                 2.0)/ 2.0);

            gradz[GZRF1_SLOT].amptran += fabs(*gradz[GZRF1_SLOT].amp) *
                loggrd.zipeak/ loggrd.zfs;

            gradz[GZRF1_SLOT].pwm += *gradz[GZRF1_SLOT].decay;

        }
        /* "Normalize" parameters for G_USER pulse */
        gradz[GZRF1_SLOT].power *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                        pow((double)*gradz[GZRF1_SLOT].amp,2.0));
        gradz[GZRF1_SLOT].powpos *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                         pow((double)*gradz[GZRF1_SLOT].amp,2.0));
        gradz[GZRF1_SLOT].powneg *= 1.0/((float)(*gradz[GZRF1_SLOT].pw) *
                                         pow((double)*gradz[GZRF1_SLOT].amp,2.0));

        /* BJM: move this here to catch minslice thickness with SpSP */
        /* Note: this makes ssCheck and empty function! */
        /* min slice thickness for ss rf pulses (mm) */
        ss_min_slthk  = _ss_min_slthk.fixedflag ?       ((void)(nbw_ssrf/(loggrd.zfs*(0.1)*GAM)), ss_min_slthk) : nbw_ssrf/(loggrd.zfs*(0.1)*GAM);
        a_gzrf1_ss_max  = _a_gzrf1_ss_max.fixedflag ?  ((void)(loggrd.zfs), a_gzrf1_ss_max) : loggrd.zfs;

        /* MRIge91352 - SAR/dbdt changes for E3 */  

        /* MRIge64190: make sure it adheres to dBdt limits */

        if(cfdbdtper > 0)
        {
            if(ss_convolution_flag)   /* Using Convolution Model to calculate PNS */
            {
                float max_pns, p_pns, tmp_dx;
                int tmp_k, tmp_j;
                float acon[200], tcon[200];
                int tmp_esp;

                /* calculate waveform*/

                tmp_esp=pw_rf1/num_rf1lobe;  /* width of each lobe*/
                tmp_dx=FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);  /* maximal effective distence */

                /* the unit of tcon: s;  the unit of acon: T/m */ 
                for(tmp_j=0;tmp_j<num_rf1lobe;tmp_j++)
                {
                    tcon[tmp_j*3]=(float)(tmp_esp*tmp_j*0.000001);
                    tcon[tmp_j*3+1]=(float)(tmp_esp*tmp_j+pw_ss_rampz)*0.000001;
                    tcon[tmp_j*3+2]=(float)(tmp_esp*(tmp_j+1)-pw_ss_rampz)*0.000001;
                    if( (tmp_j%2) ==1)
                    {
                        acon[tmp_j*3]=0.0;
                        acon[tmp_j*3+1]=a_gzrf1_ss_max*tmp_dx*0.0001;
                        acon[tmp_j*3+2]=a_gzrf1_ss_max*tmp_dx*0.0001;
                    }
                    else
                    {
                        acon[tmp_j*3]=0.0;
                        acon[tmp_j*3+1]=0.0-a_gzrf1_ss_max*tmp_dx*0.0001;
                        acon[tmp_j*3+2]=0.0-a_gzrf1_ss_max*tmp_dx*0.0001;
                    }
                }

                /* calculate PNS with Convolution Model*/
                max_pns=0.0;
                for(tmp_k=1;tmp_k<num_rf1lobe*3;tmp_k++)
                {
                    p_pns=0.0;
                    for(tmp_j=0;tmp_j<tmp_k;tmp_j++)
                    {
                        p_pns=p_pns+(acon[tmp_j+1]-acon[tmp_j])/(tcon[tmp_j+1]-tcon[tmp_j])* 
                                     ((float)cfrfact*0.000001)/cfrinf*
                                     ( 1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j+1]) - 
                                       1.0/(((float)cfrfact)*0.000001+tcon[tmp_k]-tcon[tmp_j]));
                    }
                    if(fabs(p_pns)>max_pns)
                        max_pns=fabs(p_pns);
                }

                /* set a_gzrf1_ss_max based on max_pns and cfdbdtper */
                /* when shape of waveform is fixed, PNS is propotional to amplitude */
                a_gzrf1_ss_max  = _a_gzrf1_ss_max.fixedflag ?    ((void)(a_gzrf1_ss_max*FMin(2,1.0,(float)cfdbdtper/(max_pns*100.0))), a_gzrf1_ss_max) : a_gzrf1_ss_max*FMin(2,1.0,(float)cfdbdtper/(max_pns*100.0));
            }
            else
            {
                a_gzrf1_ss_max  = _a_gzrf1_ss_max.fixedflag ?             
                                          ((void)((cfdbdtper/100.0)*(cfrinf*(1.0+(cfrfact/(2*(float)pw_ss_rampz))))*(float)pw_ss_rampz/(FMax(3,cfdbdtdx,cfdbdtdy,cfdbdtdz)*100.0)), a_gzrf1_ss_max) : (cfdbdtper/100.0)*(cfrinf*(1.0+(cfrfact/(2*(float)pw_ss_rampz))))*(float)pw_ss_rampz/(FMax(3,cfdbdtdx,cfdbdtdy,cfdbdtdz)*100.0);
            }
        } 
        else if(cfdbdtts > 0)
        {
            a_gzrf1_ss_max  = _a_gzrf1_ss_max.fixedflag ?           ((void)(cfdbdtts*(float)pw_ss_rampz/(FMax(3,cfdbdtdx,cfdbdtdy,cfdbdtdz)*100.0)), a_gzrf1_ss_max) : cfdbdtts*(float)pw_ss_rampz/(FMax(3,cfdbdtdx,cfdbdtdy,cfdbdtdz)*100.0);
        }

       dbdt_slthk = (nbw_ssrf/ (a_gzrf1_ss_max * (0.1) * GAM));
        
       /* for EPI, min slthk is based on convolution dbdt calculation model */
       if(opepi == PSD_ON && breast_spsp_flag == PSD_OFF &&
          cffield == B0_30000 && cfgcoiltype == PSD_XRMB_COIL)
       { 
           FILE * fp; 
           if((fp=fopen("/usr/g/bin/.spspReily","r")) == NULL) 
           { 
               if(cfdbdtper >=80 && cfdbdtper < 100) 
                   dbdt_slthk = 3.6; 
               else if(cfdbdtper >= 100 && cfdbdtper <= 114 ) 
                   dbdt_slthk = 2.9; 
           } 
           else 
           { 
               fclose(fp); 
           } 
       }

        ss_min_slthk  = _ss_min_slthk.fixedflag ?             ((void)(ceilf(((dbdt_slthk>ss_min_slthk)?dbdt_slthk:ss_min_slthk)*10.0)/10.0), ss_min_slthk) : ceilf(((dbdt_slthk>ss_min_slthk)?dbdt_slthk:ss_min_slthk)*10.0)/10.0;

        /* slew rate limit */
        sr_slthk = nbw_ssrf/((pw_ss_rampz*(save_gmax/save_ramptime)) * (0.1) * GAM);
        ss_min_slthk  = _ss_min_slthk.fixedflag ?             ((void)(ceilf(((sr_slthk>ss_min_slthk)?sr_slthk:ss_min_slthk)*10.0)/10.0), ss_min_slthk) : ceilf(((sr_slthk>ss_min_slthk)?sr_slthk:ss_min_slthk)*10.0)/10.0;

        /* min slice offset (mm) for the spsp pulse */
        /* the 186.0 (mm) value is a function of the bandwidth of the Omega board
           [+/-78.125kHz and a given slice thickness and set at SR17 mode.  All
           other SR moded are indexed with the loggrd.zfs value */
        /* SVBranch: HCSDM00193936: Code below were moved to ssCheck() */            

    } /* end ss_rf1 = 1 */

    return(SUCCESS);
}

float get_fa_scaling_factor_ss(float * max_fa, float act_fa, float nom_fa, float nom_max_b1)
{
    double max_b1_limit, cur_b1_limit, act_b1;
    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;
    INT i;

    if (act_fa <= 0.0 || nom_fa <= 0.0 || nom_max_b1 <= 0.0)
    {
        *max_fa = 180.0;
        return 1.0;
    }

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils);
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);

    /* handle cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);

        if (cur_b1_limit < max_b1_limit)
        {
            max_b1_limit = cur_b1_limit;
        } 
    }

    max_b1_limit = max_b1_limit/100; /* uT to Gauss conversion */

    *max_fa = (float)floor(max_b1_limit*nom_fa/nom_max_b1);
    if(*max_fa > 180.0) *max_fa = 180.0;

    act_b1 = nom_max_b1*act_fa/nom_fa;

    if (act_b1 <= max_b1_limit)
    {
        return 1.0;
    }

    return (float)(max_b1_limit/act_b1);
}


#include "rfsspsummary.h"

/* Effective T1 calculation of CSF for T1FLAIR_EFFECTIVE_T1_MODEL */
float calcEffT1CSF(float slice_interval,
                   float eff_slthick,
                   float eff_invthick)
{
    float effT1;
    float gtr;
    float gtr_correction1 = 0.435;
    float gtr_correction2 = 0.295;
    int T1_CSF_100_3T  = 4200000;
    int T1_CSF_50_3T   = 2450000;
    int T1_CSF_40_3T   = 2000000;
    int T1_CSF_30_3T   = 1600000;
    int T1_CSF_100_15T = 3750000;
    int T1_CSF_50_15T  = 2350000;
    int T1_CSF_30_15T  = 1550000;

    gtr = (slice_interval - eff_slthick)/ (gtr_correction1 * eff_invthick) + gtr_correction2;

    switch ( ( int ) cffield )
    {
        case B0_30000:
            if (gtr >= 1)
                effT1 = T1_CSF_100_3T;
            else if (gtr >= 0.5)
                effT1 = T1_CSF_50_3T + (float)(T1_CSF_100_3T - T1_CSF_50_3T)/(1 - 0.5)*(gtr - 0.5);
            else if (gtr >= 0.4)
                effT1 = T1_CSF_40_3T + (float)(T1_CSF_50_3T - T1_CSF_40_3T)/(0.5 - 0.4)*(gtr - 0.4);
            else if (gtr >= 0.3)
                effT1 = T1_CSF_30_3T + (float)(T1_CSF_40_3T - T1_CSF_30_3T)/(0.4 - 0.3)*(gtr - 0.3);
            else
                effT1 = T1_CSF_30_3T;
            break;

        case B0_15000:
        default:
            if (gtr >= 1)
                effT1 = T1_CSF_100_15T;
            else if (gtr >= 0.5)
                effT1 = T1_CSF_50_15T + (float)(T1_CSF_100_15T - T1_CSF_50_15T)/(1 - 0.5)*(gtr - 0.5);
            else if (gtr >= 0.3)
                effT1 = T1_CSF_30_15T + (float)(T1_CSF_50_15T - T1_CSF_30_3T)/(0.5 - 0.3)*(gtr - 0.3);
            else
                effT1 = T1_CSF_30_15T;

            break;
    }

    return effT1;
}


float get_invthick(int numAcqs)
{
    float inv_thick = exist(opslthick);

    if(PSD_ON == t1flair_flag)
    {
        inv_thick = exist(opslthick);
    }
    else
    {
        if(PSD_ON == invThickOpt){
            double timeAdjSlCenDeltaDistance, adjInvPulseDeltaTime;
            timeAdjSlCenDeltaDistance = act_acqs * packs * (exist(opslthick)+exist(opslspace));
            adjInvPulseDeltaTime = tmin_flair;
            inv_thick = timeAdjSlCenDeltaDistance/(1+adjInvPulseDeltaTime/(2*opti));
            /* set invthick in FlairSetup() only for T2FLAIR*/
        }
        else
        {
            /* limit IR slice thick scaling to 3 */
            if(incinv)
            {
                inv_thick = (float)IMin(2, numAcqs, 3) * (exist(opslthick) + exist(opslspace));
            }
            else
            {
                inv_thick = exist(opslthick) + exist(opslspace);
            }
        }
    }

    return inv_thick;
}


/* Null TI calculation from given parameters */
float getNullTI(int repetitionTime,
                int relaxationTime,
                float slice_interval,
                float eff_slthick,
                float eff_invthick)
{
    float autoti = avminti;
    FILE* dbgfn;
    float t1_csf;

    if ((int)cffield == B0_30000)
    {
        t1_csf = T1_CSF_30000;
    }
    else if ((int)cffield == B0_15000)
    {
        t1_csf = T1_CSF_15000;
    }
    else
    {
        t1_csf = T1_CSF_10000;
    }

    if(autoti_model == T1FLAIR_FIXED_T1_MODEL) /* calculate null TI based on Fixed T1 model */
    {
        float crosstalk_decay_factor = 10.345;
        float crosstalk_amp_factor = 1.0;
        float gscale_correction = 0.7722;
        float min_ratio = 0.1305;
        float temp;
        float crosstalk;     /* crosstalk effect on null TI */

        /* Theoretical value of CSF nulling TI */
        autoti = t1_csf * (log(2.0) - log(1.0 + exp(- (float)relaxationTime/ t1_csf)));

        temp = FMax(2, min_ratio, (slice_interval - eff_slthick * gscale_correction)/ eff_invthick);

        crosstalk = exp( - ((float)repetitionTime/ 2)/ t1_csf) * exp( - crosstalk_decay_factor * temp );

        autoti = autoti * (1 - crosstalk * crosstalk_amp_factor);
    }
    else if(autoti_model == T1FLAIR_EFFECTIVE_T1_MODEL)
    {
        /* calculate null TI based on Effective T1 model */

        float effT1CSF;

        effT1CSF = calcEffT1CSF(slice_interval, eff_slthick, eff_invthick);

        autoti = effT1CSF * (log(2.0) - log(1.0 + exp(- (float)relaxationTime/ effT1CSF)));
    }
    else if (autoti_model == T1FLAIR_EFFECTIVE_TR_MODEL_FAT)
    {
        /* calculae null TI for Fat */
        float effTRFat;
        float gtr;
        const float p2 = 0.9686;
        const float p1 = 0.1493;
        const float p0 = 0.4441;
        float gtr_correction1 = 0.435;
        float gtr_correction2 = 0.111;
        float T1_Fat;

        /* To calculate the same TI value as pre-DV24 */
        slice_interval = exist(opslthick) + exist(opslspace);

        /* spacing to slice thickness ratio */
        gtr = (slice_interval - eff_slthick)/ (gtr_correction1 * eff_invthick) + gtr_correction2;

        if ((int)cffield == B0_30000)
        {
            T1_Fat = T1_FAT_30000;
        }
        else if ((int)cffield == B0_15000)
        {
            T1_Fat = T1_FAT_15000;
        }
        else
        {
            T1_Fat = T1_FAT_30000;
        }

        /* quadratic fitting to characterize the cross-talk effect */
        effTRFat = (p2 * gtr * gtr + p1 * gtr + p0) * (float)repetitionTime;

        autoti = T1_Fat * (log(2.0) - log(1.0 + exp(- effTRFat/ T1_Fat)));

        if (debug_t1flairenh)
        {
#ifdef PSD_HW
            dbgfn = fopen("/usr/g/service/log/t1flair_fatt1_model_info","a+");
#else
            dbgfn = fopen("t1flair_fatt1_model_info","a+");
#endif
            if (dbgfn != NULL)
            {
                fprintf(dbgfn, "\ngtr =%lf\teffTRFat = %lf\tautoti = %lf\n", gtr, effTRFat, autoti);
                fclose(dbgfn);
            }
        }
    }
    else if (autoti_model == T1FLAIR_LEGACY_MODEL) /* calculate CSF null TI based on old algorithm */
    {
        float temp;
        float autoti_scale1 = 1.0;
        float autoti_scale2 = 1.0;

        temp = exp( - autoti_scale1 * repetitionTime/ ( float ) t1_csf );
        autoti = - (float) (autoti_scale2 * t1_csf * log( 0.5 + 0.5 * temp ));
    }
    else if(autoti_model == T2FLAIR_FIXED_T1_MODEL) /* calculate null TI based on Fixed T1 model */
    {
        float crosstalk_decay_factor = 12.057;
        float crosstalk_amp_factor = 1.0;
        float gscale_correction = 0.7722;
        float offset_TI_t2flair = 100000;
        float temp;
        float crosstalk;     /* crosstalk effect on null TI */

        if ((int)cffield == B0_30000)
        {
            offset_TI_t2flair = 100000;
        }
        else if ((int)cffield == B0_15000)
        {
            offset_TI_t2flair = 0000;
        }
        else
        {
            offset_TI_t2flair = 100000;
        }

        /* Theoretical value of CSF nulling TI */
        autoti = t1_csf * (log(2.0) - log(1.0 + exp(- (float)relaxationTime/ t1_csf)));

        temp = (slice_interval - eff_slthick * gscale_correction)/ eff_invthick;

        crosstalk = exp( - ((float)repetitionTime/ 2)/ t1_csf) * exp( - crosstalk_decay_factor * temp );

        autoti = autoti * (1 - crosstalk * crosstalk_amp_factor) - offset_TI_t2flair;
    }
    else if (autoti_model == T2FLAIR_EFFECTIVE_T1_MODEL)
    {
        int t1CSF;
        float effT1CSF;
        float temp_ratio;       /* (slice gap) / (IR pulse width) */
        float crosstalk;
        float intercept, slope; /* crosstalk amplitude factor is almost linear against temp_ratio */
        float gtr_correction1 = 0.408997;
        float gtr_correction2 = 0.18;

        temp_ratio = (slice_interval - eff_slthick)/ (gtr_correction1 * eff_invthick) + gtr_correction2;

        t1CSF = 5000000;
        intercept = 0.952;
        slope = -1.273;

        switch ( ( int ) cffield )
        {
            case B0_30000: /* Find optimized parameters to support */
                break;
            case B0_15000: /* same as default */
                break;
            case B0_10000: /* Find optimized parameters to support */
                break;
            default:
                break;
        }

        crosstalk = (intercept + slope * temp_ratio) * exp( - ((float)repetitionTime/ 2)/ (float)t1CSF );
        effT1CSF = (float)t1CSF * (1 - crosstalk);
        autoti = effT1CSF * (log(2.0) - log(1.0 + exp(- (float) relaxationTime/ effT1CSF)));
    }
    else if(autoti_model == T2FLAIR_SINGLE_DOUBLE_INV_MODEL)
    {
        float residual_signal = 0.03; /* Target Mz = 0.03*M0 at TI to avoid negative Mz,
                                         which leads to out-of-phase effect with surrounding tissue */
        float coefficient = 0.025; /* This coefficient accounts for slice profile non-ideality */

        float InvGap, ratio_single, ratio_double;
        float signal_single, signal_double;
        float temp_invthick, eff_invthick;
        double timeAdjSlCenDeltaDistance;
        int adjInvPulseDeltaTime;

        int TIdiff = 10000000; /* a big value */
        int prevTI = 2000000;
        int iter = 0;
        int maxiter = 10;

        timeAdjSlCenDeltaDistance =  2 * slice_interval;
        adjInvPulseDeltaTime = repetitionTime - relaxationTime;

        signal_single = (1-exp(-(float)(repetitionTime-adjInvPulseDeltaTime)/t1_csf))/
                                (1+exp(-(float)(repetitionTime-adjInvPulseDeltaTime)/t1_csf));
        signal_double = (1-2*exp(-((float)repetitionTime/2-adjInvPulseDeltaTime)/t1_csf)+
                         exp(-(float)(repetitionTime-adjInvPulseDeltaTime)/t1_csf))/
                                (1-exp(-(float)(repetitionTime-adjInvPulseDeltaTime)/t1_csf));

        while((TIdiff > 10000) && (iter < maxiter))
        {
            temp_invthick = timeAdjSlCenDeltaDistance/ (1+(float)adjInvPulseDeltaTime/(2*prevTI));
            eff_invthick = (1 - coefficient) * temp_invthick; /* account for slice profile non-ideality */

            InvGap = timeAdjSlCenDeltaDistance - eff_invthick;

            ratio_single = FMin(2, InvGap/exist(opslthick), 1.0);
            ratio_single = FMax(2, ratio_single, 0.0);
            ratio_double = 1.0 - ratio_single;

            autoti = -t1_csf * log( (1.0-residual_signal)/
                             (1.0 + ratio_single*signal_single + ratio_double*signal_double) );

            TIdiff = abs((int)autoti - prevTI);
            prevTI = (int)autoti;
            iter += 1;
        }
    }
    else if(autoti_model == T2FLAIR_SINGLE_INV_MODEL)
    {
        float residual_signal = 0.01; /* Target Mz = 0.01*M0 at TI to avoid negative Mz,
                                         which leads to out-of-phase effect with surrounding tissue */

        float Minit;                  /* Mz just before IR pulse */
        float temp;
        float t1_csf_si;
        switch ( ( int ) cffield )
                {
                            case B0_30000:
                                t1_csf_si = (float)T1_CSF_30000;
                                break;
                            case B0_15000:
                            default:
                                t1_csf_si = (float)T1_CSF_15000_SINGLE_INV;
                                break;
                }
        
        
        temp =  exp(- (float)relaxationTime/ t1_csf_si);
        Minit = (1 - temp)/ (1 + temp);
        autoti = - t1_csf_si* log((1.0 - residual_signal)/ (1.0 + Minit));
    }

    return autoti;
}


/* Null TR calculation from given parameters */
float getNullTR(int inversionTime,
                int null_period,
                float slice_interval,
                float eff_slthick,
                float eff_invthick)
{
    float nulltr = avmintr;
    float t1_csf;

    if ((int)cffield == B0_30000)
    {
        t1_csf = T1_CSF_30000;
    }
    else if ((int)cffield == B0_15000)
    {
        t1_csf = T1_CSF_15000;
    }
    else
    {
        t1_csf = T1_CSF_10000;
    }

    if(autoti_model == T1FLAIR_FIXED_T1_MODEL) /* calculate null TR based on Fixed T1 model */
    {
        float crosstalk_decay_factor = 10.345;
        float crosstalk_amp_factor = 1.0;
        float min_ratio = 0.1305;
        float temp, temptr;
        float crosstalk;     /* crosstalk effect on null TI */

        /* Theoretical value of CSF nulling TR */
        temptr = null_period - t1_csf * log(2.0 * exp(- (float)inversionTime/ t1_csf) - 1);

        temp = FMax(2, min_ratio, (slice_interval - eff_slthick)/ eff_invthick);

        crosstalk = exp( - ((float)temptr/ 2)/ t1_csf) * exp( - crosstalk_decay_factor * temp );

        crosstalk = crosstalk_amp_factor * crosstalk;

        nulltr = temptr + (exp(temptr - null_period) + 1) * inversionTime * crosstalk;
    }
    else if(autoti_model == T1FLAIR_EFFECTIVE_T1_MODEL)
    {
        /* calculate null TR based on Effective T1 model */

        float effT1CSF;

        effT1CSF = calcEffT1CSF(slice_interval, eff_slthick, eff_invthick);

        nulltr = null_period - effT1CSF * log(2.0 * exp(- (float)inversionTime/ effT1CSF) - 1);
    }
    else if (autoti_model == T1FLAIR_EFFECTIVE_TR_MODEL_FAT)
    {
        /* calculae null TR for Fat */
        float gtr;
        const float p2 = 0.9686;
        const float p1 = 0.1493;
        const float p0 = 0.4441;
        float gtr_correction1 = 0.435;
        float gtr_correction2 = 0.111;
        float T1_Fat;

        /* To calculate the same TI value as pre-DV24 */
        slice_interval = exist(opslthick) + exist(opslspace);

        /* spacing to slice thickness ratio */
        gtr = (slice_interval - eff_slthick)/ (gtr_correction1 * eff_invthick) + gtr_correction2;

        if ((int)cffield == B0_30000)
        {
            T1_Fat = T1_FAT_30000;
        }
        else if ((int)cffield == B0_15000)
        {
            T1_Fat = T1_FAT_15000;
        }
        else
        {
            T1_Fat = T1_FAT_30000;
        }

        nulltr = - T1_Fat * log(2.0 * exp(- (float)inversionTime/ T1_Fat) - 1)/ (p2 * gtr * gtr + p1 * gtr + p0);
    }
    else if (autoti_model == T1FLAIR_LEGACY_MODEL) /* calculate CSF null TR based on old algorithm */
    {
        float temp;
        float autoti_scale1 = 1.0;
        float autoti_scale2 = 1.0;

        temp = exp( -( ( float ) inversionTime/ (autoti_scale2 * t1_csf) ) );
        nulltr = - t1_csf/ autoti_scale1 * log( 2.0 * temp - 1 );
    }
    else if(autoti_model == T2FLAIR_FIXED_T1_MODEL)
    {
        /* calculate null TR based on Fixed T1 model. Impossible to calculate null TR based on Effective T1 model. */
        float temptr, tempti;
        float deltati, deltatr;
        int i, Nrepeat = 5;

        if(inversionTime < t1_csf * log(2.0))
        {
            /* Theoretical value of CSF nulling TR */
            temptr = null_period - t1_csf * log(2.0 * exp(- (float)inversionTime/ t1_csf) - 1);

            for(i = 0; i < Nrepeat; i++)
            {
                tempti = getNullTI(temptr,
                                   temptr - null_period,
                                   slice_interval,
                                   eff_slthick,
                                   eff_invthick);

                deltati = inversionTime - tempti;
                deltatr = (exp( (temptr - null_period)/ t1_csf ) + 1) * deltati;
                nulltr = temptr + (exp( (temptr + deltatr/2 - null_period)/ t1_csf ) + 1) * deltati;
                if(i == Nrepeat - 1 && nulltr < temptr)
                {
                    nulltr = temptr;
                }
                temptr = nulltr;

                if(autotr_flair_debug == PSD_ON)
                {
                    FILE *fp;
                    fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                    if (NULL != fp){
                        fprintf(fp,"getNullTR(%d):temptr=%f,tempti=%f,inversionTime=%d\n"
                              ,i,temptr,tempti,inversionTime);
                        fclose(fp);
                    }
                }
            }
        }
        else
        {
            nulltr = avmaxtr + 1000000;
        }
    }
    else if(autoti_model == T2FLAIR_EFFECTIVE_T1_MODEL)
    {
        int deltaTR = 100000;     /* accuracy of null TR */
        int t1CSF;
        int temptr;
        int tempti;
        double effT1CSF;
        double temp_ratio;       /* (slice gap) / (IR pulse width) */
        double crosstalk;
        double intercept, slope; /* crosstalk amplitude factor is almost linear against temp_ratio */
        float gtr_correction1 = 0.408997;
        float gtr_correction2 = 0.18;

        temp_ratio = (slice_interval - eff_slthick)/ (gtr_correction1 * eff_invthick) + gtr_correction2;

        t1CSF = 5000000;
        intercept = 0.952;
        slope = -1.273;

        switch ( ( int ) cffield )
        {
            case B0_30000: /* Find optimized parameters to support */
                break;
            case B0_15000: /* same as default */
                break;
            case B0_10000: /* Find optimized parameters to support */
                break;
            default:
                break;
        }

        /* Step 1: Derive roughly estimated null TR from TI. It is underestimated compared to null TR. */

        temptr =  2 * opte - t1CSF * ( log( 2 * exp( - (double)inversionTime/ (double)t1CSF ) - 1 ) );

        /* Step 2: Derive TI from the underestimated TR. It is shorter than opti. */

        crosstalk = (intercept + slope * temp_ratio)
                  * exp( - ((double)temptr/ 2)/ (double)t1CSF );
        effT1CSF = (double)t1CSF * (1 - crosstalk);
        tempti = (int)(effT1CSF * (log(2.0) - log(1.0 + exp(- (double)(temptr - 2 * opte)/ effT1CSF))));

        /* Step 3: Estimate null TR by iterative calculation. It is overestimated compared to exact null TR. */

        while(tempti < exist(opti))
        {
            temptr = temptr + deltaTR;
            crosstalk = (intercept + slope * temp_ratio)
                      * exp( - ((double)temptr/ 2)/ (double)t1CSF );
            effT1CSF = (double)t1CSF * (1 - crosstalk);
            tempti = (int)(effT1CSF * (log(2.0) - log(1.0 + exp(- (double)(temptr - 2 * opte)/ effT1CSF))));
        }

        nulltr = temptr;
    }
    else if(autoti_model == T2FLAIR_SINGLE_INV_MODEL)
    {
        float residual_signal = 0.01; /* Target Mz = 0.01*M0 at TI to avoid negative Mz,
                                         which leads to out-of-phase effect with surrounding tissue */

        float Minit;                  /* Mz just before IR pulse */
        float temp;
        float t1_csf_si;
        switch ( ( int ) cffield )
        {
            case B0_30000:
                t1_csf_si = (float)T1_CSF_30000;
                break;
            case B0_15000:
            default:
                t1_csf_si = (float)T1_CSF_15000_SINGLE_INV;
                break;
        }

        temp = FMax(2, 0.50, exp(- inversionTime/ t1_csf_si)); /* Minit should be less than 1 */
        Minit = (1 - residual_signal)/ temp - 1;
        nulltr = null_period - t1_csf_si * log((1 - Minit)/ (1 + Minit));
    }

    return nulltr;
}


float calc_cross_tr(int n1,
                    int n2,
                    float t1min,
                    float t2min,
                    float start_tr,
                    float tolerance,
                    int numAcqs,
                    float minimum_tr,
                    int boundary_type)
{
    float cutoffResidue, cur, prev;
    float null_ti = 0.0;
    float curResidue = 100000000.0;
    int ntimes = 0;

    cutoffResidue = tolerance;
    cur = start_tr;

    while(fabs(curResidue) > cutoffResidue)
    {
        ntimes = ntimes + 1;
        prev = cur;
        null_ti = getNullTI((int)prev,
                            (int)prev - act_esp * exist(opetl),
                            (float)numAcqs * (exist(opslthick) + exist(opslspace)),
                            exist(opslthick)/ gscale_rf1,
                            get_invthick(numAcqs)/ gscale_rf0);

        if( boundary_type == 0 ){ /* low boundary */
            cur = (null_ti + t2min)*n2/n1;
        }else{ /* up boundary */
            cur = ( null_ti - t1min ) * n2/ (n1-1);
            if(cur < minimum_tr){
                cur = -10000000.0; /* return invalid value */
                break;
            }
        }
        curResidue = cur - prev;
    }

    if(autotr_flair_debug == PSD_ON)
    {
        FILE *fp;
#ifdef PSD_HW
        fp = fopen("/usr/g/service/log/autotr_flair.log","a");
#else
        fp = fopen("autotr_flair.log","a");
#endif
        if (fp != NULL)
        {
            fprintf(fp,"****** ntimes=%d,curResidue=%f,null_ti=%f,boundary_type=%d\n",ntimes,curResidue,null_ti,boundary_type);
            fclose(fp);
        }
    }

    /* for safety, just use a larger value */
    return cur;
}


STATUS
T1flair_analytical_ManualTR(void)
{
    double ti = 0.0;
    double ti1 = 0.0;
    double ti2 = 0.0;
    double tr, minTR, mint1, mint2, t1Excite, t2Excite, dtr1, dtr2, t1, t2, maxTI, mindtr, n1tmp, tr1, tr2, dtr, tmptr;
    int maxn2, maxn2_acq1, maxn2_acq2, maxn1, n2, n1, dn2, tmpn2, ii, n1u, n1b, tmpn1, numAcqs, d_maxn2, tmpacq;
    int inBound = FALSE;
    FILE *dbgfn;

    minTR = FMax(2, (double)tmin_total, (double)avmintr);
    tr = exist(optr);
    if (tr < minTR) tr = minTR;

    n1 = 0;
    dn2 = 0;
    dtr1 = dtr1_tolerance;
    dtr2 = dtr2_tolerance;

    mint1 = tmin_total_ir;
    mint2 = tmin_total_acq_seq;
    t1Excite = RUP_GRD(GRAD_UPDATE_TIME + tlead + hrf0 +
                       IMax (2, (48   + pw_gzrf0a), minimumPreRfSspTime() - psd_rf_wait));
    t2Excite = sp_sattime + cs_sattime + satdelay + pw_gzrf1a + hrf1a;
    mint1 = mint1 - t1Excite + t2Excite;
    mint2 = mint2 - t2Excite + t1Excite;

    t1flair_mint1  = _t1flair_mint1.fixedflag ?  ((void)((float)mint1), t1flair_mint1) : (float)mint1;
    t1flair_mint2  = _t1flair_mint2.fixedflag ?  ((void)((float)mint2), t1flair_mint2) : (float)mint2;

    maxn2 = (int)(tr/(mint1 + mint2));
    maxn2_acq1 = maxn2;
    maxn2_acq2 = maxn2;

    if (exist(opautoti) == PSD_ON)
    {
        tmpacq = 1;

        ti1 = getNullTI((int)tr,
                        (int)tr - esp * exist(opetl),
                        (float)tmpacq * (exist(opslthick) + exist(opslspace)),
                        exist(opslthick)/ gscale_rf1,
                        get_invthick(tmpacq)/ gscale_rf0);

        tmpacq = 2;

        ti2 = getNullTI((int)tr,
                        (int)tr - esp * exist(opetl),
                        (float)tmpacq * (exist(opslthick) + exist(opslspace)),
                        exist(opslthick)/ gscale_rf1,
                        get_invthick(tmpacq)/ gscale_rf0);
    }

    /* Step 1: Find the actual maximum n2 for 1 acquisition*/

    /* We need to validate TI at first, assume it is 1 acq */
    if (exist(opautoti) == PSD_ON)
    {
        ti = ti1;
        tmpacq = 1;
    }else{
        ti = exist(opti);
    }

    /*HCSDM00388564, for STIR-DWI, only allow changing ti when opautoti is ON*/
    if ( PSD_ON == exist(opdiffuse) )
    {
        if (exist(opautoti) == PSD_ON)
        {
            if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
                ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
            }
        }
    }
    else
    {
        if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
            ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
        }
    }

    /* d_maxn2 is the max n2 reduction tolerance */
    if( 0 != force_odd_even_slquant){
        d_maxn2 = 3;
    }else{
        d_maxn2 = 2;
    }
    if( d_maxn2 >= maxn2 ){
        d_maxn2 = maxn2 - 1;
    }

    /* Start to loop through */
    inBound = FALSE;
    mindtr = -1;
    tmpn2 = 0;
    for (ii = maxn2; ii >= maxn2 - d_maxn2; ii--)
    {
        if((1==force_odd_even_slquant) && (ii%2 == 0)){
            continue; /* slice banding fix */
        }
        else if( (2==force_odd_even_slquant) && (ii%2 == 1) && (maxn2 > 1) ){
            continue;
        }

        /* calculate the minTR */
        minTR = ii*(mint1 + mint2);

        /* calculate the fractional n1 */
        n1tmp = (ti + mint2)/tr*ii;
        /* The upper and bottom integer n1 */
        n1u = (int)n1tmp + 1;
        n1b = (int)n1tmp;

        /* Find the maximum n1 with the current ii */
        if (ii%2 == 0){
            maxn1 = ii/2 - 1;
        }else{
            maxn1 = ii/2;
        }
        /* for extreme case, we just set maxn1 to 1 to prevent
         * software from being broken, the image constrast may
         * not be as expected */
        if (maxn1 < 1){
           maxn1 = 1;
        }

        /* Calculate the lower and upper invalid tr boundary */
        if( n1b >= 1 ){
            tr1 = (ti - mint1)*ii/(n1u - 1);
            tr2 = (ti + mint2)*ii/n1b;
        }

        /* Check if the current tr is within the solution region */
        if ( n1b >= 1 && (tr <= tr1 + dtr1 || tr >= tr2 - dtr2) )
        {
            if (n1u <= maxn1) /* n1/n2 shall be < 0.5 */
            {
                /* we found the solution of maximum n2 */
                maxn2_acq1 = ii;
                inBound = TRUE;
                break;
            }
            else if (n1b == maxn1 && tr >= tr2 - dtr2) /* n1/n2 shall be < 0.5 */
            {
                /* we found the solution of maximum n2 */
                maxn2_acq1 = ii;
                inBound = TRUE;
                break;
            }
            else
            {
                /* n1/n2 >= 0.5, we calculate tr distance to the
                 * solution boundary*/
                float target_tr;
                if (exist(opautoti) == PSD_ON){
                    target_tr = calc_cross_tr( maxn1, ii, mint1, mint2, tr,
                                           dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr = (ti + mint2)*ii/maxn1;
                }

                dtr = fabs(tr - target_tr);
                /* we track the minimum distance and its corresponding
                 * maximum n2 */
                if ( (mindtr < 0.0) || (mindtr > dtr) )
                {
                    mindtr = dtr;
                    tmpn2 = ii;
                }
            }
        }
        else if( n1b >= 1 )
        {
            /* tr is not within the solution region */
            float target_tr1 = 0.0;
            float target_tr2 = 0.0;
            if( n1b >= maxn1 ){
                if (exist(opautoti) == PSD_ON){
                    target_tr2 = calc_cross_tr( maxn1, ii, mint1, mint2, tr,
                                               dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr2 = (ti + mint2)*ii/maxn1;
                }
                dtr = fabs(tr - target_tr2);
            }else{
                if (exist(opautoti) == PSD_ON){

                    target_tr1 = calc_cross_tr( n1u, ii, mint1, mint2, tr,
                                                dtr1 + 1000.0, tmpacq, minTR, 1 );
                    target_tr2 = calc_cross_tr( n1b, ii, mint1, mint2, tr,
                                                dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr1 = tr1;
                    if( target_tr1 < minTR ){
                        target_tr1 = -10000000.0; /* invalid TR */
                    }
                    target_tr2 = tr2;
                }

                dtr = FMin(2, fabs(tr - target_tr1), fabs(tr - target_tr2));
            }

            if ( (mindtr < 0.0) || (mindtr > dtr) )
            {
                mindtr = dtr;
                tmpn2 = ii;
            }
        }
        else  /* special case: n1b < 1 */
        {
            /* for special case n1b < 1, the n1 can only be 1 and we
             * alway have solution for the current TR */
            maxn2_acq1 = ii;
            inBound = TRUE;
            break;
        }
    }

    /* if we cannot find the in-boundary solution, we just take the one
     * with the minimum distance */
    if (inBound == FALSE)
    {
        maxn2_acq1 = tmpn2;
    }

    /* Step 2: Find the actual maximum n2 for >1 acquisition*/

    /* We need to validate TI at first, assume it is > 1 acq */
    if (exist(opautoti) == PSD_ON)
    {
        ti = ti2;
        tmpacq = 2;
    }else{
        ti = exist(opti);
    }

    /*HCSDM00388564, for STIR-DWI, only allow changing ti when opautoti is ON*/
    if ( PSD_ON == exist(opdiffuse) )
    {
        if (exist(opautoti) == PSD_ON)
        {
            if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
                ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
            }
        }
    }
    else
    {
        if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
            ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
        }
    }

    /* Start loop through */
    inBound = FALSE;
    mindtr = -1;
    tmpn2 = 0;

    d_maxn2 = 2;
    if( d_maxn2 >= maxn2 ){
        d_maxn2 = maxn2 - 1;
    }

    for (ii = maxn2; ii >= maxn2 - d_maxn2; ii--)
    {
        /* calculate the minTR */
        minTR = ii*(mint1 + mint2);

        /* calculate the fractional n1 */
        n1tmp = (ti + mint2)/tr*ii;
        /* The upper and bottom integer n1 */
        n1u = (int)n1tmp + 1;
        n1b = (int)n1tmp;

        maxn1 = ii - 1;
        /* for extreme case, we just set maxn1 to 1 to prevent
         * software from being broken
         * */
        if (maxn1 < 1){
           maxn1 = 1;
        }

        /* Calculate the lower and upper invalid tr boundary */
        if( n1b >= 1 ){
            tr1 = (ti - mint1)*ii/(n1u - 1);
            tr2 = (ti + mint2)*ii/n1b;
        }

        /* Check if the current tr is within the solution region */
        if ( n1b >= 1 && (tr <= tr1 + dtr1 || tr >= tr2 - dtr2) )
        {
            if (n1u <= maxn1)
            {
                /* we found the solution of maximum n2 */
                maxn2_acq2 = ii;
                inBound = TRUE;
                break;
            }
            else if (n1b == maxn1 && tr >= tr2 - dtr2)
            {
                /* we found the solution of maximum n2 */
                maxn2_acq2 = ii;
                inBound = TRUE;
                break;
            }
            else
            {
                float target_tr;
                if (exist(opautoti) == PSD_ON){
                    target_tr = calc_cross_tr( maxn1, ii, mint1, mint2, tr,
                                           dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr = (ti + mint2)*ii/maxn1;
                }

                dtr = fabs(tr - target_tr);
                /* we track the minimum distance and its corresponding
                 * maximum n2 */
                if ( (mindtr < 0.0) || (mindtr > dtr) )
                {
                    mindtr = dtr;
                    tmpn2 = ii;
                }
            }
        }
        else if( n1b >= 1 )
        {
            /* tr is not within the solution region */
            float target_tr1 = 0.0;
            float target_tr2 = 0.0;
            if( n1b >= maxn1 ){
                if (exist(opautoti) == PSD_ON){
                    target_tr2 = calc_cross_tr( maxn1, ii, mint1, mint2, tr,
                                               dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr2 = (ti + mint2)*ii/maxn1;
                }
                dtr = fabs(tr - target_tr2);
            }else{
                if (exist(opautoti) == PSD_ON){
                    target_tr1 = calc_cross_tr( n1u, ii, mint1, mint2, tr,
                                                dtr1 + 1000.0, tmpacq, minTR, 1 );
                    target_tr2 = calc_cross_tr( n1b, ii, mint1, mint2, tr,
                                                dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{
                    target_tr1 = tr1;
                    if( target_tr1 < minTR ){
                        target_tr1 = -10000000.0; /* invalid TR */
                    }
                    target_tr2 = tr2;
                }
                dtr = FMin(2, fabs(tr - target_tr1), fabs(tr - target_tr2));
            }

            if ( (mindtr < 0.0) || (mindtr > dtr) )
            {
                mindtr = dtr;
                tmpn2 = ii;
            }
        }
        else  /* special case: n1b < 1 */
        {
            /* for special case n1b < 1, the n1 can only be 1 and we
             * alway have solution for current TR */
            maxn2_acq1 = ii;
            inBound = TRUE;
            break;
        }
    }

    /* if we cannot find the in-boundary solution, we just take the one
     * with the minimum distance */
    if (inBound == FALSE)
    {
        maxn2_acq2 = tmpn2;
    }

    /* Step 3: Now we can calculate avmaxslquant, acqs and slice number
     * per acq */

    if( max_slice_num_reduction >= 0 ){
        avmaxslquant = maxn2 - max_slice_num_reduction;
    }else{
        avmaxslquant = IMin(2, maxn2_acq1, maxn2_acq2);
    }

    if (PSD_ON == req_edge_slice_enh_flag && avmaxslquant > 2)
    {
        avmaxslquant = avmaxslquant - 2;
        act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_ON), act_edge_slice_enh_flag) : PSD_ON;
    }
    else
    {
        act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), act_edge_slice_enh_flag) : PSD_OFF;
    }

    if(enht2flairacqs > 0){
        if(((int)(opslquant/avmaxslquant)) < enht2flairacqs){
            avmaxslquant = (int)( opslquant/enht2flairacqs  + 1);
        }
    }

    if (maxpass(_acqs.fixedflag ? (_temp626_acqs=acqs,&_temp626_acqs) : &acqs,seq_type,(int)exist(opslquant), avmaxslquant) == FAILURE) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxpass");
        return FAILURE;
    }

    /* opuser8 is Minimum Acqs for Interleaved STIR */
    if ((PSD_ON == exist(opdiffuse)) && (PSD_ON == t1flair_flag))
    {
        if (acqs < (int)opuser8)
        {
            acqs  = _acqs.fixedflag ?  ((void)((int)opuser8), acqs) : (int)opuser8;
        }
    }

    act_acqs  = _act_acqs.fixedflag ?  ((void)(acqs), act_acqs) : acqs;
    avmaxacqs = act_acqs;

    if (slicein1(_slquant_per_trig.fixedflag ? (_temp627_slquant_per_trig=slquant_per_trig,&_temp627_slquant_per_trig) : &slquant_per_trig, acqs, seq_type) == FAILURE) {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
        slquant_per_trig  = _slquant_per_trig.fixedflag ? ((void)(1), slquant_per_trig) : 1;
        return FAILURE;
    }

    if (PSD_ON == act_edge_slice_enh_flag)
    {
        slquant_per_trig  = _slquant_per_trig.fixedflag ?    ((void)(slquant_per_trig+2), slquant_per_trig) : slquant_per_trig+2;
    }
    numAcqs = acqs;
    n2 = slquant_per_trig;

    /* Step 4: Find the actual tr and dummy slice number */
    inBound = FALSE;
    mindtr = -1;
    tmpn2 = 0;
    tmptr = 0;
    tmpn1 = 0;

    /* Validate TI */
    if (exist(opautoti) == PSD_ON)
    {
        tmpacq = (numAcqs <= 1) ? 1 : 2;
        ti = (numAcqs <= 1) ? ti1 : ti2;
    }else{
        ti = exist(opti);
    }

    /*HCSDM00388564, for STIR-DWI, only allow changing ti when opautoti is ON*/
    if ( PSD_ON == exist(opdiffuse) )
    {
        if (exist(opautoti) == PSD_ON)
        {
            if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
                ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
            }
        }
    }
    else
    {
        if( ti < FMax(2, (double)(T1FLAIR_MIN_TI), mint1) ){
            ti = FMax(2, (double)(T1FLAIR_MIN_TI), mint1);
        }
    }

    for (ii = n2; ii <= maxn2; ii++)
    {
        if((1==force_odd_even_slquant) && (1 == numAcqs) && (ii%2 == 0)){
            continue; /* slice banding fix */
        }
        else if((2==force_odd_even_slquant) && (1 == numAcqs) && (ii%2 == 1) && (maxn2 > 1)){
            continue; 
        }     

        /* calculate the minTR */
        minTR = ii*(mint1 + mint2);

        /* Calculate the "fractional" n1 */
        n1tmp = (ti+mint2)/tr*ii;

        /* the "upper" and "bottom" integer n1 */
        n1u = (int) n1tmp + 1;
        n1b = (int) n1tmp;

        /* Find the maximum n1 with the current ii */
        if (numAcqs == 1)
        {
            if (ii%2 == 0)
                maxn1 = ii/2 - 1;
            else
                maxn1 = ii/2;
        }
        else
        {
            maxn1 = ii - 1;
        }

        /* for extreme case, we just set maxn1 to 1 to prevent 
         * software from being broken, the image constrast may
         * not be as expected */
        if (maxn1 < 1){
           maxn1 = 1; 
        }

        if( n1b >= 1 ){
            /* Calculate the lower invalid tr boundary */
            tr1 = (ti-mint1)*ii/(n1u-1);
            /* Calculate the upper invalid tr boundary */
            tr2 = (ti+mint2)*ii/n1b;
        }

        /* Check if the current tr is within the solution region */
        if( n1b >= 1 && (tr <= tr1 + dtr1 || tr >= tr2 - dtr2) )
        {
            if( n1u <= maxn1 ) 
            {
                /* We find the solution of maximum n2 */
                /* The dummy slice number */
                dn2 = ii - n2;
                /* n1 and actual tr */
                if( tr >= tr2 - dtr2 )
                {
                    n1 = n1b;
                    tr = (tr < tr2) ? tr2 : tr;
                }
                else
                {
                    n1 = n1u;
                    tr = (tr > tr1) ? tr1 : tr;
                }
                inBound = TRUE;
                break;
            }
            else if ( n1b == maxn1 && tr >= tr2 - dtr2)  
            {
                /* we find the solution of maximum n2 */
                /* dummy slice number */
                dn2 = ii - n2;
                n1 = maxn1;
                /* actual tr */
                if (tr < tr2)
                    tr = tr2;
                inBound = TRUE;
                break;
            }
            else
            { 
                /* We calculate the tr distance to solution bondary */
                float target_tr;
                if (exist(opautoti) == PSD_ON){ 
                    target_tr = calc_cross_tr( maxn1, ii, mint1, mint2, tr, 
                                           dtr2 + 1000.0, tmpacq, minTR, 0 ); 
                }else{
                    target_tr = (ti + mint2)*ii/maxn1;
                }
                                           
                dtr = fabs(tr - target_tr);

                /* we track the minimum distance and its corresponding
                 * maximum n2 */
                if ( (mindtr < 0.0) || (mindtr > dtr) )
                {
                    mindtr = dtr;
                    tmpn2 = ii;
                    tmptr = target_tr;
                    tmpn1 = maxn1;
                }
            }
        }
        else if( n1b >= 1 )
        {  
            float target_tr1 = 0.0;
            float target_tr2 = 0.0;
            if( n1b >= maxn1 ){
                if (exist(opautoti) == PSD_ON){ 
                    target_tr2 = calc_cross_tr( maxn1, ii, mint1, mint2, tr, 
                                               dtr2 + 1000.0, tmpacq, minTR, 0 ); 
                }else{
                    target_tr2 = (ti + mint2)*ii/maxn1;
                }
                dtr = fabs(tr - target_tr2);
            }else{
                if (exist(opautoti) == PSD_ON){ 
                    target_tr1 = calc_cross_tr( n1u, ii, mint1, mint2, tr, 
                                                dtr1 + 1000.0, tmpacq, minTR, 1 );
                    target_tr2 = calc_cross_tr( n1b, ii, mint1, mint2, tr,
                                                dtr2 + 1000.0, tmpacq, minTR, 0 );
                }else{ 
                    target_tr1 = tr1; 
                    if( target_tr1 < minTR ){
                        target_tr1 = -10000000.0; /* invalid TR */
                    }
                    target_tr2 = tr2; 
                }
                dtr = FMin(2, fabs(tr - target_tr1), fabs(tr - target_tr2));
            }

            if ( (mindtr < 0.0)  || (mindtr > dtr) )
            { 
                mindtr = dtr;
                tmpn2 = ii;
                if( n1b < maxn1 )
                {
                    if( fabs(tr-target_tr2) <= fabs(tr-target_tr1) )
                    {
                        tmptr = target_tr2;
                        tmpn1 = n1b; /* CHANGED FROM n1u TO n1b! */
                    }
                    else
                    { 
                        tmptr = target_tr1;
                        tmpn1 = n1u;
                    }
                }
                else
                {
                    tmptr = target_tr2;
                    tmpn1 = maxn1;
                }
            }    
        }
        else  /* special case: n1b < 1 */
        {
            /* for special case n1b < 1, the n1 can only be 1 and we
             * alway have solution for all TR > minTR */
             dn2 = ii - n2;
             n1 = 1;
             inBound = TRUE;
             break;
       }
    }

    /* If we cannot find the in-boundary solution, we just take the one
     * with minimum distance */
    if( inBound ==  FALSE)
    {
        dn2 = tmpn2-n2;
        tr = tmptr;
        n1 = tmpn1;
    }

    /* for auto TI, We need to recalculate TI since tr may have been adjusted */
    if (exist(opautoti) == PSD_ON){
        ti = getNullTI((int)tr,
                       (int)tr - esp * exist(opetl),
                       (float)tmpacq * (exist(opslthick) + exist(opslspace)),
                       exist(opslthick)/ gscale_rf1,
                       get_invthick(tmpacq)/ gscale_rf0);
    }

    /* calculate maxTI based on actual tr value */
    maxTI = tr - mint2;

    /* Step 5: Calculate the t1 and t2 time */
    t1 = ti - tr*(n1 - 1)/(n2 + dn2);
    t2 = tr*n1/(n2 + dn2) - ti;

    /* Step 6: Calculate the CV and property values */
    act_ti  = _act_ti.fixedflag ?  ((void)(ti), act_ti) : ti;
    act_tr  = _act_tr.fixedflag ?  ((void)(tr), act_tr) : tr;

    avminti_t1flair  = _avminti_t1flair.fixedflag ?  ((void)((int)mint1), avminti_t1flair) : (int)mint1;
    avmaxti_t1flair  = _avmaxti_t1flair.fixedflag ?  ((void)(maxTI), avmaxti_t1flair) : maxTI;

    /* t1flair_stir: corrected inner_spacing calculation */
    inner_spacing  = _inner_spacing.fixedflag ?        ((void)(t1-mint1+(tmin_total_ir-ir_grad_time)), inner_spacing) : t1-mint1+(tmin_total_ir-ir_grad_time);
    post_spacing  = _post_spacing.fixedflag ?    ((void)(t2-mint2), post_spacing) : t2-mint2;
    if (inner_spacing < 0)
    {
        post_spacing  = _post_spacing.fixedflag ?  ((void)(inner_spacing), post_spacing) : post_spacing+inner_spacing;
        inner_spacing  = _inner_spacing.fixedflag ?  ((void)(0), inner_spacing) : 0;
    }
    if (post_spacing < 0)
    {
        inner_spacing  = _inner_spacing.fixedflag ?  ((void)(post_spacing), inner_spacing) : inner_spacing+post_spacing;
        post_spacing  = _post_spacing.fixedflag ?  ((void)(0), post_spacing) : 0;
    }
    if (inner_spacing < 0 || post_spacing < 0)
    {
        return FAILURE;
    }

    slquant_in_ti  = _slquant_in_ti.fixedflag ?    ((void)(n1-1), slquant_in_ti) : n1-1;
    ir_time_total  = _ir_time_total.fixedflag ?              ((void)(RUP_GRD(act_ti+pw_gzrf0a+hrf0-t_exa+tlead+GRAD_UPDATE_TIME)), ir_time_total) : RUP_GRD(act_ti+pw_gzrf0a+hrf0-t_exa+tlead+GRAD_UPDATE_TIME);
    dummyslices  = _dummyslices.fixedflag ?  ((void)(dn2), dummyslices) : dn2;
    slquant_per_trig  = _slquant_per_trig.fixedflag ?  ((void)(dummyslices), slquant_per_trig) : slquant_per_trig+dummyslices;
    seqtime_t1flair  = _seqtime_t1flair.fixedflag ?    ((void)(RUP_GRD(t1+t2)), seqtime_t1flair) : RUP_GRD(t1+t2);
    if(debug_t1flairenh){
#ifdef PSD_HW
        dbgfn = fopen("/usr/g/service/log/t1flair_debug_info","a+");
#else
        dbgfn = fopen("t1flair_debug_info","a+");
#endif
        if (dbgfn != NULL)
        {
            fprintf(dbgfn, "maxTI=%f, maxn2=%d, maxn2_acq1=%d, maxn2_acq2=%d\n", maxTI, maxn2, maxn2_acq1, maxn2_acq2);
            fprintf(dbgfn, "t1 = %d t2=%d act_ti = %d act_tr = %d innerspacing = %d post_spacing = %d\n",
                    (int)t1, (int)t2, (int)act_ti, (int)act_tr, (int)inner_spacing, (int)post_spacing);
            fprintf(dbgfn, "slquant_inti = %d ir_time_total=%d avmaxsl = %d slpertrig = %d dummysli= %d seqtime=%d acq = %d\n",
                    slquant_in_ti, (int)ir_time_total, avmaxslquant, slquant_per_trig, dummyslices, (int)seqtime_t1flair, acqs);
            fprintf(dbgfn, "avmaxti_t1flair =%d avminti_t1flair = %d\n", (int)avmaxti_t1flair, (int)avminti_t1flair);
            fclose(dbgfn);
        }
    }
    return SUCCESS;
}


STATUS
T1flair_analytical_AutoTR(int tmpnumAcqs)
{
    double minTR, mint1, mint2, t1Excite, t2Excite, ti, t1, t2, tr, TRbot, TRup, TIup, TIbot, crossptTR, R, Rup, Rbot, cutoffResidue, curResidue, prevTR, contrastCurveTI;
    int maxn1, n2, n1, n2Acq, curn1, curn2, noSolution, numAcqs;
    FILE *dbgfn;

    minTR = FMax(3, (double)tmin_total, (double)(avmintr), (double)avmintr_autotr_t1flair);
    mint1 = tmin_total_ir;
    mint2 = tmin_total_acq_seq;
    t1Excite = RUP_GRD(GRAD_UPDATE_TIME + tlead + hrf0 +
                       IMax (2, (48   + pw_gzrf0a), minimumPreRfSspTime() - psd_rf_wait));
    t2Excite = sp_sattime + cs_sattime + satdelay + pw_gzrf1a + hrf1a;
    mint1 = mint1 - t1Excite + t2Excite;
    mint2 = mint2 - t2Excite + t1Excite;

    /*HCSDM00388564, for STIR-DWI, only allow changing ti when opautoti is ON*/
    if ( (PSD_ON == exist(opdiffuse)) && (exist(opautoti) == PSD_OFF) )
    {
        ti = exist(opti);
    }
    else
    {
        ti = 800000; /* usecs */
    }

    tr = 1000000; /* in usecs */
    TRbot=1;
    TRup =1;

    numAcqs = tmpnumAcqs;
    if (numAcqs <= 0)
        numAcqs = 1;

    /* initialize to user requested numAcqs */
    n2Acq = 1;
    curn1 = 1;
    curn2 = 2;
    noSolution = TRUE;
    while(noSolution) /* numAcq loop */
    {
        TRup = avmaxtr;

        /* n2 without dummy slices in acq */
        n2Acq = (int)ceil((float)(exist(opslquant))/ numAcqs);

        if (PSD_ON == req_edge_slice_enh_flag && n2Acq > 1)
        {
            n2Acq = n2Acq + 2;
            act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_ON), act_edge_slice_enh_flag) : PSD_ON;
        }
        else
        {
            act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), act_edge_slice_enh_flag) : PSD_OFF;
        }

        n2 = n2Acq;

        while(TRUE) /* n2 loop */
        {
            int no_skip;

            if(numAcqs == 1)
            {
                maxn1 = (int)floor((n2 - 1.0)/ 2.0);
            }
            else
            {
                maxn1 = n2 - 1;
            }

            /* for extreme case, we just set maxn1 to 1 to prevent
             * software from being broken, the image constrast may
             * not be as expected */
            if (maxn1 < 1){
                maxn1 = 1;
            }

            TRbot = n2 * (mint1 + mint2);
            TRbot = FMax(2, minTR, TRbot);
            if(TRbot >= TRup)
            {
                break;
            }

            TIup = getNullTI((int)TRup,
                             (int)TRup - act_esp * exist(opetl),
                             (float)numAcqs * (exist(opslthick) + exist(opslspace)),
                             exist(opslthick)/ gscale_rf1,
                             get_invthick(numAcqs)/ gscale_rf0);

            TIbot = getNullTI((int)TRbot,
                              (int)TRbot - act_esp * exist(opetl),
                              (float)numAcqs * (exist(opslthick) + exist(opslspace)),
                              exist(opslthick)/ gscale_rf1,
                              get_invthick(numAcqs)/ gscale_rf0);

            Rbot = (TIup + mint2)/ TRup;
            Rup = (TIbot + mint2)/ TRbot;

            n1 = maxn1;
            crossptTR = TRup + 1;

            while(n1 > 0)
            {
                R = ((double)n1)/ n2;

                if(R > Rup)
                {
                    if (n1 == 1){
                        /* for this extreme case, the solution is the
                         * minimum TR */
                        crossptTR = TRbot;
                        break;
                    } else {
                        /* the cross point TR is less than minimum TR */
                        n1--;
                        continue;
                    }
                }
                if(R < Rbot)
                {
                    break;
                }

                cutoffResidue = 1000.0; /* in usecs for tr */
                tr = TRup;
                prevTR = TRup;
                curResidue = 100000000;

                /*
                 * Try to find the cross point between the bottom solution
                 * boundary and the IQ curve within the TR limits for a n1
                 * value
                 */
                while(fabs(curResidue) > cutoffResidue)
                {
                    prevTR = tr;
                    contrastCurveTI = getNullTI((int)tr,
                                                (int)tr - act_esp * exist(opetl),
                                                (float)numAcqs * (exist(opslthick) + exist(opslspace)),
                                                exist(opslthick)/ gscale_rf1,
                                                get_invthick(numAcqs)/ gscale_rf0);

                    tr = (contrastCurveTI + mint2)/ R;
                    curResidue = tr - prevTR;
                    if (curResidue > 0 && noSolution == FALSE)
                        break;
                }

                /*
                 * We find a solution within the TR limits
                 */
                crossptTR = tr;
                break; /* out of n1 while loop */

            }

            no_skip = 1;
            if( 1 == numAcqs ){
                if( 1 == force_odd_even_slquant && 0 == n2%2 ){
                    no_skip = 0;
                }

                if( 2 == force_odd_even_slquant && 1 == n2%2 ){
                    no_skip = 0;
                }
            }

            if((crossptTR < TRup)&& 1 == no_skip ) /* slice banding fix for 1 acq*/
            {
                noSolution = FALSE;
                TRup = crossptTR;
                curn2 = n2;
                curn1 = n1;

                /*HCSDM00388564, for STIR-DWI, only allow changing ti when opautoti is ON*/
                if ( (PSD_ON == exist(opdiffuse)) && (exist(opautoti) == PSD_OFF) )
                {
                    ti = exist(opti);
                }
                else
                {
                    ti = getNullTI((int)TRup,
                               (int)TRup - act_esp * exist(opetl),
                               (float)numAcqs * (exist(opslthick) + exist(opslspace)),
                               exist(opslthick)/ gscale_rf1,
                               get_invthick(numAcqs)/ gscale_rf0);
                }

                t1 = ti - TRup * (curn1 - 1.0)/ curn2;
                t2 = TRup * curn1/ curn2 - ti;
                if ((t1 - mint1) <  -1000 || (t2 - mint2) < -1000){
                    noSolution = TRUE;
                }
            }
            n2++;
        }

        if(noSolution)
        {
            numAcqs += 1;
        }

        /* HCSDM00155932 : Defensive fix for infinite loop of numAcqs */
        if(numAcqs > AUTOTR_MAX_NUMACQS)
        {
            return FAILURE; 
        }

    }/* numAcq loop */

    /**
     * Calculate the t1 and t2 time
     */
    t1 = ti - TRup * (curn1 - 1.0)/ curn2;
    t2 = TRup * curn1/ curn2 - ti;

    /**
     * Calculate the CV and property values
     */

    act_ti  = _act_ti.fixedflag ?  ((void)(ti), act_ti) : ti;
    act_tr  = _act_tr.fixedflag ?  ((void)(TRup), act_tr) : TRup;

    /* t1flair_stir: corrected inner_spacing calculation */
    inner_spacing  = _inner_spacing.fixedflag ?        ((void)(t1-mint1+(tmin_total_ir-ir_grad_time)), inner_spacing) : t1-mint1+(tmin_total_ir-ir_grad_time);
    post_spacing  = _post_spacing.fixedflag ?    ((void)(t2-mint2), post_spacing) : t2-mint2; /*TODO*/
    if (inner_spacing < 0)
    {
        post_spacing  = _post_spacing.fixedflag ?  ((void)(inner_spacing), post_spacing) : post_spacing+inner_spacing;
        inner_spacing  = _inner_spacing.fixedflag ?  ((void)(0), inner_spacing) : 0;
    }
    if (post_spacing < 0)
    {
        inner_spacing  = _inner_spacing.fixedflag ?  ((void)(post_spacing), inner_spacing) : inner_spacing+post_spacing;
        post_spacing  = _post_spacing.fixedflag ?  ((void)(0), post_spacing) : 0;
    }
    if (inner_spacing < 0 || post_spacing < 0)
    {
        return FAILURE;
    }
    slquant_in_ti  = _slquant_in_ti.fixedflag ?    ((void)(curn1-1), slquant_in_ti) : curn1-1; /* TODO */
    ir_time_total  = _ir_time_total.fixedflag ?              ((void)(RUP_GRD(act_ti+pw_gzrf0a+hrf0-t_exa+tlead+GRAD_UPDATE_TIME)), ir_time_total) : RUP_GRD(act_ti+pw_gzrf0a+hrf0-t_exa+tlead+GRAD_UPDATE_TIME);
    avmaxslquant = n2Acq;
    slquant_per_trig  = _slquant_per_trig.fixedflag ?  ((void)(curn2), slquant_per_trig) : curn2;
    dummyslices  = _dummyslices.fixedflag ?    ((void)(curn2-ceil((double)exist(opslquant)/numAcqs)), dummyslices) : curn2-ceil((double)exist(opslquant)/numAcqs);

    if (PSD_ON == act_edge_slice_enh_flag)
    {
        avmaxslquant = avmaxslquant - 2;
        dummyslices  = _dummyslices.fixedflag ?    ((void)(dummyslices-2), dummyslices) : dummyslices-2;
    }
    seqtime_t1flair  = _seqtime_t1flair.fixedflag ?    ((void)(RUP_GRD(t1+t2)), seqtime_t1flair) : RUP_GRD(t1+t2);
    acqs  = _acqs.fixedflag ?  ((void)(numAcqs), acqs) : numAcqs;
    avmaxacqs = acqs;

    if(debug_t1flairenh){
#ifdef PSD_HW
        dbgfn = fopen("/usr/g/service/log/t1flair_debug_info","a+");
#else
        dbgfn = fopen("t1flair_debug_info","a+");
#endif
        if (dbgfn != NULL)
        {
            fprintf(dbgfn,"ti = %d TRup = %d curn1 = %d curn2 = %d\n",(int)ti, (int)TRup, curn1, curn2);
            fprintf(dbgfn, "t1 = %d t2=%d act_ti = %d act_tr = %d innerspacing = %d post_spacing = %d\n",
                    (int)t1, (int)t2, (int)act_ti, (int)act_tr, (int)inner_spacing, (int)post_spacing);
            fprintf(dbgfn, "slquant_inti = %d ir_time_total=%d avmaxsl = %d slpertrig = %d dummysli= %d seqtime=%d acq = %d\n",
                    slquant_in_ti, (int)ir_time_total, avmaxslquant, slquant_per_trig, dummyslices, (int)seqtime_t1flair, acqs);
            fprintf(dbgfn, "autotr avmaxti_t1flair =%d avminti_t1flair = %d\n", (int)avmaxti_t1flair, (int)avminti_t1flair);

            fclose(dbgfn);
        }
    }
    return SUCCESS;
}


STATUS
T1flair_analytical_seqtime(void)
{
    if (t1flair_flag == PSD_ON)
    {
        dda_t1flair  = _dda_t1flair.fixedflag ?  ((void)(1), dda_t1flair) : 1;

        T1flair_analytical_ManualTR();

        if ( PSD_ON == t1flair_autotr_flag )
        {
            int currnumacqs, curracttr;
            pitracqnub = 0;
            pitrnub = 6;

            if( isValueSystem() )
            {
                piautotrmode = PSD_AUTO_TR_MODE_IN_RANGE_TR;
            }
            else
            {
                piautotrmode = PSD_AUTO_TR_MODE_ADVANCED_IN_RANGE_TR;
            }

            if (exist(optracq) > 0)
            {
                if (T1flair_analytical_AutoTR(exist(optracq)) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
            }
            currnumacqs = acqs;
            pitracqval2 = 0;
            pitracqval3 = 0;
            pitracqval4 = 0;
            tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
            tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(pitrval3), tr_acq_val3) : pitrval3;
            tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;

            /* if want to exclude unreasonable numacqs (TR very close to
             * numacqs -1, need this part to get currentacttr*/
            curracttr = act_tr;
            if (currnumacqs > 0)
            {
                if (T1flair_analytical_AutoTR(currnumacqs) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
                if (acqs == currnumacqs)
                {
                    curracttr = act_tr;
                }
            }

            if (currnumacqs > 1)
            {
                if (T1flair_analytical_AutoTR(currnumacqs - 1) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
                if (acqs == currnumacqs - 1)
                {
                    tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(act_tr), tr_acq_val2) : act_tr;
                    if( isValueSystem() )
                    { 
                        pitrval2 = (int)tr_acq_val2;
                    }
                    pitracqval2 = acqs;
                    pitracqnub = pitracqnub | 2;
                }
            }
            if (currnumacqs >= 0)
            {
                if (T1flair_analytical_AutoTR(currnumacqs + 1) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
                /*if ((acqs == currnumacqs + 1) && ((int)(fabs((float)act_tr - (float)curracttr)) > 20ms))*//* I want this */
                if (acqs == currnumacqs + 1)
                {
                    tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(act_tr), tr_acq_val4) : act_tr;
                    if( isValueSystem() )
                    {
                        pitrval4 = (int)tr_acq_val4;
                    }
                    pitracqval4 = acqs;
                    pitracqnub = pitracqnub | 8;
                }
            }
            if (currnumacqs > 0)
            {
                if (T1flair_analytical_AutoTR(currnumacqs) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
                if (acqs == currnumacqs)
                {
                    tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(act_tr), tr_acq_val3) : act_tr;
                    if( isValueSystem() )
                    {
                        pitrval3 = (int)tr_acq_val3;
                    }
                    pitracqval3 = acqs;
                    pitracqnub = pitracqnub | 4;
                }
            }
            if(exist(optracq) > 0  && existcv(optracq))
            {
                if (T1flair_analytical_AutoTR(exist(optracq)) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_AutoTR");
                    return FAILURE;
                }
            }
            else
            {
                if (T1flair_analytical_ManualTR() == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"T1flair_analytical_ManualTR");
                    return FAILURE;
                }
            }

            if(exist(opinrangetr) > 0)
            {
                cvoverride(optr,act_tr,PSD_FIX_OFF,PSD_EXIST_ON);
            }
        }
        else /*non auto TR mode */
        {
            pitracqnub = 0;
            pitrnub = 6;
            piautotrmode = PSD_AUTO_TR_MODE_MANUAL_TR;
        }

        if ( exist(opautoti) == PSD_ON || exist(optracq) )
        {
            cvoverride( opti, act_ti, PSD_FIX_ON, PSD_EXIST_ON);
        }

    }
    else
    {
        dda_t1flair  = _dda_t1flair.fixedflag ?  ((void)(0), dda_t1flair) : 0;
    }

    return SUCCESS;
}


STATUS maxslquant1_T2flair( INT Maxslquant, INT *requestedTR, INT null_period, INT Packs, INT acqType, INT seqTimPresc , INT gating)
{
    LONG estcycles;
    LONG repetitionTime;
    float temptr;           /* temporary TR value */
    float tempti;           /* temporary TI value */
    int tempslquant;        /* #slices per pass */
    int tempacqs;           /* temprorary acqs */
    int Nrepeat = 5;

    if( (exist(opflair) == PSD_ON) || (exist(opt2flair) == PSD_ON) )
    {
        int minti;              /* minimum TI for given tempslquant etc. */
        int mintr;              /* minimum TR for given tempslquant, opti etc. */
        int i;
        float temptr0;

        tempslquant = (int)(Maxslquant/ Packs) + ((Maxslquant % Packs) ? 1 : 0);
        if(t2flair_extra_ir_flag == PSD_ON)
        {
            tempslquant = tempslquant + 1;
        }

        temptr = avmintr;
        if(avmintr < max_seqsar * tempslquant)
        {
            temptr = max_seqsar * tempslquant;
        }

        tempacqs = (int)(exist(opslquant)/ Maxslquant) + ((exist(opslquant) % Maxslquant) ? 1 : 0);

        if(exist(opautoti) == PSD_ON && existcv(opautoti) && temptr <= avmaxtr)
        {
            tempti = getNullTI(temptr,
                               temptr - null_period,
                               (float)tempacqs * (exist(opslthick) + exist(opslspace)),
                               exist(opslthick)/ gscale_rf1,
                               get_invthick(tempacqs)/ gscale_rf0);

            minti = (tempslquant - 1) * tmin_flair
                  + sp_sattime + cs_sattime + satdelay + beg_nontetime
                  + (pw_rf0/2 + IMax(2,pw_gzrf0d,pw_gyk0a+pw_gyk0+pw_gyk0d));

            if(autotr_flair_debug == PSD_ON)
            {
                FILE *fp;
                fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                if (NULL != fp){
                    fprintf(fp,"pre:temptr=%f,tempti=%f,minti=%d,tempslquant=%d,tempacqs=%d,tmin_flair=%d\n"
                          ,temptr,tempti,minti,tempslquant,tempacqs,tmin_flair);
                    fclose(fp);
                }
            }

            if(tempti >= minti)
            {
                full_irtime  = _full_irtime.fixedflag ?            ((void)(tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;
                mintr = (full_irtime + time_ssi + tempslquant * tmin_flair) * Packs;

                if(temptr < mintr)
                {
                    temptr = mintr;

                    for(i = 0; i < Nrepeat; i++)
                    {
                        temptr0 = temptr;

                        tempti = getNullTI(temptr,
                                           temptr - null_period,
                                           (float)tempacqs * (exist(opslthick) + exist(opslspace)),
                                           exist(opslthick)/ gscale_rf1,
                                           get_invthick(tempacqs)/ gscale_rf0);

                        full_irtime  = _full_irtime.fixedflag ?            ((void)(tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;
                        temptr = (full_irtime + time_ssi + tempslquant * tmin_flair) * Packs;

                        if(autotr_flair_debug == PSD_ON)
                        {
                            FILE *fp;
                            fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                            if (NULL != fp){
                                fprintf(fp,"tempti>=minti(%d):temptr=%f,tempti=%f,tempslquant=%d\n"
                                      ,i,temptr,tempti,tempslquant);
                                fclose(fp);
                            }
                        }
                    }
                    temptr = temptr + (temptr - temptr0);
                }
            }
            else
            {
                tempti = minti;

                temptr = getNullTR(tempti,
                                   null_period,
                                   (float)tempacqs * (exist(opslthick) + exist(opslspace)),
                                   exist(opslthick)/ gscale_rf1,
                                   get_invthick(tempacqs)/ gscale_rf0);

                tempti = getNullTI(temptr,
                                   temptr - null_period,
                                   (float)tempacqs * (exist(opslthick) + exist(opslspace)),
                                   exist(opslthick)/ gscale_rf1,
                                   get_invthick(tempacqs)/ gscale_rf0);

                if(tempti < minti)
                {
                    tempti = minti;
                }

                full_irtime  = _full_irtime.fixedflag ?            ((void)(tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;
                mintr = (full_irtime + time_ssi + tempslquant * tmin_flair) * Packs;

                if(autotr_flair_debug == PSD_ON)
                {
                    FILE *fp;
                    fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                    if (NULL != fp){
                        fprintf(fp,"post getNullTR() tempti=%f,temptr=%f,mintr=%d\n"
                              ,tempti,temptr,mintr);
                        fclose(fp);
                    }
                }

                if(temptr < mintr)
                {
                    temptr = mintr;

                    for(i = 0; i < Nrepeat; i++)
                    {
                        temptr0 = temptr;

                        tempti = getNullTI(temptr,
                                           temptr - null_period,
                                           (float)tempacqs * (exist(opslthick) + exist(opslspace)),
                                           exist(opslthick)/ gscale_rf1,
                                           get_invthick(tempacqs)/ gscale_rf0);

                        full_irtime  = _full_irtime.fixedflag ?            ((void)(tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : tempti-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;
                        temptr = (full_irtime + time_ssi + tempslquant * tmin_flair) * Packs;

                        if(autotr_flair_debug == PSD_ON)
                        {
                            FILE *fp;
                            fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                            if (NULL != fp){
                                fprintf(fp,"tempti<minti(%d):temptr=%f,tempti=%f,tempslquant=%d\n"
                                      ,i,temptr,tempti,tempslquant);
                                fclose(fp);
                            }
                        }
                    }

                    if(tempti >= minti)
                    {
                        temptr = temptr + (temptr - temptr0);
                    }
                    else
                    {
                        temptr = avmaxtr + 1000000;
                    }
                }
            }
            cvoverride(opti, (int)tempti, PSD_FIX_OFF, PSD_EXIST_ON);
        }
        else if(temptr <= avmaxtr)
        {
            full_irtime  = _full_irtime.fixedflag ?            ((void)(exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime), full_irtime) : exist(opti)-sp_sattime-cs_sattime-satdelay-beg_nontetime+beg_nontitime;
            mintr = (full_irtime + time_ssi + tempslquant * tmin_flair) * Packs;
            if(temptr < mintr)
            {
                temptr = mintr;
            }

            minti = (tempslquant - 1) * tmin_flair
                  + sp_sattime + cs_sattime + satdelay + beg_nontetime
                  + (pw_rf0/2 + IMax(2,pw_gzrf0d,pw_gyk0a+pw_gyk0+pw_gyk0d));
            if(exist(opti) < minti)
            {
                temptr = avmaxtr + 1000000;
            }

            if(autotr_flair_debug == PSD_ON)
            {
                FILE *fp;
                fp = fopen("/usr/g/service/log/autotr_flair.log","a");
                if (NULL != fp){
                    fprintf(fp,"AutoTI off: mintr=%d, temptr=%f\n", mintr, temptr);
                    fclose(fp);
                }
            }
        }

        repetitionTime = ceil(temptr);

        if((TYPCAT == acqType) || (TYPNCAT == acqType))
        {
            if(gating == TRIG_LINE)
            {
                repetitionTime = repetitionTime + TR_SLOP;
                estcycles = (INT)ceil((double)(repetitionTime * cflinfrq/ 1e6));
                repetitionTime = estcycles * 1e6/ cflinfrq;

                if (avround)
                {
                    advroundup(&repetitionTime);
                }

                *requestedTR = repetitionTime;
                return SUCCESS;
            }
            else if(gating == TRIG_INTERN)
            {   /* If TRIG_INTERN for FSE_SPEC_SHEET Cases */

                if (avround)
                {
                    advroundup(&repetitionTime);
                }

                *requestedTR = repetitionTime;
                return SUCCESS;
            }
        }
    }
    return FAILURE;
}


STATUS T2flair_automintr_set_display_acqs( int null_period, int Packs )
{
    int i, tmp_acqs_num;

    if ( ((PSD_ON == exist(opflair)) ||(PSD_ON == exist(opt2flair)))
        && (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) )
    {
        if ( exist(opslquant) && existcv(opslquant) )
        {
            if (exist(optracq) > 0)
            {
                if(slicein1(_sl_acq.fixedflag ? (_temp628_sl_acq=sl_acq,&_temp628_sl_acq) : &sl_acq,exist(optracq) , seq_type) == FAILURE) {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    sl_acq  = _sl_acq.fixedflag ? ((void)(1), sl_acq) : 1;
                    return FAILURE;
                }

                if(maxslquant1_T2flair(sl_acq, _tr_acq.fixedflag ? (_temp629_tr_acq=tr_acq,&_temp629_tr_acq) : &tr_acq, null_period, Packs, seq_type, tmin_total, gating) == FAILURE) {
                    epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_T2flair");
                    return FAILURE;
                }
                keep_opti  = _keep_opti.fixedflag ?  ((void)(exist(opti)), keep_opti) : exist(opti);

                tr_acq  = _tr_acq.fixedflag ?        ((void)((avmintr>tr_acq)?avmintr:tr_acq), tr_acq) : (avmintr>tr_acq)?avmintr:tr_acq;
                tr_acq  = _tr_acq.fixedflag ?         ((void)((avmaxtr>tr_acq)?tr_acq:avmaxtr), tr_acq) : (avmaxtr>tr_acq)?tr_acq:avmaxtr;
                if(tr_acq == avmaxtr)
                {
                    maxslquant(&avmaxslquant, tr_acq, other_slice_limit, seq_type, tmin_total);
                }
                cvoverride(optr,tr_acq,PSD_FIX_OFF,PSD_EXIST_ON);

                /* Recalculate avail_image_time, make sure TR is overridden before calling imgtimutil */
                if(imgtimutil(premid_rf90, seq_type, gating, _avail_image_time.fixedflag ? (_temp630_avail_image_time=avail_image_time,&_temp630_avail_image_time) : &avail_image_time)==FAILURE) {
                    epic_error(use_ermes,"%s failed",EM_PSD_ROUTINE_FAILURE,EE_ARGS(1), STRING_ARG,"imgtimutil");
                    return FAILURE;  /* DCZ: need return FAILURE */
                }
                if (avail_image_time < tmin)
                    avail_image_time  = _avail_image_time.fixedflag ?  ((void)(tmin), avail_image_time) : tmin;

                act_tr  = _act_tr.fixedflag ?  ((void)(avail_image_time), act_tr) : avail_image_time;

                if(tr_acq > avmaxtr)
                {
                    cvoverride(optracq, exist(optracq)+1, PSD_FIX_ON, PSD_EXIST_ON);
                }

                if(maxpass(_acqs.fixedflag ? (_temp631_acqs=acqs,&_temp631_acqs) : &acqs,seq_type,(int)exist(opslquant),avmaxslquant) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxpass");
                    return FAILURE;
                }

                if(slicein1(_slquant_per_trig.fixedflag ? (_temp632_slquant_per_trig=slquant_per_trig,&_temp632_slquant_per_trig) : &slquant_per_trig, acqs , seq_type) == FAILURE) {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    slquant_per_trig  = _slquant_per_trig.fixedflag ? ((void)(1), slquant_per_trig) : 1;
                    return FAILURE;
                }

                if(slquant_per_trig == 0)
                {
                    epic_error(use_ermes,"slquant_per_trig is 0",EM_PSD_SLQUANT_ZERO,0);
                    return FAILURE;
                }
            } /* optracq > 0 */

            pitracqnub = 2+4+8;
            if(avmaxacqs > 1 && ((avmaxacqs-1) <=  _optracq.maxval) )
            {
                tmp_acqs_num = avmaxacqs-1;
                for(i=avmaxacqs-1; i>=1 ;i--)
                {
                    if (slicein1(_sl_acq_val2.fixedflag ? (_temp633_sl_acq_val2=sl_acq_val2,&_temp633_sl_acq_val2) : &sl_acq_val2, i, seq_type) == FAILURE) {
                        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"slicein1");
                        sl_acq_val2  = _sl_acq_val2.fixedflag ? ((void)(1), sl_acq_val2) : 1;
                        return FAILURE;
                    }

                    tmp_acqs_num = ceil(exist(opslquant)/ sl_acq_val2) + ((exist(opslquant)%sl_acq_val2) ? 1:0);
                    if(tmp_acqs_num == i)
                        break;
                }

                if(maxslquant1_T2flair(sl_acq_val2, _tr_acq_val2.fixedflag ? (_temp634_tr_acq_val2=tr_acq_val2,&_temp634_tr_acq_val2) : &tr_acq_val2, null_period, Packs, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_T2flair");
                        return FAILURE;
                }

                if(avmaxacqs > 1)
                {
                    if((exist(opslquant) > (tmp_acqs_num-1)*sl_acq_val2) &&
                       (exist(opslquant) <= tmp_acqs_num * sl_acq_val2) &&
                       (tr_acq_val2 <= avmaxtr) &&
                       (tr_acq_val2 >= avmintr) )  /* MRIhc34158 */
                    {
                        if( isValueSystem() )
                        {
                            pitrval2 = (int) tr_acq_val2;
                        }
                        pitracqval2 = tmp_acqs_num;

                        /* YMSmr08934: do not show 1 acq in case of interleave acquisition */
                        if(pitracqval2==1 && exist(opileave)==PSD_ON)
                        {
                            pitracqval2 = 0;
                            pitracqnub = pitracqnub & ~2 ;
                            tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
                        }
                    } else {
                        pitracqval2 = 0;
                        pitracqnub = pitracqnub & ~2 ;
                        tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
                    }
                }
            } else {
                pitracqval2 = 0;
                pitracqnub = pitracqnub & ~2 ;
                tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
            }

            if(slicein1(_sl_acq_val3.fixedflag ? (_temp635_sl_acq_val3=sl_acq_val3,&_temp635_sl_acq_val3) : &sl_acq_val3, avmaxacqs, seq_type) == FAILURE) {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                sl_acq_val3  = _sl_acq_val3.fixedflag ? ((void)(1), sl_acq_val3) : 1;
                return FAILURE;
            }

            if(maxslquant1_T2flair(sl_acq_val3, _tr_acq_val3.fixedflag ? (_temp636_tr_acq_val3=tr_acq_val3,&_temp636_tr_acq_val3) : &tr_acq_val3, null_period, Packs, seq_type, tmin_total, gating) == FAILURE) {
                epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_T2flair");
                return FAILURE;
            }

            if(avmaxacqs > 0 && ((avmaxacqs) <= _optracq.maxval) )
            {
                if((exist(opslquant) > ((avmaxacqs)-1)*sl_acq_val3) &&
                   (exist(opslquant) <= (avmaxacqs) * sl_acq_val3)  &&
                   (tr_acq_val3 <= avmaxtr) &&
                   (tr_acq_val3 >= avmintr) ) {  /* MRIhc34158 */
                    if( isValueSystem() )
                    {
                        pitrval3 = (int) tr_acq_val3;
                    }
                    pitracqval3 = avmaxacqs;
                } else {
                    pitracqval3 = 0;
                    pitracqnub = pitracqnub & ~4 ;
                    tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(pitrval3), tr_acq_val3) : pitrval3;
                }
            }

            tmp_acqs_num = avmaxacqs+1;
            for(i=avmaxacqs+1; i<=exist(opslquant) ;i++)
            {
                if(slicein1(_sl_acq_val4.fixedflag ? (_temp637_sl_acq_val4=sl_acq_val4,&_temp637_sl_acq_val4) : &sl_acq_val4, i, seq_type) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    sl_acq_val4  = _sl_acq_val4.fixedflag ? ((void)(1), sl_acq_val4) : 1;
                    return FAILURE;
                }

                tmp_acqs_num = ceil(exist(opslquant)/ sl_acq_val4) + ((exist(opslquant)%sl_acq_val4) ? 1:0);
                if(tmp_acqs_num == i)
                    break;
            }

            if(avmaxacqs < exist(opslquant))
            {
                if(maxslquant1_T2flair(sl_acq_val4, _tr_acq_val4.fixedflag ? (_temp638_tr_acq_val4=tr_acq_val4,&_temp638_tr_acq_val4) : &tr_acq_val4, null_period, Packs, seq_type, tmin_total, gating) == FAILURE) {
                    epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_T2flair");
                    return FAILURE;
                }
                if(avmaxacqs > 0 && ((avmaxacqs+1) <= _optracq.maxval) )
                {
                    if((exist(opslquant) > (tmp_acqs_num-1)*sl_acq_val4) &&
                        (exist(opslquant) <= tmp_acqs_num * sl_acq_val4) &&
                        (tr_acq_val4 <= avmaxtr) &&
                        (tr_acq_val4 >= avmintr) ) {  /* MRIhc34158 */
                        if( isValueSystem() )
                        {
                           pitrval4 = (int)tr_acq_val4;
                        }
                        pitracqval4 = tmp_acqs_num;
                    } else {
                        tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
                        pitracqval4 = 0;
                        pitracqnub  = pitracqnub & ~8;
                    }
                }
            } else {
                tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
                pitracqval4 = 0;
                pitracqnub  = pitracqnub & ~8;
            }
            if( exist(optracq) > 0 && existcv(optracq) && exist(opautoti) == PSD_ON ) {
                cvoverride(opti,keep_opti,PSD_FIX_ON,PSD_EXIST_ON);
            }
        }
    } else {
        pitracqval2 = 0;
        pitracqval3 = 0;
        pitracqval4 = 0;
        pitracqnub = 0;
    }

    return SUCCESS;
}


#ifdef __STDC__ 
STATUS DTI_Eval( void )
#else /* !__STDC__ */
STATUS DTI_Eval() 
#endif /* __STDC__ */ 
{
    update_opmintedif();

    optimizedTEFlag  = _optimizedTEFlag.fixedflag ?      ((void)((isRioSystem())?PSD_ON:exist(opmintedif)), optimizedTEFlag) : (isRioSystem())?PSD_ON:exist(opmintedif);

    if( (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON) )
    {
        if((exist(opdfaxx) == PSD_OFF) && (exist(opdfaxy) == PSD_OFF) && (exist(opdfaxz) == PSD_OFF) &&
           (exist(opdfaxtetra) == PSD_OFF) && (exist(opdfax3in1) == PSD_OFF) && (exist(opdfaxall) == PSD_OFF) &&
           (tensor_flag == PSD_OFF))
        {
            float allowed_min_bval;
            float allowed_max_bval = bmax_fixed;

            if ( PSD_OFF == optimizedTEFlag )
            {
                allowed_max_bval = bmax_fixed;
            }
            else
            {
                /* b-value limits based on coil type and slew rate */
                switch ( gCoilType )
                {
                case PSD_CRM_COIL:
                case PSD_XRMB_COIL:
                case PSD_XRMW_COIL:
                case PSD_VRMW_COIL:
                case PSD_HRMW_COIL:
                    allowed_max_bval = MAXB_10000;
                    break;

                case PSD_60_CM_COIL:
                    switch ( cfsrmode )
                    {
                    case PSD_SR100:
                    case PSD_SR120:
                        allowed_max_bval = MAXB_7000;
                        break;
                    case PSD_SR77:
                        allowed_max_bval = MAXB_4000;
                        break;
                    case PSD_SR50:
                        allowed_max_bval = MAXB_2500;
                        break;
                    default:
                        allowed_max_bval = MAXB_1000;
                        break;
                    }
                    break;

                case PSD_BRM2_COIL:
                    switch ( cfsrmode )
                    {
                    case PSD_SR50:
                    case PSD_SR100:
                    case PSD_SR120:
                        allowed_max_bval = MAXB_7000;
                        break;
                    case PSD_SR77:
                        allowed_max_bval = MAXB_4000;
                        break;
                    default:
                        allowed_max_bval = MAXB_1000;
                        break;
                    }
                    break;

                case PSD_TRM_COIL:
                    if ( cfsrmode == PSD_SR77 || ( exist( opgradmode ) == TRM_BODY_COIL && existcv( opgradmode ) ) )
                        allowed_max_bval = MAXB_4000;
                    else if ( cfsrmode == PSD_SR150 || ( exist( opgradmode ) == TRM_ZOOM_COIL && existcv( opgradmode ) ) )
                        allowed_max_bval = MAXB_10000;
                    break;
                default:
                    allowed_max_bval = MAXB_1000;
                    break;
                }
            }

            if (tensor_flag == PSD_ON)
            {
                if ((PSD_XRMB_COIL == gCoilType) || (PSD_XRMW_COIL == gCoilType) || (PSD_VRMW_COIL == gCoilType) || (PSD_HRMW_COIL == gCoilType))
                    allowed_max_bval = FMin(2, allowed_max_bval, (float)MAXB_10000);
                else
                    allowed_max_bval = FMin(2, allowed_max_bval, (float)MAXB_4000);
            }

            allowed_min_bval = MINB_VALUE;
            avminbvalstab = allowed_min_bval;
            avmaxbvalstab = allowed_max_bval;
        }
    }

    if( PSD_ON == tensor_flag ) {

        piuset &= ~use0;
        cvoverride(opuser0, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        cvoverride(rampsamp, PSD_ON, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvoverride(vrgfsamp, PSD_ON, PSD_FIX_OFF, PSD_EXIST_OFF);

        if (!vrgf_bwctrl)
        {
            pircbnub = 0;
        }

        /* Prevent users from selecting interleave w/ tensor */
        if( exist(opileave) == PSD_ON) {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Tensor", STRING_ARG, "Interleaved Slice Spacing" );
            return FAILURE;
        }

        if( exist(opflair) == PSD_ON ) {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "FLAIR OPTION" );
            pitinub = 0;
            return FAILURE;
        }

        if( PSD_ON == navtrig_flag) {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "Navigator" );
            return FAILURE;
        }

        if ((exist(opslquant) > avmaxslquant) && existcv(opslquant))
        {
            epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxslquant );
            return ADVISORY_FAILURE;
        }

        /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support
           below check is already in cvcheck(). Disable it to avoid conflict with autoTR */
        if ( (act_acqs > 1) && (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) ) {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "Multiple acquisitions" );
            return FAILURE;

        }

        /* check for valid number of t2 images */
        if( exist(opdifnumt2) > MAX_T2)  {
            cvoverride(opdifnumt2, MAX_T2, PSD_FIX_ON, PSD_EXIST_ON);
        }

        if( exist(opdifnumt2) < 1)  {
            cvoverride(opdifnumt2, 1, PSD_FIX_ON, PSD_EXIST_ON);
        }
        if (PSD_ON == exist(opresearch)) 
        {
            cvmax(num_tensor, MAX_DIRECTIONS);
        }
        else
        {
            cvmax(num_tensor, act_numdir_clinical);
        }

        num_tensor  = _num_tensor.fixedflag ?  ((void)(exist(opdifnumdirs)), num_tensor) : exist(opdifnumdirs);
        num_B0  = _num_B0.fixedflag ?  ((void)(exist(opdifnumt2)), num_B0) : exist(opdifnumt2);

        if ( (exist(oprtcgate) == PSD_ON) ) { 
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "Respiratory triggering" ); 
            return FAILURE; 
        }

        if ( (exist(opirprep) == PSD_ON) ) { 
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "IR prep" ); 
            return FAILURE; 
        }

        /* Tensor only supports a single b-value */
        pinumbnub = 0;
        avminnumbvals = 1;
        avmaxnumbvals = 1;
        cvoverride(opnumbvals, 1, PSD_FIX_ON, PSD_EXIST_ON);

        opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(0), opautodifnumt2) : 0;
        pidifnumt2nub=15;
        pidifnumt2val2 = 1;
        pidifnumt2val3 = 2;
        pidifnumt2val4 = 3;

        /* Use same NEX for T2 and DW images */
        pidifnext2nub=0;
        avmindifnext2 = difnextab[0];
        avmaxdifnext2 = difnextab[0];
        cvoverride(opdifnext2, difnextab[0], PSD_FIX_ON, PSD_EXIST_ON);

        /*
         * NEED Code for Setting up Header Stamping Here 
         * opuser 20-25 will be used by DTI feature
         * usage_tag.h in /vobs/lx/include has the defn for DTI_PROC
         * rhuser 20,21,22 will be set by recon after reading in tensor.dat
         * 20,21,22 represent the diffusion direction coeffs
         */

        /* Please note that currently opuser 23 and 24 are passed by recon 
         * to TIR..this is because scan needs piuset set for all opusers
         * psd wants to use, else they will not passthrough.
         * Hence recon will set the mapLSW to also pass on 23 and 24 */

        /* Inform recon that we are doing DTI */
        opuser_usage_tag  = _opuser_usage_tag.fixedflag ?  ((void)(DTI_PROC), opuser_usage_tag) : DTI_PROC;
        rhuser_usage_tag  = _rhuser_usage_tag.fixedflag ?  ((void)(DTI_PROC), rhuser_usage_tag) : DTI_PROC;
        rhFillMapMSW  = _rhFillMapMSW.fixedflag ?  ((void)(0), rhFillMapMSW) : 0;
        rhFillMapLSW  = _rhFillMapLSW.fixedflag ?  ((void)(0), rhFillMapLSW) : 0;

        opuser23  = _opuser23.fixedflag ?  ((void)(opdifnumt2), opuser23) : opdifnumt2;
        opuser24  = _opuser24.fixedflag ?  ((void)(opdifnumdirs), opuser24) : opdifnumdirs;
        rhuser23  = _rhuser23.fixedflag ?  ((void)(opdifnumt2), rhuser23) : opdifnumt2;     /* rhuser 23 and 24 needed by recon to read tensor.dat */
        rhuser24  = _rhuser24.fixedflag ?  ((void)(opdifnumdirs), rhuser24) : opdifnumdirs;

        /* MRIge67233 Added functionality to support tensor processing on host */
        rhapp_option  = _rhapp_option.fixedflag ?  ((void)(opdifproctype), rhapp_option) : opdifproctype;
    } 
    else if(exist(opdiffuse) == PSD_ON)
    {
         if(edwi_status == PSD_ON)
         {
             opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(0), opautodifnumt2) : 0;
             pidifnumt2nub=7;
             pidifnumt2val2 = 0;
             pidifnumt2val3 = 1;
             if(exist(opdifnumt2) < 0)
             {
                 cvoverride(opdifnumt2, 0, PSD_FIX_ON, PSD_EXIST_ON);
             }
             else if(exist(opdifnumt2) > 1)
             {
                 cvoverride(opdifnumt2, 1, PSD_FIX_ON, PSD_EXIST_ON);
             }
             if(exist(opdifnumt2) == 0)
             {
                 /* T2 image acquisition off.  Disable NEX for T2 */
                 pidifnext2nub=0;
                 avmindifnext2 = 0.0;
                 avmaxdifnext2 = 0.0;
                 cvoverride(opdifnext2, 0, PSD_FIX_ON, PSD_EXIST_ON);
             }
             else if(exist(opdifnumt2)==1)
             {
                 /* T2 image acquisition on.  Enable NEX for T2 */
                 pidifnext2nub=63;
                 avmindifnext2 = 1.0;
                 avmaxdifnext2 = max_difnex_limit;
                 if( !floatIsInteger(exist(opdifnext2)) )
                 {
                     epic_error(use_ermes, "Fractional NEX is not allowed with this scan.", EM_PSD_FNEX_INCOMPATIBLE, EE_ARGS(0        ));

                     return FAILURE;
                 }
                 if(exist(opdifnext2) < avmindifnext2)
                 {
                     cvoverride(opdifnext2, avmindifnext2, PSD_FIX_ON, PSD_EXIST_ON);
                 }
                 else if(exist(opdifnext2) > avmaxdifnext2)
                 {
                     cvoverride(opdifnext2, avmaxdifnext2, PSD_FIX_ON, PSD_EXIST_ON);
                 }
             }
             pinumbnub=63;
             avminnumbvals = 1;
             avmaxnumbvals = MAX_NUM_BVALS_PSD;
             if(exist(opnumbvals) < avminnumbvals)
             {
                 cvoverride(opnumbvals, avminnumbvals, PSD_FIX_ON, PSD_EXIST_ON);
             }
             else if(exist(opnumbvals) > avmaxnumbvals)
             {
                 cvoverride(opnumbvals, avmaxnumbvals, PSD_FIX_ON, PSD_EXIST_ON);
             }
        }
        else
        {
            /* No eDWI support */
            avmindifnextab = 1.0;
            avmaxdifnextab = max_difnex_limit;

            /* Always acquire single T2 image */
            opautodifnumt2  = _opautodifnumt2.fixedflag ?  ((void)(1), opautodifnumt2) : 1;
            pidifnumt2nub = 0;
            cvoverride(opdifnumt2, 1, PSD_FIX_ON, PSD_EXIST_ON);

            /* Use name NEX for T2 and DW images */ 
            pidifnext2nub = 0;
            cvoverride(opdifnext2, difnextab[0], PSD_FIX_ON, PSD_EXIST_ON);

            /* Only supports 1 b-value */
            pinumbnub = 0;
            cvoverride(opnumbvals, 1, PSD_FIX_ON, PSD_EXIST_ON);
        }
         
    }  /* end opdiffuse check */

    /* dualspinecho option valid for diffusion or tensor, annotation is DSE */
    if ( (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON) ) {
        opuser25  = _opuser25.fixedflag ?  ((void)(dualspinecho_flag), opuser25) : dualspinecho_flag; /* opuser25 should passthrough directly to TIR */      
    }

    if( PSD_ON == weighted_avg_grad && ((opdiffuse == PSD_ON && tensor_flag == PSD_OFF) || 
        (tensor_flag == PSD_ON && num_tensor >= MIN_DTI_DIRECTIONS && 
         ((num_tensor <= act_numdir_clinical) || 
         ((PSD_ON == exist(opresearch)) && (rhtensor_file_number > 0) && (num_tensor <= MAX_DIRECTIONS)))))) 
    {
        if ( FAILURE == set_tensor_orientations() ){
            return FAILURE;
        }
    }

    return SUCCESS;

}  /* end DTI_Eval */

/*
 * Update "Optimzie TE" button label and value
 * */
static STATUS update_opmintedif()
{
    if(isRioSystem())
    {
        if(superG_key_status == PSD_ON)
        { /*if option key exists, shown as Super G, enabled, and default is ON*/
            pimintediflabel = 1;
            pimintedifvis = 1;
            pimintedifnub = 1;
            pimintedifdef = 1;
        }
        else
        { /*if option key does not exist, shown as Super G, in gray, and default is OFF*/
            pimintediflabel = 1;
            pimintedifvis = 1;
            pimintedifnub = 0;
            pimintedifdef = 0;
        }
    }
    else
    {
        /*non-Rio, shown as  Optimize TE, enabled and default ON*/
        pimintediflabel = 0;
        pimintedifvis = 1;
        pimintedifnub = 1;
        pimintedifdef = 1;
    }
    return SUCCESS;
}

/* 
 * Diffusion_Timing:
 *
 * This function is used on the host side to set up the diffusion lobe timing
 * It was moved to a function since the diffusion lobe timing is required to
 * for calculating the min and minfull TEs (avmintecalc()) on the host.  This also
 * sets up the diffusion lobe timing for the dual-spin echo case assuming the ST equ.
 * gives a reasonable timing estimate for the total width of one diffusion lobe.  It turns 
 * this provides more diffusion weighting than prescribed but it is taken care of when the 
 * actual waveforms are integrated in predownload and the dif lobe amps are adjusted.
 *
 */
static STATUS
get_diffusion_time( void )
{
    /***** Diffusion timing ****************************************/ 
    if ((opdiffuse == PSD_ON)|| (tensor_flag == PSD_ON)) {
        int tot_diff_time = 0;
        int Delta_time = 0;
        int pw_diff, pw_diffr; /* local var for calcdelta() */
        float ramp;            /* ramp time for the diff lobes */
        float bvaltemp;
        float bvaltemp_x,bvaltemp_y,bvaltemp_z;
        float gsqrsum;
        float bmax_x, bmax_y, bmax_z; /* in case the b-value is not isotropic */
        float MaxAmpx = loggrd.tx_xyz;
        float MaxAmpy = loggrd.ty_xyz;
        float MaxAmpz = loggrd.tz_xyz;
        float time_to_echo = pw_gxwad+tdaqhxa+pw_gx1_tot;
        float minMaxAmp_log = 0,minMaxAmp = 0;

        INT minRamp;

        minMaxAmp_log = FMin(3,loggrd.tx,loggrd.ty,loggrd.tz);

        derate_diffusion_amplitude(); /* Limiting the scale_all based on the max bval selected */

        if ( use_maxloggrad )
        {
            minMaxAmp = minMaxAmp_log * scale_all;
            MaxAmpx = minMaxAmp_log * scale_all;
            MaxAmpy = minMaxAmp_log * scale_all;
            MaxAmpz = minMaxAmp_log * scale_all;
        }
        else 
        {
            MaxAmpx = loggrd.tx_xyz * scale_all;
            MaxAmpy = loggrd.ty_xyz * scale_all;
            MaxAmpz = loggrd.tz_xyz * scale_all;
        }

        if((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF) || ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
        {
            /* Obl 3in1 opt */
            if (obl_3in1_opt)
            {
                MaxAmpx = target_mpg_inv * scale_all;
                MaxAmpy = target_mpg_inv * scale_all;
                MaxAmpz = target_mpg_inv * scale_all;
            }
            else
            {
                if (isRioSystem() && ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                {
                    MaxAmpx = loggrd.tx_xy * scale_all;
                    MaxAmpy = loggrd.ty_yz * scale_all;
                    MaxAmpz = loggrd.tz_xz * scale_all;
                }
                else
                {
                    MaxAmpx = loggrd.tx_xyz * scale_all;
                    MaxAmpy = loggrd.ty_xyz * scale_all;
                    MaxAmpz = loggrd.tz_xyz * scale_all;
                }
                if( !((mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag)
                    && different_mpg_amp_flag && (opdfax3in1 > PSD_OFF)) )
                {
                    MaxAmpx = FMin(3, MaxAmpx, MaxAmpy, MaxAmpz);
                    MaxAmpy = MaxAmpx;
                    MaxAmpz = MaxAmpx;
                }
            }
        }

        /* MRIhc05854: set temp variable to prescribed bvalue */
        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
        {
            bvaltemp = max_bval/3.0;
        }
        else if ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
        {
            bvaltemp = max_bval/2.0;
        }
        else
        {
            bvaltemp = max_bval;
        }

        if( (mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag) && different_mpg_amp_flag && (opdfax3in1 > PSD_OFF) )
        {
            gsqrsum = MaxAmpx*MaxAmpx + MaxAmpy*MaxAmpy + MaxAmpz*MaxAmpz;
            bvaltemp_x = MaxAmpx*MaxAmpx/  gsqrsum * max_bval;
            bvaltemp_y = MaxAmpy*MaxAmpy/  gsqrsum * max_bval;
            bvaltemp_z = MaxAmpz*MaxAmpz/  gsqrsum * max_bval;
        }
        else
        {
            bvaltemp_x = bvaltemp;
            bvaltemp_y = bvaltemp;
            bvaltemp_z = bvaltemp;
        }

        /* BJM: protect against power supply droop */
        /*      this code may seem redundant but we are calculating the diffusion */
        /*      pulse width assuming full scale amp.  If the duration is larger   */
        /*      than the spec for the CRM (~ 35ms) then the amplitude will be     */
        /*      derated to prevent power supply droop */
        
        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) || ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
        {
            minRamp = loggrd.xrta.xyz*scale_ramp;
        }
        else
        {
            minRamp = loggrd.xrta.x*scale_ramp;
        }

        /*** SVBranch: HCSDM00259119 -  mpg opt ***/
        /* For mpg opt, we may want
           to use the max grad; */
        if(mpg_opt_flag)
        {
            mpg_opt_derate  = _mpg_opt_derate.fixedflag ?      ((void)(mpg_opt_glimit_orig/FMin(3,cfxfs,cfyfs,cfzfs)), mpg_opt_derate) : mpg_opt_glimit_orig/FMin(3,cfxfs,cfyfs,cfzfs);
            MaxAmpx = MaxAmpx * mpg_opt_derate;
            MaxAmpy = MaxAmpy * mpg_opt_derate;
            MaxAmpz = MaxAmpz * mpg_opt_derate;
            if(!isStarterSystem()) minRamp = minRamp * mpg_opt_derate;
        }
        else
        {
            mpg_opt_derate  = _mpg_opt_derate.fixedflag ?  ((void)(1.0), mpg_opt_derate) : 1.0;
        }
        /**********************/        
        
        if( gCoilType == PSD_CRM_COIL ) {
            /* X diffusion pulses */
            if (optramp(_pw_gxdla.fixedflag ? (_temp639_pw_gxdla=pw_gxdla,&_temp639_pw_gxdla) : &pw_gxdla, MaxAmpx, MaxAmpx, minRamp,TYPDEF) == FAILURE) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gxdla" );
                return FAILURE;
            } 
            
            /* store ramp time in pw_diffr */
            pw_diffr = pw_gxdla;
            pw_wgxdl  = _pw_wgxdl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgxdl) : get_sse_waittime();
            pw_wgxdr  = _pw_wgxdr.fixedflag ?  ((void)(4), pw_wgxdr) : 4;

            if (PSD_OFF == dualspinecho_flag)
            {
                Delta_time = pw_wgxdl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgxdr;
            } else {
                /*MRIhc06452 back to CNV4 implementation to avoid the
                 * b-value error for DSE*/ 
                Delta_time = sep_time;
            }

            if (calcdelta(optimizedTEFlag, &pw_diff, &pw_diffr,
                          Delta_time,(INT)bvaltemp, loggrd.tx_xyz) == FAILURE) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calcdelta()" );
                return FAILURE;
            }
            
            /* derate max amplitude by ratio of currents */
            if(pw_diff > MAX_CRM_DW) { 
                MaxAmpx = (FLOAT)loggrd.tx_xyz*(BRM_PEAK_AMP/cfxipeak);
                MaxAmpy = (FLOAT)loggrd.ty_xyz*(BRM_PEAK_AMP/cfyipeak);
                MaxAmpz = (FLOAT)loggrd.tz_xyz*(BRM_PEAK_AMP/cfzipeak);
            }  
        }  /* end CRM coil check */
        
        /* X diffusion pulses */
        if (optramp(_pw_gxdla.fixedflag ? (_temp640_pw_gxdla=pw_gxdla,&_temp640_pw_gxdla) : &pw_gxdla, MaxAmpx, MaxAmpx, minRamp, TYPDEF) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gxdla" );
            return FAILURE;
        }
        
        /* store ramp time in pw_diffr */
        pw_diffr = pw_gxdla;
        pw_wgxdl  = _pw_wgxdl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgxdl) : get_sse_waittime();
        pw_wgxdr  = _pw_wgxdr.fixedflag ?  ((void)(4), pw_wgxdr) : 4;
                  
        if (PSD_OFF == dualspinecho_flag)
        {
            Delta_time = pw_wgxdl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgxdr;
        } else {
            /*MRIhc06452 back to CNV4 implementation to avoid the
             * b-value error in DSE*/
            Delta_time =  sep_time;
        }


        /* BJM - calcdelta() - using the Stejskal-Tanner equ. */
        /*       calculate the min pulse width for the prescribed b-value */
        /*  84 update - added ramps to solution of ST equ. */
        if (calcdelta(optimizedTEFlag, &pw_diff, &pw_diffr,
                      Delta_time,(INT)bvaltemp_x, MaxAmpx) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calcdelta()" );
            return FAILURE;
        }
        
        /* set decay from attack for left lobe */
        pw_gxdla  = _pw_gxdla.fixedflag ?  ((void)(pw_diffr), pw_gxdla) : pw_diffr;
        pw_gxdld  = _pw_gxdld.fixedflag ?  ((void)(pw_gxdla), pw_gxdld) : pw_gxdla;
        a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;
        
        /* set flattop of both diffusion gradient lobes */ 
        pw_gxdl  = _pw_gxdl.fixedflag ?  ((void)(pw_diff-pw_gxdla), pw_gxdl) : pw_diff-pw_gxdla;
        pw_gxdr  = _pw_gxdr.fixedflag ?  ((void)(pw_gxdl), pw_gxdr) : pw_gxdl;
        
        /* set decay and attack for right lobe */
        pw_gxdra  = _pw_gxdra.fixedflag ?  ((void)(pw_diffr), pw_gxdra) : pw_diffr;
        pw_gxdrd  = _pw_gxdrd.fixedflag ?  ((void)(pw_gxdra), pw_gxdrd) : pw_gxdra;
        a_gxdl  = _a_gxdl.fixedflag ?  ((void)(a_gxdr), a_gxdl) : a_gxdr;            
        
        incdifx  = _incdifx.fixedflag ?         ((void)(calc_incdif(_DELTAx.fixedflag ? (_temp641_DELTAx=DELTAx,&_temp641_DELTAx) : &DELTAx,_deltax.fixedflag ? (_temp642_deltax=deltax,&_temp642_deltax) : &deltax,Delta_time,pw_gxdl,pw_gxdld,pw_gxdla,pw_gxdra,bvaltemp_x)), incdifx) : calc_incdif(_DELTAx.fixedflag ? (_temp641_DELTAx=DELTAx,&_temp641_DELTAx) : &DELTAx,_deltax.fixedflag ? (_temp642_deltax=deltax,&_temp642_deltax) : &deltax,Delta_time,pw_gxdl,pw_gxdld,pw_gxdla,pw_gxdra,bvaltemp_x);

        /* MRIge49153 */
        if(incdifx > MaxAmpx)
            incdifx  = _incdifx.fixedflag ?  ((void)(MaxAmpx), incdifx) : MaxAmpx;

        /* BJM MRIge46730: set up the gradient ampltiude for gradient heating */
        /*     calcs use largest diffusion set if multiple b-value scan       */
        a_gxdl  = _a_gxdl.fixedflag ?  ((void)(incdifx), a_gxdl) : incdifx;
        a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;

        /* BJM: DSE timing */
        /* This code  sets up the diffusion lobes for the Dual-Spin Echo case         */
        /* The crude timing diagram is:                                               */
        /*       90 t1 A 180  -B   B  180 A t2 echo     (rough but not too bad)       */
        /*          tau1    tau2   tau3  tau4                                         */
        /*  We want:                                                                  */
        /*                    t1 + A  = B (or tau1 = tau2)                            */
        /*                       or                                                   */
        /*                     B = A + t2 (tau3 = tau4)                               */
        /*                                                                            */
        /*       the latter equ. is more restrictive since the time2echo > rfExIso    */
        /*       We are going to approximate the total diffusion time                 */
        /*       using the non-dual spin echo case (ST equ) to calculate the initial  */
        /*       diffusion time estimate.  Thus, A + B = (pw_gxdl + pw_gxdr)/2        */
        /*       which reduces to A + B = pw_gxdl since pw_gxdl = pw_gxdr             */
        /*       If you plug this in to the last equ. above, then.......              */
        /*                   A = (pw_gxdl - t2)/2                                     */
        /*                                  where t2 = tdaqhxa+gx1 timing             */

        if (PSD_ON == dualspinecho_flag)
        {
            /* 1st dif lobe pair */
            a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(incdifx), a_gxdl1) : incdifx;
            a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-a_gxdl1), a_gxdr1) : -a_gxdl1;

            pw_gxdl1a  = _pw_gxdl1a.fixedflag ?  ((void)(pw_diffr), pw_gxdl1a) : pw_diffr;
            pw_gxdl1d  = _pw_gxdl1d.fixedflag ?  ((void)(pw_gxdl1a), pw_gxdl1d) : pw_gxdl1a;

            pw_gxdl1  = _pw_gxdl1.fixedflag ?     ((void)(RUP_GRD((pw_gxdl-time_to_echo)/2)), pw_gxdl1) : RUP_GRD((pw_gxdl-time_to_echo)/2);

            pw_gxdr1a  = _pw_gxdr1a.fixedflag ?  ((void)(pw_diffr), pw_gxdr1a) : pw_diffr;
            pw_gxdr1d  = _pw_gxdr1d.fixedflag ?  ((void)(pw_gxdr1a), pw_gxdr1d) : pw_gxdr1a;

            pw_gxdr1  = _pw_gxdr1.fixedflag ?    ((void)(RUP_GRD(pw_gxdl-pw_gxdl1)), pw_gxdr1) : RUP_GRD(pw_gxdl-pw_gxdl1);

            tot_diff_time = pw_gxdl1 + pw_gxdr1;
 
            if(pw_gxdl1 < min180_echo_tim2) {
                pw_gxdl1  = _pw_gxdl1.fixedflag ?  ((void)(min180_echo_tim2), pw_gxdl1) : min180_echo_tim2;
                pw_gxdr1  = _pw_gxdr1.fixedflag ?     ((void)(tot_diff_time-pw_gxdl1), pw_gxdr1) : tot_diff_time-pw_gxdl1;
                if(pw_gxdr1 < GRAD_UPDATE_TIME)
                {
                    pw_gxdl1  = _pw_gxdl1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gxdl1) : RUP_GRD(tot_diff_time/2);
                    pw_gxdr1  = _pw_gxdr1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gxdl1)), pw_gxdr1) : RUP_GRD(tot_diff_time-pw_gxdl1);
                }
            }
          
            /* second pair */
            a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(incdifx), a_gxdl2) : incdifx;
            a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-a_gxdl2), a_gxdr2) : -a_gxdl2;

            pw_gxdr2a  = _pw_gxdr2a.fixedflag ?  ((void)(pw_diffr), pw_gxdr2a) : pw_diffr;
            pw_gxdr2d  = _pw_gxdr2d.fixedflag ?  ((void)(pw_gxdr2a), pw_gxdr2d) : pw_gxdr2a;

            pw_gxdr2  = _pw_gxdr2.fixedflag ?    ((void)(RUP_GRD((pw_gxdr-time_to_echo)/2)), pw_gxdr2) : RUP_GRD((pw_gxdr-time_to_echo)/2);

            pw_gxdl2a  = _pw_gxdl2a.fixedflag ?  ((void)(pw_diffr), pw_gxdl2a) : pw_diffr;
            pw_gxdl2d  = _pw_gxdl2d.fixedflag ?  ((void)(pw_gxdl2a), pw_gxdl2d) : pw_gxdl2a;

            pw_gxdl2  = _pw_gxdl2.fixedflag ?    ((void)(RUP_GRD(pw_gxdr-pw_gxdr2)), pw_gxdl2) : RUP_GRD(pw_gxdr-pw_gxdr2);

            tot_diff_time = pw_gxdl2 + pw_gxdr2;
 
            if(pw_gxdr2 < min180_echo_tim) {
                pw_gxdr2  = _pw_gxdr2.fixedflag ?  ((void)(min180_echo_tim), pw_gxdr2) : min180_echo_tim;
                pw_gxdl2  = _pw_gxdl2.fixedflag ?     ((void)(tot_diff_time-pw_gxdr2), pw_gxdl2) : tot_diff_time-pw_gxdr2;
                if(pw_gxdl2< GRAD_UPDATE_TIME)
                {
                    pw_gxdr2  = _pw_gxdr2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gxdr2) : RUP_GRD(tot_diff_time/2);
                    pw_gxdl2  = _pw_gxdl2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gxdr2)), pw_gxdl2) : RUP_GRD(tot_diff_time-pw_gxdr2);
                }
            }

            /*** SVBranch: HCSDM00259119 -  DSE opt ***/
            if (dse_opt_flag)
            {
                Delta_time = GRAD_UPDATE_TIME;
                if ( FAILURE == 
                     dse_opt_timing(bvaltemp, pw_gxdl1, pw_gxdl1a, Delta_time, MaxAmpx) )
                {
                    return FAILURE;                    
                }
                /* round the pulse width to multiple of GRAD_UPDATE_TIME */               
                pw_gxdl1  = _pw_gxdl1.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gxdl1) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gxdr1  = _pw_gxdr1.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gxdr1) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gxdl2  = _pw_gxdl2.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gxdl2) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gxdr2  = _pw_gxdr2.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gxdr2) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
            }
            /************************/            
            
        }
        
        /*** SVBranch: HCSDM00259119 -  mpg opt ***/
        if (mpg_opt_flag) 
        {
            if(FAILURE == mpg_opt_timing(0, Delta_time, MaxAmpx, bvaltemp))
                return FAILURE;
        }    
        /*********************/        
        
        /* Now, get maximum b-value for fixed timing - using old limits */ 
        ramp = (1200/1.0e6);
        
        DELTAx  = _DELTAx.fixedflag ?        ((void)((float)(31000+1200+Delta_time+1200)/1.0e6), DELTAx) : (float)(31000+1200+Delta_time+1200)/1.0e6;
        
        deltax  = _deltax.fixedflag ?    ((void)((float)(31000+1200)/1.0e6), deltax) : (float)(31000+1200)/1.0e6;
        
        /*  84 update - added ramps to solution of ST equ. */
        bmax_x = (MaxAmpx*MaxAmpx/100)*(TWOPI_GAMMA*TWOPI_GAMMA)*
            (deltax*deltax*(DELTAx - deltax/3.0)
             +(ramp*ramp*ramp)/30.0 - deltax*(ramp*ramp)/6.0 );
      
        /*MRIhc05854*/
        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF)  || ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
        {
            minRamp = loggrd.yrta.xyz*scale_ramp;
        }
        else
        {
            minRamp = loggrd.yrta.y*scale_ramp;
        }
        
        /*** SVBranch: HCSDM00259119 -  mpg opt ***/
        if(mpg_opt_flag && (!isStarterSystem())) minRamp = minRamp * mpg_opt_derate;
        /**********************/

        if (optramp(_pw_gydla.fixedflag ? (_temp643_pw_gydla=pw_gydla,&_temp643_pw_gydla) : &pw_gydla, MaxAmpy, MaxAmpy,minRamp , TYPDEF) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gydla" );
            return FAILURE;
	} 
        
        /* store ramp time in pw_diffr */
        pw_diffr = pw_gydla;
        pw_wgydl  = _pw_wgydl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgydl) : get_sse_waittime();
        pw_wgydr  = _pw_wgydr.fixedflag ?  ((void)(4), pw_wgydr) : 4;    
        
        if (PSD_OFF == dualspinecho_flag)
        {
            Delta_time = pw_wgydl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgydr;
        } else {
               /*MRIhc06452 bacl to CNV4 implementation to avoid the
                * b-value error in DSE*/ 
                Delta_time = sep_time;
              }



        /* BJM - calcdelta() - using the Stejskal-Tanner equ. */
        /*       calculate the min pulse width for the prescribed b-value */
        /*  84 update - added ramps to solution of ST equ. */
        if (calcdelta(optimizedTEFlag, &pw_diff, &pw_diffr,
                      Delta_time,(INT)bvaltemp_y, MaxAmpy) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calcdelta()" );
            return FAILURE;
	} 
        
        /* ramps of left lobe */ 
        pw_gydla  = _pw_gydla.fixedflag ?  ((void)(pw_diffr), pw_gydla) : pw_diffr;
        pw_gydld  = _pw_gydld.fixedflag ?  ((void)(pw_gydla), pw_gydld) : pw_gydla;
        
        /* flat top of both lobes */
        pw_gydl  = _pw_gydl.fixedflag ?    ((void)(pw_diff-pw_gydla), pw_gydl) : pw_diff-pw_gydla;
        pw_gydr  = _pw_gydr.fixedflag ?  ((void)(pw_gydl), pw_gydr) : pw_gydl;
        
        /* set ramps for right lobe */
        pw_gydra  = _pw_gydra.fixedflag ?  ((void)(pw_diffr), pw_gydra) : pw_diffr;
        pw_gydrd  = _pw_gydrd.fixedflag ?  ((void)(pw_gydra), pw_gydrd) : pw_gydra;

        pw_wgydl  = _pw_wgydl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgydl) : get_sse_waittime();
        pw_wgydr  = _pw_wgydr.fixedflag ?  ((void)(4), pw_wgydr) : 4;
        
        /* Calculate initial amplitude estimate */

        incdify  = _incdify.fixedflag ?         ((void)(calc_incdif(_DELTAy.fixedflag ? (_temp644_DELTAy=DELTAy,&_temp644_DELTAy) : &DELTAy,_deltay.fixedflag ? (_temp645_deltay=deltay,&_temp645_deltay) : &deltay,Delta_time,pw_gydl,pw_gydld,pw_gydla,pw_gydra,bvaltemp_y)), incdify) : calc_incdif(_DELTAy.fixedflag ? (_temp644_DELTAy=DELTAy,&_temp644_DELTAy) : &DELTAy,_deltay.fixedflag ? (_temp645_deltay=deltay,&_temp645_deltay) : &deltay,Delta_time,pw_gydl,pw_gydld,pw_gydla,pw_gydra,bvaltemp_y);

        /* MRIge49153 */
        if(incdify> MaxAmpy)
            incdify  = _incdify.fixedflag ?  ((void)(MaxAmpy), incdify) : MaxAmpy;
        
        /* Now, get maximum b-value for fixed timing - using old limits */ 
        ramp = (1200/1.0e6);
        
        DELTAy  = _DELTAy.fixedflag ?        ((void)((float)(31000+1200+Delta_time+1200)/1.0e6), DELTAy) : (float)(31000+1200+Delta_time+1200)/1.0e6;
        
        deltay  = _deltay.fixedflag ?    ((void)((float)(31000+1200)/1.0e6), deltay) : (float)(31000+1200)/1.0e6;
        
        /*  84 update - added ramps to solution of ST equ. */
        bmax_y = (MaxAmpy*MaxAmpy/100)*(TWOPI_GAMMA*TWOPI_GAMMA)*
            (deltay*deltay*(DELTAy - deltay/3.0)
             +(ramp*ramp*ramp)/30.0 - deltay*(ramp*ramp)/6.0 );
        
        /* BJM MRIge46730: set up the gradient ampltiude for gradient heating */
        /*     calcs use largest diffusion set if multiple b-value scan       */
        a_gydl  = _a_gydl.fixedflag ?  ((void)(incdify), a_gydl) : incdify;
        a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;
        
        /* BJM: dsp timing */
        if (PSD_ON == dualspinecho_flag)
        {
            /* 1st dif lobe pair */
            a_gydl1  = _a_gydl1.fixedflag ?  ((void)(incdify), a_gydl1) : incdify;
            a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-a_gydl1), a_gydr1) : -a_gydl1;

            pw_gydl1a  = _pw_gydl1a.fixedflag ?  ((void)(pw_diffr), pw_gydl1a) : pw_diffr;
            pw_gydl1d  = _pw_gydl1d.fixedflag ?  ((void)(pw_gydl1a), pw_gydl1d) : pw_gydl1a;

            pw_gydl1  = _pw_gydl1.fixedflag ?    ((void)(RUP_GRD((pw_gydl-time_to_echo)/2)), pw_gydl1) : RUP_GRD((pw_gydl-time_to_echo)/2);

            pw_gydr1a  = _pw_gydr1a.fixedflag ?  ((void)(pw_diffr), pw_gydr1a) : pw_diffr;
            pw_gydr1d  = _pw_gydr1d.fixedflag ?  ((void)(pw_gydr1a), pw_gydr1d) : pw_gydr1a;

            pw_gydr1  = _pw_gydr1.fixedflag ?    ((void)(RUP_GRD(pw_gydr-pw_gydl1)), pw_gydr1) : RUP_GRD(pw_gydr-pw_gydl1);

            tot_diff_time = pw_gydl1 + pw_gydr1;
 
            if(pw_gydl1 < min180_echo_tim2) {
                pw_gydl1  = _pw_gydl1.fixedflag ?  ((void)(min180_echo_tim2), pw_gydl1) : min180_echo_tim2;
                pw_gydr1  = _pw_gydr1.fixedflag ?     ((void)(tot_diff_time-pw_gydl1), pw_gydr1) : tot_diff_time-pw_gydl1;
                if(pw_gydr1 < GRAD_UPDATE_TIME)
                {
                    pw_gydl1  = _pw_gydl1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gydl1) : RUP_GRD(tot_diff_time/2);
                    pw_gydr1  = _pw_gydr1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gydl1)), pw_gydr1) : RUP_GRD(tot_diff_time-pw_gydl1);
                }
            }

            /* second pair */
            a_gydl2  = _a_gydl2.fixedflag ?  ((void)(incdify), a_gydl2) : incdify;
            a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-a_gydl2), a_gydr2) : -a_gydl2;
 
            pw_gydr2a  = _pw_gydr2a.fixedflag ?  ((void)(pw_diffr), pw_gydr2a) : pw_diffr;
            pw_gydr2d  = _pw_gydr2d.fixedflag ?  ((void)(pw_gydr2a), pw_gydr2d) : pw_gydr2a;

            pw_gydr2  = _pw_gydr2.fixedflag ?    ((void)(RUP_GRD((pw_gydr-time_to_echo)/2)), pw_gydr2) : RUP_GRD((pw_gydr-time_to_echo)/2);

            pw_gydl2a  = _pw_gydl2a.fixedflag ?  ((void)(pw_diffr), pw_gydl2a) : pw_diffr;
            pw_gydl2d  = _pw_gydl2d.fixedflag ?  ((void)(pw_gydl2a), pw_gydl2d) : pw_gydl2a;

            pw_gydl2  = _pw_gydl2.fixedflag ?    ((void)(RUP_GRD(pw_gydr-pw_gydr2)), pw_gydl2) : RUP_GRD(pw_gydr-pw_gydr2);

            tot_diff_time = pw_gydl2 + pw_gydr2;
 
            if(pw_gydr2 < min180_echo_tim) {
                pw_gydr2  = _pw_gydr2.fixedflag ?  ((void)(min180_echo_tim), pw_gydr2) : min180_echo_tim;
                pw_gydl2  = _pw_gydl2.fixedflag ?     ((void)(tot_diff_time-pw_gydr2), pw_gydl2) : tot_diff_time-pw_gydr2;
                if(pw_gydl2 < GRAD_UPDATE_TIME)
                {
                    pw_gydr2  = _pw_gydr2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gydr2) : RUP_GRD(tot_diff_time/2);
                    pw_gydl2  = _pw_gydl2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gydr2)), pw_gydl2) : RUP_GRD(tot_diff_time-pw_gydr2);
                }
            }
            
            /*** SVBranch: HCSDM00259119 -  DSE opt ***/
            if (dse_opt_flag)
            {
                Delta_time = GRAD_UPDATE_TIME;
                if ( FAILURE == 
                     dse_opt_timing(bvaltemp, pw_gydl1, pw_gydl1a, Delta_time, MaxAmpy) )
                {
                    return FAILURE;                    
                }
                /* round the pulse width to multiple of GRAD_UPDATE_TIME */
                pw_gydl1  = _pw_gydl1.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gydl1) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gydr1  = _pw_gydr1.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gydr1) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gydl2  = _pw_gydl2.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gydl2) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gydr2  = _pw_gydr2.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gydr2) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
            }
            /************************/            
            
        }

        /*** SVBranch: HCSDM00259119 -  mpg opt ***/
        if (mpg_opt_flag)
        {
            if(FAILURE == mpg_opt_timing(1, Delta_time, MaxAmpy, bvaltemp))
                return FAILURE;
        } 
        /*********************/        
        
        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) || ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
        {
            minRamp = loggrd.zrta.xyz*scale_ramp;
        }
        else
        {
            minRamp = loggrd.zrta.z*scale_ramp;
        }

        /*** mpg opt ***/
        if(mpg_opt_flag && (!isStarterSystem())) minRamp = minRamp * mpg_opt_derate;
        /**********************/        
        
        if (optramp(_pw_gzdla.fixedflag ? (_temp646_pw_gzdla=pw_gzdla,&_temp646_pw_gzdla) : &pw_gzdla, MaxAmpz, MaxAmpz, minRamp, TYPDEF) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp:pw_gzdla" );
            return FAILURE;
	} 
        
        /* store ramp time in pw_diffr */
        pw_diffr = pw_gzdla;
        pw_wgzdl  = _pw_wgzdl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgzdl) : get_sse_waittime();
        pw_wgzdr  = _pw_wgzdr.fixedflag ?  ((void)(4), pw_wgzdr) : 4;    
   
        if (PSD_OFF == dualspinecho_flag)
        {
            Delta_time = pw_wgzdl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgzdr;
        } else {
           /*MRIhc06452 back to the implementation of CNV4 to avoid the
            * b-value error in DSE*/
                Delta_time = sep_time;
              }


           
        /* BJM - calcdelta() - using the Stejskal-Tanner equ. */
        /*       calculate the min pulse width for the prescribed b-value */
        /*  84 update - added ramps to solution of ST equ. */
        if (calcdelta(optimizedTEFlag, &pw_diff, &pw_diffr,
                      Delta_time,(INT)bvaltemp_z, MaxAmpz) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calcdelta()" );
            return FAILURE;
	} 
        
        /* set ramps for left lobe */
        pw_gzdla  = _pw_gzdla.fixedflag ?  ((void)(pw_diffr), pw_gzdla) : pw_diffr;
        pw_gzdld  = _pw_gzdld.fixedflag ?  ((void)(pw_gzdla), pw_gzdld) : pw_gzdla;
        
        /* set flat top for both lobes */
        pw_gzdl  = _pw_gzdl.fixedflag ?    ((void)(pw_diff-pw_gzdla), pw_gzdl) : pw_diff-pw_gzdla;
        pw_gzdr  = _pw_gzdr.fixedflag ?  ((void)(pw_gzdl), pw_gzdr) : pw_gzdl;
        
        /* set ramps for right lobe */
        pw_gzdra  = _pw_gzdra.fixedflag ?  ((void)(pw_diffr), pw_gzdra) : pw_diffr;
        pw_gzdrd  = _pw_gzdrd.fixedflag ?  ((void)(pw_gzdra), pw_gzdrd) : pw_gzdra;

        pw_wgzdl  = _pw_wgzdl.fixedflag ?  ((void)(get_sse_waittime()), pw_wgzdl) : get_sse_waittime();
        pw_wgzdr  = _pw_wgzdr.fixedflag ?  ((void)(4), pw_wgzdr) : 4;
        
        /* Calculate initial amplitude estimate */
        
        incdifz  = _incdifz.fixedflag ?         ((void)(calc_incdif(_DELTAz.fixedflag ? (_temp647_DELTAz=DELTAz,&_temp647_DELTAz) : &DELTAz,_deltaz.fixedflag ? (_temp648_deltaz=deltaz,&_temp648_deltaz) : &deltaz,Delta_time,pw_gzdl,pw_gzdld,pw_gzdla,pw_gzdra,bvaltemp_z)), incdifz) : calc_incdif(_DELTAz.fixedflag ? (_temp647_DELTAz=DELTAz,&_temp647_DELTAz) : &DELTAz,_deltaz.fixedflag ? (_temp648_deltaz=deltaz,&_temp648_deltaz) : &deltaz,Delta_time,pw_gzdl,pw_gzdld,pw_gzdla,pw_gzdra,bvaltemp_z);
	   
        /* MRIge49153 */
        if(incdifz> MaxAmpz)
            incdifz  = _incdifz.fixedflag ?  ((void)(MaxAmpz), incdifz) : MaxAmpz;
        
        /* BJM MRIge46730: set up the gradient ampltiude for gradient heating */
        /*     calcs use largest diffusion set if multiple b-value scan       */
        a_gzdl  = _a_gzdl.fixedflag ?  ((void)(incdifz), a_gzdl) : incdifz;
        a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;
        
        /* BJM: (dsp) get diffusion lobe timing */
        if (PSD_ON == dualspinecho_flag)
        {
            /* 1st dif lobe pair */
            a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(incdifz), a_gzdl1) : incdifz;
            a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-a_gzdl1), a_gzdr1) : -a_gzdl1;

            pw_gzdl1a  = _pw_gzdl1a.fixedflag ?  ((void)(pw_diffr), pw_gzdl1a) : pw_diffr;
            pw_gzdl1d  = _pw_gzdl1d.fixedflag ?  ((void)(pw_gzdl1a), pw_gzdl1d) : pw_gzdl1a;

            pw_gzdl1  = _pw_gzdl1.fixedflag ?    ((void)(RUP_GRD((pw_gzdl-time_to_echo)/2)), pw_gzdl1) : RUP_GRD((pw_gzdl-time_to_echo)/2);

            pw_gzdr1a  = _pw_gzdr1a.fixedflag ?  ((void)(pw_diffr), pw_gzdr1a) : pw_diffr;
            pw_gzdr1d  = _pw_gzdr1d.fixedflag ?  ((void)(pw_gzdr1a), pw_gzdr1d) : pw_gzdr1a;

            pw_gzdr1  = _pw_gzdr1.fixedflag ?    ((void)(RUP_GRD(pw_gzdl-pw_gzdl1)), pw_gzdr1) : RUP_GRD(pw_gzdl-pw_gzdl1);

            tot_diff_time = pw_gzdl1 + pw_gzdr1;
 
            if(pw_gzdl1 < min180_echo_tim2) {
                pw_gzdl1  = _pw_gzdl1.fixedflag ?  ((void)(min180_echo_tim2), pw_gzdl1) : min180_echo_tim2;
                pw_gzdr1  = _pw_gzdr1.fixedflag ?     ((void)(tot_diff_time-pw_gzdl1), pw_gzdr1) : tot_diff_time-pw_gzdl1;
                if(pw_gzdr1 < GRAD_UPDATE_TIME)
                {
                    pw_gzdl1  = _pw_gzdl1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gzdl1) : RUP_GRD(tot_diff_time/2);
                    pw_gzdr1  = _pw_gzdr1.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gzdl1)), pw_gzdr1) : RUP_GRD(tot_diff_time-pw_gzdl1);
                }
            }

            /* second pair */
            a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(incdifz), a_gzdl2) : incdifz;
            a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-a_gzdl2), a_gzdr2) : -a_gzdl2;
       
            pw_gzdr2a  = _pw_gzdr2a.fixedflag ?  ((void)(pw_diffr), pw_gzdr2a) : pw_diffr;
            pw_gzdr2d  = _pw_gzdr2d.fixedflag ?  ((void)(pw_gzdr2a), pw_gzdr2d) : pw_gzdr2a;

            pw_gzdr2  = _pw_gzdr2.fixedflag ?     ((void)(RUP_GRD((pw_gzdr-time_to_echo)/2)), pw_gzdr2) : RUP_GRD((pw_gzdr-time_to_echo)/2);

            pw_gzdl2a  = _pw_gzdl2a.fixedflag ?  ((void)(pw_diffr), pw_gzdl2a) : pw_diffr;
            pw_gzdl2d  = _pw_gzdl2d.fixedflag ?  ((void)(pw_gzdl2a), pw_gzdl2d) : pw_gzdl2a;

            pw_gzdl2  = _pw_gzdl2.fixedflag ?    ((void)(RUP_GRD(pw_gzdr-pw_gzdr2)), pw_gzdl2) : RUP_GRD(pw_gzdr-pw_gzdr2);

            tot_diff_time = pw_gzdl2 + pw_gzdr2;
 
            if(pw_gzdr2 < min180_echo_tim) {
                pw_gzdr2  = _pw_gzdr2.fixedflag ?  ((void)(min180_echo_tim), pw_gzdr2) : min180_echo_tim;
                pw_gzdl2  = _pw_gzdl2.fixedflag ?     ((void)(tot_diff_time-pw_gzdr2), pw_gzdl2) : tot_diff_time-pw_gzdr2;
                if(pw_gzdl2 < GRAD_UPDATE_TIME)
                {
                    pw_gzdr2  = _pw_gzdr2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time/2)), pw_gzdr2) : RUP_GRD(tot_diff_time/2);
                    pw_gzdl2  = _pw_gzdl2.fixedflag ?  ((void)(RUP_GRD(tot_diff_time-pw_gzdr2)), pw_gzdl2) : RUP_GRD(tot_diff_time-pw_gzdr2);
                }
            }
            
            /*** DSE opt ***/
            if (dse_opt_flag)
            {
                Delta_time = GRAD_UPDATE_TIME;            
                if ( FAILURE == 
                     dse_opt_timing(bvaltemp, pw_gzdl1, pw_gzdl1a, Delta_time, MaxAmpz) )
                {
                    return FAILURE;                    
                }
                /* round the pulse width to multiple of GRAD_UPDATE_TIME */
                pw_gzdl1  = _pw_gzdl1.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gzdl1) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gzdr1  = _pw_gzdr1.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gzdr1) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gzdl2  = _pw_gzdl2.fixedflag ?  ((void)((int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gzdl2) : (int)((pw_d2+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
                pw_gzdr2  = _pw_gzdr2.fixedflag ?  ((void)((int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME), pw_gzdr2) : (int)((pw_d1+GRAD_UPDATE_TIME)/GRAD_UPDATE_TIME)*GRAD_UPDATE_TIME;
            }
            /************************/           
           
        }
        
        /*** mpg opt ***/
        if (mpg_opt_flag)
        {
            if(FAILURE == mpg_opt_timing(2, Delta_time, MaxAmpz, bvaltemp))
                return FAILURE;
        }
        /*********************/        

        /* Obl 3in1 opt */
        norot_incdifx  = _norot_incdifx.fixedflag ?  ((void)(incdifx), norot_incdifx) : incdifx;
        norot_incdify  = _norot_incdify.fixedflag ?  ((void)(incdify), norot_incdify) : incdify;
        norot_incdifz  = _norot_incdifz.fixedflag ?  ((void)(incdifz), norot_incdifz) : incdifz;

        /* Now, get maximum b-value for fixed timing using old limits */ 
        ramp = (1200/1.0e6);
        
        DELTAz  = _DELTAz.fixedflag ?        ((void)((float)(31000+1200+Delta_time+1200)/1.0e6), DELTAz) : (float)(31000+1200+Delta_time+1200)/1.0e6;
        
        deltaz  = _deltaz.fixedflag ?    ((void)((float)(31000+1200)/1.0e6), deltaz) : (float)(31000+1200)/1.0e6;
        
        /*  84 update - added ramps to solution of ST equ. */
        bmax_z = (MaxAmpz*MaxAmpz/100)*(TWOPI_GAMMA*TWOPI_GAMMA)*
            (deltaz*deltaz*(DELTAz - deltaz/3.0)
             +(ramp*ramp*ramp)/30.0 - deltaz*(ramp*ramp)/6.0 );

        bmax_fixed  = _bmax_fixed.fixedflag ?     ((void)((INT)FMin(3,bmax_x,bmax_y,bmax_z)), bmax_fixed) : (INT)FMin(3,bmax_x,bmax_y,bmax_z);
        
        /* round this to nearest 100 s/mm2 */
        bmax_fixed  = _bmax_fixed.fixedflag ?  ((void)((int)(100.0*floor((double)bmax_fixed/100.0))), bmax_fixed) : (int)(100.0*floor((double)bmax_fixed/100.0));
    }

    if (PSD_OFF == dualspinecho_flag)
    {
/* original */
		/* 
        xdiff_time1 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_gxdla + pw_gxdl + pw_gxdld + pw_wgxdl : 0);
        xdiff_time2 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_wgxdr + pw_gxdra + pw_gxdr + pw_gxdrd : 0);
        ydiff_time1 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_gydla + pw_gydl + pw_gydld + pw_wgydl : 0);
        ydiff_time2 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_wgydr + pw_gydra + pw_gydr + pw_gydrd : 0);
        zdiff_time1 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_gzdla + pw_gzdl + pw_gzdld + pw_wgzdl : 0);
        zdiff_time2 = (((opdiffuse==1)|| tensor_flag == PSD_ON) ? 
                       pw_wgzdr + pw_gzdra + pw_gzdr + pw_gzdrd : 0);
		*/
	/* granty reset diffusion gradient durations ??? */
	pw_gxdl  = _pw_gxdl.fixedflag ?  ((void)(4*res_gd1), pw_gxdl) : 4*res_gd1;
	pw_gxdr  = _pw_gxdr.fixedflag ?  ((void)(4*res_gd2), pw_gxdr) : 4*res_gd2;
	pw_gydl  = _pw_gydl.fixedflag ?  ((void)(4*res_gd1), pw_gydl) : 4*res_gd1;
	pw_gydr  = _pw_gydr.fixedflag ?  ((void)(4*res_gd2), pw_gydr) : 4*res_gd2;
	pw_gzdl  = _pw_gzdl.fixedflag ?  ((void)(4*res_gd1), pw_gzdl) : 4*res_gd1;
	pw_gzdr  = _pw_gzdr.fixedflag ?  ((void)(4*res_gd2), pw_gzdr) : 4*res_gd2;
	/* granty reset a_g?dl to max amplitude */
	a_gxdl  = _a_gxdl.fixedflag ?  ((void)(loggrd.tx_xyz), a_gxdl) : loggrd.tx_xyz;
	a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;
	a_gydl  = _a_gydl.fixedflag ?  ((void)(loggrd.ty_xyz), a_gydl) : loggrd.ty_xyz;
	a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;
	a_gzdl  = _a_gzdl.fixedflag ?  ((void)(loggrd.tz_xyz), a_gzdl) : loggrd.tz_xyz;
	a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;

	incdifx  = _incdifx.fixedflag ?  ((void)(a_gxdl), incdifx) : a_gxdl;
	incdify  = _incdify.fixedflag ?  ((void)(a_gydl), incdify) : a_gydl;
	incdifz  = _incdifz.fixedflag ?  ((void)(a_gzdl), incdifz) : a_gzdl;

	/* granty set wait pulses to maintain 10 ms between diffusion pulses*/
	pw_wgxdl  = _pw_wgxdl.fixedflag ?        ((void)(RUP_GRD((10000-(pw_gzrf2l1_tot+pw_gzrf2+pw_gzrf2r1_tot))/2)), pw_wgxdl) : RUP_GRD((10000-(pw_gzrf2l1_tot+pw_gzrf2+pw_gzrf2r1_tot))/2);
	pw_wgxdr  = _pw_wgxdr.fixedflag ?  ((void)(pw_wgxdl), pw_wgxdr) : pw_wgxdl;
	pw_wgydl  = _pw_wgydl.fixedflag ?  ((void)(pw_wgxdl), pw_wgydl) : pw_wgxdl;
	pw_wgydr  = _pw_wgydr.fixedflag ?  ((void)(pw_wgxdl), pw_wgydr) : pw_wgxdl;
	pw_wgzdl  = _pw_wgzdl.fixedflag ?  ((void)(pw_wgxdl), pw_wgzdl) : pw_wgxdl;
	pw_wgzdr  = _pw_wgzdr.fixedflag ?  ((void)(pw_wgxdl), pw_wgzdr) : pw_wgxdl;
	/* granty edit since we know the length of the custom diffusion pulses */
	xdiff_time1  = _xdiff_time1.fixedflag ?    ((void)(pw_gxdl+pw_wgxdl), xdiff_time1) : pw_gxdl+pw_wgxdl;
	xdiff_time2  = _xdiff_time2.fixedflag ?    ((void)(pw_gxdr+pw_wgxdr), xdiff_time2) : pw_gxdr+pw_wgxdr;
	ydiff_time1  = _ydiff_time1.fixedflag ?    ((void)(pw_gydl+pw_wgydl), ydiff_time1) : pw_gydl+pw_wgydl;
	ydiff_time2  = _ydiff_time2.fixedflag ?    ((void)(pw_gydr+pw_wgydr), ydiff_time2) : pw_gydr+pw_wgydr;
	zdiff_time1  = _zdiff_time1.fixedflag ?    ((void)(pw_gzdl+pw_wgzdl), zdiff_time1) : pw_gzdl+pw_wgzdl;
	zdiff_time2  = _zdiff_time2.fixedflag ?    ((void)(pw_gzdr+pw_wgzdr), zdiff_time2) : pw_gzdr+pw_wgzdr;
	/* granty set ramp times to zero... */
	pw_gxdla  = _pw_gxdla.fixedflag ?  ((void)(0), pw_gxdla) : 0;
	pw_gxdra  = _pw_gxdra.fixedflag ?  ((void)(0), pw_gxdra) : 0;
	pw_gydla  = _pw_gydla.fixedflag ?  ((void)(0), pw_gydla) : 0;
	pw_gydra  = _pw_gydra.fixedflag ?  ((void)(0), pw_gydra) : 0;
	pw_gzdla  = _pw_gzdla.fixedflag ?  ((void)(0), pw_gzdla) : 0;
	pw_gzdra  = _pw_gzdra.fixedflag ?  ((void)(0), pw_gzdra) : 0;
	pw_gxdld  = _pw_gxdld.fixedflag ?  ((void)(0), pw_gxdld) : 0;
	pw_gxdrd  = _pw_gxdrd.fixedflag ?  ((void)(0), pw_gxdrd) : 0;
	pw_gydld  = _pw_gydld.fixedflag ?  ((void)(0), pw_gydld) : 0;
	pw_gydrd  = _pw_gydrd.fixedflag ?  ((void)(0), pw_gydrd) : 0;
	pw_gzdld  = _pw_gzdld.fixedflag ?  ((void)(0), pw_gzdld) : 0;
	pw_gzdrd  = _pw_gzdrd.fixedflag ?  ((void)(0), pw_gzdrd) : 0;

    } 
    else {
        xdiff_time1  = _xdiff_time1.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gxdl1a+pw_gxdl1+pw_gxdl1d+pw_wgxdl1)+(pw_gxdl2a+pw_gxdl2+pw_gxdl2d+pw_wgxdl2):0)), xdiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gxdl1a+pw_gxdl1+pw_gxdl1d+pw_wgxdl1)+(pw_gxdl2a+pw_gxdl2+pw_gxdl2d+pw_wgxdl2):0);
        xdiff_time2  = _xdiff_time2.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgxdr1+pw_gxdr1a+pw_gxdr1+pw_gxdr1d)+(pw_wgxdr2+pw_gxdr2a+pw_gxdr2+pw_gxdr2d):0)), xdiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgxdr1+pw_gxdr1a+pw_gxdr1+pw_gxdr1d)+(pw_wgxdr2+pw_gxdr2a+pw_gxdr2+pw_gxdr2d):0);
        ydiff_time1  = _ydiff_time1.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gydl1a+pw_gydl1+pw_gydl1d+pw_wgydl1)+(pw_gydl2a+pw_gydl2+pw_gydl2d+pw_wgydl2):0)), ydiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gydl1a+pw_gydl1+pw_gydl1d+pw_wgydl1)+(pw_gydl2a+pw_gydl2+pw_gydl2d+pw_wgydl2):0);
        ydiff_time2  = _ydiff_time2.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgydr1+pw_gydr1a+pw_gydr1+pw_gydr1d)+(pw_wgydr2+pw_gydr2a+pw_gydr2+pw_gydr2d):0)), ydiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgydr1+pw_gydr1a+pw_gydr1+pw_gydr1d)+(pw_wgydr2+pw_gydr2a+pw_gydr2+pw_gydr2d):0);
        zdiff_time1  = _zdiff_time1.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gzdl1a+pw_gzdl1+pw_gzdl1d+pw_wgzdl1)+(pw_gzdl2a+pw_gzdl2+pw_gzdl2d+pw_wgzdl2):0)), zdiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_gzdl1a+pw_gzdl1+pw_gzdl1d+pw_wgzdl1)+(pw_gzdl2a+pw_gzdl2+pw_gzdl2d+pw_wgzdl2):0);
        zdiff_time2  = _zdiff_time2.fixedflag ?       
                               
                               ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgzdr1+pw_gzdr1a+pw_gzdr1+pw_gzdr1d)+(pw_wgzdr2+pw_gzdr2a+pw_gzdr2+pw_gzdr2d):0)), zdiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?(pw_wgzdr1+pw_gzdr1a+pw_gzdr1+pw_gzdr1d)+(pw_wgzdr2+pw_gzdr2a+pw_gzdr2+pw_gzdr2d):0);
    }

    return SUCCESS;
} /* end diffusion_timing */

/*
 * Update SSE manual TE Diffusion_Timing:
 *
 * This function is will update pw_wgx(y,z)dl and incdifx(y,z,) for single-spinecho diffusion in manual TE mode
 *
 */
static STATUS update_sse_diffusion_time( void )
{
    int Delta_time;
    float bvaltemp;
    float bvaltemp_x,bvaltemp_y,bvaltemp_z;

    float gsqrsum;

    float MaxAmpx = loggrd.tx_xyz;
    float MaxAmpy = loggrd.ty_xyz;
    float MaxAmpz = loggrd.tz_xyz;

    if(sse_manualte_derating_debug == PSD_ON)
    {
        FILE *fp= NULL;
#ifdef PSD_HW
        const char *dir_log = "/usr/g/service/log";
#else
        const char *dir_log = ".";
#endif
        char fname[255];

        sprintf(fname, "%s/epi2_diffusion_derating.txt", dir_log);
        if ( NULL != (fp = fopen(fname, "w")) )
        {
            fprintf(fp, "Before update_sse_diffusion_time(): \n");
            fprintf(fp, "pw_wgxdl: %d, pw_wgydl:%d, pw_wgzdl:%d \n", pw_wgxdl, pw_wgydl, pw_wgzdl);
            fprintf(fp, "a_gxdl: %f, pw_gxdl:%d\n", a_gxdl, pw_gxdl);
            fprintf(fp, "tmin_total: %d\n\n", tmin_total);

            fclose(fp);
        }
    }

    /***** Update Diffusion timing ****************************************/

    /* MRIhc05854: set temp variable to prescribed bvalue */
    if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
    {
        bvaltemp = max_bval/3.0;
    }
    else if ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
    {
        bvaltemp = max_bval/2.0;
    }
    else
    {
        bvaltemp = max_bval;
    }

    if( (mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag) && different_mpg_amp_flag && (opdfax3in1 > PSD_OFF) )
    {
        gsqrsum = MaxAmpx*MaxAmpx + MaxAmpy*MaxAmpy + MaxAmpz*MaxAmpz;
        bvaltemp_x = MaxAmpx*MaxAmpx/  gsqrsum * max_bval;
        bvaltemp_y = MaxAmpy*MaxAmpy/  gsqrsum * max_bval;
        bvaltemp_z = MaxAmpz*MaxAmpz/  gsqrsum * max_bval;
    }
    else
    {
        bvaltemp_x = bvaltemp;
        bvaltemp_y = bvaltemp;
        bvaltemp_z = bvaltemp;
    }

    int cur_minte;
    if (exist(opte) >= avmintefull)
    {
        cur_minte = avmintefull;
    }
    else
    {
        cur_minte = avminte;
    }

    if(smart_numoverscan == PSD_ON)
    {
        pw_wgxdl  = _pw_wgxdl.fixedflag ?          ((void)(IMax(2,RDN_GRD(get_sse_waittime()+(exist(opte)-cur_minte)/2-psd_rf_wait),4)), pw_wgxdl) : IMax(2,RDN_GRD(get_sse_waittime()+(exist(opte)-cur_minte)/2-psd_rf_wait),4);
        pw_wgydl  = _pw_wgydl.fixedflag ?  ((void)(pw_wgxdl), pw_wgydl) : pw_wgxdl;
        pw_wgzdl  = _pw_wgzdl.fixedflag ?  ((void)(pw_wgxdl), pw_wgzdl) : pw_wgxdl;
    }
    else /*for debug and testing purpose, when smart_numoverscan is OFF*/
    {
        pw_gxdl  = _pw_gxdl.fixedflag ?    ((void)(RDN_GRD((exist(opte)-cur_minte)/2)), pw_gxdl) : pw_gxdl+RDN_GRD((exist(opte)-cur_minte)/2);
        pw_gxdr  = _pw_gxdr.fixedflag ?  ((void)(pw_gxdl), pw_gxdr) : pw_gxdl;

        pw_gydl  = _pw_gydl.fixedflag ?  ((void)(pw_gxdl), pw_gydl) : pw_gxdl;
        pw_gydr  = _pw_gydr.fixedflag ?  ((void)(pw_gydl), pw_gydr) : pw_gydl;

        pw_gzdl  = _pw_gzdl.fixedflag ?  ((void)(pw_gxdl), pw_gzdl) : pw_gxdl;
        pw_gzdr  = _pw_gzdr.fixedflag ?  ((void)(pw_gzdl), pw_gzdr) : pw_gzdl;
    }

    Delta_time = pw_wgxdl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgxdr;

    incdifx  = _incdifx.fixedflag ?         ((void)(calc_incdif(_DELTAx.fixedflag ? (_temp649_DELTAx=DELTAx,&_temp649_DELTAx) : &DELTAx,_deltax.fixedflag ? (_temp650_deltax=deltax,&_temp650_deltax) : &deltax,Delta_time,pw_gxdl,pw_gxdld,pw_gxdla,pw_gxdra,bvaltemp_x)), incdifx) : calc_incdif(_DELTAx.fixedflag ? (_temp649_DELTAx=DELTAx,&_temp649_DELTAx) : &DELTAx,_deltax.fixedflag ? (_temp650_deltax=deltax,&_temp650_deltax) : &deltax,Delta_time,pw_gxdl,pw_gxdld,pw_gxdla,pw_gxdra,bvaltemp_x);

    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(incdifx), a_gxdl) : incdifx;
    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;

    Delta_time = pw_wgydl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgydr;

    incdify  = _incdify.fixedflag ?         ((void)(calc_incdif(_DELTAy.fixedflag ? (_temp651_DELTAy=DELTAy,&_temp651_DELTAy) : &DELTAy,_deltay.fixedflag ? (_temp652_deltay=deltay,&_temp652_deltay) : &deltay,Delta_time,pw_gydl,pw_gydld,pw_gydla,pw_gydra,bvaltemp_y)), incdify) : calc_incdif(_DELTAy.fixedflag ? (_temp651_DELTAy=DELTAy,&_temp651_DELTAy) : &DELTAy,_deltay.fixedflag ? (_temp652_deltay=deltay,&_temp652_deltay) : &deltay,Delta_time,pw_gydl,pw_gydld,pw_gydla,pw_gydra,bvaltemp_y);

    a_gydl  = _a_gydl.fixedflag ?  ((void)(incdify), a_gydl) : incdify;
    a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;

    Delta_time = pw_wgzdl + pw_gzrf2l1_tot + pw_gzrf2 + pw_gzrf2r1_tot + pw_wgzdr;

    incdifz  = _incdifz.fixedflag ?         ((void)(calc_incdif(_DELTAz.fixedflag ? (_temp653_DELTAz=DELTAz,&_temp653_DELTAz) : &DELTAz,_deltaz.fixedflag ? (_temp654_deltaz=deltaz,&_temp654_deltaz) : &deltaz,Delta_time,pw_gzdl,pw_gzdld,pw_gzdla,pw_gzdra,bvaltemp_z)), incdifz) : calc_incdif(_DELTAz.fixedflag ? (_temp653_DELTAz=DELTAz,&_temp653_DELTAz) : &DELTAz,_deltaz.fixedflag ? (_temp654_deltaz=deltaz,&_temp654_deltaz) : &deltaz,Delta_time,pw_gzdl,pw_gzdld,pw_gzdla,pw_gzdra,bvaltemp_z);

    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(incdifz), a_gzdl) : incdifz;
    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;

    xdiff_time1  = _xdiff_time1.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gxdla+pw_gxdl+pw_gxdld+pw_wgxdl:0)), xdiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gxdla+pw_gxdl+pw_gxdld+pw_wgxdl:0);
    xdiff_time2  = _xdiff_time2.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgxdr+pw_gxdra+pw_gxdr+pw_gxdrd:0)), xdiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgxdr+pw_gxdra+pw_gxdr+pw_gxdrd:0);
    ydiff_time1  = _ydiff_time1.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gydla+pw_gydl+pw_gydld+pw_wgydl:0)), ydiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gydla+pw_gydl+pw_gydld+pw_wgydl:0);
    ydiff_time2  = _ydiff_time2.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgydr+pw_gydra+pw_gydr+pw_gydrd:0)), ydiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgydr+pw_gydra+pw_gydr+pw_gydrd:0);
    zdiff_time1  = _zdiff_time1.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gzdla+pw_gzdl+pw_gzdld+pw_wgzdl:0)), zdiff_time1) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_gzdla+pw_gzdl+pw_gzdld+pw_wgzdl:0);
    zdiff_time2  = _zdiff_time2.fixedflag ?      
                ((void)((((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgzdr+pw_gzdra+pw_gzdr+pw_gzdrd:0)), zdiff_time2) : (((opdiffuse==1)||tensor_flag==PSD_ON)?pw_wgzdr+pw_gzdra+pw_gzdr+pw_gzdrd:0);

    if(sse_manualte_derating_debug == PSD_ON)
    {
        FILE *fp= NULL;
#ifdef PSD_HW
        const char *dir_log = "/usr/g/service/log";
#else
        const char *dir_log = ".";
#endif
        char fname[255];

        sprintf(fname, "%s/epi2_diffusion_derating.txt", dir_log);
        if ( NULL != (fp = fopen(fname, "a")) )
        {
            fprintf(fp, "After update_sse_diffusion_time(): \n");
            fprintf(fp, "pw_wgxdl: %d, pw_wgydl:%d, pw_wgzdl:%d \n", pw_wgxdl, pw_wgydl, pw_wgzdl);
            fprintf(fp, "opte: %d, cur_minte: %d, RUP_GRD((exist(opte) - cur_minte)/2):%d \n",exist(opte), cur_minte, RDN_GRD((exist(opte) - cur_minte)/2));
            fprintf(fp, "a_gxdl: %f, pw_gxdl:%d\n\n", a_gxdl, pw_gxdl);
            fprintf(fp, "tmin_total: %d\n", tmin_total);
            fclose(fp);
        }
    }

    return SUCCESS;
} /* end SSE manual TE diffusion_timing */

/* calculate incdifx,y,z */
static FLOAT calc_incdif(float *DELTA, float *delta, int Delta_time, int pw_gdl, int pw_gdld, int pw_gdla, int pw_gdra, float bvaltemp)
{
    float ramp;
    FLOAT incdif;
    *DELTA = (float)(pw_gdl + pw_gdld + Delta_time + pw_gdra)/1.0e6;
    *delta = (float)(pw_gdl + pw_gdla)/1.0e6;
    ramp = pw_gdla/1.0e6;
    /*  84 update - added ramps to solution of ST equ. */
    incdif = 10.0*sqrt((float)bvaltemp/
                        (TWOPI_GAMMA*TWOPI_GAMMA*
                            ((float)*delta * (float)*delta*((float)*DELTA - (float)*delta/3.0)+
                                ((ramp*ramp*ramp)/30.0) - (float)*delta*(ramp*ramp)/6.0 )));
    return incdif;
}

/* Get gap time between the left diffusion gradient lobe and refocusing pulse */
static INT get_sse_waittime(void)
{
    INT waittime;
    float temp_area_gy1; /* HCSDM00194511 */
    int extra_tetime;

    if((exist(opdiffuse) == PSD_OFF) || (dualspinecho_flag == PSD_ON) || (sse_enh == PSD_OFF))
    {
        return 4;
    }

    temp_area_gy1 = area_gy1;
    get_gy1_time();
    area_gy1  = _area_gy1.fixedflag ?  ((void)(temp_area_gy1), area_gy1) : temp_area_gy1;

    get_flowcomp_time();
    extra_tetime = get_extra_dpc_tetime();

    if (gx1pos == PSD_POST_180) {
        avminxa  = _avminxa.fixedflag ?         
                      ((void)(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2)), avminxa) : rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2);
        avminxb  = _avminxb.fixedflag ?               
                          ((void)(8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)), avminxb) : 8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot);
    } else {
        avminxa  = _avminxa.fixedflag ?      ((void)(rfExIso+IMax(2,pw_gx1_tot,pw_gyex1_tot)), avminxa) : rfExIso+IMax(2,pw_gx1_tot,pw_gyex1_tot);
        avminxb  = _avminxb.fixedflag ?      ((void)(tdaqhxa+pw_wgx+pw_rf2/2), avminxb) : tdaqhxa+pw_wgx+pw_rf2/2;
    }
    avminxa  = _avminxa.fixedflag ?  ((void)(extra_tetime), avminxa) : avminxa+extra_tetime;

    if (gy1pos == PSD_POST_180) {
        avminya  = _avminya.fixedflag ?         
                      ((void)(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2)), avminya) : rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2);
        avminyb  = _avminyb.fixedflag ?                
                          ((void)(8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)), avminyb) : 8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot);
    } else {
        avminya  = _avminya.fixedflag ?        ((void)(rfExIso+pw_gyex1_tot+pw_gy1_tot+pw_wgy), avminya) : rfExIso+pw_gyex1_tot+pw_gy1_tot+pw_wgy;
        avminyb  = _avminyb.fixedflag ?        ((void)(pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot)), avminyb) : pw_rf2/2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot);
    }
    avminya  = _avminya.fixedflag ?  ((void)(extra_tetime), avminya) : avminya+extra_tetime;

    avminza  = _avminza.fixedflag ?         
                  ((void)(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2)), avminza) : rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+pw_gzrf2l1_tot+(pw_rf2/2);
    avminzb  = _avminzb.fixedflag ?                 
                      ((void)(8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)), avminzb) : 8+pw_rf2/2+pw_gzrf2r1_tot+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot);
    avminza  = _avminza.fixedflag ?  ((void)(extra_tetime), avminza) : avminza+extra_tetime;

    waittime = IMin(3, (avminxb > avminxa ? RDN_GRD(avminxb-avminxa) : 4),
                       (avminyb > avminya ? RDN_GRD(avminyb-avminya) : 4),
                       (avminzb > avminza ? RDN_GRD(avminzb-avminza) : 4));
    waittime = IMax(2, RDN_GRD(waittime-psd_rf_wait), 4);

    return waittime;
}

static INT 
derate_diffusion_amplitude(void)
{
    if ( ((isRioSystem()) && (exist(opdiffuse)==PSD_ON)) || ((!epi2spec_mode) &&
          ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) ||
          ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))) )
    {
        switch(gCoilType)
        {
        case PSD_HRMW_COIL:
            scale_all  = _scale_all.fixedflag ?  ((void)(1.0), scale_all) : 1.0;

            if (exist(opmintedif) == PSD_OFF)
            {
                if((opdfaxtetra > PSD_OFF)  || (opdfax3in1 > PSD_OFF) ||
                    ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                {
                    scale_gmax = 1.0;
                }
                else if (((opdfaxx > PSD_OFF) || (opdfaxy > PSD_OFF) || (opdfaxz > PSD_OFF)) &&
                    (superG_key_status == PSD_ON) && (opdfaxall == PSD_OFF))
                { /*single direction diffusion, allow spherical derating when superG is available*/
                    float comp_max;
                    comp_max = FMax(3,cfxfs,cfyfs,cfzfs); /*orthogonal plane*/
                    
                    if (exist(opplane) == PSD_OBL)/*oblique plane: calculate the projection of logical Z on the physical axis*/
                    {
                        comp_max *= FMax(3, fabs(scan_info[0].oprot[2]),
                                            fabs(scan_info[0].oprot[5]),
                                            fabs(scan_info[0].oprot[8]));                        
                    }
                    scale_gmax = FMin(2, 1.0, spherical_derating_limit/ comp_max);
                }
                else
                {
                    if (diff_order_flag == 2)
                    {
                        scale_gmax = FMin(2, 1.0, (268.6*pow(max_bval/1000, -0.5389)+613.4)/FMin(3,cfxipeak,cfyipeak,cfzipeak));
                    }
                    else if (diff_order_flag == 1)
                    {
                        scale_gmax = FMin(2, 1.0, (219.6*pow(max_bval/1000, -0.6208)+619.6)/900);
                    }
                    else
                    {
                        scale_gmax = 1.0;
                    }
                }
                scale_all  = _scale_all.fixedflag ?  ((void)(scale_gmax), scale_all) : scale_all*scale_gmax;
            }
            break;
        case PSD_XRMB_COIL:
            if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
            {
                scale_all  = _scale_all.fixedflag ?  ((void)(0.9), scale_all) : 0.9;
            }
            else
            { 
                scale_all  = _scale_all.fixedflag ?  ((void)(0.8), scale_all) : 0.8;
            }
            break;

        case PSD_XRMW_COIL:
            if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
            {
                scale_all  = _scale_all.fixedflag ?  ((void)(0.9), scale_all) : 0.9;
            }
            else
            { 
                scale_all  = _scale_all.fixedflag ?  ((void)(0.75), scale_all) : 0.75;
            }
            break;

        case PSD_VRMW_COIL:
            if( mkgspec_x_gmax_flag || mkgspec_y_gmax_flag || mkgspec_z_gmax_flag )
            {
                scale_all  = _scale_all.fixedflag ?  ((void)(1.0), scale_all) : 1.0;
            }
            else if(PSD_ON == adaptive_mpg_glim_flag)
            {
                scale_all  = _scale_all.fixedflag ?      ((void)(adaptive_mpg_glim/FMin(3,cfxfs,cfyfs,cfzfs)), scale_all) : adaptive_mpg_glim/FMin(3,cfxfs,cfyfs,cfzfs);
            }
            else
            {
                if((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
                {
                    scale_all  = _scale_all.fixedflag ?   ((void)(2.02/3.3), scale_all) : 2.02/3.3;
                }
                else
                {
                    scale_all  = _scale_all.fixedflag ?   ((void)(2.4/3.3), scale_all) : 2.4/3.3;
                }
            }

            break;

        case PSD_TRM_COIL:
            if ( cfsrmode == PSD_SR150 || ( exist( opgradmode ) == TRM_ZOOM_COIL && existcv( opgradmode ) ) )
            {
                if(max_bval <= 700)
                {
                    if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                    {
                        scale_all  = _scale_all.fixedflag ?  ((void)(0.78), scale_all) : 0.78;
                    }
                    else if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                    {
                        scale_all  = _scale_all.fixedflag ?  ((void)(0.9), scale_all) : 0.9;
                    }
                }
                else /* bval > 700 */
                { 
                    if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                    {
                        scale_all  = _scale_all.fixedflag ?  ((void)(0.76), scale_all) : 0.76;
                    }
                    else if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                    {
                        scale_all  = _scale_all.fixedflag ?  ((void)(0.88), scale_all) : 0.88;
                    }
                }
            }
            else
            {
                if ( cfsrmode == PSD_SR77 || ( exist( opgradmode ) == TRM_BODY_COIL && existcv( opgradmode ) ) )
                {
                    if(max_bval <= 700) 
                    {
                        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                        {
                            scale_all  = _scale_all.fixedflag ?  ((void)(0.68), scale_all) : 0.68;
                        }
                        else if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                        {
                            scale_all  = _scale_all.fixedflag ?  ((void)(0.8), scale_all) : 0.8;
                        }
                    }
                    else /* bval > 700 */
                    { 
                        if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                        {
                            scale_all  = _scale_all.fixedflag ?  ((void)(0.68), scale_all) : 0.68;
                        }
                        else if((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                        {
                            scale_all  = _scale_all.fixedflag ?  ((void)(0.78), scale_all) : 0.78;
                        }
                    }
                }
            }
            break;

        case PSD_60_CM_COIL:
        case PSD_BRM2_COIL:
            if(max_bval <=700)
            {
                if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                {
                    scale_all  = _scale_all.fixedflag ?  ((void)(0.7), scale_all) : 0.7;
                }
                else if ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                {
                    scale_all  = _scale_all.fixedflag ?  ((void)(0.8), scale_all) : 0.8;
                }
            }
            else /* bval > 700 */
            {
                if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF ))
                {
                    scale_all  = _scale_all.fixedflag ?  ((void)(0.68), scale_all) : 0.68;
                }
                else if ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
                {
                    scale_all  = _scale_all.fixedflag ?  ((void)(0.8), scale_all) : 0.8;
                }
            }
            break;

        default:
            scale_all  = _scale_all.fixedflag ?  ((void)(1.0), scale_all) : 1.0;
            break;
        }
        if(isStarterSystem() && ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) ||
          ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))))
        {
            scale_all  = _scale_all.fixedflag ?  ((void)(0.818), scale_all) : 0.818;
        }
    }
    else if (epi2spec_mode)
    {
        scale_all  = _scale_all.fixedflag ?  ((void)(1.0), scale_all) : 1.0;
    }
    else
    {
        if (5550 == cfgradamp) /* SSSD */
        {
            if(PSD_ON == adaptive_mpg_glim_flag)
            {
                scale_all  = _scale_all.fixedflag ?      ((void)(adaptive_mpg_glim/FMin(3,cfxfs,cfyfs,cfzfs)), scale_all) : adaptive_mpg_glim/FMin(3,cfxfs,cfyfs,cfzfs);
            }
            else
            {
                scale_all  = _scale_all.fixedflag ?   ((void)(3.16/3.3), scale_all) : 3.16/3.3;
            }
        }
        else
        {
            scale_all  = _scale_all.fixedflag ?  ((void)(1.0), scale_all) : 1.0;
        }
    }

   return SUCCESS;
}

/*
 * BJM 4/25/00 - set_tensor_orientations()
 *
 * This function is designed to either read the tensor directions from a
 * file on disk called tensor.dat (/usr/g/bin) or call calc_orientations()
 * to generate a distribution of points on a hemisphere using a method
 * developed by Joe Zhou and Aziz Poonwalla from MDACC.
 * This function is called @ the end of predownload since we only need
 * this information just prior to download.
 */
static INT
set_tensor_orientations( void )
{
    int read_from_file = PSD_ON;
    int j;

    if( (read_from_file == PSD_ON)  && (tensor_flag == PSD_ON )) {
        FILE *fp;                           /* file pointer */
        char filestring[MAXCHAR];           /* buffer used to open data file */ 
        char compstring[MAXCHAR];           /* buffer used to open data file */ 
        char tempstring[MAXCHAR];           /* buffer to access file */
        int max_chars_per_line = MAXCHAR;   /* lines in tensor.dat header */ 
        int num_tensor_len;
#ifndef SIM
        /* const char *tensor_datapath="/usr/g/bin/";*/ /* path to tensor.dat files - hw  */
        const char *tensor_datapath="/usr/g/research/daiep/qti/";/* path to tensor.dat files - hw  */
		char tensor_datafile[80]; /* filename of tensor.dat file */
        if (rhtensor_file_number == 0)
        {
            sprintf(tensor_datafile, "tensor.dat");
        }
        else 
        {
            sprintf(tensor_datafile, "tensor%d.dat", rhtensor_file_number);
        }
#else /* !SIM */
        const char *tensor_datapath="./";         /* path to tensor.dat files - sim */
        char tensor_datafile[80];                    /* filename of tensor.dat file */

        if (rhtensor_file_number == 0)
        {
            if(PSD_VRMW_COIL == gCoilType)
            {
                sprintf(tensor_datafile, "tensor.dat.VRMW");
            }
            else
            {
                sprintf(tensor_datafile, "tensor.dat.default");
            }
        }
        else 
        { 
            sprintf(tensor_datafile, "tensor%d.dat", rhtensor_file_number);
        }
#endif /* SIM */
        
        /* Check tensor file. Move check here to get the right response to user. */
        if (PSD_ON == exist(opresearch))
        {
            if ( ((0 != rhtensor_file_number) && (rhtensor_file_number < TENSOR_FILE_RSRCH_START))  ||
                    (rhtensor_file_number > TENSOR_FILE_RSRCH_MAX) )
            {
                epic_error( use_ermes, "%s is out of range", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _rhtensor_file_number.descr);
                return FAILURE;
            }
        }
        else
        {   /* Not available in Clinical Mode */
            if ( 0 != rhtensor_file_number )
            {
                epic_error( use_ermes, "%s is out of range", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _rhtensor_file_number.descr);
                return FAILURE;
            }
        }
        
        
        /* Setup for file search - set the number of directions requested */
        sprintf( compstring, "%d", num_tensor );
        num_tensor_len = strlen( compstring );

        /* Set tensor.dat file path and append filename base and suffix */
        strcpy( filestring, tensor_datapath );
        strcat( filestring, tensor_datafile );

        /* Open file */
        if( (fp = fopen( filestring, "r" )) == NULL ) {
            char err_string[300];
            sprintf(err_string, "Can't read %s\n", filestring);
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, err_string );
            validTensorFile  = _validTensorFile.fixedflag ?  ((void)(0), validTensorFile) : 0;
            return ADVISORY_FAILURE;
        }
        validTensorFile  = _validTensorFile.fixedflag ?  ((void)(1), validTensorFile) : 1;

        /*
         * The tensor.dat file is a concatanation of several files.
         * We need to skip over all the lines until we reach the location
         * that stores the "num_tensor" orientations.
         */
        {
            int read_skip = 1;

            while( read_skip ) {
                if (fgets( tempstring, max_chars_per_line, fp ) == NULL)
                {   /* Error response to user if the file cannot be read for the user-desired entry */
                    fclose(fp); /* PWW */
                    epic_error( use_ermes, supfailfmt, 
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "Can't find entry in tensor file");
                    validTensorFileAndEntry  = _validTensorFileAndEntry.fixedflag ?  ((void)(0), validTensorFileAndEntry) : 0;
                    return ADVISORY_FAILURE;
                }
                read_skip = strncmp( compstring, tempstring, num_tensor_len );
            }
            validTensorFileAndEntry  = _validTensorFileAndEntry.fixedflag ?  ((void)(1), validTensorFileAndEntry) : 1;
        }
 
        if(debugTensor == PSD_ON) {
           printf( "Tensor Directions Read (Host) = %d\n", num_tensor );
        }

        /*
         * Next, after reaching the desired point in the file           
         * iterate over num_tensor & put the data in TENSOR_HOST[i][j] 
         */

        /* BJM: assign the T2 images first - want multiple B = 0 images */
        for( j = 0; j < num_B0; ++j ) {
            TENSOR_HOST[0][j] = TENSOR_HOST[1][j] = TENSOR_HOST[2][j] = 0.0;

            if(debugTensor == PSD_ON) {
                printf( "Tensor direction on \n");
                printf( "T2 #%d, X = %f, Y=%f, Z= %f\n", j, TENSOR_HOST[0][j], TENSOR_HOST[1][j], TENSOR_HOST[2][j] );
                fflush( stdout );
            }

        }

        /* Now do the rest of the shots */
        /*  Skip the multiple B = 0 images.  Start at num_B0 plus 1 in
            the TENSOR_HOST[][] array. */
        for ( j = num_B0; j < num_tensor + num_B0; ++j ) {          
            if( fgets( tempstring, MAXCHAR, fp ) == NULL ) { 
                printf( "ERROR: invalid tensor.dat file format!\n" ); 
            }          
            sscanf( tempstring, "%f %f %f", &TENSOR_HOST[0][j], &TENSOR_HOST[1][j], &TENSOR_HOST[2][j] );

            if(debugTensor == PSD_ON) {
                printf( "Shot = %d, X = %f, Y=%f, Z= %f\n", j, TENSOR_HOST[0][j], TENSOR_HOST[1][j], TENSOR_HOST[2][j] );
                fflush( stdout );
            }
        }

        fclose(fp); 

        /*Confirm the magnitude of the vectors are less than MAX_TENSOR_VECTOR_MAG*/
        int i;
        for(i= num_B0; i < num_tensor + num_B0; i++)
        {
            mag[i] = sqrt(TENSOR_HOST[0][i]*TENSOR_HOST[0][i] +
                          TENSOR_HOST[1][i]*TENSOR_HOST[1][i] +
                          TENSOR_HOST[2][i]*TENSOR_HOST[2][i] );

            if (mag[i]> MAX_TENSOR_VECTOR_MAG)
            {
                epic_error( use_ermes, "Support routine %s failed: tensor vectors shall not have magnitudes > 1.0",
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "set_tensor_orientations()" );
                return FAILURE;
            }
        }

        if ( (isRioSystem()) && (num_tensor > MAX_NUM_ITERS))
        {
            tensor_host_sort_flag  = _tensor_host_sort_flag.fixedflag ?  ((void)(PSD_ON), tensor_host_sort_flag) : PSD_ON;
        }
        else
        {
            tensor_host_sort_flag  = _tensor_host_sort_flag.fixedflag ?  ((void)(PSD_OFF), tensor_host_sort_flag) : PSD_OFF;
        }

        if ( (isRioSystem()) && (PSD_ON == tensor_host_sort_flag))
        {
            int status;

            if ( (status = sort_tensor_orientations()) != SUCCESS)
            {
                return status;
            }
        }


    } else if ( (read_from_file == PSD_ON)  && (opdiffuse == PSD_ON) && (tensor_flag == PSD_OFF) && (opdfaxtetra == PSD_OFF) && (opdfax3in1 == PSD_OFF )) 
    { /* DWI */
       for( j = 0; j < opdifnumt2; ++j ) {
            TENSOR_HOST[0][j] = TENSOR_HOST[1][j] = TENSOR_HOST[2][j] = 0.0;

            if(debugTensor == PSD_ON) {
                printf( "Tensor direciton on \n");
                printf( "T2 #%d, X = %f, Y=%f, Z= %f\n", j, TENSOR_HOST[0][j], 
                        TENSOR_HOST[1][j], TENSOR_HOST[2][j] );
                fflush( stdout );
            }

        }
        if( opdfaxall > PSD_OFF ) {
            j = opdifnumt2;

            if(gradopt_diffall == PSD_OFF)
            {
                TENSOR_HOST[0][j] = 1.0;
                TENSOR_HOST[1][j] = 0.0;
                TENSOR_HOST[2][j] = 0.0;
                TENSOR_HOST[0][j+1] = 0.0;
                TENSOR_HOST[1][j+1] = 1.0;
                TENSOR_HOST[2][j+1] = 0.0;
                TENSOR_HOST[0][j+2] = 0.0;
                TENSOR_HOST[1][j+2] = 0.0;
                TENSOR_HOST[2][j+2] = 1.0;
            }
            else
            {
                TENSOR_HOST[0][j] = 1.0;
                TENSOR_HOST[1][j] = 1.0;
                TENSOR_HOST[2][j] = 0.0;
                TENSOR_HOST[0][j+1] = 1.0/sqrt(2.0);
                TENSOR_HOST[1][j+1] = -1.0/sqrt(2.0);
                TENSOR_HOST[2][j+1] = 1.0;
                TENSOR_HOST[0][j+2] = -1.0/sqrt(2.0);
                TENSOR_HOST[1][j+2] = 1.0/sqrt(2.0);
                TENSOR_HOST[2][j+2] = 1.0;
            }
           
        }
        else if( opdfaxx > PSD_OFF ) {
            j = opdifnumt2;

            TENSOR_HOST[0][j] = 1.0;
            TENSOR_HOST[1][j] = 0.0;
            TENSOR_HOST[2][j] = 0.0;
        }
        else if( opdfaxy > PSD_OFF ) {
            j = opdifnumt2;

            TENSOR_HOST[0][j] = 0.0;
            TENSOR_HOST[1][j] = 1.0;
            TENSOR_HOST[2][j] = 0.0;
        }
        else if( opdfaxz > PSD_OFF ) {
            j = opdifnumt2;

            TENSOR_HOST[0][j] = 0.0;
            TENSOR_HOST[1][j] = 0.0;
            TENSOR_HOST[2][j] = 1.0;
        } 
     } else if ( (read_from_file == PSD_ON)  && (opdiffuse == PSD_ON) && (tensor_flag == PSD_OFF) && (opdfaxtetra > PSD_OFF) && (opdfax3in1 == PSD_OFF )) 
     { /* tetrahedral */
         for( j = 0; j < opdifnumt2; ++j ) { 
             TENSOR_HOST[0][j] = TENSOR_HOST[1][j] = TENSOR_HOST[2][j] = 0.0;

             if(debugTensor == PSD_ON) { 
                 printf( "Tensor direciton on \n"); 
                 printf( "T2 #%d, X = %f, Y=%f, Z= %f\n", j, TENSOR_HOST[0][j], 
                         TENSOR_HOST[1][j], TENSOR_HOST[2][j] ); 
                 fflush( stdout ); 
             } 
         } 
         j = opdifnumt2; 
         
         TENSOR_HOST[0][j]   = 1.0; TENSOR_HOST[1][j]   = 1.0; TENSOR_HOST[2][j]   = 1.0; 
         TENSOR_HOST[0][j+1] = 1.0; TENSOR_HOST[1][j+1] =-1.0; TENSOR_HOST[2][j+1] =-1.0; 
         TENSOR_HOST[0][j+2] =-1.0; TENSOR_HOST[1][j+2] =-1.0; TENSOR_HOST[2][j+2] = 1.0; 
         TENSOR_HOST[0][j+3] =-1.0; TENSOR_HOST[1][j+3] = 1.0; TENSOR_HOST[2][j+3] =-1.0; 
     } else if ( (read_from_file == PSD_ON)  && (opdiffuse == PSD_ON) && (tensor_flag == PSD_OFF) && (opdfaxtetra == PSD_OFF) && (opdfax3in1 > PSD_OFF ))
     { /* 3 in 1 */
       for( j = 0; j < opdifnumt2; ++j ) { 
           TENSOR_HOST[0][j] = TENSOR_HOST[1][j] = TENSOR_HOST[2][j] = 0.0;

           if(debugTensor == PSD_ON) { 
               printf( "Tensor direciton on \n"); 
               printf( "T2 #%d, X = %f, Y=%f, Z= %f\n", j, TENSOR_HOST[0][j], 
                       TENSOR_HOST[1][j], TENSOR_HOST[2][j] ); 
               fflush( stdout ); 
           } 
       }

       j = opdifnumt2; 

       TENSOR_HOST[0][j] = 1.0; 
       TENSOR_HOST[1][j] = 1.0; 
       TENSOR_HOST[2][j] = 1.0;

     } else {
        /* Assign the T2 image first */
        TENSOR_HOST[0][0] = TENSOR_HOST[1][0] = TENSOR_HOST[2][0] = 0.0;

        /*
         * BJM: Generate tensor directions by parsing the unit hemisphere.
         *      This is a implmenetation of Aziz and Joe's perl script from
         *      MDACC.
         */
        calc_orientations();
    }
/* granty edit for reading from file to specify diffusion waveform to play*/
    if( (read_from_file == PSD_ON)  && (tensor_flag == PSD_ON )) {
        FILE *fp;                           /* file pointer */
        char filestring[MAXCHAR];           /* buffer used to open data file */ 
        char compstring[MAXCHAR];           /* buffer used to open data file */ 
        char tempstring[MAXCHAR];           /* buffer to access file */
        int max_chars_per_line = MAXCHAR;   /* lines in tensor.dat header */ 
        int num_tensor_len;
#ifndef SIM
        const char *tensor_datapath="/usr/g/research/daiep/qti/";/* path to tensor.dat files - hw  */
        char tensor_datafile[80]; /* filename of tensor.dat file */
        if (rhtensor_file_number == 0)
        {
            sprintf(tensor_datafile, "waveform.dat");
        }
        else 
        {
            sprintf(tensor_datafile, "waveform%d.dat", rhtensor_file_number);
        }
#else /* !SIM */
        const char *tensor_datapath="./";         /* path to tensor.dat files - sim */
        char tensor_datafile[80];                    /* filename of tensor.dat file */

        if (rhtensor_file_number == 0)
        {
            if(PSD_VRMW_COIL == gCoilType)
            {
                sprintf(tensor_datafile, "waveform.dat");
            }
            else
            {
                sprintf(tensor_datafile, "waveform.dat");
            }
        }
        else 
        { 
            sprintf(tensor_datafile, "waveform%d.dat", rhtensor_file_number);
        }
#endif /* SIM */
        
        /* Check tensor file. Move check here to get the right response to user. */
        if (PSD_ON == exist(opresearch))
        {
            if ( ((0 != rhtensor_file_number) && (rhtensor_file_number < TENSOR_FILE_RSRCH_START))  ||
                    (rhtensor_file_number > TENSOR_FILE_RSRCH_MAX) )
            {
                epic_error( use_ermes, "%s is out of range", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _rhtensor_file_number.descr);
                return FAILURE;
            }
        }
        else
        {   /* Not available in Clinical Mode */
            if ( 0 != rhtensor_file_number )
            {
                epic_error( use_ermes, "%s is out of range", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _rhtensor_file_number.descr);
                return FAILURE;
            }
        }
        
        
        /* Setup for file search - set the number of directions requested */
        sprintf( compstring, "%d", num_tensor );
        num_tensor_len = strlen( compstring );

        /* Set tensor.dat file path and append filename base and suffix */
        strcpy( filestring, tensor_datapath );
        strcat( filestring, tensor_datafile );

        /* Open file */
        if( (fp = fopen( filestring, "r" )) == NULL ) {
            char err_string[300];
            sprintf(err_string, "Can't read %s\n", filestring);
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, err_string );
            validTensorFile  = _validTensorFile.fixedflag ?  ((void)(0), validTensorFile) : 0;
            return ADVISORY_FAILURE;
        }
        validTensorFile  = _validTensorFile.fixedflag ?  ((void)(1), validTensorFile) : 1;

        /*
         * The tensor.dat file is a concatanation of several files.
         * We need to skip over all the lines until we reach the location
         * that stores the "num_tensor" orientations.
         */
        {
            int read_skip = 1;

            while( read_skip ) {
                if (fgets( tempstring, max_chars_per_line, fp ) == NULL)
                {   /* Error response to user if the file cannot be read for the user-desired entry */
                    fclose(fp); /* PWW */
                    epic_error( use_ermes, supfailfmt, 
                            EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "Can't find entry in tensor file");
                    validTensorFileAndEntry  = _validTensorFileAndEntry.fixedflag ?  ((void)(0), validTensorFileAndEntry) : 0;
                    return ADVISORY_FAILURE;
                }
                read_skip = strncmp( compstring, tempstring, num_tensor_len );
            }
            validTensorFileAndEntry  = _validTensorFileAndEntry.fixedflag ?  ((void)(1), validTensorFileAndEntry) : 1;
        }
 
        if(debugTensor == PSD_ON) {
           printf( "Waveform Read (Host) = %d\n", num_tensor );
        }

        /*
         * Next, after reaching the desired point in the file           
         * iterate over num_tensor & put the data in TENSOR_HOST[i][j] 
         */

        /* BJM: assign the T2 images first - want multiple B = 0 images */
        for( j = 0; j < num_B0; ++j ) {
            WAVE_HOST[j] = 0.0;

            if(debugTensor == PSD_ON) {
                printf( "T2 #%d, B-tensor rank = %f \n", j, WAVE_HOST[j] );
                fflush( stdout );
            }

        }
		/* maybe granty */
        /* Now do the rest of the shots */
        /*  Skip the multiple B = 0 images.  Start at num_B0 plus 1 in
            the TENSOR_HOST[][] array. */
        for ( j = num_B0; j < num_tensor + num_B0; ++j ) {          
            if( fgets( tempstring, MAXCHAR, fp ) == NULL ) { 
                printf( "ERROR: invalid tensor.dat file format!\n" ); 
            }          
            sscanf( tempstring, "%f", &WAVE_HOST[j] );

            if(debugTensor == PSD_ON) {
                printf( "Shot = %d, B-tensor rank = %f\n", j, WAVE_HOST[j] );
                fflush( stdout );
            }
        }

        fclose(fp); 


     } else {
        /* Assign the T2 image first */
	WAVE_HOST[0] = 0.0;
    }
    return SUCCESS;

}   /* end set_tensor_orientations() */


/*
 * sort_tensor_orientations():
 *
 * This function sorts the amplitudes of TENSOR_HOST vectors and
 * save their indexes in to sort_index array
 *
 */
static INT sort_tensor_orientations(void)
{
    int used_index[MAX_DIRECTIONS + MAX_T2] = {0};

    int i, j, k;
    int max_index = 0;
    float max = 0.0;

    for(i = num_B0; i < num_tensor + num_B0; i++)
    {
        used_index [i] = 0;
    }

    for (j=0; j< num_iters; j++)
    {
        /*find the first untaken element for starting the comparison*/
        for(k= num_B0; k < num_tensor + num_B0; k++)
        {
            if(used_index[k] == 0)
            {
                max = mag[k];
                max_index = k;
                break;
            }
        }
        /*start from the next for searching*/
        for(i= k+1; i < num_tensor + num_B0; i++)
        {
            /*find the largest un-taken one*/
            if((mag[i]> max) && (used_index[i]== 0))
            {
                max = mag[i];
                max_index = i;
            }
        }
        /*save the max index and flag this index as used*/
        sort_index[j] = max_index;
        used_index[max_index] = 1;
    }

    if(tensor_host_sort_debug == PSD_ON)
    {
        FILE *fp2= NULL;

#ifdef PSD_HW
        const char *dir_log = "/usr/g/service/log";
#else
        const char *dir_log = ".";
#endif
        char fname[255];

        sprintf(fname, "%s/tensor_host_sort.log", dir_log);
        if (NULL != (fp2 = fopen(fname, "w")))
        {
            fprintf(fp2,"\n========\n");
            fprintf(fp2, "num_iters = %d \n", num_iters);
            fprintf(fp2, "num_tensor = %d \n", num_tensor);
            fprintf(fp2, "TENSOR_HOST:\n");

            for (i = 0; i< num_B0 + num_tensor; i++)
            {
                fprintf(fp2,"%d: :%2.6f %2.6f %2.6f\n", i,
                        TENSOR_HOST[0][i], TENSOR_HOST[1][i],TENSOR_HOST[2][i]);
            }

            fprintf(fp2,"\nActual order of tensor vectors used in cornerPoints\n");
            fprintf(fp2, "num_iters = %d \n", num_iters);
            fprintf(fp2, "num_tensor = %d \n", num_tensor);

            for (i = 0; i< num_iters; i++)
            {
                fprintf(fp2,"%d: index:%d\t, host:%2.6f %2.6f %2.6f, mag:%1.5f\n", i, sort_index[i],
                        TENSOR_HOST[0][sort_index[i]], TENSOR_HOST[1][sort_index[i]],
                        TENSOR_HOST[2][sort_index[i]], mag[sort_index[i]]);
            }
            fclose(fp2);
        }
    }

    return SUCCESS;

}/* End sort_tensor_orientations() */

/* THIS IS NOT USED BUT IS KEPT FOR HISTORICAL REASONS 
 * WE ARE USING POINTS THAT ARE UNIFORMLY DISTRIBUTED ABOUT A UNIT SPHERE 
 * BJM: this function generates the b-vector orientations via a simple geometric method 
 * the goal is to produce a set of b-vectors that are evenly distributed about the 
 * unit sphere.  This is done by assigning each vector with a solid angle or patch area 
 * on the unit sphere.  The patch area is determined by dividing the solid angle of the 
 * the hemisphere by the number of b-vectors desired.  Using this patch area, the number 
 * latitude increment (theta) is determined.  Each theta defines an area of a spherical 
 * "cap".  The difference in area between caps given by (theta) and (theta+dt) define a 
 * "band" of surface area around the sphere.  Dividing this band of area by the patch area 
 * provides the number of phi increments (vectors for that band).  This process is repeated 
 * until all the vectors are assigned. Note: this process is not perfect but is close enough 
 * for most government work plus its much faster than some non-linear minimization of forces!! 
 * Credits: MDACC's Joe Zhou and Aziz Poonawalla for the original PERL script (thanks guys)
 */
static INT
calc_orientations( void )
{
    int i,j;
    int num_lat, num_phi; 
    int index = 2;                            /* This starts at 2 since t2 and 1st b-vector assigned */

    float area_hemi = TWO_PI;                 /* Area of half unit sphere */
    float area_patch = area_hemi/num_tensor;  /* How much area per vector ? */     
    float Theta = 0.0;                        /* Theta describing each B vector */
    float Phi = 0.0;                          /* Phi describing each B vector */
    float dphi;
    float td, dt;                             /* td: latitude angle, dt: latitude increment */
    float ha, hb, hdiff;                      /* heights of spherical caps and difference */
    float area_cap1, area_cap2, area_band;    /* area of two caps, area_band = the difference */


    td = acos(1 - 1.0/(num_tensor));   /* solve for theta using solid angle formula: */
    /*   2*pi/(num b-vector) = 2*pi(1-cos(theta)) */
    dt = 2*td;                         /* increment will be twice theta */
    num_lat = floor(PI/dt);            /* how many latitude angles should we expect */

    /* recompute the latitude increment */
    dt = (TWO_PI/2.0)/num_lat;

    /* start with first b-vector along z-axis */
    TENSOR_HOST[0][1] =  0.0;  /* X gradient Amp */
    TENSOR_HOST[1][1] =  0.0;  /* Y gradient Amp */
    TENSOR_HOST[2][1] =  1.0;  /* Z gradient Amp */

    if(debugTensor) {
        printf("Shot Number = %d\n",0);
        printf("Theta = %f\n",0.);
        printf("Delta Theta = %f\n", dt);
        printf("Phi = %f\n", 0.);
        printf("Delta Phi = %f\n",0.);
        printf("X-Diffusion Amp = %f\n",TENSOR_HOST[0][0]);
        printf("Y-Diffusion Amp = %f\n",TENSOR_HOST[1][0]);
        printf("Z-Diffusion Amp = %f\n\n",TENSOR_HOST[2][0]);

        printf("Shot Number = %d\n",1);
        printf("Theta = %f\n",0.);
        printf("Delta Theta = %f\n", dt);
        printf("Phi = %f\n", 0.);
        printf("Delta Phi = %f\n",0.);
        printf("X-Diffusion Amp = %f\n",TENSOR_HOST[0][1]);
        printf("Y-Diffusion Amp = %f\n",TENSOR_HOST[1][1]);
        printf("Z-Diffusion Amp = %f\n\n",TENSOR_HOST[2][1]);


    }
    /* loop over the latitudes */
    for (i = 1; i <= num_lat; i++) {      

        /* Increment Theta (T) by an amount dt - since we've assigned z already */
        Theta += dt; 

        /* calc. two heights and their difference using simple geometry */
        ha = cos(Theta);
        hb = cos(Theta+dt);
        hdiff = (ha - hb);

        /* area_a = the surface area of a spherical cap (= 2pi*rad*height) */
        /* and so is area_b with a different height.  The */
        /* difference is the area of a band around the sphere */
        area_cap1 = TWO_PI*(1-ha);
        area_cap2 = TWO_PI*(1-hb);

        /* find the total area of the band */
        area_band = area_cap2 - area_cap1;

        /* now that we have the band area, how many patches will fit? */
        /* this will determine how many phi angles...*/
        num_phi = floor(area_band/area_patch); 
        dphi = TWO_PI/num_phi;

        for(j = 1; j<= num_phi; j++) {

            if(debugTensor) {
                printf("Shot Number = %d\n",index);
                printf("Theta = %f\n",Theta);
                printf("Delta Theta = %f\n", dt);
                printf("Phi = %f\n", Phi);
                printf("Delta Phi = %f\n",dphi);
            }

            TENSOR_HOST[0][index] =  sin(Theta)*cos(Phi);  /* X gradient Amp */
            TENSOR_HOST[1][index] =  sin(Theta)*sin(Phi);  /* Y gradient Amp */
            TENSOR_HOST[2][index] =  cos(Theta);           /* Z gradient Amp */

            if(debugTensor) {
                printf("X-Diffusion Amp = %f\n",TENSOR_HOST[0][index]);
                printf("Y-Diffusion Amp = %f\n",TENSOR_HOST[1][index]);
                printf("Z-Diffusion Amp = %f\n\n",TENSOR_HOST[2][index]);
                fflush(stdout);
            }

            Phi += dphi;   /* increment phi (rad) */
            index++;       /* increment count */
        }

        Phi = 0;  
    }

    return SUCCESS;
}   /* end calc_orientations() */




/*2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */

STATUS automintr_set_display_acqs(void)
{
    if (automintr_set_display_acqs_enh(DUMMY_SLICE_OFF) == FAILURE)
    {
        return FAILURE;
    }
    return SUCCESS;
}

STATUS automintr_set_display_acqs_enh(int dummyslice_type)
{
    /* **********************************************************
     * FIXED_ACQS:The below is calculating the new time.        *
     * Calculate the TRs for n-1,n, n+1 acqs.                   *
     * Pass the Acqs to Slicein1,get slices/pass,use that to    *
     * compute the TR using maxslquant1 defined in maxslquant.c *
     * **********************************************************/

    /*2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
    int i;
    int tmp_acqs_num;

    int multiband_flag = PSD_OFF;
    int multiband_slquant = 1;

    multiband_flag = exist(opmb);
    if (multiband_flag) {
        /* round up */
        multiband_slquant = (INT)((opslquant+(int)opaccel_mb_stride-1)/(int)opaccel_mb_stride);

        /*need to be odd number to avoid signal
         * saturation from ajacent slices*/
        /* In the future, if our rf slice profile is
         * improved or we have a better slice ordering
         * scheme, we can allow multiband_slquant to be even
         * number*/
        multiband_slquant = (multiband_slquant%2)?multiband_slquant:(multiband_slquant+1);
    }
    else{
        multiband_slquant = 1;
    }

    if(piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) {
#ifdef PSD_FSE
        if(PSD_OFF == flair_on ||
           PSD_ON == t1flair_autotr_flag || PSD_ON == t2flair_autotr_flag) {
#endif
            if(fixed_acqs_debug == DEBUG_DEV) {
                printf("\n Entry to FEATURE:piautotrmode = %d optracq  %d,"
                      "optr = %d ,pitrval2 = %d, pitrval3 = %d, "
                      "pitrval4  = %d,tmin_total = %d\n",
                       piautotrmode,exist(optracq),exist(optr),pitrval2,
                       pitrval3,pitrval4,tmin_total);
               fflush(stdout);
            }

            /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
            /* Move the codes of optracq calculation to here         */
            /* to fix legacy auto TR issue happend in SE             */

            if(exist(optracq) > 0  && existcv(optracq))
            {
                int tmp_dummyslice_flag = 0;

                if(slicein1(_sl_acq.fixedflag ? (_temp655_sl_acq=sl_acq,&_temp655_sl_acq) : &sl_acq,exist(optracq) , seq_type) == FAILURE) {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    sl_acq  = _sl_acq.fixedflag ? ((void)(1), sl_acq) : 1;
                    return FAILURE;
                } 
                /* Calculate Time for each pass */
#ifdef PSD_FSE
                if ( !((PSD_ON == t1flair_flag) && (ANALYTICAL_SEQTIME == t1flair_seqtime_method))
                     && !((PSD_ON == t2flair_on) && (PSD_OFF == classic_t2flair_flag)) )
                {
#endif
                    if ((((DUMMY_SLICE_1ACQ == dummyslice_type) && (1 == optracq)) || (DUMMY_SLICE_MULTI_ACQ == dummyslice_type)) && 
                        (0 == (sl_acq%2)))
                    {
                        tmp_dummyslice_flag = 1;
                    }
                    /* ZZ: multiband use multiband_slquant, not opslquant*/
                    if(maxslquant1(multiband_flag?multiband_slquant:(sl_acq+tmp_dummyslice_flag), _tr_acq.fixedflag ? (_temp656_tr_acq=tr_acq,&_temp656_tr_acq) : &tr_acq, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1");
                        return FAILURE;
                    }
#ifdef PSD_FSE
                } else {
                    if(maxslquant1_flair(sl_acq, _tr_acq.fixedflag ? (_temp657_tr_acq=tr_acq,&_temp657_tr_acq) : &tr_acq, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_flair");
                        return FAILURE;
                    }

                    if(t1flair_flag == PSD_ON)
                    {
                        if(tr_acq > avmaxtr)
                            tr_acq  = _tr_acq.fixedflag ?  ((void)(avmaxtr), tr_acq) : avmaxtr;
                        if(tr_acq < avmintr)
                            tr_acq  = _tr_acq.fixedflag ?  ((void)(avmintr), tr_acq) : avmintr;
                    }

                    keep_opti  = _keep_opti.fixedflag ?  ((void)(exist(opti)), keep_opti) : exist(opti);
                }
#endif
                avmaxslquant = sl_acq; /*ZZ: this is the prescribed slices opslquant*/

                /* Calculate TR limit in % to decide if the TR jump is acceptable - TBD */
                tr_limit  = _tr_limit.fixedflag ?     ((void)((int)fabs(((FLOAT)tr_acq-(FLOAT)exist(optr))/(FLOAT)exist(optr))*100), tr_limit) : (int)fabs(((FLOAT)tr_acq-(FLOAT)exist(optr))/(FLOAT)exist(optr))*100;

                if(fixed_acqs_debug == DEBUG_DEV) {
                    printf("\n maxslquant1() for %d Slices is %d\n",sl_acq,tr_acq);
                    printf("\n tr_limit = %d optr = %d tr_acq1 = %d \n",tr_limit,exist(optr),tr_acq);
                    fflush(stdout);
                }

                /* Override TR to the new value */
                tr_acq  = _tr_acq.fixedflag ?        ((void)((avmintr>tr_acq)?avmintr:tr_acq), tr_acq) : (avmintr>tr_acq)?avmintr:tr_acq;
                tr_acq  = _tr_acq.fixedflag ?         ((void)((avmaxtr>tr_acq)?tr_acq:avmaxtr), tr_acq) : (avmaxtr>tr_acq)?tr_acq:avmaxtr;
                if(tr_acq == avmaxtr)
                {
                    maxslquant(&avmaxslquant, tr_acq, other_slice_limit, seq_type, tmin_total);
                    /*ZZ: multiband max number of slices*/
                    /* the mux'ed slices have to be odd number to avoid slice signal saturation*/
                    if (multiband_flag){
                        avmaxslquant = ( (avmaxslquant%2)?avmaxslquant:(avmaxslquant-1) ) * (int)opaccel_mb_stride;
                        if (avmaxslquant > other_slice_limit){
                            int temp_count = other_slice_limit/ (int)opaccel_mb_stride;
                            avmaxslquant = ( (temp_count%2)?temp_count:(temp_count-1) ) * (int)opaccel_mb_stride;
                        }
                    }
                }
                cvoverride(optr,tr_acq,PSD_FIX_OFF,PSD_EXIST_ON);

                /* Recalculate avail_image_time, make sure TR is overridden before calling imgtimutil */
                if(imgtimutil(premid_rf90, seq_type, gating, _avail_image_time.fixedflag ? (_temp658_avail_image_time=avail_image_time,&_temp658_avail_image_time) : &avail_image_time)==FAILURE) {
                    epic_error(use_ermes,"%s failed",EM_PSD_ROUTINE_FAILURE,EE_ARGS(1), STRING_ARG,"imgtimutil");
                    return FAILURE;  /* DCZ: need return FAILURE */
                }
                if (avail_image_time < tmin)
                    avail_image_time  = _avail_image_time.fixedflag ?  ((void)(tmin), avail_image_time) : tmin;

                act_tr  = _act_tr.fixedflag ?  ((void)(avail_image_time), act_tr) : avail_image_time;
                if(fixed_acqs_debug == DEBUG_PROD) {
                    printf("\n TR is overridden to %d\n",exist(optr));
                    fflush(stdout);
                }

                if(maxpass(_acqs.fixedflag ? (_temp659_acqs=acqs,&_temp659_acqs) : &acqs,seq_type,(int)exist(opslquant),avmaxslquant) == FAILURE) {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxpass");
                    return FAILURE;
                }

                if(slicein1(_slquant_per_trig.fixedflag ? (_temp660_slquant_per_trig=slquant_per_trig,&_temp660_slquant_per_trig) : &slquant_per_trig, acqs , seq_type) == FAILURE) {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    slquant_per_trig  = _slquant_per_trig.fixedflag ? ((void)(1), slquant_per_trig) : 1;
                    return FAILURE;
                }

                if(slquant_per_trig == 0) {
                    epic_error(use_ermes,"slquant_per_trig is 0",EM_PSD_SLQUANT_ZERO,0);
                    return FAILURE;
                }
                /* recalculate slquant_per_trig and avmaxslquant if
                 * there is a dummy slice in enhanced SE.
                 */
                if ((DUMMY_SLICE_OFF != dummyslice_type) && (1 == tmp_dummyslice_flag))
                {
                    slquant_per_trig  = _slquant_per_trig.fixedflag ?  ((void)(1), slquant_per_trig) : slquant_per_trig+1;
                    avmaxslquant += 1;
                }
            } /* optracq > 0 */

            /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
            /* Enhance original auto TR algorithm.                   */
            /*  Original algorithm: support n-1, n, n+1 acqs         */
            /*  Enhanced algorithm:                                  */
            /*      >  support n-X, n, n+x acqs                      */
            /*      >  insure TR offered by autoTR is legal          */
            /*      >  Range of Acqs can be defined                  */
            /*         by minimal and maximal value of optracq       */

            /* For Acqs - X : Show the pitracqval2 with the value */
            /*                only if Acqs - X exists             */

            pitracqnub = 2+4+8;
            if(avmaxacqs > 1 && ((avmaxacqs-1) <=  _optracq.maxval))
            {
                tmp_acqs_num = avmaxacqs-1;
                for(i=avmaxacqs-1; i>=1 ;i--)
                {
                    if (slicein1(_sl_acq_val2.fixedflag ? (_temp661_sl_acq_val2=sl_acq_val2,&_temp661_sl_acq_val2) : &sl_acq_val2, i, seq_type) == FAILURE) {
                        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"slicein1");
                        sl_acq_val2  = _sl_acq_val2.fixedflag ? ((void)(1), sl_acq_val2) : 1;
                        return FAILURE;
                    }
 
                    tmp_acqs_num = (int)ceil(exist(opslquant)/ sl_acq_val2) + ((exist(opslquant)%sl_acq_val2) ? 1:0);
                    if(tmp_acqs_num == i)
                        break;
                }
#ifdef PSD_FSE
                if ( !((PSD_ON == t1flair_flag) && (ANALYTICAL_SEQTIME == t1flair_seqtime_method))
                     && !((PSD_ON == t2flair_on) && (PSD_OFF == classic_t2flair_flag)) )
                {
#endif
                    if ((((DUMMY_SLICE_1ACQ == dummyslice_type) && (1 == tmp_acqs_num)) || (DUMMY_SLICE_MULTI_ACQ == dummyslice_type)) &&
                        (0 == (sl_acq%2)))
                    {
                        sl_acq_val2  = _sl_acq_val2.fixedflag ?  ((void)(1), sl_acq_val2) : sl_acq_val2+1;
                    }
                    if(maxslquant1(sl_acq_val2, _tr_acq_val2.fixedflag ? (_temp662_tr_acq_val2=tr_acq_val2,&_temp662_tr_acq_val2) : &tr_acq_val2, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1");
                        return FAILURE;
                    }
#ifdef PSD_FSE
                } else {
                    if(maxslquant1_flair(sl_acq_val2, _tr_acq_val2.fixedflag ? (_temp663_tr_acq_val2=tr_acq_val2,&_temp663_tr_acq_val2) : &tr_acq_val2, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_flair");
                        return FAILURE;
                    }
                }
#endif
                if(avmaxacqs > 1)
                {
                    if((exist(opslquant) > (tmp_acqs_num-1)*sl_acq_val2) &&
                       (exist(opslquant) <= tmp_acqs_num * sl_acq_val2) &&
                       (tr_acq_val2 <= avmaxtr) &&
                       (tr_acq_val2 >= avmintr) )  /* MRIhc34158 */
                    {
                        if( isValueSystem())
                        {
                            pitrval2 = (int) tr_acq_val2;
                        }
                        pitracqval2 = tmp_acqs_num;

                        /* YMSmr08934: do not show 1 acq in case of interleave acquisition */
                        if(pitracqval2==1 && exist(opileave)==PSD_ON)
                        {
                            pitracqval2 = 0;
                            pitracqnub = pitracqnub & ~2 ;
                            tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
                        }
                    } else {
                        pitracqval2 = 0;
                        pitracqnub = pitracqnub & ~2 ;
                        tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
                    }
                }

                if(fixed_acqs_debug == DEBUG_DEV) {
                    printf("\nFor %d Acqs,Slices in First Pass is %d TR is %d \n ",
                              avmaxacqs-1,sl_acq_val2,tr_acq_val2);
                    fflush(stdout);
                }
            } else {
                pitracqval2 = 0;
                pitracqnub = pitracqnub & ~2 ;
                tr_acq_val2  = _tr_acq_val2.fixedflag ?  ((void)(pitrval2), tr_acq_val2) : pitrval2;
            }

            /*For Acqs - Efficient Packing , will shorten the pass to make the
            Pass full, if the pass is already full, it does not do anything
            and is shown for consistency purposes only.
            */

            if(slicein1(_sl_acq_val3.fixedflag ? (_temp664_sl_acq_val3=sl_acq_val3,&_temp664_sl_acq_val3) : &sl_acq_val3, avmaxacqs, seq_type) == FAILURE) {
                epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                sl_acq_val3  = _sl_acq_val3.fixedflag ? ((void)(1), sl_acq_val3) : 1;
                return FAILURE;
            }

#ifdef PSD_FSE
            if ( !((PSD_ON == t1flair_flag) && (ANALYTICAL_SEQTIME == t1flair_seqtime_method))
                 && !((PSD_ON == t2flair_on) && (PSD_OFF == classic_t2flair_flag)) )
            {
#endif
                if ((((DUMMY_SLICE_1ACQ == dummyslice_type) && (1 == avmaxacqs)) || (DUMMY_SLICE_MULTI_ACQ == dummyslice_type)) &&
                    (0 == (sl_acq%2)))
                {
                    sl_acq_val3  = _sl_acq_val3.fixedflag ?  ((void)(1), sl_acq_val3) : sl_acq_val3+1;
                }
                if(maxslquant1(multiband_flag?multiband_slquant:sl_acq_val3, _tr_acq_val3.fixedflag ? (_temp665_tr_acq_val3=tr_acq_val3,&_temp665_tr_acq_val3) : &tr_acq_val3, seq_type, tmin_total, gating) == FAILURE) {
                    epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1");
                    return FAILURE;
                }
#ifdef PSD_FSE
            } else {
                if(maxslquant1_flair(sl_acq_val3, _tr_acq_val3.fixedflag ? (_temp666_tr_acq_val3=tr_acq_val3,&_temp666_tr_acq_val3) : &tr_acq_val3, seq_type, tmin_total, gating) == FAILURE) {
                    epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_flair");
                    return FAILURE;
                }
            }
#endif
            if(avmaxacqs > 0 && ((avmaxacqs) <= _optracq.maxval) ) {

                if((exist(opslquant) > ((avmaxacqs)-1)*sl_acq_val3) &&
                   (exist(opslquant) <= (avmaxacqs) * sl_acq_val3)  &&
                   (tr_acq_val3 <= avmaxtr) &&
                   (tr_acq_val3 >= avmintr) ) {  /* MRIhc34158 */
                    if( isValueSystem() )
                    {
                        pitrval3 = (int) tr_acq_val3;
                    }
                    pitracqval3 = avmaxacqs;
                } else {
                    pitracqval3 = 0;
                    pitracqnub = pitracqnub & ~4 ;
                    tr_acq_val3  = _tr_acq_val3.fixedflag ?  ((void)(pitrval3), tr_acq_val3) : pitrval3;
                }
            }

            if(fixed_acqs_debug == DEBUG_DEV) {
                printf("\nAUTOMINTR: For %d Acqs,Slices in First Pass is %d TR is %d \n ", avmaxacqs,sl_acq_val3,tr_acq_val3);
                fflush(stdout);
            }

            /*  *************************************************************************
             *  For Acqs + 1 : Do not show this dropdown 
             *  this value if the n Acqs and n+1 Acqs yield the same Slices/Pass
             *  returned by slicein1 as these will turnout to have same TRs.
             *  showing up as duplicate entries.
             *  ************************************************************************/

            /* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
            /* For Acqs + X : Show the pitracqval2 with the value    */
            /*                only if Acqs + X exists                */

            tmp_acqs_num = avmaxacqs+1;
            for(i=avmaxacqs+1; i<=exist(opslquant) ;i++)
            {
                if(slicein1(_sl_acq_val4.fixedflag ? (_temp667_sl_acq_val4=sl_acq_val4,&_temp667_sl_acq_val4) : &sl_acq_val4, i, seq_type) == FAILURE)
                {
                    epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"slicein1");
                    sl_acq_val4  = _sl_acq_val4.fixedflag ? ((void)(1), sl_acq_val4) : 1;
                    return FAILURE;
                }

                tmp_acqs_num = (int)ceil(exist(opslquant)/ sl_acq_val4) + ((exist(opslquant)%sl_acq_val4) ? 1:0);
                if(tmp_acqs_num == i)
                    break;
            }

            if(avmaxacqs < exist(opslquant))
            {
#ifdef PSD_FSE
                if ( !((PSD_ON == t1flair_flag) && (ANALYTICAL_SEQTIME == t1flair_seqtime_method))
                     && !((PSD_ON == t2flair_on) && (PSD_OFF == classic_t2flair_flag)) )
                {
#endif
                    if ((((DUMMY_SLICE_1ACQ == dummyslice_type) && (1 == tmp_acqs_num)) || (DUMMY_SLICE_MULTI_ACQ == dummyslice_type)) &&
                        (0 == (sl_acq%2)))
                    {
                        sl_acq_val4  = _sl_acq_val4.fixedflag ?  ((void)(1), sl_acq_val4) : sl_acq_val4+1;
                    }
                    if(maxslquant1(multiband_flag?multiband_slquant:sl_acq_val4, _tr_acq_val4.fixedflag ? (_temp668_tr_acq_val4=tr_acq_val4,&_temp668_tr_acq_val4) : &tr_acq_val4, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1");
                        return FAILURE;
                    }
#ifdef PSD_FSE
                } else {
                    if(maxslquant1_flair(sl_acq_val4, _tr_acq_val4.fixedflag ? (_temp669_tr_acq_val4=tr_acq_val4,&_temp669_tr_acq_val4) : &tr_acq_val4, seq_type, tmin_total, gating) == FAILURE) {
                        epic_error(use_ermes,supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"maxslquant1_flair");
                        return FAILURE;
                    }
                }
#endif
                if(avmaxacqs > 0 && ((avmaxacqs+1) <= _optracq.maxval) )
                {
                    if((exist(opslquant) > (tmp_acqs_num-1)*sl_acq_val4) &&
                        (exist(opslquant) <= tmp_acqs_num * sl_acq_val4) &&
                        (tr_acq_val4 <= avmaxtr) &&
                        (tr_acq_val4 >= avmintr) ) {  /* MRIhc34158 */
                        if( isValueSystem() )
                        {
                            pitrval4 = (int)tr_acq_val4;
                        }
                        pitracqval4 = tmp_acqs_num;
                    } else {
                        tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
                        pitracqval4 = 0;
                        pitracqnub  = pitracqnub & ~8;
                    }
                }

                if(fixed_acqs_debug == DEBUG_DEV) {
                    printf("\n AUTOMINTR: For %d Acqs,Slices in First Pass is %d TR is %d \n ",
                          avmaxacqs+1,sl_acq_val4,tr_acq_val4);
                    fflush(stdout);
                }
            } else {
                tr_acq_val4  = _tr_acq_val4.fixedflag ?  ((void)(pitrval4), tr_acq_val4) : pitrval4;
                pitracqval4 = 0;
                pitracqnub  = pitracqnub & ~8;
            }

            /* Check if the user has selected any Acqs, if so, use optracq  *
             * and set the new TR and new Max Slices/Acq.                   *
             */

            if(fixed_acqs_debug == DEBUG_PROD) {
                printf("\n AUTOMINTR: OPTRACQS : %d,exist:%d \n", exist(optracq),_optracq.existflag);
                fflush(stdout);
            }

#ifdef PSD_FSE
            /* opti should be restored because opti has been updated inside maxslquant1_flair() */
            if( exist(optracq) > 0 && existcv(optracq) && (t1flair_flag == PSD_ON || t2flair_on == PSD_ON) ) {
                cvoverride(opti,keep_opti,PSD_FIX_ON,PSD_EXIST_ON);
            }

        } /* flair_on == PSD_ON */
#endif
    } else {
        pitracqval2 = 0;
        pitracqval3 = 0;
        pitracqval4 = 0;
        pitracqnub = 0;
    }

    /* HCSDM00392006  Rest tr_limit to avoid CV range out error when TR mode is changed from auto to manual
                      after detecting TR range errror. */
    if(PSD_OFF == exist(opinrangetr))
    {
        tr_limit  = _tr_limit.fixedflag ?  ((void)(_tr_limit.defval), tr_limit) : _tr_limit.defval;
    }

  return SUCCESS;
}


/* This function returns the value of piautotrmode (Auto TR mode)
   - 0:Manual TR, 1:In-Range TR, 2:Advancd In-Range TR */

int automintr_compatibility_checks (void) {
    /************************************************************
    * Put in  compatibility checks for piautotrmode            *
    * Lockout Imaging Options Resp, Nav, Gating, Sequential.   *
    ************************************************************/
#ifdef PSD_FSE
    if( (t1flair_flag == PSD_ON && t1flair_autotr_flag == PSD_OFF) || 
        (t2flair_on == PSD_ON && t2flair_autotr_flag == PSD_OFF ) ||
        (exist(opslicecnt) > 0 && existcv(opslicecnt) && pipautype != PSD_LABEL_PAU_ACQ) ||
        (exist(oprtcgate) > 0 && existcv(oprtcgate)) ||
        (exist(opnav) > 0 && existcv(opnav)) ||
        (exist(opcgate) > 0 && existcv(opcgate)) )
#else
        if((exist(opslicecnt) > 0 && existcv(opslicecnt) && PSD_LABEL_PAU_REP == pipautype) ||
           (exist(oprtcgate) > 0 && existcv(oprtcgate)) ||
           (exist(opnav) > 0 && existcv(opnav)) ||
           (exist(opcgate) > 0 && existcv(opcgate)) ||
           (exist(opirmode) > 0 && existcv(opirmode)) )
#endif
    {
        piautotrmode = PSD_AUTO_TR_MODE_MANUAL_TR;
    } else {
        piautotrmode = PSD_AUTO_TR_MODE_IN_RANGE_TR;
    }
    return piautotrmode;
}


STATUS
#ifdef __STDC__ 
avmintecalc( void )
#else /* !__STDC__ */
    avmintecalc()
#endif /* __STDC__ */
{
    int tempxy;

    if (exist(oppseq) == PSD_SE)
        avminssp  = _avminssp.fixedflag ?            ((void)(pw_rf2/2+rfupd+8+pw_wssp+tdaqhxa), avminssp) : pw_rf2/2+rfupd+8+pw_wssp+tdaqhxa;
    else                         /* gradient echo */
        avminssp  = _avminssp.fixedflag ?            ((void)(rfExIso+rfupd+8+pw_wssp+tdaqhxa), avminssp) : rfExIso+rfupd+8+pw_wssp+tdaqhxa;

    if(hsdab == 2 )
        avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+DIFFDAB_length), avminssp) : avminssp+DIFFDAB_length;
    else
        avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+HSDAB_length), avminssp) : avminssp+HSDAB_length;

    if (xtr_offset == 0) {
        avminssp  = _avminssp.fixedflag ?      ((void)(avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2])), avminssp) : avminssp+(XTRSETLNG+XTR_length[PSD_XCVR2]);
    } else {
        avminssp  = _avminssp.fixedflag ?    ((void)(avminssp+xtr_offset), avminssp) : avminssp+xtr_offset;
    }

    if (exist(oppseq) == PSD_SE)
        avminssp  = _avminssp.fixedflag ?  ((void)(2), avminssp) : avminssp*2;  

    get_gy1_time();

    get_flowcomp_time();

    if (exist(oppseq) == PSD_SE) {

        int extra_tetime;
        extra_tetime = get_extra_dpc_tetime() + get_extra_rtb0_tetime();

        if (PSD_OFF == dualspinecho_flag)
        {

            if (gx1pos == PSD_POST_180) {
                avminxa  = _avminxa.fixedflag ?           
                               ((void)(2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+xdiff_time1+pw_gzrf2l1_tot+(pw_rf2/2))), avminxa) : 2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+xdiff_time1+pw_gzrf2l1_tot+(pw_rf2/2));
                avminxb  = _avminxb.fixedflag ?            
                                   
                                   ((void)(2*(8+pw_rf2/2+pw_gzrf2r1_tot+xdiff_time2+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminxb) : 2*(8+pw_rf2/2+pw_gzrf2r1_tot+xdiff_time2+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot));

            } else {
                avminxa  = _avminxa.fixedflag ?        ((void)(2*(rfExIso+xdiff_time1+IMax(2,pw_gx1_tot,pw_gyex1_tot))), avminxa) : 2*(rfExIso+xdiff_time1+IMax(2,pw_gx1_tot,pw_gyex1_tot));
                avminxb  = _avminxb.fixedflag ?        ((void)(2*(tdaqhxa+xdiff_time2+pw_wgx+pw_rf2/2)), avminxb) : 2*(tdaqhxa+xdiff_time2+pw_wgx+pw_rf2/2);
            }
            avminxa  = _avminxa.fixedflag ?  ((void)(2*extra_tetime), avminxa) : avminxa+2*extra_tetime;

        } else {   
            int left_diff_timing = IMax(3,pw_gxdl1a,pw_gydl1a,pw_gzdl1a) + IMax(3,pw_gxdl1,pw_gydl1,pw_gzdl1) + IMax(3,pw_gxdl1d,pw_gydl1d,pw_gzdl1d) + pw_wgxdl1;
            int right_diff_timing = pw_wgxdr2 + IMax(3,pw_gxdr2a,pw_gydr2a,pw_gzdr2a) + IMax(3,pw_gxdr2,pw_gydr2,pw_gzdr2) + IMax(3,pw_gxdr2d,pw_gydr2d,pw_gzdr2d);

            avminxa  = _avminxa.fixedflag ?           
                           ((void)(4*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+(pw_rf2/2))), avminxa) : 4*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+(pw_rf2/2));
            avminxa  = _avminxa.fixedflag ?  ((void)(4*extra_tetime), avminxa) : avminxa+4*extra_tetime;

            if(xygradRightCrusherFlag == PSD_ON)
            {
                tempxy = IMax(2, pw_xgradRightCrusherRa + pw_xgradRightCrusherR + 
                         pw_xgradRightCrusherRd, pw_gzrf2r2_tot_bval);
            }
            else
            {
                tempxy = pw_gzrf2r2_tot_bval;
            }
            avminxb  = _avminxb.fixedflag ?            
                               
                               ((void)(4*(8+pw_rf2/2+tempxy+right_diff_timing+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminxb) : 4*(8+pw_rf2/2+tempxy+right_diff_timing+pw_wgx+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot));   
        }
        avminx   = _avminx.fixedflag ?      ((void)((avminxa>avminxb)?avminxa:avminxb), avminx) : (avminxa>avminxb)?avminxa:avminxb;

        if (PSD_OFF == dualspinecho_flag)
        {
            if (gy1pos == PSD_POST_180) {
                avminya  = _avminya.fixedflag ?           
                               ((void)(2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+ydiff_time1+pw_gzrf2l1_tot+(pw_rf2/2))), avminya) : 2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+ydiff_time1+pw_gzrf2l1_tot+(pw_rf2/2));
                avminyb  = _avminyb.fixedflag ?            
                                    
                                   ((void)(2*(8+pw_rf2/2+pw_gzrf2r1_tot+ydiff_time2+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminyb) : 2*(8+pw_rf2/2+pw_gzrf2r1_tot+ydiff_time2+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot)); 

            } else {
                avminya  = _avminya.fixedflag ?          ((void)(2*(rfExIso+pw_gyex1_tot+pw_gy1_tot+ydiff_time2+pw_wgy)), avminya) : 2*(rfExIso+pw_gyex1_tot+pw_gy1_tot+ydiff_time2+pw_wgy);
                avminyb  = _avminyb.fixedflag ?       
                               ((void)(2*(pw_rf2/2+ydiff_time2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot))), avminyb) : 2*(pw_rf2/2+ydiff_time2+pw_gxwad+IMax(2,pw_gx1_tot,pw_gzrf2r1_tot));              
            }
            avminya  = _avminya.fixedflag ?  ((void)(2*extra_tetime), avminya) : avminya+2*extra_tetime;

        } else {
            int left_diff_timing = IMax(3,pw_gxdl1a,pw_gydl1a,pw_gzdl1a) + IMax(3,pw_gxdl1,pw_gydl1,pw_gzdl1) + IMax(3,pw_gxdl1d,pw_gydl1d,pw_gzdl1d) + pw_wgydl1;
            int right_diff_timing = pw_wgydr2 + IMax(3,pw_gxdr2a,pw_gydr2a,pw_gzdr2a) + IMax(3,pw_gxdr2,pw_gydr2,pw_gzdr2) + IMax(3,pw_gxdr2d,pw_gydr2d,pw_gzdr2d);

            avminya  = _avminya.fixedflag ?           
                           ((void)(4*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+(pw_rf2/2))), avminya) : 4*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+(pw_rf2/2));
            avminya  = _avminya.fixedflag ?  ((void)(4*extra_tetime), avminya) : avminya+4*extra_tetime;

            if(xygradRightCrusherFlag == PSD_ON)
            {
                tempxy = IMax(2, pw_ygradRightCrusherRa + pw_ygradRightCrusherR + 
                         pw_ygradRightCrusherRd, pw_gzrf2r2_tot_bval);
            }
            else
            {
                tempxy = pw_gzrf2r2_tot_bval;
            }
            avminyb  = _avminyb.fixedflag ?            
                               
                               ((void)(4*(8+pw_rf2/2+tempxy+right_diff_timing+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminyb) : 4*(8+pw_rf2/2+tempxy+right_diff_timing+pw_wgy+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot));            
        }
        avminy   = _avminy.fixedflag ?      ((void)((avminya>avminyb)?avminya:avminyb), avminy) : (avminya>avminyb)?avminya:avminyb;

        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            avminza  = _avminza.fixedflag ?           
                           ((void)(2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+zdiff_time1+pw_gzrf2l1_tot+(pw_rf2/2))), avminza) : 2*(rfExIso+pw_gzrf1d+IMax(2,pw_gyex1_tot,pw_gz1_tot)+zdiff_time1+pw_gzrf2l1_tot+(pw_rf2/2));
            avminzb  = _avminzb.fixedflag ?            
                                
                          
                                  ((void)(2*(8+pw_rf2/2+pw_gzrf2r1_tot+zdiff_time2+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminzb) : 2*(8+pw_rf2/2+pw_gzrf2r1_tot+zdiff_time2+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot));
            avminza  = _avminza.fixedflag ?  ((void)(2*extra_tetime), avminza) : avminza+2*extra_tetime;

        } else {
            /* OK: we've got four times we need to look at.  a) aminza: 90->180 */
            /*     b) minztemp: 180->opte/2 which = c) opte/2 -> 180 */
            /*     d) avminzb: 180 -> echo. Whichever is the larget will determine the */
            /*     minimum echo time for the sequence */
            int minztemp = 0;
            int left_diff_timing = IMax(3,pw_gxdl1a,pw_gydl1a,pw_gzdl1a) + IMax(3,pw_gxdl1,pw_gydl1,pw_gzdl1) + IMax(3,pw_gxdl1d,pw_gydl1d,pw_gzdl1d) + pw_wgzdl1;
            int right_diff_timing1 = pw_wgzdr1 + IMax(3,pw_gxdr1a,pw_gydr1a,pw_gzdr1a) + IMax(3,pw_gxdr1,pw_gydr1,pw_gzdr1) + IMax(3,pw_gxdr1d,pw_gydr1d,pw_gzdr1d);
            int right_diff_timing2 = pw_wgzdr2 + IMax(3,pw_gxdr2a,pw_gydr2a,pw_gzdr2a) + IMax(3,pw_gxdr2,pw_gydr2,pw_gzdr2) + IMax(3,pw_gxdr2d,pw_gydr2d,pw_gzdr2d);

            /* 90-180 time */
            avminza  = _avminza.fixedflag ?           
                         ((void)(4*(rfExIso+pw_gzrf1d+IMin(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+pw_rf2/2)), avminza) : 4*(rfExIso+pw_gzrf1d+IMin(2,pw_gyex1_tot,pw_gz1_tot)+left_diff_timing+pw_gzrf2l1_tot_bval+pw_rf2/2); 
            avminza  = _avminza.fixedflag ?  ((void)(4*extra_tetime), avminza) : avminza+4*extra_tetime;

            /* 180 - opte/2 spacing: sep_time will add a gap between diffusion lobes */
            minztemp = 4*(GRAD_UPDATE_TIME + sep_time + right_diff_timing1 + 
                        pw_gzrf2r1_tot_bval + pw_rf2/2 );

            avminza  = _avminza.fixedflag ?      ((void)((avminza>minztemp)?avminza:minztemp), avminza) : (avminza>minztemp)?avminza:minztemp;

            /* 180 - echo center time */
            avminzb  = _avminzb.fixedflag ?            
                              
                           ((void)(4*(8+pw_rf2/2+pw_gzrf2r2_tot_bval+right_diff_timing2+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot))), avminzb) : 4*(8+pw_rf2/2+pw_gzrf2r2_tot_bval+right_diff_timing2+pw_wgz+pw_gxwad+tdaqhxa+IMax(2,pw_gx1_tot,pw_gymn1_tot+pw_gymn2_tot+pw_gy1_tot));

            avminzb  = _avminzb.fixedflag ?      ((void)((avminzb>minztemp)?avminzb:minztemp), avminzb) : (avminzb>minztemp)?avminzb:minztemp;
        }

        avminz   = _avminz.fixedflag ?      ((void)((avminza>avminzb)?avminza:avminzb), avminz) : (avminza>avminzb)?avminza:avminzb;

    } else {  /* Gradient echo */
        avminx   = _avminx.fixedflag ?           
                ((void)(rfExIso+xdiff_time1+xdiff_time2+pw_gx1a+pw_gx1+pw_gx1d+tdaqhxa+pw_wgx), avminx) : rfExIso+xdiff_time1+xdiff_time2+pw_gx1a+pw_gx1+pw_gx1d+tdaqhxa+pw_wgx;
        avminy  = _avminy.fixedflag ?           
                ((void)(rfExIso+pw_gyex1_tot+pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot+ydiff_time2+pw_wgy+tdaqhxa), avminy) : rfExIso+pw_gyex1_tot+pw_gy1_tot+pw_gymn1_tot+pw_gymn2_tot+ydiff_time2+pw_wgy+tdaqhxa;
        avminz  = _avminz.fixedflag ?           
            ((void)(rfExIso+pw_gzrf1d+pw_gz1_tot+pw_wgz+zdiff_time2+tdaqhxa), avminz) : rfExIso+pw_gzrf1d+pw_gz1_tot+pw_wgz+zdiff_time2+tdaqhxa;

        /*RTB0 correction*/
        if(rtb0_flag)
        {
            avminx  = _avminx.fixedflag ?          ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay), avminx) : avminx+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay;
            avminy  = _avminy.fixedflag ?          ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay), avminy) : avminy+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay;
            avminz  = _avminz.fixedflag ?            ((void)(IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot), avminz) : avminz+IMax(2,pw_gz1_tot,rfupd+4+rtb0_minintervalb4acq)+esp+rtb0_acq_delay-pw_gz1_tot;
        }
    }

    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminy>avminz)?avminy:avminz)), avmintetemp) : ((avminy>avminz)?avminy:avminz);
    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminx>avmintetemp)?avminx:avmintetemp)), avmintetemp) : ((avminx>avmintetemp)?avminx:avmintetemp);
    avmintetemp  = _avmintetemp.fixedflag ?      ((void)(((avminssp>avmintetemp)?avminssp:avmintetemp)), avmintetemp) : ((avminssp>avmintetemp)?avminssp:avmintetemp);

    return SUCCESS;
}   /* end avmintecalc() */

/* Get extra TE time for dynamic phase correction */
int get_extra_dpc_tetime(void)
{
    int ext_tetime;

    if(dpc_flag)
    {
        ext_tetime = IMax(3, pw_gz1_tot, rfupd+4  +pw_gxiref1_tot, pw_gyex1_tot) - IMax(2, pw_gyex1_tot, pw_gz1_tot) +
                     pw_gxiref_tot + pw_gxirefr_tot + IMax(2, pw_gzrf1d, psd_rf_wait) - pw_gzrf1d;
    }
    else
    {
        ext_tetime = 0;
    }

    return ext_tetime;
}

/* Get extra TE time for RTB0 */
int get_extra_rtb0_tetime(void)
{
    int ext_tetime;

    if(rtb0_flag)
    {
        ext_tetime = IMax(2, pw_gz1_tot, rfupd+4  + rtb0_minintervalb4acq) +
                     esp + rtb0_acq_delay - pw_gz1_tot;
    }
    else
    {
        ext_tetime = 0;
    }

    return ext_tetime;
}

STATUS get_flowcomp_time(void)
{
    int pulsecnt;

    if (ygmn_type == CALC_GMN1) {

        /* set time origin at end of bipolar flow comp lobe/beginning of
           gy1f phase encoding pulse */
        invertphase  = _invertphase.fixedflag ?  ((void)(0), invertphase) : 0;
        zeromomentsum  = _zeromomentsum.fixedflag ?  ((void)(0.0), zeromomentsum) : 0.0;
        firstmomentsum  = _firstmomentsum.fixedflag ?  ((void)(0.0), firstmomentsum) : 0.0;
        pulsepos  = _pulsepos.fixedflag ?  ((void)(0), pulsepos) : 0;

        /* compute moments for blips */
        pulsepos  = _pulsepos.fixedflag ?            ((void)(pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd), pulsepos) : pw_gy1_tot+pw_gxwad+esp-pw_gxwad/2-pw_gyb/2-pw_gybd;
        for (pulsecnt=0;pulsecnt<blips2cent;pulsecnt++) {
            rampmoments(0.0, a_gyb, pw_gyba, invertphase, _pulsepos.fixedflag ? (_temp670_pulsepos=pulsepos,&_temp670_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp671_zeromoment=zeromoment,&_temp671_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp672_firstmoment=firstmoment,&_temp672_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp673_zeromomentsum=zeromomentsum,&_temp673_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp674_firstmomentsum=firstmomentsum,&_temp674_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, a_gyb, pw_gyb, invertphase, _pulsepos.fixedflag ? (_temp675_pulsepos=pulsepos,&_temp675_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp676_zeromoment=zeromoment,&_temp676_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp677_firstmoment=firstmoment,&_temp677_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp678_zeromomentsum=zeromomentsum,&_temp678_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp679_firstmomentsum=firstmomentsum,&_temp679_firstmomentsum) : &firstmomentsum);
            rampmoments(a_gyb, 0.0, pw_gybd, invertphase, _pulsepos.fixedflag ? (_temp680_pulsepos=pulsepos,&_temp680_pulsepos) : &pulsepos,
                        _zeromoment.fixedflag ? (_temp681_zeromoment=zeromoment,&_temp681_zeromoment) : &zeromoment, _firstmoment.fixedflag ? (_temp682_firstmoment=firstmoment,&_temp682_firstmoment) : &firstmoment, _zeromomentsum.fixedflag ? (_temp683_zeromomentsum=zeromomentsum,&_temp683_zeromomentsum) : &zeromomentsum,
                        _firstmomentsum.fixedflag ? (_temp684_firstmomentsum=firstmomentsum,&_temp684_firstmomentsum) : &firstmomentsum);
            pulsepos  = _pulsepos.fixedflag ?      ((void)((esp-pw_gyba-pw_gyb/2)), pulsepos) : pulsepos+(esp-pw_gyba-pw_gyb/2);
        }
        gyb_tot_0thmoment  = _gyb_tot_0thmoment.fixedflag ?  ((void)(zeromomentsum), gyb_tot_0thmoment) : zeromomentsum;
        gyb_tot_1stmoment  = _gyb_tot_1stmoment.fixedflag ?  ((void)(firstmomentsum), gyb_tot_1stmoment) : firstmomentsum;

        /* Here we compute the gradient moment nulling pulse parameters
           for a worst case condition: when the gy1f pulse has zero
           amplitude.  Since the gy1f never really steps to zero amplitude,
           this is hardly an optimal solution.  A future option is to
           compute the minimum amplitude of gy1f across all intleaves
           in this calculation. */

        amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                  pw_gy1d, 0.0, 0.0, loggrd.ty_xyz, (float)loggrd.yrt*loggrd.scale_3axis_risetime,
                  0, _pw_gymn2a.fixedflag ? (_temp685_pw_gymn2a=pw_gymn2a,&_temp685_pw_gymn2a) : &pw_gymn2a, _pw_gymn2.fixedflag ? (_temp686_pw_gymn2=pw_gymn2,&_temp686_pw_gymn2) : &pw_gymn2, _pw_gymn2d.fixedflag ? (_temp687_pw_gymn2d=pw_gymn2d,&_temp687_pw_gymn2d) : &pw_gymn2d, _a_gymn2.fixedflag ? (_temp688_a_gymn2=a_gymn2,&_temp688_a_gymn2) : &a_gymn2);

        a_gymn2  = _a_gymn2.fixedflag ?  ((void)(-a_gymn2), a_gymn2) : -a_gymn2;
        a_gymn1  = _a_gymn1.fixedflag ?  ((void)(-a_gymn2), a_gymn1) : -a_gymn2;
        pw_gymn1a  = _pw_gymn1a.fixedflag ?  ((void)(pw_gymn2a), pw_gymn1a) : pw_gymn2a;
        pw_gymn1  = _pw_gymn1.fixedflag ?  ((void)(pw_gymn2), pw_gymn1) : pw_gymn2;
        pw_gymn1d  = _pw_gymn1d.fixedflag ?  ((void)(pw_gymn2d), pw_gymn1d) : pw_gymn2d;

        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?      ((void)(pw_gymn1a+pw_gymn1+pw_gymn1d), pw_gymn1_tot) : pw_gymn1a+pw_gymn1+pw_gymn1d;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?      ((void)(pw_gymn2a+pw_gymn2+pw_gymn2d), pw_gymn2_tot) : pw_gymn2a+pw_gymn2+pw_gymn2d;

    } else {    /* if (ygmn_type != CALC_GMN1) */
        pw_gymn1_tot  = _pw_gymn1_tot.fixedflag ?  ((void)(0), pw_gymn1_tot) : 0;
        pw_gymn2_tot  = _pw_gymn2_tot.fixedflag ?  ((void)(0), pw_gymn2_tot) : 0;
    }

    return SUCCESS;
}

STATUS get_gy1_time(void)
{
    /* All this to find pw_gy1_tot: */
    gy1_offset  = _gy1_offset.fixedflag ?  ((void)(ky_offset*fabs(area_gyb)/intleaves), gy1_offset) : ky_offset*fabs(area_gyb)/intleaves;
    area_gy1  = _area_gy1.fixedflag ?    ((void)(area_gy1+gy1_offset), area_gy1) : area_gy1+gy1_offset;
    area_gy1  = _area_gy1.fixedflag ?  ((void)(fabs(area_gy1)), area_gy1) : fabs(area_gy1);
    endview_iamp  = _endview_iamp.fixedflag ?  ((void)(max_pg_wamp), endview_iamp) : max_pg_wamp;
    endview_scale  = _endview_scale.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamp), endview_scale) : (float)max_pg_iamp/(float)endview_iamp;

    /* Find the amplitudes and pulse widths of the trapezoidal
       phase encoding pulse. */

    if (amppwtpe(_a_gy1a.fixedflag ? (_temp689_a_gy1a=a_gy1a,&_temp689_a_gy1a) : &a_gy1a,_a_gy1b.fixedflag ? (_temp690_a_gy1b=a_gy1b,&_temp690_a_gy1b) : &a_gy1b,_pw_gy1.fixedflag ? (_temp691_pw_gy1=pw_gy1,&_temp691_pw_gy1) : &pw_gy1,_pw_gy1a.fixedflag ? (_temp692_pw_gy1a=pw_gy1a,&_temp692_pw_gy1a) : &pw_gy1a,_pw_gy1d.fixedflag ? (_temp693_pw_gy1d=pw_gy1d,&_temp693_pw_gy1d) : &pw_gy1d,
                 loggrd.ty_xyz/endview_scale,loggrd.yrt*loggrd.scale_3axis_risetime,
                 area_gy1) == FAILURE)
    {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "amppwtpe" );
        return FAILURE;
    }

    a_gy1  = _a_gy1.fixedflag ?  ((void)(loggrd.ty_xyz/endview_scale), a_gy1) : loggrd.ty_xyz/endview_scale;
    pw_gy1_tot  = _pw_gy1_tot.fixedflag ?      ((void)(pw_gy1a+pw_gy1+pw_gy1d), pw_gy1_tot) : pw_gy1a+pw_gy1+pw_gy1d;

    return SUCCESS;
}

/*
 *  verify_bvalue():
 *
 *  This function checks the b-value of the gradient waveforms on each axis by 
 *  generating the waveforms using a call to pulsegen(), integrating each axis, and
 *  computing the b-value at the echo time.  This value is compared with the prescribed 
 *  b-value (opbval).  If it does not conform to the tolerance (1.5%), then the dif lobes
 *  are adjusted (roughly) using the ratio of the sqrt() of the b-values.  This usually puts you
 *  in the tolerance range.  If not, bisection is used for further refinement.  
 *  
 */

STATUS
#ifdef __STDC__
verify_bvalue( FLOAT * curr_bvalue, 
                      const FLOAT rf_excite_location, 
                      const FLOAT * rf_180_location, 
                      const INT num180s, 
                      const INT seq_entry_index, 
                      const INT bmat_flag, 
                      const INT seg_debug)
#else /* !__STDC__ */
verify_bvalue( curr_bvalue, rf_excite_location, 
               rf_180_location, num180s,
               seq_entry_index, bmat_flag, seg_debug)
    FLOAT * curr_bvalue; 
    const FLOAT rf_excite_location; 
    const FLOAT * rf_180_location;
    const INT num180s;
    const INT seq_entry_index; 
    const INT bmat_flag;
    const INT seg_debug;
#endif /* __STDC__ */
{
    
    /* Variables for b-value calculation */
    STATUS status;            /* Status variable to catch errors from function calls */
    FLOAT dif_amp[3];         /* Vector of amplitudes of diffusion gradient on all three axes */
    FLOAT orig_dif_amp[3];    /* Vector of amplitudes of diffusion gradient - 
                                 original values when starting calculation */
    INT m, n, iter_count = 0;    /* Counter */
    INT k;                       /* multi b */
    FILE *six_sigma_fp = NULL;
    FLOAT ref_bval = 0.0;

    float tolerance = 0.015;     /* Maximum deviation from prescribed bvalue = +/- tolerance */ 
    
    FLOAT scalx_A, scalx_B, scalx_mid;
    FLOAT scaly_A, scaly_B, scaly_mid;
    FLOAT scalz_A, scalz_B, scalz_mid;
    
    float MaxAmpx = loggrd.tx_xyz;
    float MaxAmpy = loggrd.ty_xyz;
    float MaxAmpz = loggrd.tz_xyz;
    float minMaxAmp_log = 0;

    INT bvalue_iter_flag = TRUE;
    INT x_iter_flag, y_iter_flag, z_iter_flag;

    INT user_bval[1+MAX_NUM_BVALS_PSD];
    float orig_incdifx, orig_incdify, orig_incdifz;

    /* Obl 3in1 opt */
    INT i;
    FLOAT current_bval,b_val_ratio,b_val_ratio_final;
    FLOAT verified_dif_amp_x,verified_dif_amp_y,verified_dif_amp_z;
    FLOAT gx_norm,gy_norm,gz_norm;
    FLOAT gx_hw,gy_hw,gz_hw;
    INT gx_bd,gy_bd,gz_bd;
    FLOAT xpscale,ypscale,zpscale;

    minMaxAmp_log = FMin(3,loggrd.tx,loggrd.ty,loggrd.tz);

    derate_diffusion_amplitude(); /* Limiting the scale_all based on the max bval selected */

    if ( use_maxloggrad)
    {
        MaxAmpx = minMaxAmp_log * scale_all;
        MaxAmpy = minMaxAmp_log * scale_all;
        MaxAmpz = minMaxAmp_log * scale_all;
    }
    else 
    {
        MaxAmpx = loggrd.tx_xyz * scale_all;
        MaxAmpy = loggrd.ty_xyz * scale_all;
        MaxAmpz = loggrd.tz_xyz * scale_all;
    }

    if((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF) || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
    {
        MaxAmpx = loggrd.tx_xyz * scale_all;
        MaxAmpy = loggrd.ty_xyz * scale_all;
        MaxAmpz = loggrd.tz_xyz * scale_all;
        MaxAmpx = FMin(3, MaxAmpx, MaxAmpy, MaxAmpz);
        MaxAmpy = MaxAmpx;
        MaxAmpz = MaxAmpx;
    }
 
    /* initial values */
    x_iter_flag = y_iter_flag = z_iter_flag = TRUE;
    
    /* This will dump a file with actual b's, errors, etc. */
    /* NOTE: it appends to the file so it will continue to grow if not removed !!! */ 
    if(collect_six_sigma) {
        six_sigma_fp = fopen("b-value.txt","a+");
        if(!six_sigma_fp){
            printf("Could not open b-value.txt");
            return FAILURE;
        }
    } 
   
    /* Initialize diff_amp vector */
    for (n=0; n < MAX_NUM_BVALS_PSD; n++)
    {
        diff_ampx[n] = 0.0;
        diff_ampy[n] = 0.0;
        diff_ampz[n] = 0.0;
        user_bval[n] = bvalstab[n];

        for (m=0; m < NUM_DWI_DIRS; m++)
        {
            diff_ampx2[n][m] = 0.0;
            diff_ampy2[n][m] = 0.0;
            diff_ampz2[n][m] = 0.0;
        }
    }
    
    /* --- Calculate the bvalue for the original estimates--- */      
    /* Store the current gradient amplitudes */
    if (PSD_OFF == dualspinecho_flag)
    {
        orig_dif_amp[0] = a_gxdl;
        orig_dif_amp[1] = a_gydl;
        orig_dif_amp[2] = a_gzdl;
    } else {
        orig_dif_amp[0] = a_gxdl1;
        orig_dif_amp[1] = a_gydl1;
        orig_dif_amp[2] = a_gzdl1;
    }

    orig_incdifx = incdifx; 
    orig_incdify = incdify; 
    orig_incdifz = incdifz;

    /* Obl 3in1 opt */
    if (PSD_ON == obl_3in1_opt)
    {
        for (k=0; k<opnumbvals; k++)
        {
            ref_bval = user_bval[k];
            scalx_mid = sqrt(ref_bval/max_bval);
            scaly_mid = scalx_mid;
            scalz_mid = scalx_mid;
            amp_difx_bverify  = _amp_difx_bverify.fixedflag ?  ((void)(log_incdifx[0]*scalx_mid), amp_difx_bverify) : log_incdifx[0]*scalx_mid;
            amp_dify_bverify  = _amp_dify_bverify.fixedflag ?  ((void)(log_incdify[0]*scaly_mid), amp_dify_bverify) : log_incdify[0]*scaly_mid;
            amp_difz_bverify  = _amp_difz_bverify.fixedflag ?  ((void)(log_incdifz[0]*scalz_mid), amp_difz_bverify) : log_incdifz[0]*scalz_mid;

            b_val_ratio_final = 1.0;
            bvalue_iter_flag = TRUE;
            iter_count = 0;

            while( (bvalue_iter_flag == TRUE) && (iter_count < 15) && (ref_bval > 0.0) )
            {
                pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON;

                /* Calculate bvalue using pulsegen */
                status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location,
                                           num180s, opte, GAM, &loggrd, seq_entry_index, tsamp,
                                           act_tr, use_ermes, seg_debug, bmat_flag);

                if (status == FAILURE || status == SKIP)
                {
                    epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
                    return FAILURE;
                }

                pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;

                current_bval = curr_bvalue[0] + curr_bvalue[1] + curr_bvalue[2];
                b_val_ratio = current_bval/ ref_bval;

                if (collect_six_sigma && (iter_count == 0))
                {
                    fprintf (six_sigma_fp,"First b-value estimate: %f  %f  %f  %f\n",
                             curr_bvalue[0],curr_bvalue[1],curr_bvalue[2],current_bval);
                    fprintf (six_sigma_fp,"Target b-value: %f, multi-b index k=%d\n",
                             ref_bval,k);
                    fprintf (six_sigma_fp,"error estimate: %f\n",
                             (1.0 - b_val_ratio)*100.0);
                }

                if( (b_val_ratio >= (1.0 - tolerance)) && (b_val_ratio <= (1.0 + tolerance)) )
                {
                    bvalue_iter_flag = FALSE;

                    if (obl_3in1_opt_debug)
                    {
                        printf("Obl3in1: Iteration converged\n");
                    }

                    if (collect_six_sigma)
                    {
                        fprintf (six_sigma_fp,"Last b-value estimate at iter %d: %f  %f  %f %f\n",iter_count, curr_bvalue[0],
                                 curr_bvalue[1], curr_bvalue[2], current_bval );
                        fprintf (six_sigma_fp,"error estimate: %f\n\n\n",
                                 (1.0 - b_val_ratio)*100.0);
                    }
                }

                if (obl_3in1_opt_debug)
                {
                    printf("Obl3in1:  \n");
                    printf("Obl3in1: k=%d iter_count=%d\n", k, iter_count);
                    printf("Obl3in1: curr_bvalue x=%f curr_bvalue y=%f curr_bvalue z=%f\n", curr_bvalue[0], curr_bvalue[1], curr_bvalue[2]);
                    printf("Obl3in1: ref_bval=%f  current_bval=%f b_val_ratio=%f\n", ref_bval, current_bval, b_val_ratio);
                }

                if (bvalue_iter_flag == TRUE)
                {
                    verified_dif_amp_x = amp_difx_bverify/sqrt(b_val_ratio);
                    verified_dif_amp_y = amp_dify_bverify/sqrt(b_val_ratio);
                    verified_dif_amp_z = amp_difz_bverify/sqrt(b_val_ratio);

                    if ((abs(verified_dif_amp_x) > abs(log_incdifx[0])) ||
                        (abs(verified_dif_amp_y) > abs(log_incdify[0])) ||
                        (abs(verified_dif_amp_z) > abs(log_incdifz[0])))
                    {
                        bvalue_iter_flag = FALSE;

                        if (obl_3in1_opt_debug)
                        {
                            printf("Obl3in1: MPG exceeds max amplitude, so no adjustment on diffusion pulses\n");
                        }
                    }

                    b_val_ratio_final *= b_val_ratio;
                    amp_difx_bverify  = _amp_difx_bverify.fixedflag ?  ((void)(verified_dif_amp_x), amp_difx_bverify) : verified_dif_amp_x;
                    amp_dify_bverify  = _amp_dify_bverify.fixedflag ?  ((void)(verified_dif_amp_y), amp_dify_bverify) : verified_dif_amp_y;
                    amp_difz_bverify  = _amp_difz_bverify.fixedflag ?  ((void)(verified_dif_amp_z), amp_difz_bverify) : verified_dif_amp_z;

                    if (obl_3in1_opt_debug)
                    {
                        printf("Obl3in1: New updated amplitude\n");
                    }
                }

                if (obl_3in1_opt_debug)
                {
                    printf("Obl3in1: log_incdifx[0]=%f\n", log_incdifx[0]);
                    printf("Obl3in1: log_incdify[0]=%f\n", log_incdify[0]);
                    printf("Obl3in1: log_incdifz[0]=%f\n", log_incdifz[0]);
                }

                iter_count++;

            } /* end while */

            for (i=0; i<num_dif; i++)
            {
                if (ref_bval > 0.0)
                {
                    diff_ampx2[k][i] = scalx_mid*log_incdifx[i]/sqrt(b_val_ratio_final);
                    diff_ampy2[k][i] = scaly_mid*log_incdify[i]/sqrt(b_val_ratio_final);
                    diff_ampz2[k][i] = scalz_mid*log_incdifz[i]/sqrt(b_val_ratio_final);
                }
                else
                {
                    diff_ampx2[k][i] = 0.0;
                    diff_ampy2[k][i] = 0.0;
                    diff_ampz2[k][i] = 0.0;
                }

                if (obl_3in1_opt_debug)
                {
                    printf("Obl3in1: Final amplitude of MPG\n");
                    printf("Obl3in1: b_val_ratio_final=%f\n", b_val_ratio_final);
                    printf("Obl3in1: k=%d user_bval=%f diff_ampx2=%f diff_ampy2=%f diff_ampz2=%f\n", k, ref_bval, diff_ampx2[k][i], diff_ampy2[k][i], diff_ampz2[k][i]);
                }

                if (collect_six_sigma)
                {
                        fprintf(six_sigma_fp, "diff_ampx2[%d][%d]=%f, diff_ampy2[%d][%d]=%f, diff_ampz2[%d][%d]=%f,\n",k,i,diff_ampx2[k][i],k,i,diff_ampy2[k][i],k,i,diff_ampz2[k][i]);
                }
            }
        } /* end k loop */

        if (obl_3in1_opt_debug)
        {
            xpscale=(float)phygrd.xfull/(phygrd.xfs *(float)max_pg_iamp);
            ypscale=(float)phygrd.yfull/(phygrd.yfs *(float)max_pg_iamp);
            zpscale=(float)phygrd.zfull/(phygrd.zfs *(float)max_pg_iamp);
            printf("Obl3in1: \n");
            printf("Obl3in1: Predicted MPG amplitude in each axis in G/cm.\n");
            for (k=0; k<opnumbvals; k++)
            {
                for(i=0; i<num_dif; i++)
                {
                    gx_norm = diff_ampx2[k][i]/ loggrd.tx;
                    gy_norm = diff_ampy2[k][i]/ loggrd.ty;
                    gz_norm = diff_ampz2[k][i]/ loggrd.tz;
                    gx_bd =(int)((float)rsprot[0][0]*gx_norm+(float)rsprot[0][1]*gy_norm+(float)rsprot[0][2]*gz_norm);
                    gy_bd =(int)((float)rsprot[0][3]*gx_norm+(float)rsprot[0][4]*gy_norm+(float)rsprot[0][5]*gz_norm);
                    gz_bd =(int)((float)rsprot[0][6]*gx_norm+(float)rsprot[0][7]*gy_norm+(float)rsprot[0][8]*gz_norm);
                    gx_hw = (float)gx_bd/ (xpscale*(float)max_pg_iamp);
                    gy_hw = (float)gy_bd/ (ypscale*(float)max_pg_iamp);
                    gz_hw = (float)gz_bd/ (zpscale*(float)max_pg_iamp);
                    printf("Obl3in1: b[%d]dir[%d] gx_hw= %f gy_hw= %f gz_hw= %f\n",k,i,gx_hw,gy_hw,gz_hw);
                }
            }
        }
    } /* end obl_3in_opt */
    else
    {
        for (k=0; k<opnumbvals; k++) {    
            x_iter_flag = y_iter_flag = z_iter_flag = TRUE;

            /* Set the gradients to the current estimates for the Rx bvalue */
            incdifx  = _incdifx.fixedflag ?  ((void)(orig_incdifx), incdifx) : orig_incdifx;
            incdify  = _incdify.fixedflag ?  ((void)(orig_incdify), incdify) : orig_incdify;
            incdifz  = _incdifz.fixedflag ?  ((void)(orig_incdifz), incdifz) : orig_incdifz;
            dif_amp[0] = incdifx;
            dif_amp[1] = incdify;
            dif_amp[2] = incdifz;      

            if (PSD_OFF == dualspinecho_flag)
            {
                a_gxdl  = _a_gxdl.fixedflag ?  ((void)(dif_amp[0]), a_gxdl) : dif_amp[0];
                a_gxdr  = _a_gxdr.fixedflag ?  ((void)(dif_amp[0]), a_gxdr) : dif_amp[0];
                a_gydl  = _a_gydl.fixedflag ?  ((void)(dif_amp[1]), a_gydl) : dif_amp[1];
                a_gydr  = _a_gydr.fixedflag ?  ((void)(dif_amp[1]), a_gydr) : dif_amp[1];
                a_gzdl  = _a_gzdl.fixedflag ?  ((void)(dif_amp[2]), a_gzdl) : dif_amp[2];
                a_gzdr  = _a_gzdr.fixedflag ?  ((void)(dif_amp[2]), a_gzdr) : dif_amp[2];

            } else {
                a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(dif_amp[0]), a_gxdl1) : dif_amp[0];
                a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)((-dif_amp[0])), a_gxdr1) : (-dif_amp[0]);
                a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(dif_amp[0]), a_gxdl2) : dif_amp[0];
                a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)((-dif_amp[0])), a_gxdr2) : (-dif_amp[0]);

                a_gydl1  = _a_gydl1.fixedflag ?  ((void)(dif_amp[1]), a_gydl1) : dif_amp[1];
                a_gydr1  = _a_gydr1.fixedflag ?  ((void)((-dif_amp[1])), a_gydr1) : (-dif_amp[1]);
                a_gydl2  = _a_gydl2.fixedflag ?  ((void)(dif_amp[1]), a_gydl2) : dif_amp[1];
                a_gydr2  = _a_gydr2.fixedflag ?  ((void)((-dif_amp[1])), a_gydr2) : (-dif_amp[1]);

                a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(dif_amp[2]), a_gzdl1) : dif_amp[2];
                a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)((-dif_amp[2])), a_gzdr1) : (-dif_amp[2]);
                a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(dif_amp[2]), a_gzdl2) : dif_amp[2];
                a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)((-dif_amp[2])), a_gzdr2) : (-dif_amp[2]);
            }

            /* MRIhc19235 */ 
            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON; 

            /* Calculate bvalue using pulsegen */
            status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location, 
                                       num180s, opte, GAM, &loggrd, seq_entry_index, tsamp, 
                                       act_tr, use_ermes, seg_debug, bmat_flag);
            if(status == FAILURE || status == SKIP) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
                return FAILURE;
            }

            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;

            if ((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
            {
                ref_bval = user_bval[k]/3.0;
            }
            else if ((opdfaxall > PSD_OFF) && (gradopt_diffall == PSD_ON))
            {
                ref_bval = user_bval[k]/2.0;
            }
            else
            {
                ref_bval = user_bval[k];
            }

            per_err_orig_x  = _per_err_orig_x.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[0])/ref_bval), per_err_orig_x) : 100.0*(ref_bval-curr_bvalue[0])/ref_bval;
            per_err_orig_y  = _per_err_orig_y.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[1])/ref_bval), per_err_orig_y) : 100.0*(ref_bval-curr_bvalue[1])/ref_bval;
            per_err_orig_z  = _per_err_orig_z.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[2])/ref_bval), per_err_orig_z) : 100.0*(ref_bval-curr_bvalue[2])/ref_bval;

            if (collect_six_sigma) {
                fprintf (six_sigma_fp,"First b-value estimate: %f  %f  %f\n", 
                         curr_bvalue[0],curr_bvalue[1],curr_bvalue[2]); 
                fprintf (six_sigma_fp,"Target b-value: %f, multi-b index k=%d\n", 
                         ref_bval,k); 
                fprintf (six_sigma_fp,"error estimate: %f  %f  %f\n", 
                         per_err_orig_x, per_err_orig_y, per_err_orig_z); 
            }

            /* Bisection to get the to proper b-value */
            /* Set initial upper and mid scale for bisection */
            scalx_A = scalx_mid = 1.0;   
            scaly_A = scaly_mid = 1.0;
            scalz_A = scalz_mid = 1.0;

            /* If the b-value calculated above is outside the tolerance, 
               then we will guess that the diffusion lobes will need to be 
               increased/decreased by the sqrt(test_opbval/curr_bvalue[0]). 
               If the scaled factor * amp, exceeds the MaxAmp, set the scale factor 
               to 1.0 and dont iterate    */

            /* Check X-axis */
            if(curr_bvalue[0] > ref_bval*(1+tolerance) || curr_bvalue[0] < ref_bval*(1-tolerance) ) {
                scalx_mid = sqrt(ref_bval/curr_bvalue[0]); 

                /* protect against overrange */
                if(incdifx*scalx_mid > MaxAmpx) {
                    scalx_mid = 1.0;
                    x_iter_flag = 0;
                }
            }

            /* Check Y-Axis */
            if(curr_bvalue[1] > ref_bval*(1+tolerance) || curr_bvalue[1] < ref_bval*(1-tolerance) ) {
                scaly_mid = sqrt(ref_bval/curr_bvalue[1]); 

                /* protect against overrange */
                if(incdify*scaly_mid > MaxAmpy) {
                    scaly_mid = 1.0;
                    y_iter_flag = 0;
                }
            }

            /* Check Z-Axis */
            if(curr_bvalue[2] > ref_bval*(1+tolerance) || curr_bvalue[2] < ref_bval*(1-tolerance) ) {
                scalz_mid = sqrt(ref_bval/curr_bvalue[2]); 

                /* protect against overrange */
                if(incdifz*scalz_mid > MaxAmpz) {
                    scalz_mid = 1.0;
                    z_iter_flag = 0;
                }
            }

            /* Set up bracketing for bisection search */
            /* Note: there may be more sophisticated searches we could do */
            /* but this is guaranteed to converge and with the intial guess */
            /* rarely takes longer than 5-6 iterations (in most cases 0)    */

            /* Set upper scale */ 
            scalx_A = (1.5*scalx_mid > 1.0) ? 1.0 : 1.5*scalx_mid;   
            scaly_A = (1.5*scaly_mid > 1.0) ? 1.0 : 1.5*scaly_mid;
            scalz_A = (1.5*scalz_mid > 1.0) ? 1.0 : 1.5*scalz_mid;

            /* Set lower scale for bisection */
            scalx_B = 0.5*scalx_mid;  
            scaly_B = 0.5*scaly_mid;
            scalz_B = 0.5*scalz_mid;

            /* Check to see if we need to iterate */
            bvalue_iter_flag = (x_iter_flag || y_iter_flag || z_iter_flag); 
            /* For low bvalues if convergence within tolerance range
               fails in 15 iterations, then force exit out of loop
               and continue..this is a kludge to prevent download
               failures and psd timeouts observed when sat is turned on 
               usually for very low b-value Rx */        
            iter_count = 0;
            while( (bvalue_iter_flag == TRUE) && (iter_count < 15) && (ref_bval > 0.0) ) {

                if (PSD_OFF ==  dualspinecho_flag)
                {
                    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(scalx_mid*dif_amp[0]), a_gxdl) : scalx_mid*dif_amp[0];
                    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(scalx_mid*dif_amp[0]), a_gxdr) : scalx_mid*dif_amp[0];
                    a_gydl  = _a_gydl.fixedflag ?  ((void)(scaly_mid*dif_amp[1]), a_gydl) : scaly_mid*dif_amp[1];
                    a_gydr  = _a_gydr.fixedflag ?  ((void)(scaly_mid*dif_amp[1]), a_gydr) : scaly_mid*dif_amp[1];
                    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(scalz_mid*dif_amp[2]), a_gzdl) : scalz_mid*dif_amp[2];
                    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(scalz_mid*dif_amp[2]), a_gzdr) : scalz_mid*dif_amp[2];

                } else {
                    a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(scalx_mid*dif_amp[0]), a_gxdl1) : scalx_mid*dif_amp[0];
                    a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(scalx_mid*(-dif_amp[0])), a_gxdr1) : scalx_mid*(-dif_amp[0]);
                    a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(scalx_mid*dif_amp[0]), a_gxdl2) : scalx_mid*dif_amp[0];
                    a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(scalx_mid*(-dif_amp[0])), a_gxdr2) : scalx_mid*(-dif_amp[0]);

                    a_gydl1  = _a_gydl1.fixedflag ?  ((void)(scaly_mid*dif_amp[1]), a_gydl1) : scaly_mid*dif_amp[1];
                    a_gydr1  = _a_gydr1.fixedflag ?  ((void)(scaly_mid*(-dif_amp[1])), a_gydr1) : scaly_mid*(-dif_amp[1]);
                    a_gydl2  = _a_gydl2.fixedflag ?  ((void)(scaly_mid*dif_amp[1]), a_gydl2) : scaly_mid*dif_amp[1];
                    a_gydr2  = _a_gydr2.fixedflag ?  ((void)(scaly_mid*(-dif_amp[1])), a_gydr2) : scaly_mid*(-dif_amp[1]);

                    a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(scalz_mid*dif_amp[2]), a_gzdl1) : scalz_mid*dif_amp[2];
                    a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(scalz_mid*(-dif_amp[2])), a_gzdr1) : scalz_mid*(-dif_amp[2]);
                    a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(scalz_mid*dif_amp[2]), a_gzdl2) : scalz_mid*dif_amp[2];
                    a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(scalz_mid*(-dif_amp[2])), a_gzdr2) : scalz_mid*(-dif_amp[2]);
                }

                /* MRIhc19235 */
                pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON;

                /* Check results */
                /* Calculate bvalue using pulsegen */
                status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location, 
                                           num180s, opte, GAM, &loggrd, seq_entry_index, 
                                           tsamp, act_tr, use_ermes, seg_debug, bmat_flag);
                if(status == FAILURE || status == SKIP) {
                    epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
                    return FAILURE;
                }

                pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;

                /* axis - X */
                if(curr_bvalue[0] < ref_bval*(1-tolerance)) {

                    /* Set new lower bound X */ 
                    scalx_B = scalx_mid;
                    x_iter_flag = TRUE; 

                    scalx_mid = scalx_B + 0.5*(scalx_A - scalx_B);

                } else if( curr_bvalue[0] > ref_bval*(1+tolerance)) {

                    /* Set new upper bound X */ 
                    scalx_A = scalx_mid;
                    x_iter_flag = TRUE;

                    scalx_mid = scalx_B + 0.5*(scalx_A - scalx_B);

                    /* protect against overrange */
                    if(incdifx*scalx_mid > MaxAmpx) {
                        scalx_mid = 1.0;
                        x_iter_flag = FALSE;
                    }

                } else {

                    /* call it good */                  
                    x_iter_flag = FALSE;                
                }

                /* axis - Y */
                if(curr_bvalue[1] < ref_bval*(1-tolerance)) {

                    /* Set new lower bound Y */
                    scaly_B = scaly_mid;
                    y_iter_flag = TRUE;

                    scaly_mid = scaly_B + 0.5*(scaly_A - scaly_B);

                } else if( curr_bvalue[1] > ref_bval*(1+tolerance)) {

                    /* Set new upper bound Y */
                    scaly_A = scaly_mid;
                    y_iter_flag = TRUE;

                    scaly_mid = scaly_B + 0.5*(scaly_A - scaly_B);

                    /* protect against overrange */
                    if(incdify*scaly_mid > MaxAmpy) {
                        scaly_mid = 1.0;
                        y_iter_flag = FALSE;
                    }

                } else {                
                    /* call it good */
                    y_iter_flag = FALSE;
                }

                /* axis - Z */
                if(curr_bvalue[2] < ref_bval*(1-tolerance)) {

                    /* Set new lower bound Z */
                    scalz_B = scalz_mid;
                    z_iter_flag = TRUE;

                    scalz_mid = scalz_B + 0.5*(scalz_A - scalz_B);

                } else if( curr_bvalue[2] > ref_bval*(1+tolerance)) {

                    /* Set new upper bound Z */
                    scalz_A = scalz_mid;
                    z_iter_flag = TRUE;

                    scalz_mid = scalz_B + 0.5*(scalz_A - scalz_B);

                    /* protect against overrange */
                    if(incdifz*scalz_mid > MaxAmpz) {
                        scalz_mid = 1.0;
                        z_iter_flag = FALSE;
                    }

                } else {
                    /* call it good */
                    z_iter_flag = FALSE;
                }

                bvalue_iter_flag = (x_iter_flag || y_iter_flag || z_iter_flag);
                iter_count++;

            } /* end while */

#ifdef UNDEF
            /* Check that new results are within tolerance */
            if ( curr_bvalue[0] < ref_bval*(1-tolerance) || curr_bvalue[1] < ref_bval*(1-tolerance) 
                 || curr_bvalue[2] < ref_bval*(1-tolerance) || curr_bvalue[0] > ref_bval*(1+tolerance) 
                 || curr_bvalue[1] > ref_bval*(1+tolerance) ||  curr_bvalue[2] > ref_bval*(1+tolerance) ) {

                /* NOTE: Could use an iterative technique here to find the proper gradients */
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "bvalue adjustment" );
                printf("Actual b-values: x = %12.8f, y = %12.8f, z = %12.8f\n",
                       curr_bvalue[0], curr_bvalue[1], curr_bvalue[2]);
                return FAILURE;
            } 
#endif   

            per_err_corr_x  = _per_err_corr_x.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[0])/ref_bval), per_err_corr_x) : 100.0*(ref_bval-curr_bvalue[0])/ref_bval;
            per_err_corr_y  = _per_err_corr_y.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[1])/ref_bval), per_err_corr_y) : 100.0*(ref_bval-curr_bvalue[1])/ref_bval;
            per_err_corr_z  = _per_err_corr_z.fixedflag ?     ((void)(100.0*(ref_bval-curr_bvalue[2])/ref_bval), per_err_corr_z) : 100.0*(ref_bval-curr_bvalue[2])/ref_bval;

            if (collect_six_sigma) { 
                fprintf (six_sigma_fp,"Last b-value estimate at iter %d: %f  %f  %f\n",iter_count, curr_bvalue[0], 
                         curr_bvalue[1], curr_bvalue[2] ); 
                fprintf (six_sigma_fp,"error estimate: %f  %f  %f\n\n\n", per_err_corr_x, 
                         per_err_corr_y, per_err_corr_z); 
            }

            /* Update the incdif CVs and put results in diff_amp arrays to pass to the Tgt */
            if (ref_bval > 0.0){
                incdifx  = _incdifx.fixedflag ?  ((void)(scalx_mid*dif_amp[0]), incdifx) : scalx_mid*dif_amp[0];
                incdify  = _incdify.fixedflag ?  ((void)(scaly_mid*dif_amp[1]), incdify) : scaly_mid*dif_amp[1];
                incdifz  = _incdifz.fixedflag ?  ((void)(scalz_mid*dif_amp[2]), incdifz) : scalz_mid*dif_amp[2];
            }
            else 
            {
                incdifx  = _incdifx.fixedflag ?  ((void)(0.0), incdifx) : 0.0;
                incdify  = _incdify.fixedflag ?  ((void)(0.0), incdify) : 0.0;
                incdifz  = _incdifz.fixedflag ?  ((void)(0.0), incdifz) : 0.0;
            }

            diff_ampx[k] = incdifx; 
            diff_ampy[k] = incdify;
            diff_ampz[k] = incdifz;

        }  /* end of multi b loop k */

        if (collect_six_sigma) { 
            for(k=0;k<opnumbvals;k++) 
            { 
                fprintf(six_sigma_fp, "diff_ampx[%d]=%f, diff_ampy[%d]=%f, diff_ampz[%d]=%f\n",k,diff_ampx[k],k,diff_ampy[k],k,diff_ampz[k]); 
            } 
        } 

        /* Put the original amplitudes back */
        /* These are used for pulsegen purposes and we want */
        /* them to be there largest */
        if (PSD_OFF == dualspinecho_flag)
        {
            a_gxdl  = _a_gxdl.fixedflag ?  ((void)(orig_dif_amp[0]), a_gxdl) : orig_dif_amp[0];
            a_gxdr  = _a_gxdr.fixedflag ?  ((void)(orig_dif_amp[0]), a_gxdr) : orig_dif_amp[0];
            a_gydl  = _a_gydl.fixedflag ?  ((void)(orig_dif_amp[1]), a_gydl) : orig_dif_amp[1];
            a_gydr  = _a_gydr.fixedflag ?  ((void)(orig_dif_amp[1]), a_gydr) : orig_dif_amp[1];
            a_gzdl  = _a_gzdl.fixedflag ?  ((void)(orig_dif_amp[2]), a_gzdl) : orig_dif_amp[2];
            a_gzdr  = _a_gzdr.fixedflag ?  ((void)(orig_dif_amp[2]), a_gzdr) : orig_dif_amp[2];

        } else {
            a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(orig_dif_amp[0]), a_gxdl1) : orig_dif_amp[0];
            a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-orig_dif_amp[0]), a_gxdr1) : -orig_dif_amp[0];
            a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(orig_dif_amp[0]), a_gxdl2) : orig_dif_amp[0];
            a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-orig_dif_amp[0]), a_gxdr2) : -orig_dif_amp[0];

            a_gydl1  = _a_gydl1.fixedflag ?  ((void)(orig_dif_amp[1]), a_gydl1) : orig_dif_amp[1];
            a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-orig_dif_amp[1]), a_gydr1) : -orig_dif_amp[1];
            a_gydl2  = _a_gydl2.fixedflag ?  ((void)(orig_dif_amp[1]), a_gydl2) : orig_dif_amp[1];
            a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-orig_dif_amp[1]), a_gydr2) : -orig_dif_amp[1];

            a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(orig_dif_amp[2]), a_gzdl1) : orig_dif_amp[2];
            a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-orig_dif_amp[2]), a_gzdr1) : -orig_dif_amp[2];
            a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(orig_dif_amp[2]), a_gzdl2) : orig_dif_amp[2];
            a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-orig_dif_amp[2]), a_gzdr2) : -orig_dif_amp[2];
        }
    }

    if (collect_six_sigma) {
        fclose(six_sigma_fp);
    }

    return SUCCESS;
    
} /* end of verify_bvalue() */

/*
 *  calc_b_matrix:
 *
 *  This function will calculate the b-matrix (on and off-axis terms).  Its include for completeness
 *  and may be used in the future.  For this to work properly, the b-matrix must be recompumted for
 *  every diffusion direction.  Thus, this loops over all the shots in a DTI scan and uses the X,Y,Z 
 *  components of the b-vector for the computation.  These are stored in the TENS[] array.
 *  
 */

STATUS calc_b_matrix( FLOAT * curr_bvalue,
                      const FLOAT rf_excite_location, 
                      const FLOAT * rf_180_location, 
                      const INT num180s, 
                      const INT seq_entry_index, 
                      const INT bmat_flag, 
                      const INT seg_debug)
{

    /* Variables for b-value calculation */
      STATUS status;            /* Status variable to catch errors from function calls */
      static INT num_dirs = -1; /* static variable that keeps track of updated to dirs */
      static INT bval = -1;
      INT i, j;
      FLOAT dif_amp[3];         /* Vector of amplitudes of diffusion gradient on all three axes */
        
      /* Set the gradients to the current estimates for the Rx bvalue */
      dif_amp[0] = incdifx;
      dif_amp[1] = incdify;
      dif_amp[2] = incdifz;    
 
      /* BJM: see if number of direcitons has changed */
      /*      If yes, then read orientations and recompute */
      /*      b-matrix.  If not, simply return....*/

      if( (num_dirs != (num_tensor + num_B0) || !floatsAlmostEqualEpsilons(bval, bvalstab[0], 2)) &&
          (bmat_flag == TRUE) ) {
          num_dirs = num_tensor + num_B0;
          bval = max_bval;
          
          /* set up tensor orientations */
          if ( FAILURE == set_tensor_orientations() ){
              return FAILURE;
          }           
          
      } else {
          /* no need */
          return SUCCESS;
      }
     
      /* loop over each direction */
      for( i = 0; i<num_dirs; i++) {
            
            if (PSD_OFF == dualspinecho_flag)
            {
                a_gxdl  = _a_gxdl.fixedflag ?  ((void)(TENSOR_HOST[0][i]*dif_amp[0]), a_gxdl) : TENSOR_HOST[0][i]*dif_amp[0];
                a_gxdr  = _a_gxdr.fixedflag ?  ((void)(TENSOR_HOST[0][i]*dif_amp[0]), a_gxdr) : TENSOR_HOST[0][i]*dif_amp[0];
                a_gydl  = _a_gydl.fixedflag ?  ((void)(TENSOR_HOST[1][i]*dif_amp[1]), a_gydl) : TENSOR_HOST[1][i]*dif_amp[1];
                a_gydr  = _a_gydr.fixedflag ?  ((void)(TENSOR_HOST[1][i]*dif_amp[1]), a_gydr) : TENSOR_HOST[1][i]*dif_amp[1];
                a_gzdl  = _a_gzdl.fixedflag ?  ((void)(TENSOR_HOST[2][i]*dif_amp[2]), a_gzdl) : TENSOR_HOST[2][i]*dif_amp[2];
                a_gzdr  = _a_gzdr.fixedflag ?  ((void)(TENSOR_HOST[2][i]*dif_amp[2]), a_gzdr) : TENSOR_HOST[2][i]*dif_amp[2];
		/* granty edit for custom waveforms */
		waveform_type  = _waveform_type.fixedflag ?  ((void)(WAVE_HOST[i]), waveform_type) : WAVE_HOST[i];
                
            } else {
                a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(TENSOR_HOST[0][i]*dif_amp[0]), a_gxdl1) : TENSOR_HOST[0][i]*dif_amp[0];
                a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(TENSOR_HOST[0][i]*(-dif_amp[0])), a_gxdr1) : TENSOR_HOST[0][i]*(-dif_amp[0]);
                a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(TENSOR_HOST[0][i]*dif_amp[0]), a_gxdl2) : TENSOR_HOST[0][i]*dif_amp[0];
                a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(TENSOR_HOST[0][i]*(-dif_amp[0])), a_gxdr2) : TENSOR_HOST[0][i]*(-dif_amp[0]);
                
                a_gydl1  = _a_gydl1.fixedflag ?  ((void)(TENSOR_HOST[1][i]*dif_amp[1]), a_gydl1) : TENSOR_HOST[1][i]*dif_amp[1];
                a_gydr1  = _a_gydr1.fixedflag ?  ((void)(TENSOR_HOST[1][i]*(-dif_amp[1])), a_gydr1) : TENSOR_HOST[1][i]*(-dif_amp[1]);
                a_gydl2  = _a_gydl2.fixedflag ?  ((void)(TENSOR_HOST[1][i]*dif_amp[1]), a_gydl2) : TENSOR_HOST[1][i]*dif_amp[1];
                a_gydr2  = _a_gydr2.fixedflag ?  ((void)(TENSOR_HOST[1][i]*(-dif_amp[1])), a_gydr2) : TENSOR_HOST[1][i]*(-dif_amp[1]);
                
                a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(TENSOR_HOST[2][i]*dif_amp[2]), a_gzdl1) : TENSOR_HOST[2][i]*dif_amp[2];
                a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(TENSOR_HOST[2][i]*(-dif_amp[2])), a_gzdr1) : TENSOR_HOST[2][i]*(-dif_amp[2]);
                a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(TENSOR_HOST[2][i]*dif_amp[2]), a_gzdl2) : TENSOR_HOST[2][i]*dif_amp[2];
                a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(TENSOR_HOST[2][i]*(-dif_amp[2])), a_gzdr2) : TENSOR_HOST[2][i]*(-dif_amp[2]);
            }
           
            /* MRIhc19235 */
            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON;
 
            /* Check results */
            /* Calculate bvalue using pulsegen */
            status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location, 
                                       num180s, opte, GAM, &loggrd, seq_entry_index, 
                                       tsamp, act_tr, use_ermes, seg_debug, bmat_flag);
            if(status == FAILURE || status == SKIP) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
                return FAILURE;
            }

            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;
 
            /* fill b-matirx */
            for(j = 0; j < 6; j++) {
                B_MATRIX[j][i] = curr_bvalue[j];
            }
   
            /* out put of b-matrix */
            if( i < num_B0) {
                fprintf(stdout,"T2 Image\n");
            } else {
                fprintf(stdout,"Diffusion Image\n");
            }
            fprintf(stdout,"Repetition = %d\n",i);
            fprintf(stdout,"X Comp = %12.8f, Y Comp = %12.8f, Z Comp = %12.8f\n",
                    TENSOR_HOST[0][i], TENSOR_HOST[1][i], TENSOR_HOST[2][i]);
            fprintf(stdout,"Matrix b-values: xy = %12.8f, xy = %12.8f, xz = %12.8f\n",
                    curr_bvalue[0],curr_bvalue[3],curr_bvalue[4]);
            fprintf(stdout,"Matrix b-values: yx = %12.8f, yy = %12.8f, yz = %12.8f\n",
                    curr_bvalue[3],curr_bvalue[1],curr_bvalue[5]);
            fprintf(stdout,"Matrix b-values: zx = %12.8f, zy = %12.8f, zz = %12.8f\n",
                    curr_bvalue[4],curr_bvalue[5],curr_bvalue[2]);
            fflush(stdout);

        } /* end for loop */           

        return SUCCESS;
        
} /* end of calc_b_matrix() */


/* BJM: added 5/20/03 for Linux */

STATUS
#ifdef __STDC__ 
nexcalc( void )
#else /* !__STDC__ */
    nexcalc()
#endif /* __STDC__ */
{ 
    /* This is a similar set of codes as the Nex bookkeeping section, except
       that all the checks have been removed because they have already been
       done once when this routine is called. */

    if (fract_ky == PSD_ON)
        fn  = _fn.fixedflag ?  ((void)(0.5), fn) : 0.5;
    else
        fn  = _fn.fixedflag ?  ((void)(1.0), fn) : 1.0;

    nop  = _nop.fixedflag ?  ((void)(1), nop) : 1;

    if(exist(opdiffuse) == PSD_ON)
        nex  = _nex.fixedflag ?   ((void)(IMax(2,(int)1,(int)max_nex)), nex) : IMax(2,(int)1,(int)max_nex);
    else
    {
        nex  = _nex.fixedflag ?   ((void)(IMax(2,(int)1,(int)opnex)), nex) : IMax(2,(int)1,(int)opnex);
        /* update the Nex fields */
        pinexnub = 62;
        pinexval2 = 1;
        pinexval3 = 2;
        pinexval4 = 4;
        pinexval5 = 8;
        pinexval6 = 16;
    }
    return SUCCESS;
}   /* end nexcalc() */

STATUS
#ifdef __STDC__ 
setb0rotmats( void )
#else /* !__STDC__ */
    setb0rotmats()
#endif /* __STDC__ */
{
    int slice, n;
    for (slice=0; slice<3; slice++) {
        for (n=0; n<9; n++)
            scan_info[slice].oprot[n] = 0.0;
    }

    /* 1st slice (1st in time order) is an axial */
    scan_info[0].oprot[0] = 1.0; /* readout on physical X */
    scan_info[0].oprot[4] = 1.0; /* blips on physical Y */
    scan_info[0].oprot[8] = 1.0; /* slice on physical Z */

    /* 2nd slice (3rd in time order) is a saggital */
    scan_info[1].oprot[3] = 1.0; /* readout on physical Y */
    scan_info[1].oprot[7] = 1.0; /* blips on physical Z */
    scan_info[1].oprot[2] = 1.0; /* slice on physical X */

    /* 3rd slice (2nd in time order) is a coronal */
    scan_info[2].oprot[6] = 1.0; /* readout on physical Z */
    scan_info[2].oprot[1] = 1.0; /* blips on physical X */
    scan_info[2].oprot[5] = 1.0; /* slice on physical Y */

    /* new geometry info! */
    opnewgeo = 1;

    /* set slice_reset */
    slice_reset  = _slice_reset.fixedflag ?  ((void)(1), slice_reset) : 1;

    return SUCCESS;
}   /* end setb0rotmats() */

/* Description:
   For Auto Protocol Optimization, it's necessary to set
   min / max / delta values of optimized parameters.
   Default setting is described in getAPxParamInit() and
   this function can modify those initial values.
*/
void
getAPxParam(optval   *min,
            optval   *max,
            optdelta *delta,
            optfix   *fix,
            float    coverage,
            int      algorithm)
{
    delta->slthick_min = delta->slthick;

    min->yres = IMax(2, avminyres, 96);
    if (cffield <= B0_15000)
    {
        max->yres = IMin(2, avmaxyres, 192);
    }
    else
    {
        max->yres = IMin(2, avmaxyres, 256);
    }

    min->xy_ratio = 0.5;
    max->xy_ratio = 2.0;

    if(algorithm & APX_ALG_AUTO_TR)
    {
        if(PSD_ON == irprep_flag)
        {
            if (cffield <= B0_15000)
            {
                min->tr = 3000000;
            }
            else
            {
                min->tr = 2500000;
            }
        }
        else
        {
            min->tr = 2000000;
        }

        max->tr = min->tr * 2;

        if(PSD_ON == exist(opinrangetr))
        {
            min->tr = IMax(2, exist(opinrangetrmin), min->tr);
            min->tr = IMin(2, min->tr, TR_MAX_EPI2/ 2);
            max->tr = IMax(2, exist(opinrangetrmax), 2 * min->tr);
        }
    }

    int bval_counter = 0;
    for (bval_counter = 0; bval_counter < opnumbvals; bval_counter++)
    {
        if ((bvalstab[bval_counter] >= 500) && (cffield <= B0_15000))
        {
            min->difnex[bval_counter] = 2; 
        }
        else
        {
            min->difnex[bval_counter] = 1;
        }
    }
}

/* Description:
   For Auto Protocol Optimization, it's necessary to set
   flags to show which parameters are optimized and
   which algirithms are applied.
   Default setting is described in getAPxAlgorithmInit() and
   this function can modify those initial values.
*/
int getAPxAlgorithm(optparam *optflag, int *algorithm)
{
    int min_acqs_change_flag = PSD_ON;

    *algorithm &= ~APX_ALG_TSCAN_CHECK;
    *algorithm &= ~APX_ALG_AUTO_ACCINC;
    *algorithm &= ~APX_ALG_AUTO_ACCDEC;

    optflag->xres = 0;
    optflag->slicecnt = 0;
    optflag->accel_ph = 0;
    if((int)exist(opdifnext2) > 0)
    {
        optflag->difnext2 = 1;
    }
    optflag->difnextab = 1;

    if((PSD_ON == min_acqs_change_flag) && (t1flair_flag || ir_prep_manual_tr_mode) && existcv(opuser8))
    {
        optflag->user8 = 1;
    }

    return APX_CORE_BH_DWI;
}

/* HCSDM00398133 HCSDM00419770 */
STATUS setUserCVs()
{
    if (PSD_ON == exist(opdiffuse))
    {
        if (t1flair_flag || ir_prep_manual_tr_mode)
        {
            piuset |= use8;
            /* min acqs for t1flair is 2 */
            opuser8  = _opuser8.fixedflag ?  ((void)(2.0), opuser8) : 2.0;
            cvmod(opuser8, 1.0, 2.0, 2.0, "STIR Minimum Acqs", 0, " ");

            if (existcv(opuser8) && ((exist(opuser8) > 2) || (exist(opuser8) < 1) || !floatIsInteger(exist(opuser8))))
            {
                epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser8.descr );
                return FAILURE;
            }
        }
        else
        {
            piuset &= ~use8;
            cvmod( opuser8, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 8", 0, "" );
            cvoverride(opuser8, _opuser8.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        }

        /* overwrite opfat to ensure fatsat performance */
        if (epic_findputcvnum("opfat") == TRUE)
        {
            opfat_on_UI = opfat;
        }

        if (rfov_flag || mux_flag || (ssgr_flag && !dualspinecho_flag))
        {
            ss_rf1_compatible = PSD_OFF;
        }
        else
        {
            ss_rf1_compatible = PSD_ON;
        }

        if(((rfov_flag && focus_B0_robust_mode) ||
           ((mux_flag || ssgr_flag) && !rfov_flag && !ss_rf1_compatible)) &&
           (!irprep_flag && !exist(opspecir)))
        {
            cvoverride(opfat, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            cvoverride(opfat, opfat_on_UI, PSD_FIX_ON, PSD_EXIST_ON);
        }
 
        if ((irprep_flag || exist(opspecir) || exist(opfat)) && (ss_rf1_compatible == PSD_ON))
        {
            piuset |= use18;
            opuser18  = _opuser18.fixedflag ?  ((void)(0.0), opuser18) : 0.0;

            if (B0_30000 == cffield)
            {
                    cvmod(opuser18, 0.0, 2.0, 0.0, "Enhanced Fat Suppression (0=Off, 1=On, 2=Breast)",0," ");
            }
            else
            {
                cvmod(opuser18, 0.0, 1.0, 0.0, "Enhanced Fat Suppression (0=Off, 1=On)",0," ");
            }

            if ((B0_30000 == cffield) && (exist(opuser18) >= 1.72) && (exist(opuser18) <= 1.74))
            {
                /* 3: sqrt(3) New Type II Spectral Spatial RF1 */
                /* Designed for Breast DWI and allow thin slice */
                enhanced_fat_suppression  = _enhanced_fat_suppression.fixedflag ?  ((void)(3), enhanced_fat_suppression) : 3;
            }
            else
            {
                int max_opuser18 = 1.0;

                if (B0_30000 == cffield)
                {
                    max_opuser18 = 2.0;
                }
                else
                {
                    max_opuser18 = 1.0;
                }

                /* only integer value allowed */
                if (existcv(opuser18) && ((exist(opuser18) > max_opuser18) || (exist(opuser18) < 0) ||
                    (!floatIsInteger(exist(opuser18)))))
                {
                    epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser18.descr );
                    return FAILURE;
                }

                /* For non-Multiband */
                /* 0: SINC RF1 */
                /* 1: Product Spectral Spatial RF1 before DV22 software */
                /* 2: New Spectral Spatial RF1 designed for Breast DWI */
                enhanced_fat_suppression  = _enhanced_fat_suppression.fixedflag ?  ((void)((int)exist(opuser18)), enhanced_fat_suppression) : (int)exist(opuser18);
            }
        }
        else
        {
            piuset &= ~use18;
            cvmod( opuser18, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 18", 0, "" );
            cvoverride(opuser18, _opuser18.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
            enhanced_fat_suppression  = _enhanced_fat_suppression.fixedflag ?  ((void)(0), enhanced_fat_suppression) : 0;
        }
    }
    else
    {
        piuset &= ~use8;
        piuset &= ~use18;
        cvmod( opuser8, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 8", 0, "" );
        cvoverride(opuser8, _opuser8.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        cvmod( opuser18, -MAXFLOAT, MAXFLOAT, 0.0, "User CV variable 18", 0, "" );
        cvoverride(opuser18, _opuser18.defval, PSD_FIX_OFF, PSD_EXIST_OFF);
        enhanced_fat_suppression  = _enhanced_fat_suppression.fixedflag ?  ((void)(PSD_OFF), enhanced_fat_suppression) : PSD_OFF;
        ss_rf1_compatible = PSD_ON;
    }

    /* FLAIR CV should not be available for tensor, cardiac gating, respiratory
     * gating, IR prep FOCUS and Multiband */
    /* FLAIR + ASSET is not compatible for NON_VALUE_SYSTEM */
    if ( exist(opdiffuse) == PSD_ON && 
         ((tensor_flag == PSD_OFF) && (exist(opcgate) == PSD_OFF) && 
          (exist(oprtcgate) == PSD_OFF) && (exist(opirprep) == PSD_OFF) &&
          (navtrig_flag == PSD_OFF) && (rfov_flag == PSD_OFF) && (mux_flag == PSD_OFF)) &&
         !((value_system_flag == NON_VALUE_SYSTEM) && (exist(opasset) > PSD_OFF)) )
    {
        piuset |= use6;
    } else {
        piuset &=~use6;
    }

    opuser6  = _opuser6.fixedflag ?  ((void)(0.0), opuser6) : 0.0;
    cvmod(opuser6, 0, 1, 0, "FLAIR Inversion (1=on, 0=off)",1," ");

    /* MRIge59852: opuser6 range check */
    /* MRIge71092 */
    if( existcv(opuser6) && ((exist(opuser6) > 1) || (exist(opuser6) < 0) || (!floatIsInteger(exist(opuser6))))) 
    {
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser6.descr );
        return FAILURE;
    }

    return SUCCESS;
}

#ifdef __STDC__ 
STATUS DTI_Check( void )
#else /* !__STDC__ */
STATUS DTI_Check() 
#endif /* __STDC__ */ 
{
    INT mindir;  /*MRIhc05854*/
    INT maxdir;
    
    if (tensor_flag == PSD_ON) {

        maxdir = (PSD_ON == exist(opresearch) && (rhtensor_file_number > 0)) ? MAX_DIRECTIONS : act_numdir_clinical;

        /* check for valid number of directions */
        if( existcv(opdifnumdirs) && (exist(opdifnumdirs) > maxdir) ) {
            epic_error( use_ermes, "The maximum number of directions allowed is %d in tensor acquisition.", EM_PSD_TENSOR_MAX_DIRS, EE_ARGS(1), INT_ARG, maxdir );
            return FAILURE;
        }

        mindir = MIN_DTI_DIRECTIONS;

        if( existcv(opdifnumdirs) && (exist(opdifnumdirs) < mindir) ) {
            epic_error( use_ermes, "The minimum number of directions allowed is %d in tensor acquisition.", EM_PSD_TENSOR_MIN_DIRS, EE_ARGS(1), INT_ARG, mindir );
            return FAILURE;
        }
       
        /* HCSDM00476194 */
        if((validTensorFile == 0) && (rhtensor_file_number >0)) {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Tensor file number (CV11)" );
            return FAILURE;
        }   
        
        /* HCSDM00476194 */
        if( existcv(opdifnumdirs) && ((validTensorFileAndEntry == 0) && (rhtensor_file_number > 0)) ) {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "# of Diffusion Directions" );
            return FAILURE;
        }   
        
        if ( !floatsAlmostEqualEpsilons(exist(opuser0), 1.0, 2) ) 
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "Ramp Sampling OFF" );
            return FAILURE;
        }

        if ( (num_tensor + num_B0)  > avmaxpasses )
        {
            epic_error( 0, "Maximum number of phases exceeded, reduce # of phases or b-values to %d", EM_PSD_MAXPHASE_EXCEEDED, EE_ARGS(1), INT_ARG, avmaxpasses );
            return FAILURE;
        }

        if( existcv(opuser10) &&
            ((int)exist(opuser10) != 0) && ((int)exist(opuser10) != 1) ) {
            epic_error( use_ermes, "%s must be set to either 0 or 1.", EM_PSD_CV_0_OR_1, EE_ARGS(1), STRING_ARG, _opuser10.descr );
            return FAILURE;
        } 

   
    } /* end tensor_flag check */  

    return SUCCESS;
}  /* end DTI_Check */



/***********************************************************************/
/* CVCHECK                                                             */
/***********************************************************************/
STATUS
#ifdef __STDC__ 
cvcheck( void )
#else /* !__STDC__ */
    cvcheck() 
#endif /* __STDC__ */ 
{
    int temp_int = 0;
    int status_flag = SUCCESS;
    int bval_counter = 0;
    float allowed_max_bval = 0;
    float allowed_min_bval = 0;

    /* Check for existance of EPI flag */
    if (exist(opepi) != PSD_ON) {
        epic_error( use_ermes, "The EPI option must be selected with this psd.", EM_PSD_EPI_EPIOPTION, EE_ARGS(0) );
        return FAILURE;
    }

    /* SVBranch: GEHmr04247 */
    if( (isSVSystem()) &&
        (((exist(opdiffuse) == PSD_ON) &&
          ((float)min_seqgrad * cfxfd_power_limit > XFD_MINSEQ_LIMIT_DWI)) ||
         ((exist(opdiffuse) == PSD_OFF) && (epi_flair == PSD_ON) &&
          ((float)min_seqgrad * cfxfd_power_limit > XFD_MINSEQ_LIMIT_FLAIR))) )
    {
        epic_error( use_ermes, "The FOV needs to be increased to %3.1f cm",
                    EM_PSD_FOV_OUT_OF_RANGE4, EE_ARGS(1), FLOAT_ARG,
                    exist(opfov)/ 10.0 + 1.0 );
        return FAILURE;
    }	
	
    /* YMSmr06515, YMSmr06769 May 2005 KK */
    if (exist(opslquant) > MAXSLQUANT_EPI){
        epic_error( use_ermes, "The number of scan locations selected must be reduced to %d for the current prescription.",
                    EM_PSD_SLQUANT_OUT_OF_RANGE, 1, INT_ARG, MAXSLQUANT_EPI);
        return FAILURE; 
    } 

    /* cvcheck for HOEC */
{ /* Start of code inlined from HoecCorr.e HoecCheck */

    if (hoecc_flag != PSD_OFF)
    {
        if (exist(opslquant) > HOEC_MAX_SLQUANT)
        {
            avmaxslquant = HOEC_MAX_SLQUANT;
            epic_error(use_ermes, "Number of slices must be reduced to %d for the current prescription.",
                       EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, HOEC_MAX_SLQUANT);
            return ADVISORY_FAILURE;
        }

        if (tot_etl > HOEC_MAX_ETL)
        {
            epic_error(use_ermes, "The echo train length must be decreased to %d.",
                       EM_PSD_ETL_TOO_BIG, EE_ARGS(1), INT_ARG, HOEC_MAX_ETL - (iref_etl+iref_etl%2));
            return FAILURE;
        }

        if (intleaves > HOEC_MAX_ILEAVE)
        {
            epic_error( use_ermes, "Max. Number of Shots for DW-EPI is %d.",
                       EM_DWEPI_MAX_SHOT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, HOEC_MAX_ILEAVE);
            return FAILURE;
        }
        
        if (pass_reps > HOEC_MAX_DIFFGRADAMP_SIZE)
        {
            epic_error(use_ermes, "The number of phases must be reduced to %-d.",
                       EM_PSD_FMPVAS_PHASES_EXCEEDED, EE_ARGS(1), INT_ARG, HOEC_MAX_DIFFGRADAMP_SIZE);
            return FAILURE;
        }
 
        if ((exist(opdiffuse) == PSD_OFF) && (exist(opflair) == PSD_ON))
        {
            epic_error(use_ermes, "Real Time Field Adjustment is not compatible with FLAIR EPI.",
                       EM_PSD_HOECC_FLAIREPI_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;
        }

        if ((exist(opdiffuse) == PSD_ON) && (dualspinecho_flag == PSD_ON) && existcv(ophoecc))
        {
            epic_error(use_ermes, "Real Time Field Adjustment is not compatible with Dual Spin Echo.",
                       EM_PSD_HOECC_DSE_INCOMPATIBLE, EE_ARGS(0));
            return FAILURE;
        }
    }
    else
    {
        if ((tensor_flag == PSD_ON) && (dualspinecho_flag == PSD_OFF) && (rfov_flag == PSD_OFF) && existcv(ophoecc))
        {
            epic_error(use_ermes, 
                       "For the current prescription, either Dual Spin Echo or Real Time Field Adjustment needs to be turned on.",
                       EM_PSD_HOECC_DSE_BOTH_OFF, EE_ARGS(0));
            
            return FAILURE;
        }
    }

    setexist(ophoecc, PSD_OFF);

} /* End of code inlined from HoecCorr.e HoecCheck */

/* Calculate per unit (1 G/cm), per axis contribution to delta gradient and frequency
   and set HOEC rh- and ih- CVs */
    /* RTB0 correction: cvcheck for RTB0 */
    /* RTB0 flag in RTB0.e (rtb0_flag) should never be different from equivalent flag in <psd>.e (rtb0_comp_flag) */
    if (rtb0_flag != rtb0_comp_flag)
    {
        if (rtb0_flag == PSD_ON)
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                       STRING_ARG, "rtb0_flag=On", 
                       STRING_ARG, "rtb0_comp_flag=Off");
        }
        else
        {
            epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                       STRING_ARG, "rtb0_flag=Off", 
                       STRING_ARG, "rtb0_comp_flag=On");
        }
        return FAILURE;
    }

    /* Support only Axial and Obl-Axial */
    if ( ! ((exist(opplane) == PSD_AXIAL) || ((exist(opplane) == PSD_OBL) && (exist(opobplane) == PSD_AXIAL))) /* NOT (Axial or Obl-Axial) */ 
         && (rtb0_flag == PSD_ON) )                                                                            /*       and RTB0=ON        */
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "Real Time Center Frequency", 
                   STRING_ARG, "Non-Axial acquisitions");
        return FAILURE;
    }

    /* In general, dda should not be <= 0 for DW-EPI. If it is, show RTB0 incompatibility error. */
    if ((dda <= 0) && (rtb0_flag == PSD_ON)) 
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "Real Time Center Frequency", 
                   STRING_ARG, "No Disdaqs");
        return FAILURE;
    }

    /* Real Time Center Frequency is incompatible with FLAIR */
    if ((epi_flair == PSD_ON) && (rtb0_flag == PSD_ON)) 
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "Real Time Center Frequency",
                   STRING_ARG, "FLAIR");
        return FAILURE;
    }

    /* Real Time Center Frequency is incompatible with FOCUS */
    if ((rfov_flag == PSD_ON) && (rtb0_flag == PSD_ON)) 
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "Real Time Center Frequency",
                   STRING_ARG, "FOCUS");
        return FAILURE;
    }

    /* Confidence thresholding cannot be used for polynomial fits */
    if (((cf_interpolation > 0) && (cf_interpolation < 4)) && (rtb0_confidence_method > 0))
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "rtb0_confidence_method>0", 
                   STRING_ARG, "cf_interpolation=1,2,3");
        return FAILURE; 
    }

    /* Confidence thresholding using Linear fit residual incompatible with Ahn Cho fits */ 
    if ((rtb0_confidence_method == 1) && (rtb0_phase_method == 0))
    {
        epic_error(use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                   STRING_ARG, "rtb0_confidence_method=1", 
                   STRING_ARG, "rtb0_phase_method=0");
        return FAILURE; 
    }

{

    if(rfov_flag == PSD_ON && muse_flag)
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "FOCUS" );
        return FAILURE;
    }

    if(mux_flag == PSD_ON && muse_flag)
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "Hyperband" );
        return FAILURE;
    }

    if(dualspinecho_flag == PSD_ON && muse_flag)
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "Dual Spin Echo" );
        return FAILURE;
    }

    if((opnumgroups > 1) && muse_flag)
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "multigroup prescription" );
        return FAILURE;
    }

    if((exist(opnshots) <= 1) && muse_flag)
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "single shot" );
        return FAILURE;
    }

}


    /* MRIge48250 - lock freq dir to R/L */
    if ( (cfsrmode == PSD_SR20 || cfsrmode == PSD_SR25) && 
         (piswapfc == 1) && existcv(opspf) && (exist(opspf) == 0) ) {
        epic_error( 0, "Frequency direction must be R/L for this sequence.", 0, EE_ARGS(0) );
        return FAILURE;
    }

    /* BJM: MRIge55304 - #ifdef SIM part - permit epi2 in simulaton mode only */
#ifndef SIM
    /* MRIge52197 - lockout epi2.e from being typed in */
    if( (exist(opdiffuse) != PSD_ON) &&
        (exist(opflair) != PSD_ON) && (tensor_flag != PSD_ON) ) {
        epic_error( use_ermes, "This prescription is not allowed", EM_PSD_INVALID_RX, EE_ARGS(0) );
        return FAILURE;
    } 
#endif /* !SIM */

    /* MRIge56891 - lock out EZDWI w/ Flair PSD Option */
    /* MRIge56913 - Lock out EZDWI when FLAIR EPI is selected - TAA */
    if( (EZflag == PSD_ON) && (exist(opflair)== PSD_ON) && floatsAlmostEqualEpsilons(exist(opuser6), 0.0, 2) )
    {
        epic_error( use_ermes, "This prescription is not allowed", EM_PSD_INVALID_RX, EE_ARGS(0) );
        return FAILURE;
    }
   
    /* MRIge59850 - lock out sequential flair 
       MRIge59560 - changed the error message to indicate incompatiblity of FLAIR EPI
       and Sequential Multiphase options - AMR */
    if((exist(opflair) == PSD_ON) && (exist(opacqo) == PSD_ON)) {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "FLAIR EPI", STRING_ARG, "Sequential Multiphase" );

        return FAILURE;
    }
     
    /*MRIhc04522 - FLAIR EPI is not compatible with sequential
     * acquisition*/
    if((exist(opflair) == PSD_ON) && (exist(opirmode) == PSD_ON)) {                 
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_IMGOPT_PSD1, EE_ARGS(2), STRING_ARG, "sequential ", STRING_ARG, "FLAIR EPI" );

        return FAILURE;                                                           
    }                                                                             
    /* irprep_support */
    if( floatsAlmostEqualEpsilons(exist(opuser6), 1.0, 2) && (exist(opirprep) == PSD_ON)) 
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_IMGOPT_PSD1, EE_ARGS(2), STRING_ARG, "IR Prep", STRING_ARG, "FLAIR Inversion" );

        return FAILURE;

    }

    if (((t1flair_flag || ir_prep_manual_tr_mode) && existcv(opuser8) && existcv(opslquant) && (exist(opslquant) < avminslquant))
        || (mux_flag && existcv(opslquant) && (exist(opslquant) < avminslquant)) )
    {
        epic_error( use_ermes, "The number of scan locations selected must be increased to %d for the current prescription",
                    EM_PSD_SLQUANT_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, avminslquant );
        return FAILURE;
    }

    if ((epi_flair== PSD_ON)&&((exist(optr) < avmintr) && existcv(optr))) {
        epic_error( use_ermes, "Minimum TR is %-d ms", EM_PSD_TR_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, (avmintr/1000) );
        return ADVISORY_FAILURE;
    }

    if ((epi_flair== PSD_ON)&&(exist(opslquant)<4)) {
        epic_error( use_ermes, "Number of slices must be greater than or equal to 4 with Flair.", EM_PSD_EPI_FLAIRSLICES, EE_ARGS(0) );
        return FAILURE;
    }

    if ((exist(opti) > (exist(optr)/(false_acqs*2))) && (epi_flair==PSD_ON)) {
        epic_error( use_ermes, "TR must be at least 4 times longer than TI.", EM_PSD_EPI_TRTI, EE_ARGS(0) );
        return ADVISORY_FAILURE;

    }

    /* MRIhc40140 */
    if ( (scan_deadtime > MAX_INST_PERIOD) && existcv(optr) && existcv(opslquant) )
    {
        epic_error(use_ermes,"Maximum TR is %-d ms",
                   EM_PSD_TR_OUT_OF_RANGE2, EE_ARGS(1), INT_ARG, (int)((MAX_INST_PERIOD+tmin-time_ssi)/1000));
        return ADVISORY_FAILURE;
    }

    /* MRIhc40140 */
    if ( (act_tr > MAX_INST_PERIOD) && existcv(opslquant) &&
         (((exist(opcgate) == PSD_ON) && existcv(ophrep)) || ((exist(oprtcgate) == PSD_ON) && existcv(oprtrep))) )
    {
        /* Calculate ctlend_last */
        if ( FAILURE == calcPulseParams(AVERAGE_POWER) )
        {
            return FAILURE;
        }

        int acq_cnt = 0;
        int max_ctlend_last = 0;
        for (acq_cnt = 0; acq_cnt < act_acqs; acq_cnt++)
        {
            if (max_ctlend_last < ctlend_last[acq_cnt])
            {
               max_ctlend_last = ctlend_last[acq_cnt];
            }
        }

        if ( max_ctlend_last > MAX_INST_PERIOD )
        {
            int temp_reps = (exist(oprtcgate) == PSD_ON) ? exist(oprtrep) : exist(ophrep);
            int temp_rate = (exist(oprtcgate) == PSD_ON) ? exist(oprtrate) : exist(ophrate); 
            int suggested_step = (ceil) ((max_ctlend_last - MAX_INST_PERIOD)/60*temp_rate*1e-6);
            epic_error(use_ermes,"The number of RR intervals must be decreased to %d for the current prescription.", EM_PSD_SPEC_DECREASE_RRI, EE_ARGS(1), INT_ARG, temp_reps-suggested_step);
            return FAILURE;
        }
    }

    if( (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON) ) {
        /*
         * BJM: MRIge57366 - calculate the maximum b-value for the system
         *                   config.
         */

        if ( PSD_OFF == optimizedTEFlag )
        {
            allowed_max_bval = bmax_fixed;
        }
        else 
        {
             /* b-value limits based on coil type and slew rate */
            switch ( cfgcoiltype )
            {
            case PSD_CRM_COIL:
                allowed_max_bval = MAXB_10000;
                break;

            case PSD_XRMB_COIL:
                allowed_max_bval = MAXB_10000;
                if ((exist(opdfaxtetra) > PSD_OFF)  || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                {
                    allowed_max_bval = MAXB_1500;
                }
                break;

            case PSD_60_CM_COIL:
            case PSD_BRM2_COIL:
                switch ( cfsrmode )
                {
                case PSD_SR100:
                case PSD_SR120:
                    allowed_max_bval = MAXB_7000;
                    if ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                    {
                         allowed_max_bval = MAXB_1500;
                    }
                    /*** SVBranch: 
                    HCSDM00097735:
                    Increase max b-value for 16Beat system 
                    under certain cases;
                    This feature can only be activated if
                    both of the following two conditions
                    are met:
                    1. slice thickness is set and is set
                       to not less than 20mm;
                    2. the TE value is set;
                    ***/
                    if((isSVSystem()) && (exist(opslthick) >= 20))
                    {
                        allowed_max_bval = MAXB_10000;
                    }
                    /*********************************/                    
                    break;
                case PSD_SR77:
                    allowed_max_bval = MAXB_4000;
                    break;
                case PSD_SR50:
                    allowed_max_bval = MAXB_2500;
                    if (isStarterSystem())
                    {
                        allowed_max_bval = MAXB_7000;
                        if ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                        {
                             allowed_max_bval = MAXB_1500;
                        }
                        if((exist(opslthick)) >= 20)
                        {
                            allowed_max_bval = MAXB_10000;
                        }
                    }
                    break;
                default:
                    allowed_max_bval = MAXB_1000;
                    break;
                }
                break;

            case PSD_TRM_COIL:
                if ( cfsrmode == PSD_SR77 || ( exist( opgradmode ) == TRM_BODY_COIL && existcv( opgradmode ) ) )
                {
                    allowed_max_bval = MAXB_4000;
                    if ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                    {
                        allowed_max_bval = MAXB_1500;
                    }
                }
                else if ( cfsrmode == PSD_SR150 || ( exist( opgradmode ) == TRM_ZOOM_COIL && existcv( opgradmode ) ) )
                {
                    allowed_max_bval = MAXB_10000;
                    if ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                    {
                        allowed_max_bval = MAXB_1500;
                    }
                }
                break;

            case PSD_XRMW_COIL:
            case PSD_VRMW_COIL:
                allowed_max_bval = MAXB_10000;
                if ((exist(opdfaxtetra) > PSD_OFF) || (exist(opdfax3in1) > PSD_OFF )|| ((exist(opdfaxall) > PSD_OFF) && (gradopt_diffall == PSD_ON)))
                {
                    allowed_max_bval = MAXB_1500;
                }
                break;

            case PSD_HRMW_COIL:
                allowed_max_bval = MAXB_10000;
                break;
            default:
                allowed_max_bval = MAXB_1000;
                break;
            }
        }

        if (tensor_flag == PSD_ON)
        {
            if ((PSD_XRMB_COIL == cfgcoiltype) || (PSD_XRMW_COIL == cfgcoiltype) || (PSD_VRMW_COIL == cfgcoiltype) || (isRioSystem()))
            {
                allowed_max_bval = FMin(2, allowed_max_bval, (float)MAXB_10000);
            }
            else
            {
                allowed_max_bval = FMin(2, allowed_max_bval, (float)MAXB_4000);
            }
        }

        allowed_min_bval = MINB_VALUE;
        avminbvalstab = allowed_min_bval;
        avmaxbvalstab = allowed_max_bval;

        /* error massages for DWI */
        for (bval_counter = 0; bval_counter < opnumbvals; bval_counter++)
        {
            if (bvalstab[bval_counter] > avmaxbvalstab) 
            {
                epic_error( use_ermes, "The max b-value = %d for this prescription", EM_PSD_MAX_BVALUE, 
                            EE_ARGS(1), INT_ARG, (int)allowed_max_bval );
                return FAILURE; 
             }
	   if (bvalstab[bval_counter] < avminbvalstab)
            {
                epic_error( use_ermes, "The min b-value = %d for this prescription", EM_PSD_MIN_BVALUE, 
                            EE_ARGS(1), INT_ARG, (int)allowed_min_bval );
                return FAILURE; 
             }
        }

        /* Synthetic DWI */
        if ((PSD_OFF == syndwi_status) && (PSD_ON == syndwi_flag))
        {
            epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Synthetic DWI" );
            return FAILURE;
        }
        if(syndwi_flag)
        {
            /* synthetic b-value range is restricted by several limits.    */
            /* 1: syn bvalue is always >= LOWER_SYNB_LIMIT_IVIM            */
            /*    due to IVIM effect mainly in liver                       */
            /* 2: syn bvalue is always <= UPPER_SYNB_LIMIT_RESTRICT_DIFF   */
            /*    due to restricted diffusion mainly in brain              */
            /* 3: available range is limited by user's b-value description */
            /*    (need to disallow if user set an agressive prescription  */
            /*     e.g syn-b=1500 with acq-b=200,220)                      */
            avminsynbvalstab = prescribed_min_bval - prescribed_bval_range * SYNBVAL_EXPAND_FACTOR;
            if (avminsynbvalstab < LOWER_SYNB_LIMIT_IVIM)
            {
                avminsynbvalstab = LOWER_SYNB_LIMIT_IVIM;
            }
            avmaxsynbvalstab = prescribed_max_bval + prescribed_bval_range * SYNBVAL_EXPAND_FACTOR;
            if (avmaxsynbvalstab > UPPER_SYNB_LIMIT_RESTRICT_DIFF)
            {
                avmaxsynbvalstab = UPPER_SYNB_LIMIT_RESTRICT_DIFF;
            }

            if (PSD_ON == exist(opresearch))
            {
                avmaxsynbvalstab = UPPER_SYNB_LIMIT_RESEARCH_MODE;
            }

            /* update the background default synbvals if it gets out of range. */
            /* this is needed to avoid error condition when user increase the number of synbvals */
            for (bval_counter = opnumsynbvals; bval_counter < MAX_NUM_SYNBVALS; bval_counter++)
            {
                if (synbvalstab[bval_counter] > avmaxsynbvalstab)
                {
                    synbvalstab[bval_counter] = avmaxsynbvalstab;
                }
                else if (synbvalstab[bval_counter] < avminsynbvalstab)
                {
                    synbvalstab[bval_counter] = avminsynbvalstab;
                }
            }

            /* error massages for synDWI */
            for (bval_counter = 0; bval_counter < opnumsynbvals; bval_counter++)
            {
                if (synbvalstab[bval_counter] > avmaxsynbvalstab || synbvalstab[bval_counter] < avminsynbvalstab)
                {
                    epic_error( use_ermes, 
                                "Available synthetic b-value range is %d to %d for the entered b-value range %d to %d.",
                                EM_PSD_SYNBVALUE_OUT_OF_RANGE, EE_ARGS(4), 
                                INT_ARG, (int)avminsynbvalstab,  INT_ARG, (int)avmaxsynbvalstab,
                                INT_ARG, (int)prescribed_min_bval , INT_ARG, (int)prescribed_max_bval);
                    return FAILURE;
                }
            }
        }

        /* MRIge71092 */
        if((!floatIsInteger(opuser6)) || (opuser6<0.0) || (opuser6>1.0))
        {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, _opuser6.descr );
            return FAILURE;
        }

        /* BJM: DTI Error Messages */
        if(FAILURE == DTI_Check()) 
        {
            return FAILURE;
        }  

        /* YMSmr06650: limit # slices to max_slice_dfaxall with MPG ALL */
        if ((exist(opslquant) > max_slice_dfaxall) && existcv(opslquant)
           && (exist(opdfaxall) > PSD_OFF) && (exist(opdiffuse) == PSD_ON))
        {
            epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, max_slice_dfaxall );
            avmaxslquant = max_slice_dfaxall;
            return ADVISORY_FAILURE;
        }

        if (tensor_flag == PSD_ON) {
            if ((exist(opslquant) > avmaxslquant) && existcv(opslquant))
            {
                epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxslquant );
                return ADVISORY_FAILURE;
            }

            if ( (act_acqs > 1) ) {
                epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "TENSOR", STRING_ARG, "Multiple acquisitions" );
                return FAILURE;
            }

        } /* end tensor_flag check */      
        /*multiband suppoprts single acq only*/
        if (mux_flag == PSD_ON) {
            if ((exist(opslquant) > avmaxslquant) && existcv(opslquant))
            {
                epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxslquant );
                return ADVISORY_FAILURE;
            }

            if ( (act_acqs > 1) ) {
                epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "HyperBand", STRING_ARG, "Multiple acquisitions" );
                return FAILURE;
            }

        } /* end mux_flag check */

        /* MUSE supports single acq only*/
        if (muse_flag == PSD_ON) {
            if ((exist(opslquant) > avmaxslquant) && existcv(opslquant))
            {
                epic_error( use_ermes, "Maximum slice quantity is %-d ", EM_PSD_SLQUANT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, avmaxslquant );
                return ADVISORY_FAILURE;
            }

            if ( (act_acqs > 1) ) {
                epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "MUSE", STRING_ARG, "Multiple acquisitions" );
                return FAILURE;
            }
        } /* end muse_flag check */
   
   } /* end opdiffuse check */

    if(mkgspec_flag)
    {
        if( PSD_OBL == exist(opplane) )
        {
            epic_error(use_ermes, "%s plane must be selected for %s.",
                       EM_PSD_PLANE_SELECTION, 2, STRING_ARG, "Orthogonal",
                       STRING_ARG, "the gradient spec PSD");
            return FAILURE;
        }
        if( PSD_ON == exist(opsilent) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD",
                       STRING_ARG, "ART" );
            return FAILURE;
        }
        if( (PSD_VRMW_COIL != cfgcoiltype) || (5550 != cfgradamp) ) /* VRMW & SSSD only */
        {
             epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD",
                        STRING_ARG, "this system" );
            return FAILURE;
        }
    }

    if( (MK_SPEC_MODE_GRAD_3AXES == mkgspec_flag) )
    {
            epic_error( use_ermes, "%s is incompatible with %s.",
                        EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "This PSD",
                        STRING_ARG, "clinical mode" );
            return FAILURE;
    }

    /* HCSDM00337293 */
    if(mkgspec_flag)
    {
        if( (PSD_OFF == exist(opdiffuse)) && (MK_SPEC_MODE_GMAX == mkgspec_flag) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD", STRING_ARG, "EPI FLAIR" );
            return FAILURE;
        }
        if( (PSD_OFF == exist(opdfax3in1)) && existcv(opdfax3in1) && (PSD_ON == different_mpg_amp_flag) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD", STRING_ARG, "other diffusion direction than 3 in 1" );
            return FAILURE;
        }
        if( (PSD_ON == dualspinecho_flag) && (PSD_ON == different_mpg_amp_flag) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD", STRING_ARG, "Dual Spin Echo" );
            return FAILURE;
        }
        if( (exist(opnumbvals) > 1) && (PSD_ON == different_mpg_amp_flag) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "The gradient spec PSD", STRING_ARG, "Multiple b-value" );
            return FAILURE;
        }
    }

    /* Check if the number of opshots are greater than opyres. */
    if ( exist(opnshots) > exist(opyres) ) { 
        epic_error( use_ermes, "Number of shots must be less than or equal to phase encode lines.", EM_PSD_EPI_NSHOTS_YRES_INCOMPATIBLE1, EE_ARGS(0) );
        avminnshots = exist(opyres);
        avmaxnshots = exist(opyres);
        return ADVISORY_FAILURE;
    }

    /* Check if the selected yres is compatible with the chosen opnshots and te */
    if ( ((rhnframes + rhhnover) % exist(opnshots)) != 0 ) { 
        temp_int = exist(opyres)/exist(opnshots);
        if ( (temp_int % 2) == 1) 
            temp_int +=1;
        newyres  = _newyres.fixedflag ?  ((void)(temp_int*exist(opnshots)), newyres) : temp_int*exist(opnshots);

        {
            int temp_yres, temp_frames, calc_sign, icount, max_count;

            max_count = IMax(2, (newyres - avminyres)/2, (avmaxyres - newyres)/2);

            for (icount=0; (icount<=max_count*2); icount++){

                calc_sign = 1 - 2*(icount%2);
                temp_yres = newyres + 2*calc_sign*(icount/2);

                if ((temp_yres >= avminyres) && (temp_yres <= avmaxyres)){
                    if(num_overscan > 0) {
                         temp_frames = (short)(ceilf((float)temp_yres*asset_factor/rup_factor)*rup_factor*fn*nop - ky_offset);
                    } else {
                         temp_frames = (short)(ceilf((float)temp_yres*asset_factor/rup_factor)*rup_factor*fn*nop);
                    }
                    if (((temp_frames + rhhnover) % 2 == 0) &&
                        ((temp_frames + rhhnover) % exist(opnshots) == 0)){
                        newyres  = _newyres.fixedflag ?  ((void)(temp_yres), newyres) : temp_yres;
                        break;
                    }
                }
            }
        }

        epic_error( use_ermes, "The nearest valid phase encoding value is %d.", EM_PSD_YRES_ROUNDING, EE_ARGS(1), INT_ARG, newyres );
        avminyres = newyres;
        avmaxyres = newyres;
        return ADVISORY_FAILURE;
    }

    /*MRIge42072*/
    if (existcv(opphasefov) && ((exist(opphasefov) < min_phasefov) || (exist(opphasefov) > 1.00)))
    {
        epic_error( use_ermes, "Phase FOV less than %0.2f and greater than %0.2f are not supported.",
                    EM_PSD_PHASEFOV_OUT_OF_RANGE2, EE_ARGS(2), FLOAT_ARG, min_phasefov, FLOAT_ARG, 1.00);
        return FAILURE;
    }

    if ( (rhnframes + rhhnover)%2 != 0 ) {
        epic_error( use_ermes, "Illegal combination of phase encode lines, shots, and fract/full TE.", EM_PSD_EPI_ILLEGAL_NFRAMES, EE_ARGS(0) );
        return FAILURE;
    }


    if ((exist(opte) < (float)avminte) && existcv(opte)) {
        epic_error( use_ermes, "The selected TE must be increased to %d ms for the current prescription.", EM_PSD_TE_OUT_OF_RANGE3, EE_ARGS(1), INT_ARG, (int)ceil((double)avminte/1000.0) );
        return ADVISORY_FAILURE;
    }

    /* Limit min FOV based on asset scan Calibration */

/* AssetMinFOV  inlined from Asset.e */
   /* Asset FOV limitations - limit to 1/4 of the calibration FOV */
   if( ASSET_SCAN == exist(opasset) )
   {
       float tmp_minfov;
       float astfv = 4.0;

       tmp_minfov = (coilInfo[0].assetCalMaxFov/astfv)/ (exist(opsquare) == 1 ? 1.0 : exist(opphasefov)); 
       tmp_minfov = 10 * ceilf((DOUBLE)(tmp_minfov/ 10.0)); /* MRIge73320 */

/* HCSDM00363815 - Avoid pop-up advisory for #slices in case that coil mode is changed */
       if( (PSD_ON == fov_advisory_ignore_mslices) && (exist(opfov) < tmp_minfov) && existcv(opfov) )
       {
           avmaxslquant = exist(opslquant);
       }

       if(avminfov < tmp_minfov)
       {
           avminfov = tmp_minfov;
           if( (exist(opfov) < avminfov) && existcv(opfov) )
           {
               epic_error(use_ermes,"The FOV needs to be increased to %3.1f cm for the current prescription or Phase FOV can be increased.",
                          EM_PSD_FOV_OUT_OF_RANGE3, EE_ARGS(1), FLOAT_ARG, avminfov/ 10.0 );
               return ADVISORY_FAILURE;
           }
       }
   }

/* AssetMinFOV  inlined from Asset.e */

    if ((exist(opfov) < avminfov) && existcv(opfov)) {
        epic_error( use_ermes, "The FOV needs to be increased to %3.1f cm for the current prescription, or receive bandwidth can be decreased.", EM_PSD_FOV_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, avminfov/10.0 );
        return ADVISORY_FAILURE;
    }  

    if (existcv(oprbw) && (exist(oprbw) < avminrbw)) {
        epic_error( use_ermes, "With the current Scan Timimg prescription, the minimum first echo bandwidth is %4.2f KHz.", EM_PSD_MIN_RBW1, EE_ARGS(1), FLOAT_ARG, avminrbw );
        return ADVISORY_FAILURE;
    }

    if ((exist(opfov) > avmaxfov) && existcv(opfov)) {
        epic_error( use_ermes, "The FOV needs to be decreased to %3.1f cm for the current prescription.", EM_PSD_FOV_OUT_OF_RANGE2, EE_ARGS(1), FLOAT_ARG, avmaxfov/10.0 );
        return ADVISORY_FAILURE;
    }

    if (existcv(opyres) && (exist(opyres) % 2) != 0) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "yres must be an even number" );
        return FAILURE; 
    }

    if (existcv(opxres) && (exist(opxres) <= 32 || exist(opxres) > 512)) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "X resolution out of range." );
        return FAILURE; 
    }

    /* Ensure that xres is a even number. ufi2_ypd */
    if (existcv(opxres) && (exist(opxres) % 2) != 0) {
        epic_error( use_ermes, "The xres must be an even number.", EM_PSD_EPI_XRES_INVALID, EE_ARGS(0) );
        return FAILURE;
    }

    /* MRIhc56388: rhfrsize limit for dynamic phasce correction */
    if( iref_etl>0 && existcv(opxres) && rhfrsize > MAXFRAMESIZE_DPC) {
        epic_error(use_ermes, "XRES is out of range",
                   EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "XRES");
        return FAILURE;
    }

    /* MRIge57061 - lock out greater than 16 NEX */
    if(exist(opdiffuse) == PSD_ON)
    {
        for (bval_counter = 0; bval_counter < exist(opnumbvals); bval_counter++)
        {
            if (difnextab[bval_counter] > max_difnex_limit || difnextab[bval_counter] < 1) 
            {
                epic_error( use_ermes, "The selected number of excitations is not valid for the current prescription."
                                        , EM_PSD_NEX_OUT_OF_RANGE, EE_ARGS(0) );
                return FAILURE; 
             }
        }

        for (bval_counter = 0; bval_counter < exist(opnumbvals); bval_counter++)
        {
            if( !floatsAlmostEqualRelative(floor(difnextab[bval_counter]), difnextab[bval_counter], 0.0001) )
            {
                epic_error(use_ermes, "Fractional NEX is not allowed with this scan.", EM_PSD_FNEX_INCOMPATIBLE, EE_ARGS(0));
                return FAILURE;
            }
        }
    }
    else
    {
        if ( !floatIsInteger(exist(opnex)) || floatsAlmostEqualEpsilons(exist(opnex), 0.0, 2)) 
        {
            epic_error(use_ermes, "Fractional NEX is not allowed with this scan.", EM_PSD_FNEX_INCOMPATIBLE, EE_ARGS(0));
            avminnex = 1.0;
            avmaxnex = FMax(2, 1.0, floor(exist(opnex)));
            return ADVISORY_FAILURE; 
        }
    }

    if (vrgfsamp == 0 && rampsamp == PSD_ON) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "vrgfsamp must be 1 when rampsamp is 1" );
        return FAILURE; 
    }

    if ( (exist(opcgate)==PSD_ON) && (opmph==PSD_ON) && (opacqo==1) ) {
        epic_error( use_ermes, "The sequential multiphase and cardiac gating options are not\ncompatible for epi.", EM_PSD_EPI_SEQMPH_CGATE_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    if (ygmn_type == CALC_GMN1 && gy1pos == PSD_PRE_180) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "gy1 pulse pos for fcomp." );
        return FAILURE;
    }

    if (SpSatCheck() == FAILURE) return FAILURE;

    if( existcv(opslthick) && (exist(opslthick) < avminslthick) ) {
        epic_error( use_ermes, "The Slice thickness must be increased to %.2f mm for the current prescription.", EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, avminslthick );
        return ADVISORY_FAILURE;
    }        

    if (a_gzrf1 > loggrd.tz) {
        epic_error( use_ermes, "The Slice thickness must be increased to %.2f mm for the current prescription.", EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, avminslthick );
        return ADVISORY_FAILURE;
    }

    if (a_gzrf2 > loggrd.tz) {
        epic_error( use_ermes, "The Slice thickness must be increased to %.2f mm for the current prescription.", EM_PSD_SLTHICK_OUT_OF_RANGE, EE_ARGS(1), FLOAT_ARG, avminslthick );
        return ADVISORY_FAILURE;

    }

    /*
     *  MRIge70693 - Due to the way multiple NEX is implemented DW-EPI not
     *  compatible with extended dynamic range. If operator choses EDR,
     *  display error message
     */
    if (exist(opptsize) == 4 && exist(opdiffuse) == PSD_ON && (edr_support == PSD_OFF)) {
        epic_error( use_ermes, "Extended Dynamic Range is not supported for DW-EPI.", EM_PSD_DWEPI_EDR_INCOMPATIBLE, EE_ARGS(0) );
        return FAILURE;
    }

    /* dB/dt error checks */
    /************************************/
    if (pidbdtts > cfdbdtts && cfdbdtts > 0.0 && existcv(opfov)) {
        epic_error( use_ermes, "Stimulation threshold exceeded (T/s).", EM_PSD_EPI_DBDTTS, EE_ARGS(0) );
        printf("\ndB/dt value of %f T/s exceeds limit of %f T/s\n",
               pidbdtts, cfdbdtts);
        return FAILURE;
    }

    if (pidbdtper > cfdbdtper && cfdbdtper > 0.0 && existcv(opfov)) {
        epic_error( use_ermes, "Stimulation threshold exceeded (%%).", EM_PSD_EPI_DBDTPER, EE_ARGS(0) );
        printf("\ndB/dt value of %f percent exceeds limit of %f percent\n",
               100.0*pidbdtper, 100.0*cfdbdtper);
        return FAILURE;  
    }

    /* multi-phase error messages */
    /* DTI change check from avmaxpasses */
    if( mph_flag == PSD_ON ) {
        if ( existcv(opslquant) && ((dwi_fphases*exist(opdiffuse)) > 
                                    avmaxpasses ) ) {
/* TOMOD: need to add errmsgs */
            epic_error( 0, "Maximum number of phases exceeded, reduce # of phases or b-values", EM_PSD_MAXPHASE_EXCEEDED, EE_ARGS(0) );
            return FAILURE;
        }

        /*No of images check 1024 im/ser*/
        if ( existcv(opslquant) && (opslquant * (dwi_fphases*exist(opdiffuse)) > 
                    max_slice_limit) ) {
/* TOMOD: need to add errmsgs */
            epic_error( 0, "Maximum number of images exceeded, reduce # of slices, phases or b-values", EM_PSD_MAXPHASE_EXCEEDED, EE_ARGS(0) );
            return FAILURE;
        }

        /* YMSmr06649 */
        if ( existcv(opslquant) && existcv(opfphases) &&
                ((opfphases * opslquant * opphases) > max_slice_limit) ) {
            epic_error(use_ermes, "The number of locations * phases has exceeded %d.",
                    EM_PSD_SLCPHA_OUT_OF_RANGE ,EE_ARGS(1),INT_ARG,max_slice_limit);
            return FAILURE;
        }

        /* MRIhc00610 */
        /* rhnpasses check*/ /* YMSmr06515: # of slice locations expansion */
        if ( existcv(opfphases) && (exist(opacqo) == 0) && ( (pass_reps * act_acqs) > avmaxpasses ) ) { 
            epic_error (use_ermes, "The maximum number of phases is %-d", 
                        EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, avmaxpasses);
            return FAILURE;
        }
        if ( existcv(opfphases) && (exist(opacqo) == PSD_ON) && (opfphases > avmaxpasses) ) {
            epic_error (use_ermes, "The maximum number of phases is %-d", 
                    EM_PSD_NUM_PASS_OUT_OF_RANGE, 1, INT_ARG, avmaxpasses);
            return FAILURE;
        }
    }


    if ( (exist(opnshots) == exist(opyres)) && (exist(opautote) == 2) ) {
        epic_error( use_ermes, "Number of Phases should exceed Number of shots if Minimum TE is selected.", EM_PSD_EPI_NPHASESNSHOTS, EE_ARGS(0) );
        return FAILURE;
    }

    /* YMSmr07177 */
    if ((opsldelay < (float)avminsldelay) && existcv(opsldelay)) { 
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Delay After Acq" );
	return FAILURE;
    }

    /* YMSmr06685, YMSmr07177 */
    if ((opsldelay > (float)avmaxsldelay) && existcv(opsldelay)) {
        epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "Delay After Acq" );
        return FAILURE;
    } 

    /* PH MRIge49595 - opnshots have to be 1 with diffusion. */
    if  ((exist(opnshots) != min_nshots) && (exist(opdiffuse) == PSD_ON) && (muse_flag == PSD_OFF) )  {

        epic_error( use_ermes, "Max. Number of Shots for DW-EPI is %d.", EM_DWEPI_MAX_SHOT_OUT_OF_RANGE, EE_ARGS(1), INT_ARG, 1 );

        return ADVISORY_FAILURE; 
    }

    if ( (exist(opxres) > 256) && (rampsamp == PSD_ON)  && (muse_flag == PSD_OFF) ) {
        epic_error( use_ermes, "xres greater than 256 and ramp sampling are not compatible.", EM_PSD_EPI_RAMPSAMP_XRES, EE_ARGS(0) );
        return FAILURE; 
    }

    if ( (cffield == B0_5000) && (exist(opfat) !=  PSD_ON) ) {
        epic_error( use_ermes, "Fat suppression must be selected with 0.5T epi.", EM_PSD_EPI_HALFT_NOFATSAT, EE_ARGS(0) );
        return FAILURE; 
    }

    if (FAILURE == Monitor_Cvcheck())
    {
        return FAILURE;
    }

    /* Check imaging options */
    status_flag = checkEpi2ImageOptions();
    if(status_flag != SUCCESS) return status_flag;

    /* Throw warning if cal files are missing */
    if(epiCalFileCVCheck() != SUCCESS) return FAILURE;

    if(aspir_flag)
    {
        if( PSD_ON == exist(opirprep) )
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "IRPREP", STRING_ARG, "ASPIR" ); 
            return FAILURE; 
        } 
        if( PSD_ON == epi_flair ) 
        { 
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "FLAIR", STRING_ARG, "ASPIR" ); 
            return FAILURE; 
        } 
    }

    if ((t1flair_flag) && exist(opcgate))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Interleaved STIR", STRING_ARG, "Cardiac Gating" );
        return FAILURE;
    }

    if ((t1flair_flag) && exist(oprtcgate))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Interleaved STIR", STRING_ARG, "Respiratory Gating" );
        return FAILURE;
    }

    if ((t1flair_flag) && (PSD_ON == navtrig_flag))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Interleaved STIR", STRING_ARG, "Navigator" );
        return FAILURE;
    }

    if ((t1flair_flag) && (exist(opirmode) == PSD_ON))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Interleaved STIR", STRING_ARG, "Sequential" );
        return FAILURE;
    }

    if ((PSD_OFF == bodynav_status) && (PSD_ON == navtrig_flag))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Body Navigator" );
        return FAILURE;
    }
    
    if ((PSD_OFF == focus_status) && (PSD_ON == rfov_flag))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "Focus" );
        return FAILURE;
    }

    if ((PSD_OFF == multiband_status) && (PSD_ON == mux_flag))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "HyperBand" );
        return FAILURE;
    }

    if ((PSD_OFF == muse_status) && (PSD_ON == muse_flag))
    {
        epic_error( use_ermes, "%s is not available without the option key.",
                    EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "MUSE" );
        return FAILURE;
    }

    if ( ( cfrecvend-cfrecvst+1<8 ) && (PSD_ON == muse_flag) )
    {
        /* MUSE does not support coils with less than 8 channels */
        epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2), STRING_ARG, "Coil with less than 8 channels",STRING_ARG, "MUSE");
        return FAILURE;
    }

    if ( (1.0/asset_factor>avmaxaccel_ph_stride/(float)exist(opnshots)) && (PSD_ON == muse_flag) && (PSD_ON != exist(opresearch)) && existcv(opnshots) ) {
		epic_error( use_ermes, "The phase acceleration must be reduced to %0.2f for this prescription.",
					EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
					FLOAT_ARG, (avmaxaccel_ph_stride/(float)exist(opnshots))  );
		return FAILURE;
    }

    if ( ( cfrecvend-cfrecvst+1<9 ) && (PSD_ON == mux_flag) && (exist(opaccel_mb_stride)>1))
    {
        /* Multiband does not support coils with less than 9 channels */
        epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2), STRING_ARG, "Coil with less than 9 channels",STRING_ARG, "HyperBand");
        return FAILURE;
    }


#ifndef SIM
    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

    if ( (!isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD) && opanatomy) 
         && !(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
             && strstr(attribute_codeMeaning, "Breast"))
         && (PSD_ON == mux_flag) && (exist(opaccel_mb_stride)>1) )
    {
        epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2), STRING_ARG, "Non-Head or Non-Breast Scan in Clinical Mode",STRING_ARG, "HyperBand");
        return FAILURE;
    }
#endif
    /* Refless EPI */
    if (ref_in_scan_flag == PSD_ON)
    {
        if (exist(opdiffuse) == PSD_OFF)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Integrated Reference Scan", STRING_ARG, "Non-Diffusion" );
            return FAILURE;
        }

        if (dda == 0)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Integrated Reference Scan", STRING_ARG, "dda 0" );
            return FAILURE;
        }

        if ((intleaves > 1) && (muse_flag == PSD_OFF))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Integrated Reference Scan", STRING_ARG, "intleaves > 1" );
            return FAILURE;
        }

        if (ref_volrecvcoil_flag == PSD_ON)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG,
                        "Switching Coil for Reference Scan", STRING_ARG, "Integrated Reference Scan" );
            return FAILURE;
        }
    }
    if(ssgr_flag)
    {
        if(PSD_OFF == exist(opdiffuse))
        {
            epic_error( use_ermes, "The Classic option is not supported in this scan.", EM_PSD_CLASSIC_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }
        else if(((ss_rf1 && existcv(opfat) && existcv(opspecir)) || rfov_flag) && (!dualspinecho_flag))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), 
                        STRING_ARG, "Classic", STRING_ARG, "Single Spin Echo with SpSp or FOCUS pulse" );
            return FAILURE;
        }
    }

        /*RTB0 correction: add 1 TR for RTB0*/ /*this will be ok for both triggered scan or non-triggered scan*/
    if (rtb0_flag == PSD_ON)
    {
        scan_time  = _scan_time.fixedflag ?  ((void)(act_tr+rtb0fittingwaittime+rtb0dummy_time), scan_time) : scan_time+act_tr+rtb0fittingwaittime+rtb0dummy_time;
        avmintscan  = _avmintscan.fixedflag ?  ((void)(scan_time), avmintscan) : scan_time;
        pitscan  = _pitscan.fixedflag ?  ((void)(avmintscan), pitscan) : avmintscan; /* This value shown in clock */
        pisctim1 = pitscan;
    }

/* ASSET Scan check */

    /* MRIhc18622 Check option key for all ASSET scans */
    if(PSD_ON == exist(opassetscan))
    {
        int ASSETKey;
#ifdef PSD_HW
        ASSETKey = !checkOptionKey( SOK_ASSET );
#else 
        ASSETKey = PSD_ON;
#endif /* PSD_HW */
        
        if( PSD_OFF == ASSETKey )
        {
            epic_error( use_ermes, "%s is not available without the option key.",
                        EM_PSD_FEATURE_OPTION_KEY, EE_ARGS(1), STRING_ARG, "ASSET" );
            return FAILURE;
        }
    }


    /* Check for invalid imaging options */
    if( ASSET_SCAN == exist(opasset) )
    {
        if( exist(oppomp) )
        {
            epic_error( use_ermes,
                        "The POMP option is not compatible with ASSET.", 
                        EM_PSD_POMP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opsquare) )
        {
            epic_error( use_ermes,
                        "The Square Pixel option is not compatible with ASSET.", 
                        EM_PSD_SQUARE_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opnpwfactor) > 1.0 )
        {
            epic_error( use_ermes,
                        "The No Phase Wrap option is not compatible with ASSET.", 
                        EM_PSD_NOPWRAP_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(oprealtime) )
        {
            epic_error( use_ermes,
                        "The Realtime option is not compatible with ASSET.", 
                        EM_PSD_REALTIME_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opcmon) )
        {
            epic_error( use_ermes,
                        "The Cardiac Compensation option is not compatible with ASSET.", 
                        EM_PSD_CMON_ASSET_INCOMPATIBLE, EE_ARGS(0) );
            return FAILURE;
        }

        if( PSD_ON == exist(opzip1024) )
        {
            epic_error( use_ermes,
                        "1024 ZIP is not compatible with ASSET.",
                        EM_PSD_NO_1024_ZIP_ASSET, EE_ARGS(0) );
            return FAILURE;
        }

        if( exist(opexor) )
        {
            epic_error(use_ermes,"%s is incompatible with %s.",
                       EM_PSD_INCOMPATIBLE,EE_ARGS(2),STRING_ARG,"Resp Comp",
                       STRING_ARG,"ASSET");
            return FAILURE;
        }
    }

    /* MRIhc32862: Slice ASSET is not supported by any 2D scans */
    if( existcv(opasset) && (PSD_ON == assetsl_flag) && (PSD_2D == exist(opimode)) )
    {
            piaccelscrn = PSD_OFF;
            piaccel_slnub = 0;
            epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                       EE_ARGS(2),STRING_ARG,"Slice ASSET",STRING_ARG,"this PSD");
            return FAILURE;
    }

    /* BJM: 1024 Support */
    if( ( ( existcv(opxres) && exist(opxres) > 512 ) || ( existcv(opyres) && exist(opyres) > 512 ) ||
           ( (existcv(opyres) && existcv(opphasefov)) && ((exist(opyres)*exist(opphasefov) > 512 )) ) ) 
         && (PSD_ON == exist(opassetscan)) )
    {
        epic_error(use_ermes,"%s is incompatible with %s",EM_PSD_INCOMPATIBLE,
                   EE_ARGS(2),STRING_ARG,"ASSET",STRING_ARG,"an image matrix larger than 512");
        return FAILURE;
    }

    if( (!value_system_flag) && exist(opassetscan) && exist(opepi) && exist(opflair) )
    {
        epic_error( use_ermes,
                    "The ASSET option is not compatible with this PSD.", 
                    EM_PSD_NO_ASSET_SCAN, EE_ARGS(0) );
        return FAILURE;
    }

    /* MRIhc18622: Patient position check is removed for asset and calib scan
       since it is checked by host (MRIhc01471) */

    if( (VALUE_SYSTEM_HDE == value_system_flag) && assetph_flag && (exist(opaccel_ph_stride) > 2.0) && existcv(opaccel_ph_stride) ) {
        epic_error( use_ermes,
	            "Phase Acceleration is out of range", 
                    EM_PSD_CV_OUT_OF_RANGE,EE_ARGS(1),STRING_ARG,"Phase Acceleration");
        return FAILURE;
    }

    if( assetph_flag && (exist(opaccel_ph_stride) > avmaxaccel_ph_stride) && existcv(opaccel_ph_stride) ) {
                epic_error( use_ermes, "The phase acceleration must "
                            "be reduced to %0.2f for this prescription.",
                            EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                            FLOAT_ARG, avmaxaccel_ph_stride);
        return FAILURE;
    }
    if( assetsl_flag && (exist(opaccel_sl_stride) > avmaxaccel_sl_stride) && existcv(opaccel_sl_stride) ) {
                epic_error( use_ermes, "The Slice acceleration must "
                            "be reduced to %0.2f for this prescription.",
                            EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                            FLOAT_ARG, avmaxaccel_sl_stride);
        return FAILURE;
    }

/* ASSET Scan check */
    if(mux_flag)
    {
/* ARCCheck inlined from ARC.e */
if ((existcv(opaccel_ph_stride) || existcv(opaccel_sl_stride)) && exist(oparc) == PSD_ON)
{
    if (exist(opsquare) && existcv(opaccel_ph_stride))
    {
        epic_error( use_ermes, "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "Square Pixel", STRING_ARG, "ARC" );
        return FAILURE;
    }

    if (PSD_ON == exist(opassetscan))
    {
        epic_error( use_ermes, "%s is incompatible with %s.",
                    EM_PSD_INCOMPATIBLE, 2, STRING_ARG, "ASSET", STRING_ARG, "ARC" );
        return FAILURE;
    }

    if (existcv(opaccel_ph_stride) && (exist(opaccel_ph_stride) > avmaxaccel_ph_stride ))
    {
        epic_error( use_ermes, "The maximum acceleration factor is %0.2f. Please select a smaller value.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, (float)(floor(avmaxaccel_ph_stride*100))/100.0 );
        
        return FAILURE;
    }

    if (existcv(opaccel_sl_stride) && (exist(opaccel_sl_stride) > avmaxaccel_sl_stride ))
    {
        epic_error( use_ermes, "The maximum acceleration factor is %0.2f. Please select a smaller value.",
                    EM_PSD_GEM_INVALID_ACCEL, EE_ARGS(1),
                    FLOAT_ARG, (float)(floor(avmaxaccel_sl_stride*100))/100.0 );
        return FAILURE;
    }
}

/* ARCCheck inlined from ARC.e */
    }

    /* diff cycling will is incompatible with the legacy hyerdab*/
    if ((diff_order_flag >0) && (hsdab !=2 ))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG,
                    "Diffusion gradient cycling", STRING_ARG, "non-diffusion hyper dab packet" );
        return FAILURE;
    }
    
    if (rpg_flag > 0)
    {
        if (PSD_OFF == distcorr_status)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "this system" );
            return FAILURE;
        }

        if (diff_order_flag == 2)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "T2+Diffusion Cycling" );
            return FAILURE;
        }
        
        if (PSD_OFF == exist(opdiffuse))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Non-Diffusion scan" );
            return FAILURE;
        }
        
        if (PSD_ON == rfov_flag)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Focus" );
            return FAILURE;
        }
        
        if (0 == dda)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "dda 0" );
            return FAILURE; 
        }

        if (PSD_ON == exist(opcgate))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Cardiac Gating" );
            return FAILURE; 
        }

        if (PSD_ON == exist(oprtcgate))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Respiratory Triggering" );
            return FAILURE; 
        }

        if (PSD_ON == exist(opnav))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Navigators" );
            return FAILURE; 
        }

        if (PSD_ON == exist(opmph))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Multi-Phase" );
            return FAILURE; 
        }

        if (PSD_ON == exist(opfcomp))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "Flow Compensation" );
            return FAILURE; 
        }

        if ((asset_factor/(float)(opnshots))>0.5)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction", STRING_ARG, "<2.0 ASSET" );
            return FAILURE;
        }
    }
    else
    {
        if (rhdistcorr_ctrl > 0)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Distortion Correction Off", STRING_ARG, "rhdistcorr_ctrl>0");
            return FAILURE;
        }
    }

    if(dpc_flag)
    {
        if(iref_etl == 0)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                STRING_ARG, "Dynamic Phase Correction", STRING_ARG, "iref_etl = 0" );
            return FAILURE;
        }

        if (exist(opdiffuse) == PSD_OFF)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                STRING_ARG, "Dynamic Phase Correction", STRING_ARG, "Non-Diffusion scan" );
            return FAILURE;
        }

        if( ky_dir == PSD_CENTER_OUT) {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2),
                STRING_ARG, "Dynamic Phase Correction", STRING_ARG, "CENTER_OUT" );
            return FAILURE;
        }

        if(rtb0_flag)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Dynamic Phase Correction", STRING_ARG, "Real Time Center Frequency");
            return FAILURE;
        }

    }

    if((hopc_flag == PSD_ON) && (pc_enh == PSD_OFF))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "High-Order Phase Correction", STRING_ARG, "Magnitude-Weighted");
        return FAILURE;
    }

    return SUCCESS;
} /* end CVCHECK */


STATUS ssCheck(void) 
{
    /* BJM: this function is no longer needed as these checks are performed in ssEval2 */
    /*      However, in order to minimize the impact to the epi source, we will keep it */
    /*      around for now....*/

    /* SVBranch: HCSDM00193936:
       The following code is moved back from ssEval2(), 
       because the scan_info at ssEval2() is not the 
       most updated */
       
    INT sl_cnt = 0; 
    float max_optloc = 0.0;
    float ss_minslthk1_rup = 0.0;
    
    if (PSD_ON == ss_rf1)   
    {
        {
            float tmp;

            if(PSD_ON == oprealtime)
            {
                tmp = ceilf( ss_psd_slthick * 10.0)/ 10.0;
            }
            else
            {
                tmp = ceilf( exist(opslthick) * 10.0)/ 10.0;
            }
            /* Maximum Offset for SpSP Pulse (mm) */
            ss_maxoff  = _ss_maxoff.fixedflag ?           
                                                                     ((void)((MAX_OMEGA_OFFSET*tmp/(ss_min_slthk*((loggrd.zfs<a_gzrf1_ss_max)?loggrd.zfs:a_gzrf1_ss_max)))), ss_maxoff) : (MAX_OMEGA_OFFSET*tmp/(ss_min_slthk*((loggrd.zfs<a_gzrf1_ss_max)?loggrd.zfs:a_gzrf1_ss_max)));
        }

        /* Initialize ss max offset flag */
        ss_maxoffex  = _ss_maxoffex.fixedflag ?  ((void)(PSD_OFF), ss_maxoffex) : PSD_OFF;
        /* Check the scan range only after slice thickness, skip,
           and slice number are set MRIge35391*/
        if ( (existcv(opslquant)==PSD_ON) &&
             (existcv(opslthick)==PSD_ON) &&
             (existcv(opslspace)==PSD_ON) ) {

            max_optloc = 0.0;    /* the maximum offset of all slices or groups of slices */

            for (sl_cnt=0; sl_cnt<(PSD_3D == (exist(opimode))?opvquant:opslquant); sl_cnt++) {
                if(fabs(scan_info[sl_cnt].optloc + scan_info[sl_cnt].optloc_shift) > max_optloc)
                    max_optloc = fabs(scan_info[sl_cnt].optloc + scan_info[sl_cnt].optloc_shift);
            }

            if ( max_optloc > ss_maxoff ) {

                /* MRIge64190: use dbdt limited amp if necessary */
                const float tmp_amp_gzrf1 = (loggrd.zfs < a_gzrf1_ss_max ) ? loggrd.zfs : a_gzrf1_ss_max;

                ss_maxoffex  = _ss_maxoffex.fixedflag ?  ((void)(PSD_ON), ss_maxoffex) : PSD_ON;
                /* New minimum slice thickness to maintain scan coverage */
                ss_minslthk1  = _ss_minslthk1.fixedflag ?  ((void)((max_optloc*ss_min_slthk*tmp_amp_gzrf1/(MAX_OMEGA_OFFSET))), ss_minslthk1) : (max_optloc*ss_min_slthk*tmp_amp_gzrf1/(MAX_OMEGA_OFFSET));

                /* round up ss_minslthk1 in error message to 0.1 mm */
                ss_minslthk1_rup = ceilf( ss_minslthk1 * 10.0 )/ 10.0;

                epic_error( use_ermes,
                            "Use a slice offset < %d mm or use a slice thickness >=%3.1f mm.",
                            EM_PSD_SS_OFFSET_EXCEEDED_F, EE_ARGS(2), INT_ARG, (int)ss_maxoff,
                            FLOAT_ARG, ss_minslthk1_rup );
                return FAILURE;

            } /* if max_optloc */

        } /* if existcv(opslquant) */
        
    } /* if(ss_rf1) */
        
    return SUCCESS;
}


/******************************ssRsp*************************************/

/*RTB0 correction*/
STATUS rtb0Init() 
{
    rtb0_movAvg  = _rtb0_movAvg.fixedflag ?  ((void)(5), rtb0_movAvg) : 5;

    /* For small number of sample points, reduce the num of skipped points */
    if ( (int) ((rhfrsize - rtb0_min_points)/2) < 20 )
    {
        rtb0_first_skip  = _rtb0_first_skip.fixedflag ?   ((void)((int)((rhfrsize-rtb0_min_points)/2)), rtb0_first_skip) : (int)((rhfrsize-rtb0_min_points)/2);
        rtb0_last_skip  = _rtb0_last_skip.fixedflag ?  ((void)(rtb0_first_skip), rtb0_last_skip) : rtb0_first_skip;
    } else {
        rtb0_first_skip  = _rtb0_first_skip.fixedflag ?  ((void)(20), rtb0_first_skip) : 20;
        rtb0_last_skip  = _rtb0_last_skip.fixedflag ?  ((void)(20), rtb0_last_skip) : 20;
    }
    return SUCCESS;
}

/* Determine if RTB0 is supported or not */

/* DTI b-value calcs using pulsegen are inlined here */
/*
 * DTI_Predownload:
 *
 *  This is inlined into Predownload of epi2.e to set up the CERD for multi-nex diffusion 
 *  and also to perform the exact b-value calculations
 */
#ifdef __STDC__ 
STATUS DTI_Predownload( void )
#else /* !__STDC__ */
STATUS DTI_Predownload() 
#endif /* __STDC__ */
{
    if ( tensor_flag == PSD_ON ) {

        /* MRIge67233 Added functionality to support tensor processing on host */
        /* rhapp gets set in loarheader init call for scic, hence moved initialization for tensor here */
        /* rhapp = 2 initiates tensor processing (app), rhapp_option defines choices ADC/FA/Combined */
        if(rhapp_option != 0) {

            rhapp  = _rhapp.fixedflag ?  ((void)(2), rhapp) : 2;

        } else {

            /* If user doesn't select any maps on DW-UI (ADC/FA/T2-Combined) */
            /* might as well not kick off an app process... */
            rhapp  = _rhapp.fixedflag ?  ((void)(0), rhapp) : 0;
        }

    }
    
    /* BJM: for multi-nex DW-EPI - override rhnavs so CERD thinks */
    /* have a single NEX scan */
    if ( (opdiffuse == PSD_ON || tensor_flag == PSD_ON) && nex > 1 ) {
        rhnavs  = _rhnavs.fixedflag ?  ((void)(1), rhnavs) : 1;
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1|512), rhtype1) : rhtype1|512;
    } else {
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1&~512), rhtype1) : rhtype1&~512;
    }

    /***************************************/
    /* Exact Diffusion B-value Calculation */
    /***************************************/
    /* CRM: 2000-12-06 */
    /* Calculate and adjust the b-values on each axis for the correct b-values */

    if ( (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON) ){
        /* Variables for b-value calculation */
        FLOAT curr_bvalue[6];     /* b-value for each gradient waveform */
        FLOAT rf_excite_location; /* Location of isocenter of excitation pulse (usec) */
        FLOAT rf_180_location[2]; /* Location of isocenter of 180 pulses (usec) pulses 
                                     MAX of 2 can be increased for other applications */
        INT num_180s;             /* Number of 180s */
        INT seq_entry_index = 0;  /* Core sequence = 0 */
        INT bmat_flag = FALSE;    /* flag to do full blown matrix calcs (need to be zero for verify_bvalue() */
        STATUS status;            /* Status variable to catch errors from function calls */
        INT hte = opte/2;         /* Half te */  

        /* ---Calculate timing parameters--- */
        /* MUST MATCH THE TIMING IN PULSEGEN TO GIVE ACCURATE RESULTS */
        /* MRIhc27253, MRIhc27365 : updated pulse params to current values*/
        if ( FAILURE == calcPulseParams(AVERAGE_POWER) ) 
        { 
            return FAILURE; 
        }

        /* Calculate magnetic isocenter of excitation pulse */
        rf_excite_location = (psd_rf_wait + pos_start + pw_gzrf1a + pw_rf1 - rfExIso);
        /* fprintf(stdout,"rf_excite_location = %12.8f\n",rf_excite_location); */

        /* SVBranch: HCSDM00259122 - walk sat case */
        if (rfov_flag && walk_sat_flag)
        {
            rf_excite_location = (psd_rf_wait + pos_start + pw_gzrf1a + pw_rf1 - rfExIso) + pw_wksat_tot;
        }

        /* Calculate location of 180s */
        /* Note: To get the correct rounding, subtract pw_rf2/2 as in pulsegen, */
        /*       do the rounding, and then add it back                          */
        if (PSD_ON == dualspinecho_flag) /* Set # of 180s */
        {
            num_180s = 2;
            rf_180_location[0] = RUP_GRD((INT)rf_excite_location + hte/2 - pw_rf2/2) + pw_rf2/2;
            rf_180_location[1] = RUP_GRD((INT)rf_excite_location + 3*hte/2 - pw_rf2/2) + pw_rf2/2;
            /* fprintf(stdout,"rf_180_location[0] = %12.8f\n",rf_180_location[0]);
               fprintf(stdout,"rf_180_location[1] = %12.8f\n",rf_180_location[1]); */
        }
        else{
            num_180s = 1;
            rf_180_location[0] = RUP_GRD((INT)rf_excite_location + hte - pw_rf2/2) + pw_rf2/2;
            /* fprintf(stdout,"rf_180_location[0] = %12.8f\n",rf_180_location[0]); */
        }

        /* Calculate the bvalue for the original estimates--- */
        /* and adjust if necessary.... */
        /* MRIge61617, to enable DWEPIQ tool to run without
           download failures..note this is a kludge fix */
        /* In case epi2gspec, set diff_amp<x,y,z>[] here. */
        if (PSD_ON == different_mpg_amp_flag)
        {
            diff_ampx[0] = incdifx;
            diff_ampy[0] = incdify;
            diff_ampz[0] = incdifz;
        }
        else if (b0calmode != 1) {
	    /* store gradient amplitudes for retrieval later */
	    int ampx_tmp = a_gxdl;
	    int ampy_tmp = a_gydl;
	    int ampz_tmp = a_gzdl;

	    /* set all gradient amplitudes to system max */
	    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(loggrd.tx_xyz), a_gxdl) : loggrd.tx_xyz;
	    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;
	    a_gydl  = _a_gydl.fixedflag ?  ((void)(loggrd.ty_xyz), a_gydl) : loggrd.ty_xyz;
	    a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;
	    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(loggrd.tz_xyz), a_gzdl) : loggrd.tz_xyz;
	    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;

	    /* granty edit calculate b-value in pulsegen */
	    seg_debug  = _seg_debug.fixedflag ?  ((void)(1), seg_debug) : 1;
	    waveform_type  = _waveform_type.fixedflag ?  ((void)(3), waveform_type) : 3; /* load isotropic waveform into instruction memory in pg */
            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON;
	    bmat_flag = 1;
        printf("daiep test1...\n" ); /* daiep test */  
        fflush(stdout); 

            status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location,
                                       num_180s, opte, GAM, &loggrd, seq_entry_index, tsamp,
                                       act_tr, use_ermes, seg_debug, bmat_flag);
        printf("daiep test2...\n" ); /* daiep test */  
        fflush(stdout); 

            if(status == FAILURE || status == SKIP) {
            	epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
            	return FAILURE;
            }

        printf("daiep test3...\n" ); /* daiep test */  
        fflush(stdout); 

            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;
	    ide_max_bval  = _ide_max_bval.fixedflag ?      ((void)(curr_bvalue[0]+curr_bvalue[1]+curr_bvalue[2]), ide_max_bval) : curr_bvalue[0]+curr_bvalue[1]+curr_bvalue[2];
	    if(ide_max_bval < max_bval){ 
		max_bval  = _max_bval.fixedflag ?   ((void)(ide_max_bval), max_bval) : ide_max_bval;
	    }

	    printf("current IDE b-value = %f \n", curr_bvalue[0] + curr_bvalue[1] + curr_bvalue[2]);
	    fflush(stdout);

            /* Calculate bvalue using pulsegen */
	    waveform_type  = _waveform_type.fixedflag ?  ((void)(1), waveform_type) : 1; /* load sde waveform into instruction memory in pg */
            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_ON), pgen_calc_bval_flag) : PSD_ON;
	    bmat_flag = 1;
            status =  pgen_calcbvalue( curr_bvalue, rf_excite_location, rf_180_location,
                                       num_180s, opte, GAM, &loggrd, seq_entry_index, tsamp,
                                       act_tr, use_ermes, seg_debug, bmat_flag);
            if(status == FAILURE || status == SKIP) {
            	epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "pgen_calcbvalue()" );
            	return FAILURE;
            }
            pgen_calc_bval_flag  = _pgen_calc_bval_flag.fixedflag ?  ((void)(PSD_OFF), pgen_calc_bval_flag) : PSD_OFF;
	    sde_max_bval  = _sde_max_bval.fixedflag ?      ((void)((curr_bvalue[0]+curr_bvalue[1]+curr_bvalue[2])/3), sde_max_bval) : (curr_bvalue[0]+curr_bvalue[1]+curr_bvalue[2])/3;
	    if(ide_max_bval < max_bval) max_bval  = _max_bval.fixedflag ?   ((void)(sde_max_bval), max_bval) : sde_max_bval;
	    printf("current SDE b-value = %f \n",(curr_bvalue[0] + curr_bvalue[1] + curr_bvalue[2])/3);
     	    fflush(stdout);
 
 	    /* set all gradient amplitudes to original values */
	    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(ampx_tmp), a_gxdl) : ampx_tmp;
	    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;
	    a_gydl  = _a_gydl.fixedflag ?  ((void)(ampy_tmp), a_gydl) : ampy_tmp;
	    a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;
	    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(ampz_tmp), a_gzdl) : ampz_tmp;
	    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;

	    /* verify b-value */
            status = verify_bvalue(curr_bvalue, rf_excite_location, rf_180_location,
                                   num_180s,seq_entry_index,bmat_flag,seg_debug);
            if(status == FAILURE || status == SKIP) {
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "verify_bvalue()" );
                return FAILURE;
            }
        }


        /* calculate the b-matrix is allowed only for TENSOR for multi b
         * incompatibility */
        if( (calc_bmatrix_flag == TRUE) && (tensor_flag == TRUE)) bmat_flag = TRUE;

        status = calc_b_matrix(curr_bvalue, rf_excite_location, rf_180_location, 
                               num_180s, seq_entry_index, bmat_flag, seg_debug); 

        if(status == FAILURE || status == SKIP) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "calc_b_matrix()" );
            return FAILURE;
        }

    } /* End exact bvalue calculation */

    return SUCCESS;
}  /* end DTI_Predownload */



STATUS
T1flairPredownload (void)
{
    if ( PSD_ON == t1flair_flag )
    {
        if ( ( false_slquant1 != 0 ) && ( seqtime_t1flair != 0 ) )
        {
            act_tr  = _act_tr.fixedflag ?    ((void)(false_slquant1*seqtime_t1flair), act_tr) : false_slquant1*seqtime_t1flair;
        }
    }
  
    return SUCCESS;

} /* end T1flairPredownload() */


/***********************************************************************/
/* PREDOWNLOAD                                                         */
/***********************************************************************/
STATUS
predownload( void )
{
    int off_index;   /* loop index */
    int i,j;       /* counters */
    int sloff;
    int acq_off;
    int pislice[SLTAB_MAX];

    /* HCSDM00361682 */
    if(focus_eval_oscil_hist)
    {
        int status;
        isPredownload  = _isPredownload.fixedflag ?  ((void)(1), isPredownload) : 1;
        set_cvs_changed_flag(TRUE);
        for(i=0; i<NUM_EVAL_IN_PREDOWNLOAD; i++)
        {
            status = cveval();
            if(status != SUCCESS)
            {
                isPredownload  = _isPredownload.fixedflag ?  ((void)(0), isPredownload) : 0;
                set_cvs_changed_flag(FALSE);
                epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "cveval" );
                return status;
            }
        }
        set_cvs_changed_flag(FALSE);
        oscil_eval_count  = _oscil_eval_count.fixedflag ?  ((void)(0), oscil_eval_count) : 0;
        isPredownload  = _isPredownload.fixedflag ?  ((void)(0), isPredownload) : 0;
        focus_eval_oscil_hist  = _focus_eval_oscil_hist.fixedflag ?  ((void)(0), focus_eval_oscil_hist) : 0;
    }

    { /* Start of code inlined from vmx.e PreDownLoad */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e PreDownLoad */


    /* to avoid side effects, set pitfeextra before loadrheader */
    pitfeextra = 0;

    /* t1flair_stir */
    if (PSD_ON == t1flair_flag)
    {
        slquant1  = _slquant1.fixedflag ?    ((void)(dummyslices+2*act_edge_slice_enh_flag), slquant1) : slquant1-dummyslices+2*act_edge_slice_enh_flag;
    }

    /* PURE Mix */
    model_parameters.epi.dualspinecho_flag  = _dualspinecho_flag.fixedflag ?  ((void)(dualspinecho_flag), dualspinecho_flag) : dualspinecho_flag;
    model_parameters.epi.rfov_flag  = _rfov_flag.fixedflag ?  ((void)(rfov_flag), rfov_flag) : rfov_flag;

    /* recon variables */
    { /* Start of code inlined from loadrheader.e rheaderinit */

        /*
          rawdata   0=NOREC, 1=NPPROC
          eepf      1 for even echo phase flip
          oepf      1 for odd echo phase flip
          eeff      1 for even echo freq flip
        */

        eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
        eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        oeff  = _oeff.fixedflag ?  ((void)(0), oeff) : 0;

        pinex = nex; /* initialize for pinex so APS can use it */

        if( (nex == 1) || (isOddNexGreaterThanOne) || (isNonIntNexGreaterThanOne) )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(baseline), rhbline) : baseline;
        }
        else
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
        }

        if( opimode == PSD_CINE )
        {
            rhbline  = _rhbline.fixedflag ?  ((void)(0), rhbline) : 0;
            if (isOddNexGreaterThanOne || isNonIntNexGreaterThanOne || nex < 2)
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_ON), cine_choplet) : PSD_ON;
            else
                cine_choplet  = _cine_choplet.fixedflag ?  ((void)(PSD_OFF), cine_choplet) : PSD_OFF;
        }

        if( rhbline )
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
        }
        else
        {
            rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
        }

        rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        if( (nex > 1) && (opimode != PSD_CINE) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if ( isOddNexGreaterThanOne || isNonIntNexGreaterThanOne )
        {
            rhtype  = _rhtype.fixedflag ?  ((void)(0), rhtype) : 0;
        }
        if( (opimode == PSD_CINE) && (!cine_choplet) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCHP), rhtype) : rhtype+RHTYPCHP;
        }
        if( opimode == PSD_CINE )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPCINE), rhtype) : rhtype+RHTYPCINE;
        }
        if( oppseq == PSD_GE || 
            oppseq == PSD_TOF || oppseq == PSD_TOFSP ||
            oppseq == PSD_PC  || oppseq == PSD_PCSP ||
            oppseq == PSD_3PLANELOC )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPGR), rhtype) : rhtype+RHTYPGR;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.5, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTNEX), rhtype) : rhtype+RHTYPFRACTNEX;
        }
        if( opimode == PSD_3D )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP3D), rhtype) : rhtype+RHTYP3D;
        }
        if( (nop > 1) && (oppomp == PSD_OFF) )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPNPW), rhtype) : rhtype+RHTYPNPW;
        }
        if( pitfeextra > 0 )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPFRACTECHO), rhtype) : rhtype+RHTYPFRACTECHO;
        }
        if(floatsAlmostEqualEpsilons(fn, 0.75, 2))
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYP75NEX), rhtype) : rhtype+RHTYP75NEX;
        }
        if( oppomp )
        {
            rhtype  = _rhtype.fixedflag ?    ((void)(rhtype+RHTYPPOMP), rhtype) : rhtype+RHTYPPOMP;
        }

        rhnecho  = _rhnecho.fixedflag ?  ((void)(opnecho), rhnecho) : opnecho;

        if( (opimode == PSD_CINE)
            && ((oppseq == PSD_PC) || (oppseq == PSD_PCSP)) )
        {
            rhnslices  = _rhnslices.fixedflag ?          ((void)(opslquant*(2+2*(exist(opflaxall)==1))), rhnslices) : opslquant*(2+2*(exist(opflaxall)==1));
        }
        else if( opcgate )
        {
            rhnslices  = _rhnslices.fixedflag ?    ((void)(opslquant*opphases), rhnslices) : opslquant*opphases;
        }
        else
        {
            rhnslices  = _rhnslices.fixedflag ?  ((void)(opslquant), rhnslices) : opslquant;
        }

        rhptsize  = _rhptsize.fixedflag ?  ((void)(opptsize), rhptsize) : opptsize;



     rhnavs  = _rhnavs.fixedflag ?      ((void)(IMax(2,(INT)(nex/2),(INT)1)), rhnavs) : IMax(2,(INT)(nex/2),(INT)1);

        rhformat  = _rhformat.fixedflag ?  ((void)(0), rhformat) : 0;
        if (nofermi)
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_FERMI), rhformat) : rhformat|RHF_NO_FERMI;
        }
        else
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_FERMI), rhformat) : rhformat&~RHF_NO_FERMI;
        }

        if (nograd == PSD_OFF) /* use 2d or 3d gradwarp */
        {
            rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_NO_GRADWARP), rhformat) : rhformat&~RHF_NO_GRADWARP;
            if ((op3dgradwarp == PSD_ON) && (exist(opslquant)>1)) /* do 3d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP13DGRADWARP), rhtype1) : rhtype1|RHTYP13DGRADWARP;
            }
            else   /* do 2d gradwarp */
            {
                rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            }
        }
        else  /* no gradwarp */
        {
            rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP13DGRADWARP), rhtype1) : rhtype1&~RHTYP13DGRADWARP;
            rhformat  = _rhformat.fixedflag ?  ((void)(RHF_NO_GRADWARP), rhformat) : rhformat|RHF_NO_GRADWARP;
        }
                
            
        if( opimode == PSD_3D )
        {
            if( zchop )
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_ZCHOP), rhformat) : rhformat|RHF_ZCHOP;
            }
            else
            {
                rhformat  = _rhformat.fixedflag ?  ((void)(RHF_YCHOP), rhformat) : rhformat|RHF_YCHOP;
            }
        }

        rhapp  = _rhapp.fixedflag ?         
                      ((void)(((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger))), rhapp) : ((PSD_ON==opscic)&&(PSD_OFF==oprealtime)&&(PSD_OFF==opfluorotrigger));

        if( (acq_type == TYPGRAD) && (opimode != PSD_CINE) )
        {
            eeff  = _eeff.fixedflag ?  ((void)(1), eeff) : 1;
        }
        else
        {
            eeff  = _eeff.fixedflag ?  ((void)(0), eeff) : 0;
        }

        if( (acq_type == TYPSPIN) && (opexor == PSD_OFF) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(1), eepf) : 1;
        }
        else if( (acq_type == TYPSPIN) && (opexor == PSD_ON) )
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }
        else
        {
            eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;
        }

        /* set bit0 in rhdacqctrl with rawdata */
        if( rawdata )
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(RHDC_RAWDATA), rhdacqctrl) : rhdacqctrl|RHDC_RAWDATA; 
        }
        else
        {
            rhdacqctrl  = _rhdacqctrl.fixedflag ?  ((void)(~(RHDC_RAWDATA)), rhdacqctrl) : rhdacqctrl&~(RHDC_RAWDATA);
        }

        set_echo_flip(_rhdacqctrl.fixedflag ? (_temp694_rhdacqctrl=rhdacqctrl,&_temp694_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff);

        rhexecctrl  = _rhexecctrl.fixedflag ?      
                        ((void)(RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter), rhexecctrl) : RHXC_AUTO_DISPLAY|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)|RHXC_XFER_IM|RHXC_INTERMEDIATE*saveinter;

        /* Begin RTIA comment --- RJF */

        /*
          For RTIA, we don't need the images to be routed to TIR.
          Neither do we want them to be displayed in autoview.
          Here is the bit definitions for rhexecctrl.

          RDB_AUTO_DISPLAY               0x0001    1 
          RDB_AUTO_LOCK                  0x0002    2 
          RDB_AUTO_PERM                  0x0004    4 
          RDB_XFER_IM                    0x0008    8 
          RDB_SAVE_IM                    0x0010    16 
          RDB_TAPE_LOCK                  0x0020    32 
          RDB_INTERMEDIATE               0x0040    64 
          RDB_OVERRIDE_BROADCAST         0x0080    128 
          RDB_OVERRIDE_IMG_INSTALL       0x0100    256 
          RDB_OVERRIDE_AUTODISPLAY       0x0200    512 
          RDB_RTD_XFER_IM_REMOTE         0x0400    1024 
          RDB_RTD_SCAN                   0x0800    2048 
          RDB_REF_SCAN                   0x1000    4096 
          RDB_DONT_WRITE_OR_INSTALL      0x2000    8192 
          RDB_RTD_XFER_ALL_IM_PER_PASS   0x4000    16384 
          RDB_XFER_IMG_RIR               0x8000    32768 
        */
        /*  End RTIA comment */

        /* Begin RTIA */

        if( (oprealtime == PSD_ON) || (opfluorotrigger == PSD_ON) )
        { 
            rhexecctrl  = _rhexecctrl.fixedflag ?        ((void)(RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR), rhexecctrl) : RHXC_OVERRIDE_IMG_INSTALL|RHXC_RTD_SCAN|RHXC_DONT_WRITE_OR_INSTALL|RHXC_XFER_IMG_RIR; 
            
            if ( (saveinter == PSD_ON) && (track_flag == PSD_ON) )
            { /*for realtime imaging, enable saving intermediate images*/
                rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_INTERMEDIATE), rhexecctrl) : rhexecctrl|RHXC_INTERMEDIATE;
            }

            /* Added for Enabling Autoview for RTIA debug */
#ifdef RTIA_AUTOVIEW_ENABLE
            rhexecctrl  = _rhexecctrl.fixedflag ?  ((void)(RHXC_AUTO_DISPLAY), rhexecctrl) : rhexecctrl|RHXC_AUTO_DISPLAY; 
#endif
        }

        /* MRIge66773 */
        if( opfluorotrigger == PSD_ON )
        {
            rhexecctrl  = _rhexecctrl.fixedflag ?    ((void)(RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock)), rhexecctrl) : rhexecctrl|RHXC_AUTO_LOCK*(0<autolock)|RHXC_AUTO_LOCK_ALLRECS*(2==autolock);
        }
 
        /* End RTIA */
        rhvquant  = _rhvquant.fixedflag ?  ((void)(opvquant), rhvquant) : opvquant;
        rhslblank  = _rhslblank.fixedflag ?  ((void)(pislblank), rhslblank) : pislblank;
        rhzeroph  = _rhzeroph.fixedflag ?         ((void)((eg_phaseres*nop/2)*(opphasefov)+0.5), rhzeroph) : (eg_phaseres*nop/2)*(opphasefov)+0.5;
        if( pitfeextra > 0 )
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(8), rhnwin) : 8;
        }
        else
        {
            rhnwin  = _rhnwin.fixedflag ?  ((void)(0), rhnwin) : 0;
        }

        if(pitfeextra > 0)
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(4.0), rhntran) : 4.0;
        }
        else if( floatsAlmostEqualEpsilons(fn, 0.5, 2) && (nop > 1.0) )
        {
            rhntran  = _rhntran.fixedflag ?    ((void)(2.0*nop), rhntran) : 2.0*nop;
        }
        else
        {
            rhntran  = _rhntran.fixedflag ?  ((void)(2.0), rhntran) : 2.0;
        }

        if (APODIZE_STRONG == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(3.0), fermi_w_factor) : 3.0;
        }
        else if (APODIZE_MEDIUM == apodize_level_flag)
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(0.9), fermi_r_factor) : 0.9;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }
        else
        {
            fermi_r_factor  = _fermi_r_factor.fixedflag ?  ((void)(1.0), fermi_r_factor) : 1.0;
            fermi_w_factor  = _fermi_w_factor.fixedflag ?  ((void)(1.0), fermi_w_factor) : 1.0;
        }

        if( (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhfermr  = _rhfermr.fixedflag ?        ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres)*prop_act_oversamplingfactor;
        }
        else
        {
            rhfermr  = _rhfermr.fixedflag ?      ((void)(fermi_rc*fermi_r_factor*(float)exist(opxres)), rhfermr) : fermi_rc*fermi_r_factor*(float)exist(opxres);
        }
        rhfermw  = _rhfermw.fixedflag ?      ((void)(fermi_wc*fermi_w_factor*(float)10.0), rhfermw) : fermi_wc*fermi_w_factor*(float)10.0;

        /* JAH: MRIge68280 -- need to use this more robust means of defining
           the eccentricity of the fermi filter so the radius in the X and Y
           directions need not be equal or based on data acquisition or
           reconstruction sizes as determined in recon. */
        /* KVA: MRIge73462 Square pixel rhferme addition */

        if( (PSD_ON == opspiral) || (PSD_ON == exist(opsilentmr)) || 
            (PSD_SPECTRO == opimode) || (PSD_ON == opprop) || (PSD_ON == opdwprop) )
        {
            rhferme  = _rhferme.fixedflag ?  ((void)(1.0), rhferme) : 1.0;
        }
        else if( (PSD_ON == opepi) || (PSD_ON == opsquare) )
        {
            rhferme  = _rhferme.fixedflag ?    ((void)(opxres/(opyres*nop)), rhferme) : opxres/(opyres*nop);
        }
        else
        {
            rhferme  = _rhferme.fixedflag ?      ((void)(opxres/(opyres*opphasefov*nop)), rhferme) : opxres/(opyres*opphasefov*nop);
        }

        rhnpasses  = _rhnpasses.fixedflag ?  ((void)(acqs), rhnpasses) : acqs;

        rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
        rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

        /* PURE */
        /*MRIge91361 add rhpure for PURE*/
        if (exist(oppurecal))
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE_CAL), rhpure) : PURE_CAL;
        }
        else
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(exist(oppure)), rhpure) : exist(oppure);
        }

        /* Turn on pure mix if PURE_ITKN4 is applied under SCENIC */
        if (PSD_ON == opscenic && SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            rhpure  = _rhpure.fixedflag ?  ((void)(PURE2), rhpure) : PURE2;
        }

        /*MRIge93538 set rhpurefilter to 1 as default*/
        rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(1), rhpurefilter) : 1;

        {
            int attribute_result_int = 0;
            float attribute_result_float = 0.0;

            /* PURE 2 */
            if(isDVSystem() && ((B0_15000 == cffield) && (!strncmp("memp_pure", get_psd_name(), 9) || !strncmp("fse_pure", get_psd_name(), 8))))
            {            	
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_LOWEREXTREMITIES) || /* Turn on MSK PURE Mix for all products*/ 
                     isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_UPPEREXTREMITIES))
            {		
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(0), rhpure_filtering_mode) : 0;
            }
            else
            {
                rhpure_filtering_mode  = _rhpure_filtering_mode.fixedflag ?  ((void)(exist(cfpure_filtering_mode)), rhpure_filtering_mode) : exist(cfpure_filtering_mode);
            }
            rhpure_lambda  = _rhpure_lambda.fixedflag ?  ((void)(coilInfo[0].pureLambda), rhpure_lambda) : coilInfo[0].pureLambda;
            rhpure_tuning_factor_surface  = _rhpure_tuning_factor_surface.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorSurface), rhpure_tuning_factor_surface) : coilInfo[0].pureTuningFactorSurface;
            rhpure_tuning_factor_body  = _rhpure_tuning_factor_body.fixedflag ?  ((void)(coilInfo[0].pureTuningFactorBody), rhpure_tuning_factor_body) : coilInfo[0].pureTuningFactorBody;

            /* PURE Blur */
            rhpure_blur_enable  = _rhpure_blur_enable.fixedflag ?        ((void)(getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0), rhpure_blur_enable) : getIntAnatomyAttribute(exist(opanatomy),ATTRIBUTE_ENABLE_PURE_BLUR,&attribute_result_int)?attribute_result_int:0;
            rhpure_blur  = _rhpure_blur.fixedflag ?        ((void)(getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0), rhpure_blur) : getFloatAnatomyAttribute(exist(opanatomy),ATTRIBUTE_PURE_BLUR,&attribute_result_float)?attribute_result_float:0.0;

            /* PURE Mix */
            strcpy(model_parameters.psd_name, get_psd_name());
            model_parameters.flip = exist(opflip);
            model_parameters.slthick = exist(opslthick);
            model_parameters.cffield  = _cffield.fixedflag ?  ((void)(cffield), cffield) : cffield;
            model_parameters.slquant = exist(opslquant);
            model_parameters.irmode = exist(opirmode);
            model_parameters.irprep = exist(opirprep);
            model_parameters.fatsat_flag = exist(opfatcl) || exist(opfat) || exist(opspecir);
            model_parameters.flex_flag = exist(opmedal);
            model_parameters.ideal_flag = exist(opdixon);
            model_parameters.obplane = exist(opobplane);
            model_parameters.plane = exist(opplane);
            model_parameters.tr = exist(optr);
            model_parameters.xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(xtg_volRecCoil), xtg_volRecCoil) : xtg_volRecCoil;
            model_parameters.pure_support = pipure;
            model_parameters.pseq_type = exist(oppseq);
            model_parameters.realtime_flag = exist(oprealtime);
            model_parameters.imode = exist(opimode);
            model_parameters.imsize = rhimsize;
            model_parameters.fov = exist(opfov);
            model_parameters.slzipfactor = exist(opslzip4)? 4 : (exist(opslzip2)? 2 : 1);

            pure_mix.enable = 0;
            pure_mix.tuning_factor_surface = rhpure_tuning_factor_surface;
            pure_mix.tuning_factor_body = rhpure_tuning_factor_body;
            pure_mix.blur_enable = rhpure_blur_enable;
            pure_mix.blur = rhpure_blur;

            /* SCENIC */
            scenic.itkn4.allow = ((cfn4_num_levels_max>0) && cfn4_allowed);
            scenic.itkn4.slice_down_sample_rate = cfn4_slice_down_sample_rate;
            scenic.itkn4.inplane_down_sample_rate = cfn4_inplane_down_sample_rate;
            scenic.itkn4.num_levels_max = cfn4_num_levels_max;
            scenic.itkn4.num_iterations_max = cfn4_num_iterations_max;
            scenic.itkn4.convergence_threshold = cfn4_convergence_threshold;
            scenic.itkn4.gain_clamp_mode = cfn4_gain_clamp_mode;
            scenic.itkn4.gain_clamp_value = cfn4_gain_clamp_value;

            scenic.scic.allow = ((cfscic_focus>0.0) && cfscic_allowed);
            scenic.scic.focus = cfscic_focus;
            scenic.scic.smooth = cfscic_smooth;
            scenic.scic.edge = cfscic_edge;
            scenic.scic.gauss = cfscic_gauss;
            scenic.scic.reduction = cfscic_reduction;
            scenic.scic.threshold = cfscic_threshold;
            scenic.scic.contrast = cfscic_contrast;

            if (B0_30000 == cffield || PSD_PURE_COMPATIBLE_2==pipure) /* 3.0 T platform */
            {
                if (FAILURE == getPUREMixParameters(model_parameters, coilInfo, exist(opanatomy), &pure_mix, _pure_mix_tx_scale.fixedflag ? (_temp695_pure_mix_tx_scale=pure_mix_tx_scale,&_temp695_pure_mix_tx_scale) : &pure_mix_tx_scale))
                {
                    epic_error(use_ermes, "Support routine %s failed.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "getPUREMixParameters");
                    return FAILURE;
                }
            }

            if (pure_mix.enable)
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(pure_mix.lambda), rhpure_mix_lambda) : pure_mix.lambda;
                if ((!strncmp("dwi_pure",model_parameters.psd_name,8) || !strncmp("fsemaster_pure",model_parameters.psd_name,14) ||
                     !strncmp("t1memp_pure",model_parameters.psd_name,11) || !strncmp("2dfast_pure",model_parameters.psd_name,11) ||
                     !strncmp("3dfse_pure",model_parameters.psd_name,10) || !strncmp("3dradial_pure",model_parameters.psd_name,13) ||
                     !strncmp("efgre3d_pure",model_parameters.psd_name,12) || !strncmp("3dtof_pure",model_parameters.psd_name,10) ||
                     !strncmp("csmemp_pure",model_parameters.psd_name,11) || !strncmp("ssfse_pure",model_parameters.psd_name,10) ||
                     !strncmp("epi_pure",model_parameters.psd_name,8) || !strncmp("asl_pure",model_parameters.psd_name,8)) &&
                    (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD)) && (isSVSystem()))
                {
                    rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(exist(opuser31)), rhpure_mix_lambda) : exist(opuser31);                
                }
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(pure_mix.tuning_factor_surface), rhpure_mix_tuning_factor_surface) : pure_mix.tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(pure_mix.tuning_factor_body), rhpure_mix_tuning_factor_body) : pure_mix.tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(pure_mix.blur_enable), rhpure_mix_blur_enable) : pure_mix.blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(pure_mix.blur), rhpure_mix_blur) : pure_mix.blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        ((void)(FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)))), rhpure_mix_alpha) : FMax(2,0.0,FMin(2,1.0,pure_mix.alpha+(exist(opuser40)/100.0)));
                rhpure_mix_otsu_class_qty  = _rhpure_mix_otsu_class_qty.fixedflag ?  ((void)(pure_mix.otsu_class_qty), rhpure_mix_otsu_class_qty) : pure_mix.otsu_class_qty;
                rhpure_mix_exp_wt  = _rhpure_mix_exp_wt.fixedflag ?  ((void)(pure_mix.exp_wt), rhpure_mix_exp_wt) : pure_mix.exp_wt;
                rhpure_mix_erode_dist  = _rhpure_mix_erode_dist.fixedflag ?  ((void)(pure_mix.erode_dist), rhpure_mix_erode_dist) : pure_mix.erode_dist;
                rhpure_mix_dilate_dist  = _rhpure_mix_dilate_dist.fixedflag ?  ((void)(pure_mix.dilate_dist), rhpure_mix_dilate_dist) : pure_mix.dilate_dist;
                rhpure_mix_aniso_blur  = _rhpure_mix_aniso_blur.fixedflag ?  ((void)(pure_mix.aniso_blur), rhpure_mix_aniso_blur) : pure_mix.aniso_blur;
                rhpure_mix_aniso_erode_dist  = _rhpure_mix_aniso_erode_dist.fixedflag ?  ((void)(pure_mix.aniso_erode_dist), rhpure_mix_aniso_erode_dist) : pure_mix.aniso_erode_dist;
                rhpure_mix_aniso_dilate_dist  = _rhpure_mix_aniso_dilate_dist.fixedflag ?  ((void)(pure_mix.aniso_dilate_dist), rhpure_mix_aniso_dilate_dist) : pure_mix.aniso_dilate_dist;
            }
            else
            {
                rhpure_mix_lambda  = _rhpure_mix_lambda.fixedflag ?  ((void)(rhpure_lambda), rhpure_mix_lambda) : rhpure_lambda;
                rhpure_mix_tuning_factor_surface  = _rhpure_mix_tuning_factor_surface.fixedflag ?  ((void)(rhpure_tuning_factor_surface), rhpure_mix_tuning_factor_surface) : rhpure_tuning_factor_surface;
                rhpure_mix_tuning_factor_body  = _rhpure_mix_tuning_factor_body.fixedflag ?  ((void)(rhpure_tuning_factor_body), rhpure_mix_tuning_factor_body) : rhpure_tuning_factor_body;
                rhpure_mix_blur_enable  = _rhpure_mix_blur_enable.fixedflag ?  ((void)(rhpure_blur_enable), rhpure_mix_blur_enable) : rhpure_blur_enable;
                rhpure_mix_blur  = _rhpure_mix_blur.fixedflag ?  ((void)(rhpure_blur), rhpure_mix_blur) : rhpure_blur;
                rhpure_mix_alpha  = _rhpure_mix_alpha.fixedflag ?        
                                        
                                           ((void)((isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0), rhpure_mix_alpha) : (isDVSystem()&&(B0_15000==cffield)&&(!strncmp("memp_pure",get_psd_name(),9)||!strncmp("fse_pure",get_psd_name(),8)))?1.0:0.0;
            }

            /* SCENIC */
            if (FAILURE == getScenicParameters(model_parameters, &scenic))
            {
                epic_error(use_ermes, "Support routine %s failed.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "getScenicParameters");
                return FAILURE;
            }
            rhn4_slice_down_sample_rate    = _rhn4_slice_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.slice_down_sample_rate), rhn4_slice_down_sample_rate) : scenic.itkn4.slice_down_sample_rate;
            rhn4_inplane_down_sample_rate  = _rhn4_inplane_down_sample_rate.fixedflag ?  ((void)(scenic.itkn4.inplane_down_sample_rate), rhn4_inplane_down_sample_rate) : scenic.itkn4.inplane_down_sample_rate;
            rhn4_num_levels_max            = _rhn4_num_levels_max.fixedflag ?  ((void)(scenic.itkn4.num_levels_max), rhn4_num_levels_max) : scenic.itkn4.num_levels_max;
            rhn4_num_iterations_max        = _rhn4_num_iterations_max.fixedflag ?  ((void)(scenic.itkn4.num_iterations_max), rhn4_num_iterations_max) : scenic.itkn4.num_iterations_max;
            rhn4_convergence_threshold     = _rhn4_convergence_threshold.fixedflag ?  ((void)(scenic.itkn4.convergence_threshold), rhn4_convergence_threshold) : scenic.itkn4.convergence_threshold;
            rhn4_gain_clamp_mode           = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_mode), rhn4_gain_clamp_mode) : scenic.itkn4.gain_clamp_mode;
            rhn4_gain_clamp_value          = _rhn4_gain_clamp_value.fixedflag ?  ((void)(scenic.itkn4.gain_clamp_value), rhn4_gain_clamp_value) : scenic.itkn4.gain_clamp_value;
    
            rh_ime_scic_enable   = _rh_ime_scic_enable.fixedflag ?    ((void)((scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type)), rh_ime_scic_enable) : (scenic.scic.allow&&SCENIC_TYPE_SCIC_FILTER==rhscenic_type);
            rh_ime_scic_focus    = _rh_ime_scic_focus.fixedflag ?  ((void)(scenic.scic.focus), rh_ime_scic_focus) : scenic.scic.focus;
            rh_ime_scic_smooth   = _rh_ime_scic_smooth.fixedflag ?  ((void)(scenic.scic.smooth), rh_ime_scic_smooth) : scenic.scic.smooth;
            rh_ime_scic_edge     = _rh_ime_scic_edge.fixedflag ?  ((void)(scenic.scic.edge), rh_ime_scic_edge) : scenic.scic.edge;
            rh_ime_scic_gauss    = _rh_ime_scic_gauss.fixedflag ?  ((void)(scenic.scic.gauss), rh_ime_scic_gauss) : scenic.scic.gauss;
            rh_ime_scic_reduction  = _rh_ime_scic_reduction.fixedflag ?  ((void)(scenic.scic.reduction), rh_ime_scic_reduction) : scenic.scic.reduction;
            rh_ime_scic_threshold  = _rh_ime_scic_threshold.fixedflag ?  ((void)(scenic.scic.threshold), rh_ime_scic_threshold) : scenic.scic.threshold;
            rh_ime_scic_contrast   = _rh_ime_scic_contrast.fixedflag ?  ((void)(scenic.scic.contrast), rh_ime_scic_contrast) : scenic.scic.contrast;

            if (PURE2 == exist(oppure) || SCENIC_TYPE_ITKN4_FILTER <= rhscenic_type) 
            {
                /* turn off gain clamp mode when gain_clamp_value is less
                 *              * than 0.5 or bigger than 5.0*/
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?    ((void)((rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f)), rhn4_gain_clamp_mode) : (rhn4_gain_clamp_value<5.0f)&&(rhn4_gain_clamp_value>=0.5f);
            }
            else
            {
                rhn4_gain_clamp_value  = _rhn4_gain_clamp_value.fixedflag ?  ((void)(5.0f), rhn4_gain_clamp_value) : 5.0f;
                rhn4_gain_clamp_mode  = _rhn4_gain_clamp_mode.fixedflag ?  ((void)(0), rhn4_gain_clamp_mode) : 0;
            }
            rhpure_gain_clamp_value  = _rhpure_gain_clamp_value.fixedflag ?  ((void)(rhn4_gain_clamp_value), rhpure_gain_clamp_value) : rhn4_gain_clamp_value;
            rhpure_gain_clamp_mode  = _rhpure_gain_clamp_mode.fixedflag ?  ((void)(rhn4_gain_clamp_mode), rhpure_gain_clamp_mode) : rhn4_gain_clamp_mode;        
        }

        if( truenex <= 0 )
        {
            /* PSDs which do not use truenex, as tools, and Spectro,
               will use nex. Truenex is used in Odd Nex NPW cases */
            truenex  = _truenex.fixedflag ?  ((void)(nex), truenex) : nex;
        }

        /* Set NEX for unacquired encodes for when zero-fill BAM is enabled */
        rhnex_unacquired  = _rhnex_unacquired.fixedflag ?  ((void)((int)(ceil(truenex))), rhnex_unacquired) : (int)(ceil(truenex));

        if( opimode==PSD_CINE )
        {
            rhrawsize = (n64)opclocs * (n64)opnecho * (n64)rhfrsize
                * (n64)((oppseq == PSD_PC || oppseq == PSD_PCSP) ?
                        (2 + (opflaxall == 1 ? 2 : 0)) : 1)
                * (n64)(2*rhptsize) * (n64)opcphases
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((float)(1 - rawdata) + (truenex * (float)rawdata)));

        }
        else
        {
            rhrawsize = (n64)slquant1 * (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                * (n64)ceil((float)(1 + (rhbline * rawdata) + rhnframes + rhhnover)
                            * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));

            /*a MRIge91983 - RDP - minimal acquisition size (single coil, single slice, 50 views) */
            if (rotateflag == 2)
            {
                rhrawsize = (n64)opnecho * (n64)rhfrsize * (n64)(2*rhptsize)
                    * (n64)ceil((float)(1 + (rhbline * rawdata) + 50 + rhhnover)
                                * ((exnex * (float)(1 - rawdata)) + (truenex * (float)rawdata)));
            }
        }


     if( oppomp )
     {
         if( opxres == 512 )
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(1024), rhrcyres) : 1024;
         }
         else
         {
             rhrcyres  = _rhrcyres.fixedflag ?  ((void)(512), rhrcyres) : 512;
         }
     }
     else
     {
         rhrcyres  = _rhrcyres.fixedflag ?  ((void)(eg_phaseres), rhrcyres) : eg_phaseres;
     }

        if( ((exist(opzip512) == PSD_ON) && (existcv(opzip512)) )
            || (exist(opxres) > 256) )
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(512), rhrcxres) : 512;           /* 512 ZIP or standard 512 recon */
        }
        else 
        {
            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(256), rhrcxres) : 256;           /* Standard 256 recon */
        }

        rhmethod  = _rhmethod.fixedflag ?  ((void)(oppomp), rhmethod) : oppomp;
        rhdaxres  = _rhdaxres.fixedflag ?  ((void)(opxres), rhdaxres) : opxres;

        rhrcctrl  = _rhrcctrl.fixedflag ?            
                          ((void)(recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG), rhrcctrl) : recon_mag_image*RHRCMAG|rawmode*RHRCRAW|recon_pha_image*RHRCPHS|recon_imag_image*RHRCIMAG|recon_qmag_image*RHRCQMAG;
        if( cfcompress < 100 )
        {
            rhrcctrl  = _rhrcctrl.fixedflag ?  ((void)(RHRCCOMP), rhrcctrl) : rhrcctrl+RHRCCOMP;
        }

        if ( opimode==PSD_CINE )
        {
            rhcphases  = _rhcphases.fixedflag ?  ((void)(opcphases), rhcphases) : opcphases;
            /*have to convert this from uSec to Sec */
            rhctr  = _rhctr.fixedflag ?  ((void)((FLOAT)optr/1000000.0), rhctr) : (FLOAT)optr/1000000.0;
            rhcrrtime  = _rhcrrtime.fixedflag ?  ((void)(60.0/(FLOAT)opchrate), rhcrrtime) : 60.0/(FLOAT)opchrate; /* also in Sec */
        }

        /* Support choice of gradient coil for twin gradient coils (Gili) */
        rhgradmode  = _rhgradmode.fixedflag ?  ((void)(opgradmode), rhgradmode) : opgradmode;

        rhte  = _rhte.fixedflag ?  ((void)(opte), rhte) : opte;
        rhte2  = _rhte2.fixedflag ?  ((void)(opte2), rhte2) : opte2;
        
        rhscancent  = _rhscancent.fixedflag ?  ((void)(piscancenter), rhscancent) : piscancenter;
       
        if(PSD_MINTE == exist(opautote))
        {
          /* EPI - MinTE with ramp sampling will be a problem hence not supported
             SSFSE - MinTE but full acquisition is done , disabled temporarily */
          if((PSD_ON == exist(opepi)) || (PSD_ON == exist(opssfse)) || (PSD_ON == exist(opspiral)))
            rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
          else if((PSD_3D == exist(opimode)) && (PSD_ON == exist(opdixon)))
            rhfeextra  = _rhfeextra.fixedflag ?       ((void)((int)((fnecho_lim-0.5)*rhfrsize+0.5)), rhfeextra) : (int)((fnecho_lim-0.5)*rhfrsize+0.5);
          else
           rhfeextra  = _rhfeextra.fixedflag ?    ((void)(rhfrsize-exist(opxres)/2), rhfeextra) : rhfrsize-exist(opxres)/2;
        }
        else
        {
          rhfeextra  = _rhfeextra.fixedflag ?  ((void)(0), rhfeextra) : 0;
        }

        rh3dgw_interptype  = _rh3dgw_interptype.fixedflag ?  ((void)(RH3DGW_BICUBIC_INTERP), rh3dgw_interptype) : RH3DGW_BICUBIC_INTERP; 

    } /* End of code inlined from loadrheader.e rheaderinit */

    
    /* t1flair_stir */
    if (PSD_ON == t1flair_flag)
    {
        slquant1  = _slquant1.fixedflag ?    ((void)(dummyslices+2*act_edge_slice_enh_flag), slquant1) : slquant1+dummyslices+2*act_edge_slice_enh_flag;
    }

    /* Asset */

/* AssetSetRhVars  inlined from Asset.e */
/* THIS CODE NEEDS TO BE INLINED AFTER */
/* @inline loadrheader.e rheaderinit in predownload */

    /*ASSET*/
    rhasset  = _rhasset.fixedflag ?  ((void)(exist(opasset)), rhasset) : exist(opasset);
    rhasset_calthresh  = _rhasset_calthresh.fixedflag ?  ((void)(coilInfo[0].assetCalThreshold), rhasset_calthresh) : coilInfo[0].assetCalThreshold;
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(asset_factor), rhasset_R) : asset_factor;
    rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(assetsl_factor), rhassetsl_R) : assetsl_factor;
    rhasset_phases  = _rhasset_phases.fixedflag ?  ((void)(1), rhasset_phases) : 1;       /* The number of phases in a pass */

    /* ASSET: reset rhferme after rheaderinit to divide out
       the ASSET R factor */
    if( existcv(opasset) && (PSD_ON == assetph_flag) )
    {
        rhferme  = _rhferme.fixedflag ?   ((void)(rhferme/rhasset_R), rhferme) : rhferme/rhasset_R;
    }

    /* MRIhc18622 Set AR-ASSET tuning factors */
    if( PSD_ON == exist(opassetscan) )
    {
        char * coil_name = coilInfo[0].coilName;
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        int sag_cor_flag = ((PSD_SAG == exist(opplane))
                            || (PSD_COR == exist(opplane)) 
                            || (PSD_OBL == exist(opplane)
                                && ((PSD_SAG == exist(opobplane))
                                    || (PSD_COR == exist(opobplane))))); 

        int torso_flag = (((isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                            && strcmp(attribute_codeMeaning, "Breast")) 
                           || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_ABDOMEN)
                           || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_PELVIS) 
                           || (sag_cor_flag && (NULL != strstr(coil_name,"Lower Limb")
                                                || NULL != strstr(coil_name,"PV UL")
                                                || NULL != strstr(coil_name,"Legs"))))
                          && ((cfrecvend - cfrecvst + 1) > 1));

        int localTx_flag = ((TX_COIL_LOCAL == getTxCoilType()) && ((cfrecvend - cfrecvst + 1) > 1));

        /* Set rhasset_torso for any coil that can be used for breathhold 
           acquisitions in the torso.  Also include for Sag & Cor scans with
           Lower Limb and PV UL modes for ASSET artifacts at edge of FOV */
        if( 0 != torso_flag )
        {
            rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(1), rhasset_torso) : 1;
        }
        else
        {
            rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(0), rhasset_torso) : 0;
        }

        /* Set rhasset_localTx for local Tx phased array coils */
        if( 0 != localTx_flag  )
        {
            rhasset_localTx  = _rhasset_localTx.fixedflag ?  ((void)(1), rhasset_localTx) : 1;
        }
        else
        {
            rhasset_localTx  = _rhasset_localTx.fixedflag ?  ((void)(0), rhasset_localTx) : 0;
        }

        /* Use different calibration apodization for 3D TOF 
           in the head transmit position (MRIhc20285) */
        if( ((PSD_3D == exist(opimode)) || (PSD_3DM == exist(opimode)))
             && ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq)))
             && isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD) )
        {
            rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(1), rhasset_alt_cal) : 1;
        }
        else
        {
            rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(0), rhasset_alt_cal) : 0;
        }
    }
    else
    {
        rhasset_torso  = _rhasset_torso.fixedflag ?  ((void)(0), rhasset_torso) : 0;
        rhasset_alt_cal  = _rhasset_alt_cal.fixedflag ?  ((void)(0), rhasset_alt_cal) : 0;
    }
/* AssetSetRhVars  inlined from Asset.e */

    /* MUSE This must be done after AssetSetRhVars such that rhasset_torso is set to 1 for Muse regardless of coils*/
/* MuseSetRhVars  inlined from Muse.e */
{
	if (muse_flag)
	{
		rhmuse  = _rhmuse.fixedflag ?  ((void)(muse_flag), rhmuse) : muse_flag;
		rhasset_torso  = _rhasset_torso.fixedflag ? ((void)(0), rhasset_torso) : 0; /*force this to 0 for MUSE in phase 1 promote*/
		rhferme  = _rhferme.fixedflag ?    ((void)(rhferme*exist(opnshots)), rhferme) : rhferme*exist(opnshots); /* HCSDM00466566 */
	}
	else
	{
		rhmuse  = _rhmuse.fixedflag ?  ((void)(0), rhmuse) : 0;
		/*don't force rhasset_torso if muse is off. let Asset.e set it*/
	}
}


    if(mux_flag)
    {
/* ARCrh inlined from ARC.e */

if ((PSD_OFF == exist(opassetscan)) && (PSD_OFF == exist(opassetcal)))
{
    int uid;
    time_t now_epoch = time(NULL);
    struct tm now;
    struct timeval now2;

    if (!(arc_ph_flag || arc_sl_flag))
    {
        /* Turn off ARC recon, if no acceleration */
        rhasset  = _rhasset.fixedflag ?  ((void)(0), rhasset) : 0;
    }

    /* Initialize annotated acceleration factors if no acceleration */
    if (!arc_ph_flag)
    {
        rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0), rhasset_R) : 1.0;
    }

    if (!arc_sl_flag)
    {
        rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(1.0), rhassetsl_R) : 1.0; 
    }      
   
    /* Generate unique ID for this scan for naming kacq files and
       debug files.  Use the current date and time (MMDDHHMMSS).
       Cannot include the year because this is larger than a 
       signed 32-bit integer */

    localtime_r(&now_epoch, &now);
    gettimeofday(&now2, NULL);
    uid = (floor)(now2.tv_usec/1000.0) +
        now.tm_sec      * 1000 +
        now.tm_min      * 100000 +
        now.tm_hour     * 10000000;

    rhkacq_uid  = _rhkacq_uid.fixedflag ?  ((void)(uid), rhkacq_uid) : uid;
}

if (arc_ph_flag || arc_sl_flag) 
{
    /* Enable ARC Recon */
    rhasset  = _rhasset.fixedflag ?  ((void)(ACCEL_ARC), rhasset) : ACCEL_ARC;

    /* zero fill BAM for ARC */
    rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL;

    /* Annotate acceleration factors */
    rhasset_R  = _rhasset_R.fixedflag ?  ((void)(1.0/exist(opaccel_ph_stride)), rhasset_R) : 1.0/exist(opaccel_ph_stride);
    rhassetsl_R  = _rhassetsl_R.fixedflag ?  ((void)(1.0/exist(opaccel_sl_stride)), rhassetsl_R) : 1.0/exist(opaccel_sl_stride);
}

/* ARCrh inlined from ARC.e */
    }
    /* > 1024 im/ser -Venkat
     * rhformat(14th bit) : 0=Normal 1=Multiphase scan
     * rhmphasetype       : 0=Int MPh 1=Seq Mph
     * rhnphases          : No of phases in a multiphase scan
     */
 
    cvmax(rhnphases, avmaxpasses); 

    if ( enable_1024 )
    {
        rhformat  = _rhformat.fixedflag ?  ((void)(RHF_SINGLE_PHASE_INFO), rhformat) : rhformat|RHF_SINGLE_PHASE_INFO;

        if (exist(opacqo) == PSD_OFF) 
        {
            rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(0), rhmphasetype) : 0; /* Interleaved multiphase*/
        }
        else
        {
            rhmphasetype  = _rhmphasetype.fixedflag ?  ((void)(1), rhmphasetype) : 1; /* Sequential multiphase*/
        }

        rhnphases  = _rhnphases.fixedflag ?  ((void)(dwi_fphases), rhnphases) : dwi_fphases; /* No of phases in a multiphase scan*/
    }
    else
    {
        rhformat  = _rhformat.fixedflag ?  ((void)(~RHF_SINGLE_PHASE_INFO), rhformat) : rhformat&~RHF_SINGLE_PHASE_INFO;
        rhnphases  = _rhnphases.fixedflag ?  ((void)(exist(opfphases)), rhnphases) : exist(opfphases);
    }


    /* now set it for fract ky annotation */
    pitfeextra = fract_ky;

    /* *****************************
       Slice Ordering
       *************************** */

    if (use_myscan==1) myscan();

    if (exist(opslquant) == 3 && b0calmode == 1)
        setb0rotmats();

    if (slice_reset == 1) {
        for (off_index=0;off_index<opslquant;off_index++)
            scan_info[off_index].optloc = slice_loc;
    }

    if (scan_offset != 0 )
        for (off_index=0;off_index<opslquant;off_index++)
            scan_info[off_index].optloc += (float)scan_offset;

    if (debug_scan)
        psd_dump_scan_info();

    order_routine  = _order_routine.fixedflag ?  ((void)(seq_type), order_routine) : seq_type;

    /* t1flair_stir */
    if (PSD_ON == t1flair_flag)
    {
        int s;
        if (orderslice(order_routine,opslquant+(dummyslices+ 2*act_edge_slice_enh_flag)*acqs,
                       slquant1, gating) == FAILURE)
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"orderslice");
            return FAILURE;
        }

        t1flair_slice_info_enh[0] = slquant1;
        for (s = 0; s <slquant1; s++)
        {
            t1flair_slice_info_enh[s+1] = data_acq_order[s*acqs].sltime;
        }

        if (orderslice(order_routine,opslquant,
                       (slquant1 - dummyslices- 2*act_edge_slice_enh_flag), 
                       gating) == FAILURE)
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"orderslice");
            return FAILURE;
        }

        t1flair_slice_info_reg[0] = slquant1-dummyslices - 2*act_edge_slice_enh_flag;
        for (s = 0; s <slquant1-dummyslices - 2*act_edge_slice_enh_flag; s++)
        {
            t1flair_slice_info_reg[s+1] = data_acq_order[s*acqs].sltime;
        }

    }
    else if (mux_flag)
    {
        if (orderslice(TYPMULTIBAND, opslquant, slquant1, gating) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "orderslice" );
            return FAILURE;
        }
    }
    else
    {
        if (orderslice(order_routine, opslquant, slquant1, gating) == FAILURE) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "orderslice" );
            return FAILURE;
        }
    }

    /* MRIhc27254, MRIhc27361 slice ordering is interleaved to prevent slice
     * intensity variation */
    if ( exist(opcgate) == PSD_ON )
    {
        int ii, jj, numReps;
        int iRR = 0;         /* index for RR 0,1,2,...*/
        int rr_start = 0;    /* index for the starting slice in each RR 0,1,2,...*/

        if (act_acqs > 1)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG,
                        "Multi Acquisition", STRING_ARG, "Cardiac Triggering" );
            return FAILURE;
        }

        /* n.b. for TYPXRR numAcqs is always 1 */
        numReps = ((0 == (opslquant % slquant1)) ?  opslquant/ slquant1 : opslquant/ slquant1 + 1);
        typncat(data_acq_order, pislice, opslquant, numReps, opimode, oppseq, exist(opflaxall));

        for (ii = 0; ii <= opslquant -1; ii++)
        {
            rsp_info[pislice[ii]].rsptloc    = scan_info[ii].optloc    + scan_info[ii].optloc_shift;
            rsp_info[pislice[ii]].rsprloc    = scan_info[ii].oprloc    + scan_info[ii].oprloc_shift;
            rsp_info[pislice[ii]].rspphasoff = scan_info[ii].opphasoff + scan_info[ii].opphasoff_shift;

            for (jj = 0; jj <= 8; jj++) 
            {
                rsprot[pislice[ii]][jj] = hostToRspRotMat(scan_info[ii].oprot[jj]);
            }

            rsptrigger[ii] = TRIG_INTERN; /* initialize the trigger as internal */

            if (opslquant <= ophrep) 
            {
                rsptrigger[ii] = gating;
            }
            else 
            {
                if (ii == rr_start)
                {
                    iRR += 1;
                    if (iRR <= (opslquant % ophrep))
                    {
                        rsptrigger[ii] = gating;
                        rr_start += (int)(opslquant/ophrep) + 1;
                    }
                    if (iRR > (opslquant % ophrep))
                    {
                        rsptrigger[ii] = gating;
                        rr_start += (int)(opslquant/ophrep);
                    }
                }
            }
        }
    }

    if(mux_flag)
    {
        if(scan_info[2].optloc - scan_info[1].optloc > 0)
        {
            rhmb_slice_order_sign  = _rhmb_slice_order_sign.fixedflag ?  ((void)(1), rhmb_slice_order_sign) : 1;
        }
        else
        {
            rhmb_slice_order_sign  = _rhmb_slice_order_sign.fixedflag ?  ((void)(-1), rhmb_slice_order_sign) : -1;
        }
    }

    /* Value1.5T May 2005 KK */
    if(ghost_check&&gck_offset_fov)
       rsp_info[0].rspphasoff = get_act_phase_fov()/ 4.0;

    /* set slice order for multi phase (seq,intl)	*/
    if ( order_routine == TYPNCAT && opfphases > 1 && opdiffuse == PSD_OFF && tensor_flag == PSD_OFF) {


        acq_off = reps*slquant1;

        if (acqmode == 0)  /* interleaved */
        {
            
            /*Venkat > 1024 im/ser */
            /* do nothing ! */
        } /* end if interleaved */

        else if (acqmode == 1)  /* sequential */
        {
            for (i=0; i<acqs; i++)  /* slices loop */
            {
                /*Venkat > 1024 im/ser */
                for (j=0; j<1; j++)
                {
                    sloff = i*reps + j;
                    data_acq_order[sloff].slloc = i;

                    /*MRIge59759 -- actual data order is 0,acq/2,1,acq/2+1...
                      i/2 is integer 0,0,1,1,2,2,... i%2 marks the odd acqs
                      and ceil(acqs/2) adds the offset.*/

                    data_acq_order[sloff].slpass = i/2 + ((i%2)*ceil((float)acqs/2.0));
                    data_acq_order[sloff].sltime = j;
                }
            }
        } /* end if sequential */
    }

    /* Load data_acq_order for diffusion acquisition */
    if ( pass_reps > 1) {
        /* dw-epi, tensor and multiphase(with fphases > 1) interleaved epi-flair enter here*/
        /* Should not enter "if" for Tensor and multiphase epi-(flair)-Venkat*/
        if( (! enable_1024) )
        {
            for (j = 1; j < pass_reps; j++) {
                for (i = 0; i < opslquant*opphases; i++) {
                    sloff = i + j*opslquant*opphases;
                    data_acq_order[sloff].slloc = data_acq_order[i].slloc;
                    data_acq_order[sloff].slpass = data_acq_order[i].slpass + j*act_acqs;
                    data_acq_order[sloff].sltime = data_acq_order[i].sltime;
                }
            }
        }
    } /* if order_routine==TYPMPMP && pass_reps>1 */

    if (debug_order) {
        int max_ims = 0;

        /*
            1024 im/ser -Venkat
         */
        if( enable_1024 )
            max_ims = opslquant*opphases*reps;
        else
            max_ims = opslquant*dwi_fphases*opphases*reps;

        printf("\nslloc\tslpass\tsltime\t\n");
        for (i = 0; i < max_ims; i++) {
            printf("%d\t%d\t%d\n",data_acq_order[i].slloc,
                   data_acq_order[i].slpass,
                   data_acq_order[i].sltime);
        }
    }

    /* t1flair_stir */
    /* Predownload section for t1flair */
    if (T1flairPredownload() == FAILURE)
    {
        return FAILURE;
    }

    trig_scan  = _trig_scan.fixedflag ?  ((void)(gating), trig_scan) : gating; 

    if (debug_scan)
        psd_dump_rsp_info();

    /* rsprot code */
    for (i=0; i<opslquant*opphases; i++){
        if (obl_debug == 1)
            printf("Slice %d\n",i);
        for (j=0; j<9; j++){
            rsprot_unscaled[i][j] = rsprot[i][j];
            if (obl_debug == 1)
                printf("rsprot_unscaled[%d] = %ld\n",j,rsprot_unscaled[i][j]);
        }
    }

    if (scalerotmats(rsprot, &loggrd, &phygrd, (int)(opslquant*opphases), obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD. \nPlease try again or restart the system.",
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* **************************************
       Image Header CVs
       ************************************** */

    /* The routine imgtimutil() rounds down optr to full integer line cycles and
     * subtracts TR_SLOP in the calculation of act_tr. Therefore, act_tr is
     * never greater than optr, except in epi. In epi, act_tr is rounded up
     * to hrdwr_period (=64us) at the call of imgtimutil(). Because of this,
     * act_tr + TR_SLOP could be greater than optr. When this happens (ie, ihtr>optr),
     * we get download failure. In order to avoid this download failure, it is fixed 
     * by replacing:
     ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP :0);
     * with:
     ihtr = act_tr + ((gating==TRIG_LINE) ? TR_SLOP :0);
     if(gating==TRIG_LINE) ihtr = ihtr - hrdwr_period;

     * MRIge34441, ypd */

    if (opcgate == PSD_OFF && oprtcgate == PSD_OFF && mph_flag == PSD_OFF)
    {
        ihtr  = _ihtr.fixedflag ?       ((void)(act_tr+((gating==TRIG_LINE)?TR_SLOP:0)), ihtr) : act_tr+((gating==TRIG_LINE)?TR_SLOP:0);
        if(gating==TRIG_LINE) ihtr  = _ihtr.fixedflag ?    ((void)(ihtr-hrdwr_period), ihtr) : ihtr-hrdwr_period;
        ihtdel1  = _ihtdel1.fixedflag ?  ((void)(MIN_TDEL1), ihtdel1) : MIN_TDEL1;
    }
    else if (mph_flag == PSD_ON && opcgate == PSD_OFF)
    {
        ihtr  = _ihtr.fixedflag ?       ((void)(act_tr+((gating==TRIG_LINE)?TR_SLOP:0)), ihtr) : act_tr+((gating==TRIG_LINE)?TR_SLOP:0);
        if(gating==TRIG_LINE) ihtr  = _ihtr.fixedflag ?    ((void)(ihtr-hrdwr_period), ihtr) : ihtr-hrdwr_period;
        free(ihtdeltab);

        if( enable_1024 )
        {
            ihtdeltab = (int *)malloc(opslquant*sizeof(int));
            exportaddr(ihtdeltab, (int)(opslquant*sizeof(int)));
            for (i=0; i<opslquant; i++)
            {
                /* YMSmr06832 */
                if (acqmode == 0) { /* interleaved */
                    if(epi_flair == PSD_ON){
                        ihtdeltab[i] =
                            (data_acq_order[i].slpass) *
                            (disdaq_shots*dda_fact/(float)passr_shots + nex*reps*core_shots) * act_tr +
                            (disdaq_shots*dda_fact/(float)passr_shots + nex*reps*core_shots-1) * act_tr +
                            ((int)(data_acq_order[i].sltime/false_slquant1))*(act_tr/(float)false_acqs) + exist(opti) +
                            RUP_GRD(avail_se_time/false_slquant1 - time_ssi) *
                            (data_acq_order[i].sltime % false_slquant1 + 1) +
                            (data_acq_order[i].slpass) * pass_delay*num_passdelay;
                    } else {
                        ihtdeltab[i] =
                            (data_acq_order[i].slpass) *
                            (disdaq_shots*dda_fact + nex*reps*core_shots) * act_tr +
                            (disdaq_shots*dda_fact + nex*reps*core_shots-1) * act_tr +
                            (data_acq_order[i].sltime + 1)*(act_tr/(float)slquant1) +
                            (data_acq_order[i].slpass) * pass_delay*num_passdelay;
                    }
                }
                else if (acqmode == 1) { /* sequential */
                    ihtdeltab[i] = 
                        (data_acq_order[i].slpass + 1) * 
                        (disdaq_shots*dda_fact/(float)reps + nex*core_shots) * act_tr +
                        (data_acq_order[i].sltime)*(act_tr/(float)slquant1) +
                        (data_acq_order[i].slpass) * pass_delay*num_passdelay;
                }
            }
        }
        else
        {
            ihtdeltab = (int *)malloc(dwi_fphases*opslquant*sizeof(int));
            exportaddr(ihtdeltab, (int)(dwi_fphases*opslquant*sizeof(int)));
            for (i=0; i<dwi_fphases*opslquant; i++)
            {
                ihtdeltab[i] = data_acq_order[i].slpass*
                    (disdaq_shots + nex*reps*(core_shots)) * act_tr +
                    (disdaq_shots + nex*reps*(core_shots-1)) * act_tr +
                    (data_acq_order[i].sltime+1)*(act_tr/(float)slquant1) +
                    data_acq_order[i].slpass*pass_delay*num_passdelay;
            }
        }

    }    
    else {
        free(ihtdeltab);
        free(ihtrtab);

        if( enable_1024 )
        {
            ihtdeltab = (int *)malloc(opphases*opslquant*sizeof(int));
            exportaddr(ihtdeltab, (int)(opphases*opslquant*sizeof(int)));
            ihtrtab = (int *)malloc(opphases*opslquant*sizeof(int));
            exportaddr(ihtrtab, (int)(opphases*opslquant*sizeof(int)));

            if (opphases > 1) {
                for (i = 0; i < opphases*opslquant; i++) {
                    if (data_acq_order[i].sltime < opslquant) {
                        ihtrtab[i] = act_tr - ((opphases/opslquant) - 1)
                            *opslquant*psd_tseq;
                    } else {
                        ihtrtab[i] = opslquant*psd_tseq;
                    }
                }
                for (i = 0; i < opphases*opslquant; i++) {
                    ihtdeltab[i] = optdel1 + psd_tseq*data_acq_order[i].sltime;
                }
            } else {
                /* Cross R-R */
                int n_per_RR = 0;
                int n_fill = opslquant % ophrep; /* # of filled R-R intervals */
                int ii, iii;
                int tmpslorder[opslquant]; /* temporal slice order */

                /* Calculate array mapping temporal slice order to
                 * spatial slice order */
                for (i = 0; i < opslquant; i++)
                {
                    tmpslorder[pislice[i]]=i;
                }

                iii = 0;
                for (i = 0; i < ophrep; i++)
                {
                    n_per_RR = opslquant/ ophrep;
                    if (n_fill > 0)
                    {
                        /* Number of slices not evenly divisible by number
                         * of R-R intervals.  Increase number per R-R by 1
                         * and pack 1 extra slice into first n_fill R-R's */
                        n_per_RR += 1;
                        n_fill -= 1;
                    }

                    for (ii = 0; ii < n_per_RR; ii++)
                    {
                        /* If there are more R-R's than slices, we do
                         * not acquire data on the extra R-R's at the end */
                        if (iii < opslquant)
                        {
                            ihtdeltab[tmpslorder[iii]] = optdel1 + psd_tseq*ii;
                            ihtrtab[tmpslorder[iii]] = act_tr;
                            iii++;
                        }
                    }
                }

            }
        }
        else
        {
            ihtdeltab = (int *)malloc(opphases*opslquant*dwi_fphases*sizeof(int));
            exportaddr(ihtdeltab, (int)(opphases*opslquant*dwi_fphases*sizeof(int)));
            ihtrtab = (int *)malloc(opphases*opslquant*dwi_fphases*sizeof(int));
            exportaddr(ihtrtab, (int)(opphases*opslquant*dwi_fphases*sizeof(int)));

            if (opphases > 1) {
                for (i = 0; i < opphases*opslquant*dwi_fphases; i++) {
                    if (data_acq_order[i].sltime < opslquant) {
                        ihtrtab[i] = act_tr - ((opphases/opslquant) - 1)
                            *opslquant*psd_tseq;
                    } else {
                        ihtrtab[i] = opslquant*psd_tseq;
                    }
                }
                for (i = 0; i < opphases*opslquant*dwi_fphases; i++) {
                    ihtdeltab[i] = optdel1 + psd_tseq*data_acq_order[i].sltime;
                }
            } else {
                /* Cross R-R */
                int n_per_RR = 0;
                int n_fill = opslquant % ophrep; /* # of filled R-R intervals */
                int ii, iii;
                int tmpslorder[opslquant]; /* temporal slice order */

                /* Calculate array mapping temporal slice order to
                 * spatial slice order */
                for (i = 0; i < opslquant; i++)
                {
                    tmpslorder[pislice[i]]=i;
                }

                iii = 0;
                for (i = 0; i < ophrep; i++)
                {
                    n_per_RR = opslquant/ ophrep;
                    if (n_fill > 0)
                    {
                        /* Number of slices not evenly divisible by number
                         * of R-R intervals.  Increase number per R-R by 1
                         * and pack 1 extra slice into first n_fill R-R's */
                        n_per_RR += 1;
                        n_fill -= 1;
                    }

                    for (ii = 0; ii < n_per_RR; ii++)
                    {
                        /* If there are more R-R's than slices, we do
                         * not acquire data on the extra R-R's at the end */
                        if (iii < opslquant)
                        {
                            ihtdeltab[tmpslorder[iii]] = optdel1 + psd_tseq*ii;
                            ihtrtab[tmpslorder[iii]] = act_tr;
                            iii++;
                        }
                    }
                }
            } 
        }

        if(debug_tdel)
        {
            for(i=0;i< opphases*opslquant; i++)
            {
                printf("ihtrtab[%d] = %d\n",i,ihtrtab[i]);
            }
        }
        fflush(stdout);
    } /* if (opcgate == PSD_OFF) */

    /* RTG or Nav */
    if ((exist(oprtcgate) == PSD_ON) || (navtrig_flag == PSD_ON))
    {
        int ikount, jkount = 0;

        ihtr  = _ihtr.fixedflag ?  ((void)(act_tr), ihtr) : act_tr;
        free(ihtrtab);
        if(exist(oprtcgate) == PSD_ON)
        {
            free(ihtdeltab);
            ihtdeltab = (int *)malloc(opphases*exist(opslquant)*sizeof(int));
            exportaddr(ihtdeltab, (int)(opphases*exist(opslquant)*sizeof(int)));
        }
        ihtrtab = (int *)malloc(opphases*exist(opslquant)*sizeof(int));
        exportaddr(ihtrtab, (int)(opphases*exist(opslquant)*sizeof(int)));

        jkount= 0;
        for (ikount = 0; ikount < exist(opslquant); ikount++) {
            jkount = ikount/oprtrep;
            if(exist(oprtcgate) == PSD_ON)
            {
                ihtdeltab[ikount] = 60000000/oprtrate*oprtpoint + psd_tseq*jkount;
            }
            ihtrtab[ikount] = act_tr;
        }
    } /* end RTG */

    if(debug_tdel && ( mph_flag == PSD_ON ) )
    {
        int max_ims = 0;

        /*
         * 1024 im/ser Venkat
         */
        if( enable_1024 )
            max_ims = opphases*opslquant;
        else
            max_ims = opphases*opslquant*dwi_fphases;
        
        for(i=0;i< max_ims; i++)
        {
            printf("ihtdeltab[%d] = %d\n",i,ihtdeltab[i]);
        }
    }
    fflush(stdout);

    /* set ihmaxtdelphase
     * This is the tdel value for the last acquired slice for the first phase
     * Used in ifcc to calculate the tdel values for the rest of the phases
     * -Venkat
     */ 
    if( enable_1024 )
    {
        /* YMSmr06832 */
        if( epi_flair == PSD_ON ){
            ihmaxtdelphase = acqs * ((disdaq_shots*dda_fact/(float)passr_shots + nex*reps*core_shots) * act_tr + pass_delay*num_passdelay);
        } else {
            ihmaxtdelphase = 0;

            for(i=0;i<opslquant*opphases;i++) 
            { 
                if((ihmaxtdelphase < ihtdeltab[i]) && 
                   (data_acq_order[i].slpass == 0 )){ 
                    ihmaxtdelphase = ihtdeltab[i];
                }
            }

            ihmaxtdelphase = ihmaxtdelphase + opsldelay;
            ihmaxtdelphase = ihmaxtdelphase * acqs;
        }
    }

    if(debug_tdel)
    {
        printf("ihmaxtdelphase = %10d\n",ihmaxtdelphase);
        fflush(stdout);
    }



    ihte1  = _ihte1.fixedflag ?  ((void)(opte), ihte1) : opte;

    /* nex annotation requirements changed at a late date per MRIge24292 */
    ihnex  = _ihnex.fixedflag ?  ((void)(nex), ihnex) : nex;

    ihflip  = _ihflip.fixedflag ?  ((void)(flip_rf1), ihflip) : flip_rf1;
    ihvbw1  = _ihvbw1.fixedflag ?  ((void)((FLOAT)(rint(oprbw))), ihvbw1) : (FLOAT)(rint(oprbw));
    iheesp  = _iheesp.fixedflag ?  ((void)(eesp), iheesp) : eesp;

    /* *********************
       SAT Positioning
    *********************/
    if(SatPlacement(act_acqs) == FAILURE)
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"SatPlacement");
        return FAILURE;
    }
 
    rhnpasses  = _rhnpasses.fixedflag ?  ((void)(act_acqs*pass_reps), rhnpasses) : act_acqs*pass_reps;
    eepf  = _eepf.fixedflag ?  ((void)(0), eepf) : 0;

    /* If phase enc grad is flipped, inform recon */
    if (PSD_ON == pepolar)
    {
        oepf  = _oepf.fixedflag ?  ((void)(1), oepf) : 1;
    }
    else
    {
        oepf  = _oepf.fixedflag ?  ((void)(0), oepf) : 0;
    }
    set_echo_flip(_rhdacqctrl.fixedflag ? (_temp696_rhdacqctrl=rhdacqctrl,&_temp696_rhdacqctrl) : &rhdacqctrl, &chksum_rhdacqctrl, eepf, oepf, eeff, oeff); /* clear bit 1 - flips image in phase dir */

    rhdaxres  = _rhdaxres.fixedflag ?  ((void)(rhfrsize), rhdaxres) : rhfrsize;

    rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(0), rhpcctrl) : 0;
    if ((exist(opdiffuse) == PSD_ON) && (ref_in_scan_flag == PSD_ON))
    {
        rhref  = _rhref.fixedflag ?  ((void)(5), rhref) : 5;
        rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_INTEGRATED_REF), rhpcctrl) : rhpcctrl|RHPCCTRL_INTEGRATED_REF;
    }
    else
    {
        /* Turn on new epi phase correction algorithm */
        /* BJM: 2 = Nearest Neighbor processing */
        rhref  = _rhref.fixedflag ?  ((void)(2), rhref) : 2; /* 0=old algorithm, 1 = new algorithm */
    }

    if(iref_etl > 0)
    {
        if(sndpc_flag == PSD_OFF)
            rhref  = _rhref.fixedflag ?  ((void)(3), rhref) : 3; /* Legacy dynamic phase correction */
        else
            rhref  = _rhref.fixedflag ?  ((void)(4), rhref) : 4; /* Self-navigated dynamic phase correction */
        rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_DYNAMICPC_B0ONLY), rhpcctrl) : rhpcctrl|RHPCCTRL_DYNAMICPC_B0ONLY;
    }

    if(rf_chop == PSD_ON)
    {
        rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_DWI_NEXS_RFCHOPPED), rhpcctrl) : rhpcctrl|RHPCCTRL_DWI_NEXS_RFCHOPPED;
    }

    /*MRIge93538 Turn off the advanced filter for DWI or DTI with PURE
      so that the ADC and EADC calculation will not be affected*/
    rhpurefilter  = _rhpurefilter.fixedflag ?  ((void)(0), rhpurefilter) : 0;

    if(vrgf_reorder == PSD_ON) {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(VRGF_AFTER_PCOR_ALT), rhtype1) : rhtype1|VRGF_AFTER_PCOR_ALT;
    } else {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(~VRGF_AFTER_PCOR_ALT), rhtype1) : rhtype1&~VRGF_AFTER_PCOR_ALT;
    }

    rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1BAM0FILL), rhtype1) : rhtype1|RHTYP1BAM0FILL; /* zero fill for smart NEX */
    if(opdiffuse == PSD_ON)
    {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1|RHTYP1DIFFUSIONEPI;
    }
    else
    {
        rhtype1  = _rhtype1.fixedflag ?  ((void)(~RHTYP1DIFFUSIONEPI), rhtype1) : rhtype1&~RHTYP1DIFFUSIONEPI;
    }

    rhileaves  = _rhileaves.fixedflag ?  ((void)(intleaves), rhileaves) : intleaves;
    rhkydir  = _rhkydir.fixedflag ?  ((void)(ky_dir), rhkydir) : ky_dir;
    rhalt  = _rhalt.fixedflag ?  ((void)(ep_alt), rhalt) : ep_alt;

    cvmax(rhreps, avmaxpasses); 

    /*MRIhc09116, YMSmr07202*/
    /* Needed for recon fixes. MRIge35288, MRIge36731. */
    if (exist(opmph)!=PSD_OFF)
        rhreps  = _rhreps.fixedflag ?  ((void)(exist(opfphases)), rhreps) : exist(opfphases);
    else if (rhpcspacial == 0 && opdiffuse == PSD_ON) /*MRIge41682*/
    {
        rhreps  = _rhreps.fixedflag ?              ((void)((ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnumt2+opdifnumdirs*opnumbvals), rhreps) : (ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0)+opdifnumt2+opdifnumdirs*opnumbvals;  /* Refless EPI */
    }
    else
    {
        rhreps  = _rhreps.fixedflag ?  ((void)(reps), rhreps) : reps;
    }

    /* BJM: need to set rhreps to the total number of */
    /* phases (reps) for a tensor scan when rhpcpspacial is */
    /* used */
    if( (rhpcspacial == 0) && (tensor_flag == PSD_ON)) {
        rhreps  = _rhreps.fixedflag ?            ((void)((ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0)+num_tensor+num_B0), rhreps) : (ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0)+num_tensor+num_B0;  /* Refless EPI */
    }

    /* determine region to be used for phase correction: */
    if (get_act_freq_fov() <= 300.0)
        pckeeppct  = _pckeeppct.fixedflag ?  ((void)(100.0), pckeeppct) : 100.0;
    else
        pckeeppct  = _pckeeppct.fixedflag ?     ((void)((300.0/get_act_freq_fov())*100.0), pckeeppct) : (300.0/get_act_freq_fov())*100.0;


    /* MRIge51452 - enable 256zip and annotation. */
    /* MRIge53876 - 256zip for matrix less than 256x256 */
    if ( !strncmp("epi2is",get_psd_name(),6) )
    {
        rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1;  /* enable reduced image size */
    }
    else if ( (opxres<256) && (opyres<256) )
    {
        rhmethod  = _rhmethod.fixedflag ?  ((void)(0), rhmethod) : 0;  /* Always zip to 256 for sr20. HOUP */
    }
    else
    {
        rhmethod  = _rhmethod.fixedflag ?  ((void)(1), rhmethod) : 1;  /* enable reduced image size */
    }

    {
        int power;
        float temp;

        if (rhmethod == 1) {

            if (vrgfsamp == 1) {

                temp = (float)opxres;
                power = 0;

                while (temp > 1) {
                    temp/= 2.0;
                    ++power;
                }

                fft_xsize  = _fft_xsize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_xsize) : (int)pow(2.0,(double)power);

                temp = (float)opyres;
                power = 0;

                while (temp > 1) {
                    temp/= 2.0;
                    ++power;
                }

                fft_ysize  = _fft_ysize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_ysize) : (int)pow(2.0,(double)power);

                image_size  = _image_size.fixedflag ?    ((void)(IMax(2,fft_xsize,fft_ysize)), image_size) : IMax(2,fft_xsize,fft_ysize);
                fft_xsize  = _fft_xsize.fixedflag ?  ((void)(image_size), fft_xsize) : image_size;
                fft_ysize  = _fft_ysize.fixedflag ?  ((void)(image_size), fft_ysize) : image_size;

                rhrcxres  = _rhrcxres.fixedflag ?  ((void)(fft_xsize), rhrcxres) : fft_xsize;
                rhrcyres  = _rhrcyres.fixedflag ?  ((void)(fft_ysize), rhrcyres) : fft_ysize;
                rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;

            } else {   /* non-VRGF */

                temp = (float)rhdaxres;
                power = 0;

                while (temp > 1) {
                    temp/= 2.0;
                    ++power;
                }

                fft_xsize  = _fft_xsize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_xsize) : (int)pow(2.0,(double)power);

                temp = (float)opyres;
                power = 0;

                while (temp > 1) {
                    temp/= 2.0;
                    ++power;
                }

                fft_ysize  = _fft_ysize.fixedflag ?  ((void)((int)pow(2.0,(double)power)), fft_ysize) : (int)pow(2.0,(double)power);

                image_size  = _image_size.fixedflag ?    ((void)(IMax(2,fft_xsize,fft_ysize)), image_size) : IMax(2,fft_xsize,fft_ysize);
                fft_xsize  = _fft_xsize.fixedflag ?  ((void)(image_size), fft_xsize) : image_size;
                fft_ysize  = _fft_ysize.fixedflag ?  ((void)(image_size), fft_ysize) : image_size;

                rhrcxres  = _rhrcxres.fixedflag ?  ((void)(fft_xsize), rhrcxres) : fft_xsize;
                rhrcyres  = _rhrcyres.fixedflag ?  ((void)(fft_ysize), rhrcyres) : fft_ysize;
                rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
            }	

        } else {   /* rhmethod == 0 Image = 256x256  or 512x512 */

            if(opxres<=256)fft_xsize = _fft_xsize.fixedflag ? ((void)(256), fft_xsize) : 256;
            if(opxres>256)fft_xsize = _fft_xsize.fixedflag ? ((void)(512), fft_xsize) : 512;

            if(eg_phaseres<=256)fft_ysize = _fft_ysize.fixedflag ? ((void)(256), fft_ysize) : 256;
            if(eg_phaseres>256)fft_ysize = _fft_ysize.fixedflag ? ((void)(512), fft_ysize) : 512;

            image_size   = _image_size.fixedflag ?  ((void)(IMax(2,fft_xsize,fft_ysize)), image_size) : IMax(2,fft_xsize,fft_ysize);
            fft_xsize  = _fft_xsize.fixedflag ?  ((void)(image_size), fft_xsize) : image_size;
            fft_ysize  = _fft_ysize.fixedflag ?  ((void)(image_size), fft_ysize) : image_size;

            rhrcxres  = _rhrcxres.fixedflag ?  ((void)(image_size), rhrcxres) : image_size;
            rhrcyres  = _rhrcyres.fixedflag ?  ((void)(image_size), rhrcyres) : image_size;
            rhimsize  = _rhimsize.fixedflag ?  ((void)(image_size), rhimsize) : image_size;
        }

    	/* granty edit turns of default interpolation */
    	rhimsize  = _rhimsize.fixedflag ?  ((void)(opxres), rhimsize) : opxres;
    	rhrcxres  = _rhrcxres.fixedflag ?  ((void)(opxres), rhrcxres) : opxres;
    	rhrcyres  = _rhrcyres.fixedflag ?  ((void)(opyres), rhrcyres) : opyres;

        /* number of points to exclude, beginning and end, for phase correction */
        rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?    ((void)((fft_xsize*(100.0-pckeeppct)/100.0)/2.0), rhpcdiscbeg) : (fft_xsize*(100.0-pckeeppct)/100.0)/2.0;
        rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?    ((void)(IMax(2,rhpcdiscbeg,2)), rhpcdiscbeg) : IMax(2,rhpcdiscbeg,2);
        rhpcdiscend  = _rhpcdiscend.fixedflag ?  ((void)(rhpcdiscbeg), rhpcdiscend) : rhpcdiscbeg;

        /* BJM: set discard pts = 0 */
        if(rhref == 2 || rhref == 5)
        {
            rhpcdiscbeg  = _rhpcdiscbeg.fixedflag ?  ((void)(0), rhpcdiscbeg) : 0;
            rhpcdiscend  = _rhpcdiscend.fixedflag ?  ((void)(0), rhpcdiscend) : 0;
        }
    }

    rhpcdiscmid  = _rhpcdiscmid.fixedflag ?  ((void)(0), rhpcdiscmid) : 0;

    /* number of interleaves to acquire for phase correction (ref) */
    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY)
        rhpcileave  = _rhpcileave.fixedflag ?  ((void)(0), rhpcileave) : 0;   /* collect them all */
    else
        rhpcileave  = _rhpcileave.fixedflag ?  ((void)(0), rhpcileave) : 0;   /* collect 1 only and interpolate */

    if (fract_ky == PSD_FRACT_KY)
        cvmax(rhpcbestky, rhnframes+rhhnover+1);
    else
        cvmax(rhpcbestky, rhnframes+1);

    if (exist(oppseq) == PSD_SE) {   /* spin echo - best line coincident
                                        w/ Hahn echo */
        if (fract_ky == PSD_FULL_KY && ky_dir == PSD_TOP_DOWN) {
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(rhnframes+1)/2.0+ky_offset), rhpcbestky) : (float)(rhnframes+1)/2.0+ky_offset;
        } else if (fract_ky == PSD_FULL_KY && ky_dir == PSD_BOTTOM_UP) {
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(rhnframes+1)/2.0-ky_offset), rhpcbestky) : (float)(rhnframes+1)/2.0-ky_offset;
        } else if (fract_ky == PSD_FRACT_KY || ky_dir == PSD_BOTTOM_UP) {
            rhpcbestky  = _rhpcbestky.fixedflag ?    ((void)((float)(2*rhnframes+1)/2.0-ky_offset), rhpcbestky) : (float)(2*rhnframes+1)/2.0-ky_offset;
        } else if (fract_ky == PSD_FULL_KY || ky_dir == PSD_CENTER_OUT) {
            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)((float)(rhnframes+1)/2.0), rhpcbestky) : (float)(rhnframes+1)/2.0;
        }
    } else {                  /* gradient echo - best line is 1st in time */
        if (fract_ky == PSD_FULL_KY && ky_dir == PSD_TOP_DOWN) {
            rhpcbestky  = _rhpcbestky.fixedflag ?         ((void)((1.0+(float)(rhnframes+1)/2.0)/2.0), rhpcbestky) : (1.0+(float)(rhnframes+1)/2.0)/2.0;          
        } else if (fract_ky == PSD_FULL_KY && ky_dir == PSD_BOTTOM_UP) {
            rhpcbestky  = _rhpcbestky.fixedflag ?         ((void)(((float)rhnframes+(float)(rhnframes+1)/2.0)/2.0), rhpcbestky) : ((float)rhnframes+(float)(rhnframes+1)/2.0)/2.0;
        } else if (fract_ky == PSD_FRACT_KY || ky_dir == PSD_BOTTOM_UP) {
            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)(rhnframes), rhpcbestky) : rhnframes;
        } else if (fract_ky == PSD_FULL_KY || ky_dir == PSD_CENTER_OUT) {
            rhpcbestky  = _rhpcbestky.fixedflag ?  ((void)((float)(rhnframes+1)/2.0), rhpcbestky) : (float)(rhnframes+1)/2.0;
        }
    }

    if (fract_ky == PSD_FRACT_KY) {
        switch (ky_dir) {
        case PSD_TOP_DOWN:
            rhhdbestky  = _rhhdbestky.fixedflag ?    ((void)(opyres/2+ky_offset), rhhdbestky) : opyres/2+ky_offset;
            break;
        case PSD_BOTTOM_UP:
            rhhdbestky  = _rhhdbestky.fixedflag ?    ((void)(opyres/2-ky_offset), rhhdbestky) : opyres/2-ky_offset;
            break;
        case PSD_CENTER_OUT:
        default:
            rhhdbestky  = _rhhdbestky.fixedflag ?  ((void)(0), rhhdbestky) : 0;
            break;
        }
    }

    cvrefindex1  = _cvrefindex1.fixedflag ?  ((void)(opnshots), cvrefindex1) : opnshots;

    /* Value1.5T May 2005 KK */
    if(ghost_check == 1) {
      rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
      rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
    }
    else if(ghost_check == 2){
      rhpccon  = _rhpccon.fixedflag ?  ((void)(1), rhpccon) : 1;
      rhpclin  = _rhpclin.fixedflag ?  ((void)(1), rhpclin) : 1;
    }

    /* update for addition of external gradient waveforms for qti - granty */
    ia_gxdl  = _ia_gxdl.fixedflag ?  ((void)(a_gxdl*MAX_PG_IAMP), ia_gxdl) : a_gxdl*MAX_PG_IAMP;
    ia_gxdr  = _ia_gxdr.fixedflag ?  ((void)(a_gxdr*MAX_PG_IAMP), ia_gxdr) : a_gxdr*MAX_PG_IAMP;
    ia_gydl  = _ia_gydl.fixedflag ?  ((void)(a_gydl*MAX_PG_IAMP), ia_gydl) : a_gydl*MAX_PG_IAMP;
    ia_gydr  = _ia_gydr.fixedflag ?  ((void)(a_gydr*MAX_PG_IAMP), ia_gydr) : a_gydr*MAX_PG_IAMP;
    ia_gzdl  = _ia_gzdl.fixedflag ?  ((void)(a_gzdl*MAX_PG_IAMP), ia_gzdl) : a_gzdl*MAX_PG_IAMP;
    ia_gzdr  = _ia_gzdr.fixedflag ?  ((void)(a_gzdr*MAX_PG_IAMP), ia_gzdr) : a_gzdr*MAX_PG_IAMP;

    /* Coil Selection */
    cvmax(rhpccoil, (INT)((cfrecvend - cfrecvst)+1));
    cvmin(rhpccoil, (INT)(-1));

    {
        INT numcoils = ((cfrecvend - cfrecvst)+1);

        /* BJM: use coil #4 for phase correcion with 8 channel */
        /* head coil */
        /* 11.0 update - use all coils, rhpccoil = 0 */

        if(numcoils > 1)
            rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0; /* (INT)(numcoils)/2.0; */
        else
            rhpccoil  = _rhpccoil.fixedflag ?  ((void)(1), rhpccoil) : 1;

        /* MRIge91081 - disable ref scan per coil for Asset */
        /* asset = 2 for scans, 1 for calibration */
        if(exist(opasset) == 2) { 

            char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
            getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

            if ((cffield == B0_30000) &&
                (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
                 && strstr(attribute_codeMeaning, "Breast")))
            {
                rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0;
            }
            else
            {
                rhpccoil  = _rhpccoil.fixedflag ?  ((void)((INT)(-1)), rhpccoil) : (INT)(-1);
            }
        }
    }

    if (pc_enh == PSD_ON)
    {
        char * coil_name = coilInfo[0].coilName;
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        rhpccoil  = _rhpccoil.fixedflag ?  ((void)(0), rhpccoil) : 0;
        if (1 == intleaves)
        {
            rhpcctrl  = _rhpcctrl.fixedflag ?    ((void)((RHPCCTRL_NN_WEIGHT|RHPCCTRL_CON_ALIGN)), rhpcctrl) : rhpcctrl|(RHPCCTRL_NN_WEIGHT|RHPCCTRL_CON_ALIGN);
        }
        else
        {
			/* Enable phase alignment feature for MUSE */
			if (muse_flag) 
			{
				rhpcctrl  = _rhpcctrl.fixedflag ?    ((void)((RHPCCTRL_NN_WEIGHT|RHPCCTRL_CON_ALIGN)), rhpcctrl) : rhpcctrl|(RHPCCTRL_NN_WEIGHT|RHPCCTRL_CON_ALIGN);	
			}
			else 
            {
                /*The phase alignment feature, RHPCCTRL_CON_ALIGN, does not work with multi-shot EPI*/
                rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_NN_WEIGHT), rhpcctrl) : rhpcctrl|RHPCCTRL_NN_WEIGHT;
            }
        }

        /* Enable PC estimation after view projection for Breast and Neck coils */
        if (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST)
             && strstr(attribute_codeMeaning, "Breast"))
        {
            rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_NN_PROJ), rhpcctrl) : rhpcctrl|RHPCCTRL_NN_PROJ;
        }
        else if ((PSD_VRMW_COIL == cfgcoiltype) &&
                 ((strstr(coil_name, "Spine 18 1") != NULL) ||
                  (strstr(coil_name, "Neck Spine 32") != NULL) ||
                  (strstr(coil_name, "Neck Chest 32 AA") != NULL)))
        {
            rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_NN_PROJ), rhpcctrl) : rhpcctrl|RHPCCTRL_NN_PROJ;
        }

        if(hopc_flag == PSD_ON)
        {
            rhpcctrl  = _rhpcctrl.fixedflag ?  ((void)(RHPCCTRL_NN_POLYFITTING), rhpcctrl) : rhpcctrl|RHPCCTRL_NN_POLYFITTING;
        }
    }

    if (ref_volrecvcoil_flag == PSD_ON)
    {
        rhpccoil  = _rhpccoil.fixedflag ?  ((void)(1), rhpccoil) : 1;
    }

    /* Turn on constant and linear phase correction */
    rhpccon  = _rhpccon.fixedflag ?  ((void)(PSD_ON), rhpccon) : PSD_ON;
    rhpclin  = _rhpclin.fixedflag ?  ((void)(PSD_ON), rhpclin) : PSD_ON;

    /* for single-shot ref scan, minimum fit orders are 1 */
    if ( rhpcileave > 0 ) {
        cvmod(rhpcconorder, 1, 4, 2, "Constant fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
        cvmod(rhpclinorder, 1, 4, 2, "Constant fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
    }
    else {
        cvmod(rhpcconorder, 0, 4, 2, "Linear fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
        cvmod(rhpclinorder, 0, 4, 2, "Linear fit order: 0=vu spcfc;1=Kybest;2=line;3,4=poly",0," ");
    }

    cvmax(rhpcshotfirst, intleaves-1);
    rhpcshotfirst  = _rhpcshotfirst.fixedflag ?  ((void)(0), rhpcshotfirst) : 0;
    cvmin(rhpcshotlast, rhpcshotfirst);
    cvmax(rhpcshotlast, intleaves - 1);
    rhpcshotlast  = _rhpcshotlast.fixedflag ?    ((void)(intleaves-1), rhpcshotlast) : intleaves-1;

    /* set con and lin orders: 0=vu spcfc, 1=kybest, 2=line, 3,4=poly */
    rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(2), rhpcconorder) : 2;
    rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(0), rhpclinorder) : 0;

    /* set con and lin #pts */
    cvmax(rhpcconnpts, 4);
    cvmax(rhpclinnpts, 4);
    rhpcconnpts  = _rhpcconnpts.fixedflag ?  ((void)(4), rhpcconnpts) : 4;
    if (etl > 3) {
        while (rhpcconnpts > etl/2) {
            rhpcconnpts  = _rhpcconnpts.fixedflag ?    ((void)(rhpcconnpts-1), rhpcconnpts) : rhpcconnpts-1;
        }
        cvmax(rhpcconnpts, etl/2);
    } 
    else {
        rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(1), rhpcconorder) : 1;
    }

    if (etl>3) {
        rhpclinnpts  = _rhpclinnpts.fixedflag ?    ((void)(IMin(2,4,etl/2)), rhpclinnpts) : IMin(2,4,etl/2);
        cvmax(rhpclinnpts, etl/2);
    }
    else {
        rhpclinnpts  = _rhpclinnpts.fixedflag ?  ((void)(3), rhpclinnpts) : 3; /* value does not matter */
        rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(0), rhpclinorder) : 0;
    }

    if ( (etl == 1) ) {
        rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
        rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
        rhpcconorder  = _rhpcconorder.fixedflag ?  ((void)(1), rhpcconorder) : 1;
        rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(0), rhpclinorder) : 0;
    }

    /* HCSDM00153103, HCSDM00159442 */
    if (PSD_ON == calc_rate)
    {
        rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
        rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
    }

    /* Refless EPI */
    if ((exist(opdiffuse) == PSD_ON) && (ref_in_scan_flag == PSD_ON))
    {
        rhpclin  = _rhpclin.fixedflag ?  ((void)(0), rhpclin) : 0;
        rhpccon  = _rhpccon.fixedflag ?  ((void)(0), rhpccon) : 0;
    }

    if ((TX_COIL_BODY == getTxCoilType()) && (RX_COIL_LOCAL == getRxCoilType()))
    {
        rhpclinnorm  = _rhpclinnorm.fixedflag ?  ((void)(1), rhpclinnorm) : 1;
        rhpcconnorm  = _rhpcconnorm.fixedflag ?  ((void)(1), rhpcconnorm) : 1;
    }
    else
    {
        rhpclinnorm  = _rhpclinnorm.fixedflag ?  ((void)(0), rhpclinnorm) : 0;
        rhpcconnorm  = _rhpcconnorm.fixedflag ?  ((void)(0), rhpcconnorm) : 0;
    }

    rhpclinfitwt  = _rhpclinfitwt.fixedflag ?  ((void)(0), rhpclinfitwt) : 0;
    cvmax(rhpclinfitwt, 0);
    rhpclinavg  = _rhpclinavg.fixedflag ?  ((void)(0), rhpclinavg) : 0;

    cvmax(rhpcthrespts, 32);

    rhpcconfitwt  = _rhpcconfitwt.fixedflag ?  ((void)(0), rhpcconfitwt) : 0;
    cvmax(rhpcconfitwt, 0);

    final_xres  = _final_xres.fixedflag ?  ((void)(exist(opxres)), final_xres) : exist(opxres);
    rhvrgfxres  = _rhvrgfxres.fixedflag ?  ((void)(final_xres), rhvrgfxres) : final_xres;
    rhvrgf  = _rhvrgf.fixedflag ?  ((void)(vrgfsamp), rhvrgf) : vrgfsamp;

    rhdab0s  = _rhdab0s.fixedflag ?  ((void)(cfrecvst), rhdab0s) : cfrecvst;
    rhdab0e  = _rhdab0e.fixedflag ?  ((void)(cfrecvend), rhdab0e) : cfrecvend;

    if (rawdata == PSD_ON)
        rhrawsize = 2*slquant1*(1+rhbline+rhnframes+rhhnover+iref_frames)*2
            *rhptsize*nex*rhfrsize;
    else
        rhrawsize = (n64)slquant1 * (n64)rhfrsize * (n64)(2*rhptsize)
            * (n64)ceil((float)(1 + rhnframes + rhhnover+iref_frames));

    /* update size variables for DW-EPI */
    rhrawsize *= reps*exist(opphases);
    rhnslices  = _rhnslices.fixedflag ?  ((void)(exist(opslquant)*exist(opphases)*dwi_fphases), rhnslices) : exist(opslquant)*exist(opphases)*dwi_fphases;

    /* BJM - for multi-nex DW-EPI */
    if(opdiffuse == PSD_ON)
    {
       if(nex > 1 && tensor_flag == PSD_OFF)
       {
           rhnecho  = _rhnecho.fixedflag ?  ((void)(nex), rhnecho) : nex;
           pinecho  = _pinecho.fixedflag ?  ((void)(1), pinecho) : 1;
           rhrawsize *= nex;
       }
       else if(tensor_flag == PSD_ON)
       {
           rhnecho  = _rhnecho.fixedflag ?  ((void)(nex), rhnecho) : nex;
           pinecho  = _pinecho.fixedflag ?  ((void)(1), pinecho) : 1;
           rhrawsize *= nex;
       }
    }

    if ((rhdab0e - rhdab0s) == 0) {
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1&~RHTYP1AUTOPASS), rhtype1) : rhtype1&~RHTYP1AUTOPASS;  /* clear automatic scan/pass detection bit */
    }

    /* Tell TARDIS there is a hyperscan dab packet and to use HRECON. */
    if (hsdab > 0)
        rhformat  = _rhformat.fixedflag ?    ((void)(rhformat|64), rhformat) : rhformat|64;

    /* Turn on row-flipping */
    rhformat  = _rhformat.fixedflag ?    ((void)(rhformat|2048), rhformat) : rhformat|2048;

    /* Turn off image compression */
    rhrcctrl  = _rhrcctrl.fixedflag ?    ((void)(RHRCMAG+rawmode*RHRCRAW), rhrcctrl) : RHRCMAG+rawmode*RHRCRAW;
    
    if(rpg_flag > 0)
    {
        /* Other Distortion Correction  options include:  RH_DIST_CORR_RIGID, RH_DIST_OUTPUT_REVERSET2 */
        rhdistcorr_ctrl  = _rhdistcorr_ctrl.fixedflag ?      ((void)(RH_DIST_CORR_B0+(rpg_in_scan_flag?RH_DIST_CORR_RPG:0)+RH_DIST_CORR_AFFINE), rhdistcorr_ctrl) : RH_DIST_CORR_B0+(rpg_in_scan_flag?RH_DIST_CORR_RPG:0)+RH_DIST_CORR_AFFINE;
	/* granty edit force save of reverse polarity B0 images 7/2/2018 */
	rhdistcorr_ctrl  = _rhdistcorr_ctrl.fixedflag ?  ((void)(29), rhdistcorr_ctrl) : 29; 
    }
    else
    {
        rhdistcorr_ctrl  = _rhdistcorr_ctrl.fixedflag ?  ((void)(0), rhdistcorr_ctrl) : 0;
    }
    /* Fill in Image/DICOM Header for Distortion Correction */
    ihdistcorr  = _ihdistcorr.fixedflag ?  ((void)(rhdistcorr_ctrl), ihdistcorr) : rhdistcorr_ctrl;   /* Add to DICOM tag (0043,10B3) */
    ihpepolar  = _ihpepolar.fixedflag ?  ((void)(pepolar), ihpepolar) : pepolar;            /* Updates DICOM tag (0018,9034) */

    /* use zero-filling if CV5 is zero */
    if ( (PSD_OFF == (int)opuser5 ) && (PSD_ON == exist(opdiffuse)) )
    {
        rhtype  = _rhtype.fixedflag ?  ((void)(~RHTYPFRACTNEX), rhtype) : rhtype&~RHTYPFRACTNEX;
    }

    dc_chop  = _dc_chop.fixedflag ?      ((void)((muse_flag)?0:1), dc_chop) : (muse_flag)?0:1; 

    if (dc_chop == 1) {
        rhtype  = _rhtype.fixedflag ?    ((void)(rhtype&~RHTYPCHP), rhtype) : rhtype&~RHTYPCHP;  /* clear chopper bit */
        rhblank  = _rhblank.fixedflag ?  ((void)(blank), rhblank) : blank;
    } else {
        rhtype  = _rhtype.fixedflag ?    ((void)(rhtype|RHTYPCHP), rhtype) : rhtype|RHTYPCHP;   /* set chopper bit */
        rhblank  = _rhblank.fixedflag ?  ((void)(0), rhblank) : 0;
    }

    /* number of points to blank on display */
    if (image_size < 256)
        rhblank  = _rhblank.fixedflag ?  ((void)((4*image_size)/256), rhblank) : (4*image_size)/256;

    /* fermi filter control - different for epi due to vrgf */
    rhfermr  = _rhfermr.fixedflag ?  ((void)(exist(opxres)/2), rhfermr) : exist(opxres)/2;

    if (!strncmp("epi2wwwl",get_psd_name(),8))
    {
        cvoverride(rhnew_wnd_level_flag, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* split predownlaod into two modules so gcc assembler can process */
    if (predownload1()==FAILURE) {
        return FAILURE;
    }
    /* BJM call exact b-value calcs and scaling */
    if ( FAILURE == DTI_Predownload() ) {
        return FAILURE;
    } 

    /* Focus RFOV HCSDM00150820 */
    if ((PSD_ON == opdiffuse) && rfov_flag && rfov_cmplx_avg_flag && (nex > 1))
    {
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1&~RHTYP1IMGNEX), rhtype1) : rhtype1&~RHTYP1IMGNEX;      /* Turn off usual mag image nex */
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1|RHTYP1CMPLXIMGNEX), rhtype1) : rhtype1|RHTYP1CMPLXIMGNEX;  /* Bit mask for Complex Averaging */
    }
    else
    {
        rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1&~RHTYP1CMPLXIMGNEX), rhtype1) : rhtype1&~RHTYP1CMPLXIMGNEX; /* Make sure Complex Averaging is off */
    }

    if((rhtype1 & RHTYP1CMPLXIMGNEX) && (1 == oepf))
    {
        epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG,
                    "Complex Averaging", STRING_ARG, "Phase Encoding Flip" );
        return FAILURE;
    }

    /* Set pulse parameters */
    if ( FAILURE == calcPulseParams(AVERAGE_POWER) )
    {
        return FAILURE;
    }

    /* Set the amps back that are scaled within calcPulseParams function */
    if((PSD_ON == gradHeatMethod) && (PSD_ON == derate_amp)) 
    {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            ia_gxdl  = _ia_gxdl.fixedflag ?     ((void)((int)(a_gxdl*(float)max_pg_iamp/loggrd.tx)), ia_gxdl) : (int)(a_gxdl*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr  = _ia_gxdr.fixedflag ?     ((void)((int)(a_gxdr*(float)max_pg_iamp/loggrd.tx)), ia_gxdr) : (int)(a_gxdr*(float)max_pg_iamp/loggrd.tx);
            
            ia_gydl  = _ia_gydl.fixedflag ?     ((void)((int)(a_gydl*(float)max_pg_iamp/loggrd.ty)), ia_gydl) : (int)(a_gydl*(float)max_pg_iamp/loggrd.ty);
            ia_gydr  = _ia_gydr.fixedflag ?     ((void)((int)(a_gydr*(float)max_pg_iamp/loggrd.ty)), ia_gydr) : (int)(a_gydr*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl  = _ia_gzdl.fixedflag ?     ((void)((int)(a_gzdl*(float)max_pg_iamp/loggrd.tz)), ia_gzdl) : (int)(a_gzdl*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr  = _ia_gzdr.fixedflag ?     ((void)((int)(a_gzdr*(float)max_pg_iamp/loggrd.tz)), ia_gzdr) : (int)(a_gzdr*(float)max_pg_iamp/loggrd.tz);
        } 
        else 
        {
            ia_gxdl1  = _ia_gxdl1.fixedflag ?     ((void)((int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx)), ia_gxdl1) : (int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr1  = _ia_gxdr1.fixedflag ?     ((void)((int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx)), ia_gxdr1) : (int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx);
        
            ia_gxdl2  = _ia_gxdl2.fixedflag ?     ((void)((int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx)), ia_gxdl2) : (int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr2  = _ia_gxdr2.fixedflag ?     ((void)((int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx)), ia_gxdr2) : (int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx);

            ia_gydl1  = _ia_gydl1.fixedflag ?     ((void)((int)(a_gydl1*(float)max_pg_iamp/loggrd.ty)), ia_gydl1) : (int)(a_gydl1*(float)max_pg_iamp/loggrd.ty);
            ia_gydr1  = _ia_gydr1.fixedflag ?     ((void)((int)(a_gydr1*(float)max_pg_iamp/loggrd.ty)), ia_gydr1) : (int)(a_gydr1*(float)max_pg_iamp/loggrd.ty);
            
            ia_gydl2  = _ia_gydl2.fixedflag ?     ((void)((int)(a_gydl2*(float)max_pg_iamp/loggrd.ty)), ia_gydl2) : (int)(a_gydl2*(float)max_pg_iamp/loggrd.ty);
            ia_gydr2  = _ia_gydr2.fixedflag ?     ((void)((int)(a_gydr2*(float)max_pg_iamp/loggrd.ty)), ia_gydr2) : (int)(a_gydr2*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl1  = _ia_gzdl1.fixedflag ?     ((void)((int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz)), ia_gzdl1) : (int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr1  = _ia_gzdr1.fixedflag ?     ((void)((int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz)), ia_gzdr1) : (int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz);
            
            ia_gzdl2  = _ia_gzdl2.fixedflag ?     ((void)((int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz)), ia_gzdl2) : (int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr2  = _ia_gzdr2.fixedflag ?     ((void)((int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz)), ia_gzdr2) : (int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz);  
        }
    }

    /* set up tensor orientations */
    if ( FAILURE == set_tensor_orientations() ){
        return FAILURE;
    }  

    if (ss_fa_scaling_flag)
    {
        override_fatsat_high_weight  = _override_fatsat_high_weight.fixedflag ?  ((void)(PSD_ON), override_fatsat_high_weight) : PSD_ON;
    }
    else
    {
        override_fatsat_high_weight  = _override_fatsat_high_weight.fixedflag ?  ((void)(PSD_OFF), override_fatsat_high_weight) : PSD_OFF;
    }

    if (PSD_OFF == override_fatsat_high_weight)
    {
        if ((opweight > BIG_PATIENT_WEIGHT) && (ss_rf1 == PSD_ON))
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_IMGOPT_PSD1, EE_ARGS(2), STRING_ARG, "SPSP RF (Chem Sat=None/water)", STRING_ARG, "high pat. weight (>160kg) for EPI" ); 
            return FAILURE;
        }
    }

#ifndef SIM
    if(exist(opdiffuse) == PSD_ON && opdifnumt2 == 0 && ADC_warning_flag == PSD_ON)
    {
        int bval_different = PSD_OFF;
        for(i=1; i<opnumbvals; i++)
        {
            if(!floatsAlmostEqualEpsilons(bvalstab[i], bvalstab[0], 2))
            {
                bval_different = PSD_ON;
                break;
            }
        }
        if(bval_different == PSD_OFF)
        {
            epic_warning( "At least two distinctive b-values are needed to create an ADC map");
            ADC_warning_flag  = _ADC_warning_flag.fixedflag ?  ((void)(PSD_OFF), ADC_warning_flag) : PSD_OFF;
        }
    }

    if (bigpat_warning_flag == PSD_ON)
    {
        if (((flip_rf1 < opflip) && (ss_rf1 == PSD_ON)) || 
            ((ir_fa_scaling_flag == PSD_ON) && (ir_on == PSD_ON) && (flip_rf0 < 180.0)))
        {
            epic_warning( "Image quality may be degraded due to reduced flip angles at high patient weights" );
            bigpat_warning_flag  = _bigpat_warning_flag.fixedflag ?  ((void)(PSD_OFF), bigpat_warning_flag) : PSD_OFF;
        }
    }

    /*multiband band gap warning*/
    if (mux_band_gap_warning_flag == PSD_ON)
    {
        if(mux_flag && (mux_slice_shift_mm_rf1<30)){
            epic_warning( "Image quality may be degraded if HyperBand spacing less than 30mm for certain coils. Please consider to increase slice thickness, spacing or number of slices." );
        }
        mux_band_gap_warning_flag  = _mux_band_gap_warning_flag.fixedflag ?  ((void)(PSD_OFF), mux_band_gap_warning_flag) : PSD_OFF;
    }

#endif

    for (i=0; i<opnumbvals; i++)
    {
        difnextab_rsp[i] = (int)difnextab[i];
    }

    if (opdfax3in1 > PSD_OFF || opdfaxtetra > PSD_OFF || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
    {
         invertCrusherXY  = _invertCrusherXY.fixedflag ?  ((void)(PSD_ON), invertCrusherXY) : PSD_ON; 
         invertSliceSelectZ2  = _invertSliceSelectZ2.fixedflag ?  ((void)(PSD_OFF), invertSliceSelectZ2) : PSD_OFF;
    }
    else
    {
         invertCrusherXY  = _invertCrusherXY.fixedflag ?  ((void)(PSD_OFF), invertCrusherXY) : PSD_OFF; 
         invertSliceSelectZ2  = _invertSliceSelectZ2.fixedflag ?  ((void)(PSD_ON), invertSliceSelectZ2) : PSD_ON;
    }

    if ((1 == global_shim_method) && oppscvquant)
    {
        pidoshim = PSD_CONTROL_PSC_SPECIAL;
    }

    /*RTB0 correction*/
    if(rtb0_flag)
    {
        rtb0Init();
    }

    if (PSD_ON == t1flair_flag)
    {
        act_slquant1 = slquant1 - dummyslices - 2*act_edge_slice_enh_flag;

    }
    else
    {
        act_slquant1 = slquant1;
    }

    for(i=0;i<opslquant; i++)
    {
        int slmod_acqs = opslquant%acqs;
        if((data_acq_order[i].slpass < slmod_acqs) || (slmod_acqs == 0))
        {
            slloc2sltime[data_acq_order[i].slloc] = 
                data_acq_order[i].slpass*act_slquant1+data_acq_order[i].sltime;
            sltime2slloc[data_acq_order[i].slpass*act_slquant1+data_acq_order[i].sltime] = 
                data_acq_order[i].slloc;
        }
        else
        {
            slloc2sltime[data_acq_order[i].slloc] = 
                data_acq_order[i].slpass*(act_slquant1-1)+slmod_acqs+data_acq_order[i].sltime;
            sltime2slloc[data_acq_order[i].slpass*(act_slquant1-1)+slmod_acqs+data_acq_order[i].sltime] = 
                data_acq_order[i].slloc;
        }
    }


    /*RTB0 Correction: convert sltime2slloc to float, such that weighted_polyfit function can take it*/
    if (rtb0_flag){
        intarr2float(f_sltime2slloc, sltime2slloc, opslquant); /*convert from int array to float array*/
    }

    /* scale Flip Angles for non-Multiband here */
    /* PURE Mix */
    if ((PURE2 == exist(oppure)) && pure_mix.enable && (PSD_OFF == mux_flag))
    {
        if (90.0*pure_mix_tx_scale < flip_rf1)
        {
            ia_rf1  = _ia_rf1.fixedflag ?  ((void)((int)(pure_mix_tx_scale*ia_rf1*90.0/flip_rf1)), ia_rf1) : (int)(pure_mix_tx_scale*ia_rf1*90.0/flip_rf1);
        }
        if (PSD_SE == oppseq)
        {
            ia_rf2  = _ia_rf2.fixedflag ?  ((void)((int)(pure_mix_tx_scale*ia_rf2)), ia_rf2) : (int)(pure_mix_tx_scale*ia_rf2);
        }
    }
    /* HCSDM00129469: Shading has been observed at the center of brain due to overtipping.
       The software mitigation is to reduce the flip angles of rf1 and rf2 equivalent to TG
       reduced by #counts of TGenh (default as 5.5, HCSDM00168896) */
    else if (TGenh < 0)
    {
        ia_rf1  = _ia_rf1.fixedflag ?   ((void)((int)(ia_rf1*pow(10.0,(double)(TGenh/200.0)))), ia_rf1) : (int)(ia_rf1*pow(10.0,(double)(TGenh/200.0)));
        if(PSD_SE == oppseq)
        {
            ia_rf2  = _ia_rf2.fixedflag ?   ((void)((int)(ia_rf2*pow(10.0,(double)(TGenh/200.0)))), ia_rf2) : (int)(ia_rf2*pow(10.0,(double)(TGenh/200.0)));
        }
    }

    /* Multiband */
    if(mux_flag)
    {
        rhmb_factor  = _rhmb_factor.fixedflag ?  ((void)(exist(opaccel_mb_stride)), rhmb_factor) : exist(opaccel_mb_stride);
        if (use_slice_fov_shift_blips)
        {
            if ( ((INT)exist(opaccel_mb_stride) * (INT)exist(opaccel_ph_stride)%slice_fov_shift) && (PSD_ON == mux_flag))
            {
                epic_error(use_ermes, "%s is incompatible with %s", EM_PSD_INCOMPATIBLE,
                           EE_ARGS(2), STRING_ARG, "Slice FOV Shift Factor",STRING_ARG, "HyperBand Factor");
                return FAILURE;
            }
            rhmb_slice_fov_shift_factor  = _rhmb_slice_fov_shift_factor.fixedflag ?  ((void)(slice_fov_shift), rhmb_slice_fov_shift_factor) : slice_fov_shift;
        }
        else{
            rhmb_slice_fov_shift_factor  = _rhmb_slice_fov_shift_factor.fixedflag ?  ((void)(1), rhmb_slice_fov_shift_factor) : 1;
        }
    }
    else
    {
        rhmb_factor  = _rhmb_factor.fixedflag ?  ((void)(1), rhmb_factor) : 1;
        rhmb_slice_fov_shift_factor  = _rhmb_slice_fov_shift_factor.fixedflag ?  ((void)(1), rhmb_slice_fov_shift_factor) : 1;
    }

    { /* Start of code inlined from loadrheader.e rheaderpredownload */

        /* set flags for channel compression and optimal recon */

        /* Step 1. check anatomy */
#ifndef SIM
        anatomy_channel_compr_enable = isApplicationAllowedForAnatomy(opanatomy, ATTRIBUTE_VIRTUAL_CHANNEL_RECON);
        anatomy_optimal_recon_enable = isApplicationAllowedForAnatomy(opanatomy, ATTRIBUTE_OPTIMAL_SNR_RECON);
        anatomy_self_uni_corr_enable = isApplicationAllowedForAnatomy(opanatomy, ATTRIBUTE_SELF_SENSITIVITY_UNIFORM_CORRECTION);
#else
        anatomy_channel_compr_enable = PSD_ON;
        anatomy_optimal_recon_enable = PSD_ON;
        anatomy_self_uni_corr_enable = PSD_ON;
#endif

        /* Step 2. check recon application, refer to following files for those conditions:
           /vobs/recon/Orchestra/LiveSupport/Deployment/LxInventory.cpp
           /vobs/recon/Orchestra/LiveSupport/Deployment/LxInventory/[recon app name].cpp::LxIsMatch() */

        /* Step 2-1. Check PSD Application corresponding to Recon Application. */
        if ( (rhpropellerCtrl > 0) ||
             ( ((int)rhuser0 == rhdaxres) && ((int)rhuser1 > 0) && ((int)rhuser2 > 0) && ((int)rhuser3 == 1) && ((int)rhuser4 == rhnframes) ) )
        {
            /* PROPELLER */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhtype1 & RHTYPSPIRAL)
        {
            /* Realtime Spiral, Spiral */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhtype1 & RHTYPECTRICKS)
        {
            /* TRICKS */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhviewSharing3D > 0)
        {
            /* DISCO */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhrc3dcinectrl & CINE3D_ACQ)
        {
            /* 3D CINE */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhtype & RHTYPCINE) || (rhfcinemode & FCINE_ON) || (rhfcinemode & FCINE_OLD) )
        {
            /* CINE, Fast Card */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhformat & RHF_SPECTRO)
        {
            /* Spectro Single Voxel */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhformat & RHF_PSIR_CORRECTION) && (rhformat & RHF_CSI) )
        {
            /* Spectro MCSI */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhformat & RHF_CSI) && (rhrcctrl > 0) )
        {
            /* Spectro Multi Voxel */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhexecctrl & RHXC_REF_SCAN) || (rhutctrl & 2) )
        {
            /* EPI Reference Scan */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( ( (rhasset == ASSET_CAL) || (rhasset == ASSET_REG_CAL) ) || (rhpure == 1) )
        {
            /* 3D Calibration, 2D Calibration */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhtype1 & RHTYP1DIFFUSIONEPI)
        {
            /* Diffusion EPI */
            apps_channel_compr_enable = PSD_OFF; /* It will be activated on MR27 */
        }
        else if ( (rhformat & RHF_HS) &&
                  !( (rhexecctrl & RHXC_RTD_XFER_IM_REMOTE) || (rhexecctrl & RHXC_RTD_SCAN) ) &&
                  !( (rhreps > 1) || (rhmb_factor > 1) ) )
        {
            /* EPI */
            apps_channel_compr_enable = PSD_OFF; /* It will be activated on MR27 */
        }
        else if ( (rhformat & RHF_HS) && (rhexecctrl & RHXC_RTD_SCAN) && !(rhexecctrl & RHXC_RTD_XFER_IM_REMOTE) )
        {
            /* EPI Realtime */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhformat & RHF_HS) && (rhexecctrl & RHXC_RTD_XFER_IM_REMOTE) )
        {
            /* functional MRI */
            apps_channel_compr_enable = PSD_OFF; /* It will be activated on MR27 */
        }
        else if ( (rhformat & RHF_HS) && ( (rhreps > 1) || (rhmb_factor > 1) ) && !(rhtype1 & RHTYP1DIFFUSIONEPI) )
        {
            /* EPI Multi Phase */
            apps_channel_compr_enable = PSD_OFF; /* It will be activated on MR27 */
        }
        else if ( (rhexecctrl & RHXC_RTD_SCAN) && !(rhtype1 & RHTYP1RCALLPASS) && (rhmedal_mode & 2) )
        {
            /* Flex FTMRA */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhexecctrl & RHXC_RTD_SCAN) && !(rhtype1 & RHTYP1RCALLPASS) && (rhtype & RHTYP3D) )
        {
            /* FTMRA */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if ( (rhexecctrl & RHXC_RTD_SCAN) && !(rhtype1 & RHTYPSPIRAL) && !(rhformat & RHF_HS) )
        {
            /* Realtime 2D */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhmedal_mode & 2)
        {
            /* Flex */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhrcmavric_control > 0)
        {
            /* MAVRIC */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhtype1 & RHTYP1RADIAL3D)
        {
            /* 3D Radial */
            apps_channel_compr_enable = PSD_OFF;
        }
        else if (rhtype & RHTYP3D)
        {
            /* Cartesian 3D */
            apps_channel_compr_enable = PSD_ON;
        }
        else
        {
            /* Cartesian 2D */
            apps_channel_compr_enable = PSD_ON;
        }

        /* Step 2-2. Check self-sensitivity uniformity correction compatibility */
        if (rhrcideal & IDEAL_ON_OFF_FLAG)
        {
            /* IDEAL: No recon implementation */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if ( (rhvtype & VASCULAR) || (rhvtype & PHASE_CON) )
        {
            /* Phase Contrast: No recon implementation */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if (rhrc_cardt1map_ctrl & 1)
        {
            /* Cardiac T1 Map: No recon implementation */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if ( (rhfiesta == RHFIESTA_RMS_AVE) && (rhrcctrl & RHRCPHS) && (rhchannel_combine_filter_type != RHCHANNEL_COMBINE_FILTER_TYPE_NONE) )
        {
            /* Swan Phase Image: No recon implementation */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if (rhfiesta > 0)
        {
            /* Echo Combine for Multi echo: Uniformity correction should be common sensitivity map among each echo */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if ( (exist(opmph) > 0) || (exist(opdynaplan) > 0) || (exist(opdisco) > 0) )
        {
            /* Multi Phase, Dynaplan, DISCO: Uniformity correction should use common sensitivity map among each phase */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else if ( (rhtype & RHTYPFRACTECHO) || (rhtype & RHTYPFRACTNEX) )
        {
            /* Homodyne: Current self-uniformity correction does not support Homodyne processing. 
               Once recon supports, this handling should be removed. */
            apps_self_uni_corr_enable = PSD_OFF;
        }
        else
        {
            apps_self_uni_corr_enable = PSD_ON;
        }

        /* Step 2-3. Check channel-synthesized uniformity correction compatibility */
        if ( rhtype1 & RHTYP13DGRADWARP )
        {
            /* 3D Gradwarp: Channel-synthesized uniformity correction doesn't support 3D Gradwarp currently.
               Once recon supports, this handling should be removed. */
            apps_channel_compr_enable = PSD_OFF;
            apps_self_uni_corr_enable = PSD_OFF;
        }

        /* Step 3-1. set PSD internal CVs */
        if ( apps_channel_compr_enable &&
             ( (cfVirtualChannelRecon && anatomy_channel_compr_enable) ||
             ( (cfOptimalSnrRecon && anatomy_optimal_recon_enable) ) ) )
        {
            if (cfVirtualChannelRecon && anatomy_channel_compr_enable && (coilInfo[0].pureCompatible > 0))
            {
                if (cfOptimalSnrRecon && anatomy_optimal_recon_enable)
                {
                    channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_ON), channel_compression) : PSD_ON;
                    optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_ON), optimal_channel_combine) : PSD_ON;
                    enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_ON), enforce_cal_for_channel_combine) : PSD_ON;
                }
                else
                {
                    channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_ON), channel_compression) : PSD_ON;
                    optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_OFF), optimal_channel_combine) : PSD_OFF;
                    enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_ON), enforce_cal_for_channel_combine) : PSD_ON;
                }
            }
            else /* Channel Compression is disabled, Optimal Recon is enabled */
            {
                if (anatomy_self_uni_corr_enable && (opasset == 0))
                {
                    if (apps_self_uni_corr_enable)
                    {
                        channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
                        optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_ON), optimal_channel_combine) : PSD_ON;
                        enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_OFF), enforce_cal_for_channel_combine) : PSD_OFF;
                    }
                    else /* Auto cal should not run for optimal recon in Spine */
                    {
                        channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
                        optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_OFF), optimal_channel_combine) : PSD_OFF;
                        enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_OFF), enforce_cal_for_channel_combine) : PSD_OFF;
                    }
                }
                else
                {
                    /* After IQ issue is resolved, optimal recon will be enabled with external cal */
                    channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
                    optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_OFF), optimal_channel_combine) : PSD_OFF;         /* will be PSD_ON */
                    enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_OFF), enforce_cal_for_channel_combine) : PSD_OFF; /* will be PSD_ON */
                }
            }
        }
        else
        {
            channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
            optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_OFF), optimal_channel_combine) : PSD_OFF;
            enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_OFF), enforce_cal_for_channel_combine) : PSD_OFF;
        }

        /* Step 3-2. overwrite PSD internal CVs */
        if (rhchannel_combine_method == RHCCM_ASSET_COMBINE_NO_TWMENPO)
        {
            channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
            optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_ON), optimal_channel_combine) : PSD_ON;
            enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_ON), enforce_cal_for_channel_combine) : PSD_ON;
        }
        else if (rhchannel_combine_method == RHCCM_eC3_RECON_FOR_MAG_PHASE_I_Q_IMAGES)
        {
            /* eC3 recon: optimal recon can't support eC3 because annefact signal appears on many virtual
               channel images after optimal channel transformation. Refer to TDR (DOC1930652) in detail.
               Once recon supports, this handling should be removed. */
            channel_compression  = _channel_compression.fixedflag ?  ((void)(PSD_OFF), channel_compression) : PSD_OFF;
            optimal_channel_combine  = _optimal_channel_combine.fixedflag ?  ((void)(PSD_OFF), optimal_channel_combine) : PSD_OFF;
            enforce_cal_for_channel_combine  = _enforce_cal_for_channel_combine.fixedflag ?  ((void)(PSD_OFF), enforce_cal_for_channel_combine) : PSD_OFF;
        }

        /* Step 4. set rhCVs for Channel Compression and Optimal Recon */
        if (channel_compression)
        {
            rhvircpolicy  = _rhvircpolicy.fixedflag ?  ((void)(RHVIRCPOLICY_RECON_AUTO), rhvircpolicy) : RHVIRCPOLICY_RECON_AUTO;
        }
        else
        {
            rhvircpolicy  = _rhvircpolicy.fixedflag ?  ((void)(RHVIRCPOLICY_DISABLE), rhvircpolicy) : RHVIRCPOLICY_DISABLE;
        }

        if (optimal_channel_combine)
        {
            rhsnrnoise  = _rhsnrnoise.fixedflag ?  ((void)(RHSNRNOISE_OPTIMAL_PRESCAN), rhsnrnoise) : RHSNRNOISE_OPTIMAL_PRESCAN;
        }
        else
        {
            rhsnrnoise  = _rhsnrnoise.fixedflag ?  ((void)(RHSNRNOISE_BALANCED_PRESCAN), rhsnrnoise) : RHSNRNOISE_BALANCED_PRESCAN;
        }

        if (channel_compression)
        {
            rhvircoilunif  = _rhvircoilunif.fixedflag ?  ((void)(RHVIRCOILUNIF_CALSCAN), rhvircoilunif) : RHVIRCOILUNIF_CALSCAN;
        }
        else if (optimal_channel_combine)
        {
            if (enforce_cal_for_channel_combine)
            {
                rhvircoilunif  = _rhvircoilunif.fixedflag ?  ((void)(RHVIRCOILUNIF_CALSCAN), rhvircoilunif) : RHVIRCOILUNIF_CALSCAN;
            }
            else
            {
                rhvircoilunif  = _rhvircoilunif.fixedflag ?  ((void)(RHVIRCOILUNIF_SELF_SENSITIVITY), rhvircoilunif) : RHVIRCOILUNIF_SELF_SENSITIVITY;
            }
        }
        else
        {
            rhvircoilunif  = _rhvircoilunif.fixedflag ?  ((void)(RHVIRCOILUNIF_NONE), rhvircoilunif) : RHVIRCOILUNIF_NONE;
        }

        /* Step 5. set opcalrequired */
        if (enforce_cal_for_channel_combine || SCENIC_TYPE_PURE_ITKN4 == rhscenic_type)
        {
            cvoverride(opcalrequired, PSD_ON, PSD_FIX_ON, PSD_EXIST_ON);
            override_opcalrequired  = _override_opcalrequired.fixedflag ?  ((void)(PSD_ON), override_opcalrequired) : PSD_ON;
        }
        else if (override_opcalrequired == PSD_OFF)
        {
            cvoverride(opcalrequired, PSD_OFF, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            /* set opcalrequired in each PSD when overridde_opcalrequired = PSD_ON */
        }

        if (dump_channel_comp_optimal_recon)
        {
            FILE *fp;
            fp = fopen("/usr/g/service/log/dump_channel_comp_optimal_recon.log","a");
            if (NULL != fp)
            {
                fprintf(fp, "\n*** Flags for Channel Compression and Optimal Recon ***\n");
                fprintf(fp, "config: cfVirtualChannelRecon=%d, cfOptimalSnrRecon=%d\n",
                        cfVirtualChannelRecon, cfOptimalSnrRecon);
                fprintf(fp, "anatomy: channel_compr_enable=%d, optimal_recon_enable=%d, self_uni_corr_enable=%d\n",
                        anatomy_channel_compr_enable, anatomy_optimal_recon_enable, anatomy_self_uni_corr_enable);
                fprintf(fp, "apps: channel_compr_enable=%d, self_uni_corr_enable=%d\n",
                        apps_channel_compr_enable, apps_self_uni_corr_enable);
                fprintf(fp, "internal flag: channel_compression=%d, optimal_channel_combine=%d, enforce_cal_for_channel_combine=%d\n",
                        channel_compression, optimal_channel_combine, enforce_cal_for_channel_combine);
                fprintf(fp, "rhCVs: rhvircpolicy=%d, rhsnrnoise=%d, rhvircoilunif=%d\n",
                        rhvircpolicy, rhsnrnoise, rhvircoilunif);
                fprintf(fp, "opcalrequired=%d\n",
                        opcalrequired);
                fclose(fp);
            }
        }

        if (PSD_ON == dump_scenic_parameters)
        {
            FILE *fp;
            fp = fopen("/usr/g/service/log/scenic_filter_parameters.log","a");
            if (NULL != fp)
            {
                fprintf(fp, "\n\n*** Flags for ITKN4 and SCIC ***\n");
                fprintf(fp, "cfscenic = %d, rhscenic_type = %d, piscenic = %d, opscenic = %d \n",
                        cfscenic, rhscenic_type, piscenic, opscenic);
                fprintf(fp, "piscic   = %d, opscic        = %d, pipure   = %d, oppure   = %d, rhpure   = %d \n",
                        piscic, opscic, pipure, oppure, rhpure);

                fprintf(fp, "\n*** Parameters for ITKN4 ***\n");
                fprintf(fp, "cfn4_allowed = %d \n", cfn4_allowed);
                fprintf(fp, "cfn4_slice_down_sample_rate   = %f    ", cfn4_slice_down_sample_rate);
                fprintf(fp, "rhn4_slice_down_sample_rate   = %f \n", rhn4_slice_down_sample_rate);
                fprintf(fp, "cfn4_inplane_down_sample_rate = %f    ", cfn4_inplane_down_sample_rate );
                fprintf(fp, "rhn4_inplane_down_sample_rate = %f \n", rhn4_inplane_down_sample_rate );
                fprintf(fp, "cfn4_num_levels_max     = %d                 ", cfn4_num_levels_max);
                fprintf(fp, "rhn4_num_levels_max     = %d \n", rhn4_num_levels_max);
                fprintf(fp, "cfn4_num_iterations_max = %d                 ", cfn4_num_iterations_max);
                fprintf(fp, "rhn4_num_iterations_max = %d \n", rhn4_num_iterations_max);
                fprintf(fp, "cfn4_convergence_threshold = %f       ", cfn4_convergence_threshold);
                fprintf(fp, "rhn4_convergence_threshold = %f \n", rhn4_convergence_threshold);
                fprintf(fp, "cfn4_gain_clamp_mode  = %d                   ", cfn4_gain_clamp_mode);
                fprintf(fp, "rhn4_gain_clamp_mode  = %d \n", rhn4_gain_clamp_mode);
                fprintf(fp, "cfn4_gain_clamp_value = %f            ", cfn4_gain_clamp_value);
                fprintf(fp, "rhn4_gain_clamp_value = %f \n", rhn4_gain_clamp_value);

                fprintf(fp, "\n*** Parameters for SCIC ***\n");
                fprintf(fp, "cfscic_allowed        = %d          ", cfscic_allowed );
                fprintf(fp, "rh_ime_scic_enable    = %d \n", rh_ime_scic_enable );
                fprintf(fp, "cfscic_edge           = %f   ", cfscic_edge);
                fprintf(fp, "rh_ime_scic_edge      = %f \n", rh_ime_scic_edge);
                fprintf(fp, "cfscic_smooth         = %f   ", cfscic_smooth);
                fprintf(fp, "rh_ime_scic_smooth    = %f \n", rh_ime_scic_smooth);
                fprintf(fp, "cfscic_focus          = %f   ", cfscic_focus);
                fprintf(fp, "rh_ime_scic_focus     = %f \n", rh_ime_scic_focus);
                fprintf(fp, "cfscic_reduction      = %f  ", cfscic_reduction);
                fprintf(fp, "rh_ime_scic_reduction = %f \n", rh_ime_scic_reduction);
                fprintf(fp, "cfscic_gauss          = %f   ", cfscic_gauss);
                fprintf(fp, "rh_ime_scic_gauss     = %f \n", rh_ime_scic_gauss);
                fprintf(fp, "cfscic_threshold      = %f   ", cfscic_threshold);
                fprintf(fp, "rh_ime_scic_threshold = %f \n", rh_ime_scic_threshold);
                fprintf(fp, "cfscic_contrast       = %f   ", cfscic_contrast);
                fprintf(fp, "rh_ime_scic_contrast  = %f \n", rh_ime_scic_contrast);
                fprintf(fp, "\n");
                fclose(fp);
            }
        }
    } /* End of code inlined from loadrheader.e rheaderpredownload */


    /* Call acoustic model */
    enable_acoustic_model  = _enable_acoustic_model.fixedflag ?  ((void)(isAcousticDataAvailable()), enable_acoustic_model) : isAcousticDataAvailable();
    if( enable_acoustic_model && (PSD_OFF == oploadprotocol) )
    {
        int min_acoustic;// Temporary variable, not used in any calculation
        enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(1), enforce_minseqseg) : 1;
        seqEntryIndex  = _seqEntryIndex.fixedflag ?  ((void)(idx_seqcore), seqEntryIndex) : idx_seqcore;
        acoustic_seq_repeat_time  = _acoustic_seq_repeat_time.fixedflag ?  ((void)((int)(act_tr/((mux_flag)?mux_slquant:slquant1))), acoustic_seq_repeat_time) : (int)(act_tr/((mux_flag)?mux_slquant:slquant1));

        if( FAILURE == minseq(&min_acoustic, gradx, GX_FREE, grady, GY_FREE, gradz, GZ_FREE, &loggrd, seqEntryIndex,
                    tsamp,act_tr, use_ermes, seg_debug) )
        {
            epic_error(use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE,
                    EE_ARGS(1), STRING_ARG, "minseq for acoustic");
            enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(0), enforce_minseqseg) : 0;
            enable_acoustic_model  = _enable_acoustic_model.fixedflag ?  ((void)(0), enable_acoustic_model) : 0;
            return FAILURE;
        }
        enforce_minseqseg  = _enforce_minseqseg.fixedflag ?  ((void)(0), enforce_minseqseg) : 0;
        enable_acoustic_model  = _enable_acoustic_model.fixedflag ?  ((void)(0), enable_acoustic_model) : 0;
    }
    /* granty edit save p-files by default */ 
    rhtype1  = _rhtype1.fixedflag ?    ((void)(rhtype1|4096), rhtype1) : rhtype1|4096; 
    autolock  = _autolock.fixedflag ?  ((void)(1), autolock) : 1;
    return SUCCESS;
}   /* end predownload() */

STATUS
predownload1( void )
{
    int i;
    float t_array[7];                     /* timing parametrers for DW-EPI sequence */
    int xfull,yfull,zfull;

    xfull=max_pg_iamp;
    yfull=max_pg_iamp;
    zfull=max_pg_iamp;

    /* Prescan Slice Calc **********************/

    if (prescanslice(_pre_pass.fixedflag ? (_temp697_pre_pass=pre_pass,&_temp697_pre_pass) : &pre_pass, _pre_slice.fixedflag ? (_temp698_pre_slice=pre_slice,&_temp698_pre_slice) : &pre_slice, opslquant) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "prescanslice" );
        return FAILURE;
    }

    aps2_rspslqb  = _aps2_rspslqb.fixedflag ?  ((void)(0), aps2_rspslqb) : 0;
    aps2_rspslq  = _aps2_rspslq.fixedflag ?   ((void)(mux_flag?mux_slquant:slquant1), aps2_rspslq) : mux_flag?mux_slquant:slquant1;

    /* Find the corresponding spacial slice/pass for the prescan/center slice location */
    {
        int savei = 0;

        for (i = 0; i < opphases*opslquant; i++) {
            if (data_acq_order[i].sltime == pre_slice) {
                savei = i;
                i = opphases*opslquant;
            }
        }

        if ( (mph_flag==PSD_ON) && (acqmode==1) ) {  /* multi-phase sequential */
            for (i = 0; i < reps*opphases*opslquant; i++) {
                if (data_acq_order[i].slpass == pre_pass) {
                    savei = i;
                    i = reps*opphases*opslquant;
                }
            }
        }

        slice_num  = _slice_num.fixedflag ?    ((void)(savei+1), slice_num) : savei+1;
    }

    rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(1), rhpctemporal) : 1;         /* use first temporal position */

    if (opdiffuse == PSD_ON && floatsAlmostEqualEpsilons(opuser14, 1.0, 2)) 
    {
        /* Use rhpctemporal = 0 - one ref for each temporal position  - for Diffusion */
        /* Use center slice only for ref scan to cut down on reference scan time */
        rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(0), rhpctemporal) : 0;
        ref_mode  = _ref_mode.fixedflag ?  ((void)(1), ref_mode) : 1;
    }
    else 
    {
        rhpctemporal  = _rhpctemporal.fixedflag ?  ((void)(1), rhpctemporal) : 1;         /* use first temporal position */
        ref_mode  = _ref_mode.fixedflag ?  ((void)(1), ref_mode) : 1;   /* loop to center slice */
    }

    rhpclinorder  = _rhpclinorder.fixedflag ?  ((void)(2), rhpclinorder) : 2; /* lin fit */ 

    /* mph, seq, play 1 rep */
    if ( (mph_flag==PSD_ON) && (acqmode==1) && (rhpctemporal==1) )
        slice_num  = _slice_num.fixedflag ?    ((void)(data_acq_order[slice_num-1].slpass+1), slice_num) : data_acq_order[slice_num-1].slpass+1;

    /* Figure out rhpcpspacial given opuser value.           
     * Spacial phase correction (rhpcspacial) is only 
     * compatible with constant in-plane shift on each slice */
    if (((vol_shift_type & VOL_SHIFT_FREQ_DIR_ALLOWED) || 
         (vol_shift_type & VOL_SHIFT_PHASE_DIR_ALLOWED)) &&
         (vol_shift_constraint_type == VOL_SHIFT_CONSTRAINT_NONE))
    {
        rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(0), rhpcspacial) : 0;
    }
    else if(exist(refSliceNum) != -1 && exist(refSliceNum) > 0) {

        /* Is ref slice in a valid prescription range */
        if(existcv(opslquant) && exist(opslquant) >= exist(refSliceNum)) {
            /* Figure out temporal position of desired ref slice (interleaved order) */
            /* the slice prescribed is in terms of the spatial order.  This converts */
            /* the spatial index to the temporal position in the pass.               */
            /* Note: the must subtract 1 since slice index starts @ 0!               */

            rhpcspacial  = _rhpcspacial.fixedflag ?    ((void)((INT)(data_acq_order[(INT)(exist(refSliceNum)-1)].sltime+1)), rhpcspacial) : (INT)(data_acq_order[(INT)(exist(refSliceNum)-1)].sltime+1);
            pre_slice  = _pre_slice.fixedflag ?     ((void)(rhpcspacial-1), pre_slice) : rhpcspacial-1;
        } else {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "predownload: Error!: Ref Scan Slice Index > number of slices" );
            return FAILURE;
        }

        if( exist(refSliceNum) != -1 && acqs > 1) {
            epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "predownload: Error!: refSliceNum != -1 & acqs > 1 not compatible" );
            return FAILURE;
        }

    } else {
        /* MRIhc19933 */
        /* One ref for all, using prescan slice */
        rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(0), rhpcspacial) : 0;            /* use all slices */

        if ( (mph_flag==PSD_ON) && (acqmode==1) ) /* multi-phase sequential */
        {
            rhpcspacial  = _rhpcspacial.fixedflag ?  ((void)(1), rhpcspacial) : 1;
        }    
    }

    rhpcspacial_dynamic  = _rhpcspacial_dynamic.fixedflag ?  ((void)(rhpcspacial), rhpcspacial_dynamic) : rhpcspacial;

    /* set rhscnframe and rhpasframe */
    if(exist(opdiffuse) != PSD_ON)
    {
        if (acqmode == 0) {   /* interleaved */
            rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(opnex*(rhnframes+rhhnover)+baseline)), rhscnframe) : rhnslices*(opnex*(rhnframes+rhhnover)+baseline);
            rhpasframe  = _rhpasframe.fixedflag ?    ((void)(slquant1*(opnex*(rhnframes+rhhnover)+baseline)), rhpasframe) : slquant1*(opnex*(rhnframes+rhhnover)+baseline);
        } else if (acqmode == 1) {  /* sequential */
            rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(opnex*(rhnframes+rhhnover)+baseline)), rhscnframe) : rhnslices*(opnex*(rhnframes+rhhnover)+baseline);
            rhpasframe  = _rhpasframe.fixedflag ?    ((void)(reps*(opnex*(rhnframes+rhhnover)+baseline)), rhpasframe) : reps*(opnex*(rhnframes+rhhnover)+baseline);
        }
    }
    else
    {
        if (acqmode == 0) {   /* interleaved */
            rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(max_nex*(rhnframes+rhhnover)+baseline)), rhscnframe) : rhnslices*(max_nex*(rhnframes+rhhnover)+baseline);
            rhpasframe  = _rhpasframe.fixedflag ?    ((void)(slquant1*(max_nex*(rhnframes+rhhnover)+baseline)), rhpasframe) : slquant1*(max_nex*(rhnframes+rhhnover)+baseline);
        } else if (acqmode == 1) {  /* sequential */
            rhscnframe  = _rhscnframe.fixedflag ?    ((void)(rhnslices*(max_nex*(rhnframes+rhhnover)+baseline)), rhscnframe) : rhnslices*(max_nex*(rhnframes+rhhnover)+baseline);
            rhpasframe  = _rhpasframe.fixedflag ?    ((void)(reps*(max_nex*(rhnframes+rhhnover)+baseline)), rhpasframe) : reps*(max_nex*(rhnframes+rhhnover)+baseline);
        }
    }
    

    if ( rhpcspacial == 0 ) 
        ref_mode  = _ref_mode.fixedflag ?  ((void)(0), ref_mode) : 0;
    else
        ref_mode  = _ref_mode.fixedflag ?  ((void)(1), ref_mode) : 1; /* loop to the center slice */

    /* Refless EPI */
    if (ref_in_scan_flag == PSD_ON)
    {
        if (ref_mode != 0)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Integrated Reference Scan", STRING_ARG, "ref_mode != 0" );
            return FAILURE;
        }

        if (rhpctemporal != 1)
        {
            epic_error( use_ermes, "%s is incompatible with %s.", EM_PSD_INCOMPATIBLE, EE_ARGS(2), STRING_ARG, "Integrated Reference Scan", STRING_ARG, "rhpctemporal != 1" );
            return FAILURE;
        }
    }
    else
    {
        if (rhref == 5)
        {
            epic_error( use_ermes, "%s is out of range.", EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1), STRING_ARG, "rhref" );
            return FAILURE;
        }
    }

    if (rhpcileave == 0)
        refnframes  = _refnframes.fixedflag ?  ((void)(rhnframes), refnframes) : rhnframes;
    else
        refnframes  = _refnframes.fixedflag ?  ((void)(rhnframes/intleaves), refnframes) : rhnframes/intleaves;

    /* set rhrefframes and rhrefframep */
    if (ref_mode == 0) {  /* excite all slices in ref scan */
        if (acqmode == 0) {   /* interleaved */
            if (rhpctemporal == 0)
                rhrefframes  = _rhrefframes.fixedflag ?  ((void)(rhnslices*(refnframes+rhhnover+baseline)), rhrefframes) : rhnslices*(refnframes+rhhnover+baseline);
            else
                rhrefframes  = _rhrefframes.fixedflag ?  ((void)((rhnslices/reps)*(refnframes+rhhnover+baseline)), rhrefframes) : (rhnslices/reps)*(refnframes+rhhnover+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(slquant1*((refnframes+rhhnover)+baseline)), rhrefframep) : slquant1*((refnframes+rhhnover)+baseline);
        } else if (acqmode == 1) {  /* sequential */
            if (rhpctemporal == 0)
                rhrefframes  = _rhrefframes.fixedflag ?    ((void)(rhnslices*((refnframes+rhhnover)+baseline)), rhrefframes) : rhnslices*((refnframes+rhhnover)+baseline);
            else
                rhrefframes  = _rhrefframes.fixedflag ?    ((void)((rhnslices/reps)*((refnframes+rhhnover)+baseline)), rhrefframes) : (rhnslices/reps)*((refnframes+rhhnover)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(reps*((refnframes+rhhnover)+baseline)), rhrefframep) : reps*((refnframes+rhhnover)+baseline);
        }
    }
    else if (ref_mode == 1) {  /* loop to center slice in ref scan */
        if (acqmode == 0) {   /* interleaved */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)((pre_slice+1)*((refnframes+rhhnover)+baseline)), rhrefframes) : (pre_slice+1)*((refnframes+rhhnover)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)((pre_slice+1)*((refnframes+rhhnover)+baseline)), rhrefframep) : (pre_slice+1)*((refnframes+rhhnover)+baseline);
        } else if (acqmode == 1) {  /* sequential */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)((pre_pass+1)*((refnframes+rhhnover)+baseline)), rhrefframes) : (pre_pass+1)*((refnframes+rhhnover)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(reps*((refnframes+rhhnover)+baseline)), rhrefframep) : reps*((refnframes+rhhnover)+baseline);
        }
    }
    else if (ref_mode == 2) {  /* excite center slice only in ref scan */
        if (acqmode == 0) {   /* interleaved */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)(reps*((refnframes+rhhnover)+baseline)), rhrefframes) : reps*((refnframes+rhhnover)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?    ((void)(reps*((refnframes+rhhnover)+baseline)), rhrefframep) : reps*((refnframes+rhhnover)+baseline);
        } else if (acqmode == 1) {  /* sequential */
            rhrefframes  = _rhrefframes.fixedflag ?    ((void)(((refnframes+rhhnover)+baseline)), rhrefframes) : ((refnframes+rhhnover)+baseline);
            rhrefframep  = _rhrefframep.fixedflag ?   ((void)(((refnframes+rhhnover)+baseline)), rhrefframep) : ((refnframes+rhhnover)+baseline);
        }
    }
    else {
        epic_error( use_ermes, "invalid ref_mode value, use 0, 1, or 2.", EM_PSD_REF_MODE_ERROR, EE_ARGS(0) );
        return FAILURE;
    }

    /* *******************************
       Entry Point Table Evaluation
       ******************************* */

    if (entrytabinit(entry_point_table, (int)ENTRY_POINT_MAX) == FAILURE)
        return FAILURE;

    /* Scan entry point */
    strcpy(entry_point_table[L_SCAN].epname, "scan");

    /* Set xmtadd according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtadd is too big. 
       Add in coilatten, too. */
    xmtaddScan  = _xmtaddScan.fixedflag ?    ((void)(-200*log10(maxB1[L_SCAN]/maxB1Seq)+getCoilAtten()), xmtaddScan) : -200*log10(maxB1[L_SCAN]/maxB1Seq)+getCoilAtten(); 
    
    if (xmtaddScan > cfdbmax) {
        extraScale  = _extraScale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddScan)/200.0)), extraScale) : (float)pow(10.0,(cfdbmax-xmtaddScan)/200.0);
        xmtaddScan  = _xmtaddScan.fixedflag ?  ((void)(cfdbmax), xmtaddScan) : cfdbmax;
    } else {
        extraScale  = _extraScale.fixedflag ?  ((void)(1.0), extraScale) : 1.0;
    }

    if (setScale(L_SCAN, RF_FREE, rfpulse, maxB1[L_SCAN], 
                 extraScale) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setScale" );
        return FAILURE;
    }

    entry_point_table[L_SCAN].epxmtadd = (short) rint((double)xmtaddScan);

    if (cs_sat == PSD_ON)
        rfpulse[RFCSSAT_SLOT].num = 1;

    /* MRIge75651 */
    if (powermon(&entry_point_table[L_SCAN], L_SCAN, (int)RF_FREE,
                         rfpulse, (int)(act_tr/((mux_flag)?mux_slquant:slquant1))) == FAILURE)
        return FAILURE;

    /*multiband*/
    if (FAILURE == Monitor_Predownload( rfpulse, entry_point_table, (int)RF_FREE, (int)(act_tr/((mux_flag)?mux_slquant:slquant1)),
                                        _monave_sar.fixedflag ? (_temp699_monave_sar=monave_sar,&_temp699_monave_sar) : &monave_sar, _moncave_sar.fixedflag ? (_temp700_moncave_sar=moncave_sar,&_temp700_moncave_sar) : &moncave_sar, _monpeak_sar.fixedflag ? (_temp701_monpeak_sar=monpeak_sar,&_temp701_monpeak_sar) : &monpeak_sar ))
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "Monitor_Predownload");
        return FAILURE;
    }

    entry_point_table[L_SCAN].epfilter = (unsigned char)echo1_filt.fslot;
    entry_point_table[L_SCAN].epprexres = rhfrsize;
    entry_point_table[L_SCAN].epstartrec = rhdab0s;
    entry_point_table[L_SCAN].ependrec = rhdab0e;
    entry_point_table[L_SCAN].epfastrec = fast_rec;

    /* Now copy into APS2, MPS2, REF */
    entry_point_table[L_APS2] = entry_point_table[L_MPS2] =
        entry_point_table[L_REF] = entry_point_table[L_SCAN];

    strcpy(entry_point_table[L_MPS2].epname, "mps2");
    strcpy(entry_point_table[L_APS2].epname, "aps2");
    strcpy(entry_point_table[L_REF].epname, "ref");


    /* Calculate per unit (1 G/cm), per axis contribution to delta gradient and frequency
       and set HOEC rh- and ih- CVs */
{
    int i, j;

    /* HCSDM00190686: Disallow the case when DSE and HOECC are both off under clinical 
       mode with Tensor, if FOCUS is not selected. Note that we need to repeat this 
       check in predownload to make sure the impact on various workflow can be fully 
       captured */
    if ((tensor_flag == PSD_ON) && (hoecc_flag == PSD_OFF) && (dualspinecho_flag == PSD_OFF) 
        && (rfov_flag == PSD_OFF) && (opresearch == PSD_OFF)) /* add the last condition to make the simulator work, daiep */
    {
        epic_error(use_ermes, 
                   "For the current prescription, either Dual Spin Echo or Real Time Field Adjustment needs to be turned on.", 
                   EM_PSD_HOECC_DSE_BOTH_OFF, EE_ARGS(0));
        
        return FAILURE;
    }

    /* Some initialization */
    for (i=0; i<HOEC_MAX_DIFFGRADAMP_SIZE; i++)
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
        {
            rhdiffusion_grad_amp[i][j] = 0.0;
        }

    for (i=0; i<HOEC_MAX_NUM_BASES; i++)
    {
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
        {
            rhhoec_bases.hoec_coef[i][j] = 0.0;
        }
        rhhoec_bases.hoec_xorder[i] = hoec_cal_info.termIndex2xyzOrderMapping[0][i];
        rhhoec_bases.hoec_yorder[i] = hoec_cal_info.termIndex2xyzOrderMapping[1][i];
        rhhoec_bases.hoec_zorder[i] = hoec_cal_info.termIndex2xyzOrderMapping[2][i];
    }

    if (fract_ky == PSD_FULL_KY)
    {
        necho_before_te  = _necho_before_te.fixedflag ?  ((void)((int)(etl/2)), necho_before_te) : (int)(etl/2);
    }
    else
    {
        necho_before_te  = _necho_before_te.fixedflag ?      ((void)((muse_flag)?num_overscan/intleaves:num_overscan), necho_before_te) : (muse_flag)?num_overscan/intleaves:num_overscan;
    }

    if (hoecc_flag == PSD_ON && psd_per_echo_corr == 1)  /* determine which echo to plot result */
    {
        if (psd_debug_echo_index == -1)  /* echo index for k-space center */
        {
            psd_echo_for_debug  = _psd_echo_for_debug.fixedflag ?  ((void)(necho_before_te-1), psd_echo_for_debug) : necho_before_te-1;  /* -1 is because we start with index 0 */
        }
        else if (psd_debug_echo_index == -2)  /* last echo */
        {
            psd_echo_for_debug  = _psd_echo_for_debug.fixedflag ?    ((void)(tot_etl-1), psd_echo_for_debug) : tot_etl-1;
        }
        else if (psd_debug_echo_index>=0 && psd_debug_echo_index<=tot_etl-1)  /* nth echo */
        {
            psd_echo_for_debug  = _psd_echo_for_debug.fixedflag ?  ((void)(psd_debug_echo_index), psd_echo_for_debug) : psd_debug_echo_index;
        }
        else
        {
            psd_echo_for_debug  = _psd_echo_for_debug.fixedflag ?  ((void)(necho_before_te-1), psd_echo_for_debug) : necho_before_te-1;  /* default to the k-space center echo */
        }
    }
    else
    {
        psd_echo_for_debug  = _psd_echo_for_debug.fixedflag ?  ((void)(0), psd_echo_for_debug) : 0;
    }

    /* Set DWI timing array, which is used later for HOEC (or linear EC in epi2.e) calculation
       Meanings of the timing array (all units are us):
       t_array[0]: ramp time of DW gradient
       t_array[1]: flat-top time of the DW gradient
       t_array[2]: interval between the end of the first gradient lobe and the begining
                   of the 2nd gradient lobe
       t_array[3]: interval between the very begining of the first DW gradient pulse and the
                   center of the 180 degree pulse
       t_array[4]: interval between the end of the 2nd DW gradient pulse and the begining of
                   the read-out starting point
       t_array[5]: interval between the begining of the read-out and the time where the center
                   of the k-space data is acquired
       t_array[6]: interleave shift for opnshots > 1
    */

    t_array[0]=pw_gxdla;
    t_array[1]=pw_gxdl;
    t_array[2]=pw_wgxdl+pw_gzrf2l1a+pw_gzrf2l1+pw_gzrf2l1d+pw_gzrf2+
               pw_gzrf2r1a+pw_gzrf2r1+pw_gzrf2r1d+pw_wgxdr;
    t_array[3]=pw_gxdla+pw_gxdl+pw_gxdld+pw_wgxdl+pw_gzrf2l1a+pw_gzrf2l1+
               pw_gzrf2l1d+pw_gzrf2/2.0;
    t_array[4]=(opte/2)-(necho_before_te*esp+pw_gzrf2/2+pw_gzrf2r1a+pw_gzrf2r1+
               pw_gzrf2r1d+pw_wgxdr+pw_gxdra+pw_gxdr+pw_gxdrd); /* removed a pw_wgxdr from the original code */
    t4_tmp = _t4_tmp.fixedflag ? ((void)(t_array[4]), t4_tmp) : t_array[4];
    if (t_array[4]<0) t_array[4]=0.0;
    t_array[5]=necho_before_te*esp;  /* change num_overscan to necho_before_te to cover the full ky case */
    t_array[6] = delt * tfon;  /* this will affect t_array[4] as the interleaves shift */
    /* Calculate HOEC impact on gradient and frequency */
    if (hoecc_flag != PSD_OFF)
    {
        CalcPsdReconHoecCorr(hoecc_psd_flag, hoecc_recon_flag, psd_per_echo_corr,
                            (mux_flag?mux_slquant:opslquant), rsprot_unscaled, t_array, esp, necho_before_te, tot_etl, intleaves);

        /* set rh-CVs */
        rhhoecc  = _rhhoecc.fixedflag ?  ((void)(hoecc_recon_flag), rhhoecc) : hoecc_recon_flag; /* HOCE correction flag for recon */
        rhhoec_fit_order  = _rhhoec_fit_order.fixedflag ?  ((void)(hoec_cal_info.fit_order), rhhoec_fit_order) : hoec_cal_info.fit_order; /* fit order of HOEC */
    }
    else
    {
        /* set rh-CVs */
        rhhoecc  = _rhhoecc.fixedflag ?  ((void)(PSD_OFF), rhhoecc) : PSD_OFF;
        rhhoec_fit_order  = _rhhoec_fit_order.fixedflag ?  ((void)(0), rhhoec_fit_order) : 0;
    }

    if (muse_flag == PSD_OFF)
	{
    	rhesp  = _rhesp.fixedflag ?  ((void)(esp), rhesp) : esp; /* echo spacing */
	} 
	else 
	{
		rhesp  = _rhesp.fixedflag ?  ((void)(eesp), rhesp) : eesp; /* effective echo spacing accounts for interleaving */
	}
}
 
/* Functions that calculate per unit, per axis contribution to delta grad and freq */

    /* Compute offsets due to linear EC */
    if((opdiffuse==PSD_ON) && (dwicntrl==1) && (hoecc_flag==PSD_OFF))  /* do not use linear correction if HOECC is on */
    {
        dwicorrcal(dwigcor, dwibcor, dwikcor, dwicntrl, dwidebug, rsprot_unscaled, xfull, yfull, zfull, t_array);  /* Note: t_array is set in HoecCalcCorrectionPredownload */
    }

    /* Prescan echos.  Collect 2 frames for MPS2.  Frames 1 & 2 are */
    /* subtracted and added together and each result is displayed in */
    /* the prescan windows */
    etot  = _etot.fixedflag ?  ((void)(2), etot) : 2;  

    if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FRACT_KY) {
        emid  = _emid.fixedflag ?    ((void)(num_overscan/intleaves-1), emid) : num_overscan/intleaves-1;
        emid  = _emid.fixedflag ?  ((void)(ky_offset/intleaves), emid) : emid+ky_offset/intleaves;
    } else if (ky_dir == PSD_CENTER_OUT && fract_ky == PSD_FULL_KY) {
        emid  = _emid.fixedflag ?  ((void)(0), emid) : 0;
    } else if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
               fract_ky == PSD_FULL_KY) {
        emid  = _emid.fixedflag ?  ((void)((etl-1)/2), emid) : (etl-1)/2;
        emid  = _emid.fixedflag ?  ((void)(ky_offset/intleaves), emid) : emid+ky_offset/intleaves;
    }
    else if ((ky_dir==PSD_TOP_DOWN || ky_dir==PSD_BOTTOM_UP) &&
             fract_ky == PSD_FRACT_KY) {
        emid  = _emid.fixedflag ?    ((void)(num_overscan/intleaves-1), emid) : num_overscan/intleaves-1;
        emid  = _emid.fixedflag ?  ((void)(ky_offset/intleaves), emid) : emid+ky_offset/intleaves;
    }
    else{
        emid  = _emid.fixedflag ?  ((void)(0), emid) : 0;
    }

    /* First echo in train to send to MPS2 */
    if (exist(oppseq) == PSD_SE) {
        /* spin echo epi */
        e1st  = _e1st.fixedflag ?     ((void)(emid-etot/2), e1st) : emid-etot/2;
    } else if (exist(oppseq) == PSD_GE) {
        /* gradient echo epi */
        e1st  = _e1st.fixedflag ?  ((void)(0), e1st) : 0;
    } else {
        /* default */
        e1st  = _e1st.fixedflag ?  ((void)(0), e1st) : 0;
    }

    /* check for negative values */
    emid  = _emid.fixedflag ?        ((void)(((emid<0)?0:emid)), emid) : ((emid<0)?0:emid);
    e1st  = _e1st.fixedflag ?        ((void)(((e1st<0)?0:e1st)), e1st) : ((e1st<0)?0:e1st);

    entry_point_table[L_MPS2].epprexres = rhfrsize;
    entry_point_table[L_APS2].epprexres = rhfrsize;

    if (debug_scan) {
        psd_dump_scan_info();
        psd_dump_rsp_info();
    } 

    /* *****************************
       Auto Prescan Init

       Inform Auto Prescan about
       prescan parameters.
       *************************** */

    pitr = prescan1_tr; /* first pass prescan TR */
    pichop = 0; /* no chop for APS */
    picalmode = 0;
    pislquant = etot*slquant1;  /*Number of slices in 2nd pass prescan*/ 

    /* Must be called before first setfilter() call in predownload */
    initfilter();

    if (setfilter( &echo1_filt, SCAN) == FAILURE) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "setfilter" );
        return FAILURE;
    } 


if (smartprep_flag || navigator_flag)
{
    /* FOR MERGE */
    setfilter(echo1mon_filt, SCAN);
    filter_echo1mon  = _filter_echo1mon.fixedflag ?  ((void)(echo1mon_filt->fslot), filter_echo1mon) : echo1mon_filt->fslot;
}


    /* set CV for EP_TRAIN macro */
    scanslot  = _scanslot.fixedflag ?  ((void)(echo1_filt.fslot), scanslot) : echo1_filt.fslot;

    /*RTB0 correction*/
    /*MF B0 correction*/
    if(rtb0_flag)
    {
        filter_rtb0echo  = _filter_rtb0echo.fixedflag ?  ((void)(scanslot), filter_rtb0echo) : scanslot;
    }


{ /* Start of code inlined from Prescan.e PSfilter */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                            PSfilter                               *
     *                                                                   *
     * Write here the code unique to the Host PSD process.               *
     *********************************************************************/
    /* PS filter must be called with no arguments. num_filter_slot 
       is a CV which comes from individual PSDs, which get incremented 
       in the PSD so that Prescan filter generation takes place for 
       the next slot in psd_filter_spec. - RJF 13/Oct/1998 */
    /* vmx 10/13/94 YI */
    PSfilter();
    /* end vmx */

    if(psddebugcode)
    {
        dump_runtime_filter_info(psd_filt_spec);
    }
} /* End of code inlined from Prescan.e PSfilter */

  
    rhfast_rec  = _rhfast_rec.fixedflag ?  ((void)(0), rhfast_rec) : 0;
    frtime  = _frtime.fixedflag ?  ((void)((float)((rhfrsize-1)*tsp)), frtime) : (float)((rhfrsize-1)*tsp);
    
    /* Open /usr/g/bin/vrgf.param and write out the VRGF parameters
       If auto mode, request that scan call the vrgf program */

    piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(0), piforkvrgf) : 0;
    if (vrgfsamp == PSD_ON) {
        if (genVRGF(&gradout,
                    (int)exist(opxres),
                    tsp,
                    a_gxw,
                    (float)(pw_gxwl + pw_gxw/2)/1.0e6,
                    (float)(pw_gxwad)/1.0e6,
                    2.0/(epiloggrd.xbeta + 1.0),
                    epiloggrd.xbeta) == FAILURE)
            return FAILURE;

        if (autovrgf == PSD_ON)
            piforkvrgf  = _piforkvrgf.fixedflag ?  ((void)(1), piforkvrgf) : 1;
    }
    
    /* Turn on/off bandpass asymmetry correction */
    if(PSDDVMR != psd_board_type) 
    { 
	if(((rhdab0e - rhdab0s + 1) > number_of_bc_files) || (value_system_flag)) 
	{
	   rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(0), rhbp_corr) : 0;  /* turn it off if the number of BC files */
        /* does not match the number of active receivers */
    	} 
	else 
    	{    
           rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(1), rhbp_corr) : 1;   /* else turn it on */
    	}
    }
    else
    {
	rhbp_corr  = _rhbp_corr.fixedflag ?  ((void)(0), rhbp_corr) : 0; /* MRIhc24730 : Bandpass asymmetry correction will */
                     /* not be applied for DVMR receive chain hardware*/
    } 

    /* Local Scope */
    {
        float delta_freq;  /* delta frequency (Hz) */
        float full_bw;     /* full bandwidth  (Hz) */
        float read_offset; /* readout offset (Hz) */

        full_bw = 1.0/(tsp*1.0e-6);
        delta_freq = full_bw/(float)rhfrsize;

        /*	read_offset = a_gxw * GAM * scan_info[0].oprloc / 10.0; */
        read_offset = 0.0;
        rhrecv_freq_s  = _rhrecv_freq_s.fixedflag ?      ((void)(-((float)rhfrsize*delta_freq/2.0+read_offset)+0.5), rhrecv_freq_s) : -((float)rhfrsize*delta_freq/2.0+read_offset)+0.5;
        rhrecv_freq_e  = _rhrecv_freq_e.fixedflag ?    ((void)((float)((rhfrsize-1)/2)*delta_freq+read_offset), rhrecv_freq_e) : (float)((rhfrsize-1)/2)*delta_freq+read_offset;
    }

    if (vrgfsamp == PSD_ON) {
        dacq_adjust  = _dacq_adjust.fixedflag ?     
                    ((void)((float)pw_gxw/2.0+(float)(pw_gxwad)-(float)(pw_gyba+pw_gyb+pw_gybd)/2.0-tsp*((float)rhfrsize-1.0)/2.0), dacq_adjust) : (float)pw_gxw/2.0+(float)(pw_gxwad)-(float)(pw_gyba+pw_gyb+pw_gybd)/2.0-tsp*((float)rhfrsize-1.0)/2.0;
    } else {
        dacq_adjust  = _dacq_adjust.fixedflag ?      ((void)((float)pw_gxw/2.0-tsp*((float)rhfrsize-1.0)/2.0), dacq_adjust) : (float)pw_gxw/2.0-tsp*((float)rhfrsize-1.0)/2.0;
    }

    /* protect against negative adjustment */
    dacq_adjust  = _dacq_adjust.fixedflag ?        ((void)(((dacq_adjust<0)?0:dacq_adjust)), dacq_adjust) : ((dacq_adjust<0)?0:dacq_adjust);

    /* Check for spacial spectral pulse offset error at end of
       predownload, so that the scan_info file will be properly set */
    if (ssCheck() ==FAILURE) return FAILURE;

#ifndef SIM
    /* compute interpolated time delays for phase-encode blip correction method */
    if ( FAILURE == blipcorrdel(_bc_delx.fixedflag ? (_temp702_bc_delx=bc_delx,&_temp702_bc_delx) : &bc_delx, _bc_dely.fixedflag ? (_temp703_bc_dely=bc_dely,&_temp703_bc_dely) : &bc_dely, _bc_delz.fixedflag ? (_temp704_bc_delz=bc_delz,&_temp704_bc_delz) : &bc_delz, esp,
                                getTxCoilType(), debug_oblcorr) ) {
        epic_error( use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "blipcorrdel" );
        return FAILURE;
    }
#endif

    /* Use volRec coil for Reference Scan */
    if ((ref_in_scan_flag == PSD_OFF) && (ref_volrecvcoil_flag == PSD_ON))
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_REF], 0);
    }

    return SUCCESS;
}    /* end predownload1() */

/*
 *  calcPulseParams
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    This function sets pulse widths and instruction amplitudes needed
 *    for pulse generation.
 */
STATUS
#ifdef __STDC__ 
calcPulseParams( int encode_mode )
#else /* !__STDC__ */
    calcPulseParams() 
#endif /* __STDC__ */
{
    /* Obl 3in1 opt */
    float log_incdifx_scaled = 0;
    float log_incdify_scaled = 0;
    float log_incdifz_scaled = 0;

    /* Include EPIC-generated code */
#include "predownload.in"

    /* MRIge59113 */
    { /* Start of code inlined from Inversion_new.e InversionPredownload */

        if(exist(opflair))
            irslquant  = _irslquant.fixedflag ?  ((void)(false_slquant1), irslquant) : false_slquant1;
        else
            irslquant  = _irslquant.fixedflag ?  ((void)(1), irslquant) : 1;

        if(PSD_ON == exist(opspecir))
        {
            ihti  = _ihti.fixedflag ?  ((void)(exist(opti)), ihti) : exist(opti);
            setexist(ihti, PSD_ON);
        }
        else if (ir_on == PSD_ON)
        {
            if (!opflair)
                ihti  = _ihti.fixedflag ?  ((void)(opti), ihti) : opti;
            setexist(ihti,PSD_ON);

            if ( existcv(opti) && (exist(opti) > 1500000) )
                prescan1_tr  = _prescan1_tr.fixedflag ?    ((void)(opti+500000), prescan1_tr) : opti+500000;
            else
                prescan1_tr  = _prescan1_tr.fixedflag ?  ((void)(2000000), prescan1_tr) : 2000000; 

            ia_rf0  = _ia_rf0.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF0_SLOT].amp)), ia_rf0) : max_pg_iamp*(*rfpulse[RF0_SLOT].amp);
            pw_omegarf0 = _pw_omegarf0.fixedflag ? ((void)(pw_rf0), pw_omegarf0) : pw_rf0;
            ia_omegarf0 = _ia_omegarf0.fixedflag ? ((void)(-max_pg_iamp), ia_omegarf0) : -max_pg_iamp;
            rf0_phase  = _rf0_phase.fixedflag ?  ((void)(0.25), rf0_phase) : 0.25;
        }
        else
        {
            setexist(ihti,PSD_OFF);
        }
        rf0_phase  = _rf0_phase.fixedflag ?  ((void)(0.25), rf0_phase) : 0.25;
    } /* End of code inlined from Inversion_new.e InversionPredownload */

{ /* Start of code inlined from Prescan.e PSpredownload */
    /*********************************************************************
     *                     PRESCAN.E HOST SECTION                        *
     *                         PSpredownload                             *
     *                                                                   *
     * Write here the code unique to the Host PSD process. All code to   *
     * be executed in predownload() must be written here.                *
     *********************************************************************/
    if (FAILURE==PSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==FTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==XTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ASpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==RSpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==DTGpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==AutoCoilpredownload())
    {
        return FAILURE;
    }
    if (FAILURE==ExtCalpredownload())
    {
        return FAILURE;
    }

} /* End of code inlined from Prescan.e PSpredownload */


     FILE *fp_grad = NULL;

    /*****************************
      Timing for SCAN entrypoint
    ****************************/
  
    /*************************************************************************
      pos_start marks the position of the start of the attack ramp of
      the gradient for the excitation pulse.  If Sat or other prep pulses
      are played before excitation, then the pos_start marker is incremented
      accordingly to account for the prep time.
      
      Because the rf unblank must be played at least -rfupa us prior to
      the excitation pulse, pos_start must allow enough space for this
      unblank if the attack of the ramp is not long enough.  Rather than
      arbitrarily making the attack pulse longer, the start position is
      adjusted and the attack ramp is optimized.
      
      Note also that rfupa is a negative number, so it is negated in
      the following calculation to make it a positive number.
    ************************************************************************/
    pos_start  = _pos_start.fixedflag ?    ((void)(RUP_GRD((int)tlead+GRAD_UPDATE_TIME)), pos_start) : RUP_GRD((int)tlead+GRAD_UPDATE_TIME);
    if ((pos_start + pw_gzrf1a) < -rfupa) {
        pos_start  = _pos_start.fixedflag ?      ((void)(RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME))), pos_start) : RUP_GRD((int)(-rfupa-pw_gzrf1a+GRAD_UPDATE_TIME));
    }

    /*
      Ordering of pulse is for non cardiac:
      spatial sat, chemsat, 90 (180) readout and killer.

      For cardiac:
      90 (180) readout, spatial sat, chemsat, and killer
    */
    sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(0), sp_satcard_loc) : 0;

    if ( (existcv(opcgate)) && (exist(opcgate)==PSD_ON) )
    {
        /* Set some values for the scan clock */
        pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_CARDIAC), pidmode) : PSD_CLOCK_CARDIAC; /* Display views  and clock */
        /*
           piclckcnt 
           piclckcnt is used is estimating the scan time remaining in
           a cardiac scan.  It is the number of cardiac triggers within
           an effective TR interval used by the PSD to initiate a 
           sequence after the initial  cardiac trigger 

           piviews
           piviews is used by the Tgt in cardiac scans to display the
           number of heart beat triggers the PSD will use 
           to complete a scan 

           trigger_time
           Amount of time to leave for the cardiac trigger.
         */

        ctlend  = _ctlend.fixedflag ?          ((void)(IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi))), ctlend) : IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi));
        if (opphases  > 1) 
        {
            piviews  = _piviews.fixedflag ?  ((void)(nreps), piviews) : nreps; /* used by the Tgt in cardiac scans to display the
                                number of heart beat triggers the PSD will use 
                                to complete a scan */
            piclckcnt  = _piclckcnt.fixedflag ?  ((void)(0), piclckcnt) : 0;
            trigger_time  = _trigger_time.fixedflag ?         
                          ((void)(RDN_GRD((int)(0.01*oparr*(60.0/ophrate)*1e6*ophrep))), trigger_time) : RDN_GRD((int)(0.01*oparr*(60.0/ophrate)*1e6*ophrep));
            ctlend_last[0] = RDN_GRD(act_tr - trigger_time - td0 -
                    (opphases -1) * psd_tseq - tmin - time_ssi);
        } 
        else 
        {
            ctlend_fill[0] = RDN_GRD(piait - (((int)(opslquant/ophrep) +
                            (opslquant%ophrep ? 1:0) -1) *
                        psd_tseq) - tmin - time_ssi);
            ctlend_unfill[0] = RDN_GRD(ctlend_fill[0] +
                    (opslquant%ophrep ? psd_tseq:0));
            /* Cross R-R */
            if (opslquant >= ophrep) 
            {
                piclckcnt  = _piclckcnt.fixedflag ?    ((void)(ophrep-1), piclckcnt) : ophrep-1;
                piviews  = _piviews.fixedflag ?    ((void)((nreps+rtb0_dda)*ophrep), piviews) : (nreps+rtb0_dda)*ophrep; /*RTB0 correction*/
                trigger_time  = _trigger_time.fixedflag ?       ((void)(.01*oparr*(60.0/ophrate)*1e6), trigger_time) : .01*oparr*(60.0/ophrate)*1e6;
                ctlend_last[0] = ctlend_unfill[0];
            } 
            else 
            {
                piclckcnt  = _piclckcnt.fixedflag ?    ((void)(opslquant-1), piclckcnt) : opslquant-1;
                piviews  = _piviews.fixedflag ?    ((void)((nreps+rtb0_dda)*opslquant), piviews) : (nreps+rtb0_dda)*opslquant; /*RTB0 correction*/
                trigger_time  = _trigger_time.fixedflag ?              ((void)((0.01*oparr*(60.0/ophrate)*1e6*(ophrep+1-opslquant))), trigger_time) : (0.01*oparr*(60.0/ophrate)*1e6*(ophrep+1-opslquant));
                ctlend_last[0] = RDN_GRD(ctlend_fill[0] + (ophrep - opslquant) *
                        ((1 -.01*oparr) * (60.0/ophrate) * 1e6));
            }
        }

        ps2_dda  = _ps2_dda.fixedflag ?  ((void)(dda), ps2_dda) : dda;
        if (optdel1 < pitdel1) 
        { /* Calculate time from middle of last echo to when 
             spatial sat, chemsat or killer can begin */
            post_echo_time  = _post_echo_time.fixedflag ?              ((void)(tdaqhxb+pw_gxwad-rfupa+1+gkdelay+gktime), post_echo_time) : tdaqhxb+pw_gxwad-rfupa+1+gkdelay+gktime;
            postsat  = _postsat.fixedflag ?  ((void)(opsat), postsat) : opsat;

            if( irprep_flag == PSD_ON )
            {
                sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_ir_start+ir_time), sp_satstart) : pos_ir_start+ir_time;
            } 
            else 
            {
                sp_satstart  = _sp_satstart.fixedflag ?    ((void)(td0+tlead), sp_satstart) : td0+tlead;
            }

            sp_satstart  = _sp_satstart.fixedflag ?            ((void)(sp_satstart+pw_gzrf1a+t_exa+psd_rf_wait+te_time+post_echo_time), sp_satstart) : sp_satstart+pw_gzrf1a+t_exa+psd_rf_wait+te_time+post_echo_time;
            cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
            post_echo_time  = _post_echo_time.fixedflag ?      ((void)(post_echo_time+sp_sattime+cs_sattime), post_echo_time) : post_echo_time+sp_sattime+cs_sattime;

            if( irprep_flag == PSD_ON ){
                pos_start  = _pos_start.fixedflag ?      ((void)(pos_start+ir_time+pos_ir_start), pos_start) : pos_start+ir_time+pos_ir_start; 
            }

            sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(1), sp_satcard_loc) : 1;
        } 
        else 
        {
            postsat  = _postsat.fixedflag ?  ((void)(PSD_OFF), postsat) : PSD_OFF;

            if( irprep_flag == PSD_ON ){
                sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_ir_start+ir_time), sp_satstart) : pos_ir_start+ir_time;
            } else {
                sp_satstart  = _sp_satstart.fixedflag ?      ((void)(GRAD_UPDATE_TIME+tlead+ir_time), sp_satstart) : GRAD_UPDATE_TIME+tlead+ir_time;
            }

            cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
            pos_start  = _pos_start.fixedflag ?           ((void)(pos_start+sp_sattime+cs_sattime+ir_time+satdelay), pos_start) : pos_start+sp_sattime+cs_sattime+ir_time+satdelay;

            if( irprep_flag == PSD_ON ){
                pos_start  = _pos_start.fixedflag ?    ((void)(pos_start+pos_ir_start), pos_start) : pos_start+pos_ir_start;
            }

            sp_satcard_loc  = _sp_satcard_loc.fixedflag ?  ((void)(0), sp_satcard_loc) : 0;
        }
    } 
    else if ( ((existcv(oprtcgate)) && (exist(oprtcgate)==PSD_ON)) || /* RTG */
              (PSD_ON == navtrig_flag) ) 
    {
        /* Set some values for the scan clock */
        pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_CARDIAC), pidmode) : PSD_CLOCK_CARDIAC; /* Display views  and clock */
        /* piclckcnt 
           piclckcnt is used in estimating the scan time remaining in
           a cardiac scan.  It is the number of cardiac triggers within
           an effective TR interval used by the PSD to initiate a
           sequence after the initial  cardiac trigger

           piviews
           piviews is used by the Tgt in cardiac scans to display the
           number of heart beat triggers the PSD will use
           to complete a scan

           trigger_time  
           Amount of time to leave for the cardiac trigger.  */

        int acq_cnt = 0;  /* counter */
        int tmp_slquant_acq = 0;
        ctlend  = _ctlend.fixedflag ?   ((void)(IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi))), ctlend) : IMax(2,(int)GRAD_UPDATE_TIME,RDN_GRD(psd_tseq-tmin-time_ssi));        

        for (acq_cnt = 0; acq_cnt < act_acqs; acq_cnt++)
        { 
            tmp_slquant_acq = opslquant/ act_acqs + ((opslquant % act_acqs > acq_cnt) ? 1 : 0);

            ctlend_fill[acq_cnt] = RDN_GRD(pirtait - (((int)(tmp_slquant_acq/ oprtrep) +
                            (tmp_slquant_acq  % oprtrep ? 1 : 0) - 1) * psd_tseq) - tmin);
            ctlend_unfill[acq_cnt] = RDN_GRD(ctlend_fill[acq_cnt] + (tmp_slquant_acq % oprtrep?psd_tseq : 0));
        }

        /* Cross R-R  */
        /* HCSDM00432487: Support cross R-R with multi acq case */ 
        if (opslquant >= oprtrep * act_acqs) 
        {   /* No cross R-R case */
            piclckcnt  = _piclckcnt.fixedflag ?    ((void)(oprtrep-1), piclckcnt) : oprtrep-1;
            piviews  = _piviews.fixedflag ?    ((void)((nreps+rtb0_dda)*oprtrep), piviews) : (nreps+rtb0_dda)*oprtrep;
            trigger_time  = _trigger_time.fixedflag ?        ((void)(.01*oprtarr*(60.0/oprtrate)*1e6), trigger_time) : .01*oprtarr*(60.0/oprtrate)*1e6;

            /* Need filling more than 0 to ctlend_last in each acq to avoid prep fail */
            for (acq_cnt = 0; acq_cnt < act_acqs; acq_cnt++)
            {
                ctlend_last[acq_cnt] = ctlend_unfill[acq_cnt];
            }  
        }
        else 
        {   /* Cross R-R case */
            piclckcnt  = _piclckcnt.fixedflag ?    ((void)(exist(opslquant)-1), piclckcnt) : exist(opslquant)-1;
            piviews  = _piviews.fixedflag ?      
                         ((void)(((nreps/act_acqs)*exist(opslquant))+(rtb0_dda*(exist(opslquant)/act_acqs+(opslquant%act_acqs?1:0)))), piviews) : ((nreps/act_acqs)*exist(opslquant))+(rtb0_dda*(exist(opslquant)/act_acqs+(opslquant%act_acqs?1:0)));
            trigger_time  = _trigger_time.fixedflag ?               ((void)(.01*oprtarr*(60.0/oprtrate)*1e6*(oprtrep+1-(exist(opslquant)/act_acqs))), trigger_time) : .01*oprtarr*(60.0/oprtrate)*1e6*(oprtrep+1-(exist(opslquant)/act_acqs));
            /* In cross R-R with multi acq case, ctlend_last[] will be used each acq */
            for (acq_cnt = 0; acq_cnt < act_acqs; acq_cnt++)
            {
                if (oprtrep > opslquant/ act_acqs + (opslquant%act_acqs > acq_cnt? 1 : 0))
                { /* Cross R-R case in current acq */
                    ctlend_last[acq_cnt] = RDN_GRD(ctlend_fill[acq_cnt] + 
                            (oprtrep - (exist(opslquant)/ act_acqs)) * (60.0/ oprtrate) * 1e6);
                }
                else
                { /* Non cross R-R case in current acq */
                    ctlend_last[acq_cnt] = ctlend_fill[acq_cnt];
                }
            }
        }

        ps2_dda  = _ps2_dda.fixedflag ?  ((void)(dda), ps2_dda) : dda;

        if( irprep_flag == PSD_ON ){
            sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_ir_start+ir_time), sp_satstart) : pos_ir_start+ir_time;
        } else {
            sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_start+ir_time), sp_satstart) : pos_start+ir_time;
        }

        cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
        pos_start  = _pos_start.fixedflag ?          ((void)(pos_start+ir_time+sp_sattime+cs_sattime+satdelay), pos_start) : pos_start+ir_time+sp_sattime+cs_sattime+satdelay;

        if( irprep_flag == PSD_ON ){
            pos_start  = _pos_start.fixedflag ?    ((void)(pos_start+pos_ir_start), pos_start) : pos_start+pos_ir_start;
        }

    } 
    else 
    {
        pidmode  = _pidmode.fixedflag ?  ((void)(PSD_CLOCK_NORM), pidmode) : PSD_CLOCK_NORM; /* Display scan clock in seconds */
        ps2_dda  = _ps2_dda.fixedflag ?  ((void)(dda), ps2_dda) : dda;

        if( irprep_flag == PSD_ON ){
            sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_ir_start+ir_time), sp_satstart) : pos_ir_start+ir_time;
        } else {
            sp_satstart  = _sp_satstart.fixedflag ?    ((void)(pos_start+ir_time), sp_satstart) : pos_start+ir_time;
        }

        cs_satstart  = _cs_satstart.fixedflag ?        ((void)(sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME), cs_satstart) : sp_satstart+sp_sattime-rfupa+CHEM_SSP_FREQ_TIME;
        pos_start  = _pos_start.fixedflag ?          ((void)(pos_start+ir_time+sp_sattime+cs_sattime+satdelay), pos_start) : pos_start+ir_time+sp_sattime+cs_sattime+satdelay;

        if( irprep_flag == PSD_ON ){
            pos_start  = _pos_start.fixedflag ?    ((void)(pos_start+pos_ir_start), pos_start) : pos_start+pos_ir_start;
        }

    }
    
    /* YMSmr07671 */
    sp_satcard_loc  = _sp_satcard_loc.fixedflag ?      ((void)(sp_satcard_loc||irprep_flag||epi_flair), sp_satcard_loc) : sp_satcard_loc||irprep_flag||epi_flair;
  
    if (ss_rf1 != PSD_ON) {
        pos_moment_start  = _pos_moment_start.fixedflag ?      ((void)(pos_start+t_exa+pw_gzrf1a), pos_moment_start) : pos_start+t_exa+pw_gzrf1a;
        
        /* SVBranch: HCSDM00259122  - walk sat case for Type I 2D RF */
        if (rfov_flag && walk_sat_flag)
        {
            pos_moment_start  = _pos_moment_start.fixedflag ?    ((void)(pos_moment_start+pw_wksat_tot), pos_moment_start) : pos_moment_start+pw_wksat_tot;
        }            
    }
    cs_satstart  = _cs_satstart.fixedflag ?  ((void)(RUP_GRD(cs_satstart)), cs_satstart) : RUP_GRD(cs_satstart);
    sp_satstart  = _sp_satstart.fixedflag ?  ((void)(RUP_GRD(sp_satstart)), sp_satstart) : RUP_GRD(sp_satstart); 
    
    /***SVBranch: HCSDM00259122  -  FOCUS walk sat calc ***/
    /* update the walk-sat module start time
       based on the new pos_start; */
    if (rfov_flag && walk_sat_flag)
    {
        if ( FAILURE == walk_sat_timing() ) return FAILURE;
    }
    /*********************************/
  
    /*
     * Initialize the waits for the cardiac instruction.
     * Pulse widths of wait will be set to td0 for first slice
     * of an R-R in RSP.  All other slices will be set to 
     * the GRAD_UPDATE_TIME.
     */
    pw_x_td0  = _pw_x_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_x_td0) : GRAD_UPDATE_TIME;
    pw_y_td0  = _pw_y_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_y_td0) : GRAD_UPDATE_TIME;
    pw_z_td0  = _pw_z_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_z_td0) : GRAD_UPDATE_TIME;
    pw_rho_td0  = _pw_rho_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_rho_td0) : GRAD_UPDATE_TIME;
    pw_ssp_td0  = _pw_ssp_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_ssp_td0) : GRAD_UPDATE_TIME;
    pw_theta_td0  = _pw_theta_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_theta_td0) : GRAD_UPDATE_TIME;
    pw_omega_td0  = _pw_omega_td0.fixedflag ?  ((void)(GRAD_UPDATE_TIME), pw_omega_td0) : GRAD_UPDATE_TIME;

    freq_dwi = _freq_dwi.fixedflag ? ((void)(0.0), freq_dwi) : 0.0;   /* B0 frequency offset */
    phase_dwi = _phase_dwi.fixedflag ? ((void)(0.0), phase_dwi) : 0.0;  /* B0 phase offset */
 
    a_gz_dwi = _a_gz_dwi.fixedflag ? ((void)(0.0), a_gz_dwi) : 0.0;
    a_gy_dwi = _a_gy_dwi.fixedflag ? ((void)(0.0), a_gy_dwi) : 0.0;
    a_gx_dwi = _a_gx_dwi.fixedflag ? ((void)(0.0), a_gx_dwi) : 0.0;

    ia_gx1  = _ia_gx1.fixedflag ?     ((void)((int)(a_gx1*(float)max_pg_iamp/loggrd.tx)), ia_gx1) : (int)(a_gx1*(float)max_pg_iamp/loggrd.tx);

    /* BJM: pulsegen on the host does not utilize the grad[].scale fields */
    /*      The actual amplitudes are used instead.  For the diffusion lobes, */
    /*      we can account for the frequency of occurance by scaling the amp */

    if((PSD_ON == gradHeatMethod)  && (PSD_ON == derate_amp)) 
    {    
        /*MRIhc05854: 1*/
        if( weighted_avg_grad == PSD_ON && pgen_calc_bval_flag == PSD_OFF && AVERAGE_POWER == encode_mode ) 
        {
            int kk;

            cur_num_iters = 0; /*single-TR average power mode in generating cp files*/

            scale_difx  = _scale_difx.fixedflag ?  ((void)(0.0), scale_difx) : 0.0;
            scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
            scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;

            if ( weighted_avg_debug == PSD_ON ) 
            {
                fp_grad = fopen("/tmp/dwi_grad_debug","a");
            }
            if(tensor_flag == PSD_ON)
            {
                for( kk=0; kk< (opdifnumdirs + opdifnumt2); kk++) 
                {
					/*
                    scale_difx += TENSOR_HOST[0][kk] * TENSOR_HOST[0][kk];
                    scale_dify += TENSOR_HOST[1][kk] * TENSOR_HOST[1][kk];
                    scale_difz += TENSOR_HOST[2][kk] * TENSOR_HOST[2][kk];
					*/
					/* original */

			/* granty edit to adjust for different diffusion waveforms 5/15/2018 */
		    if(floatsAlmostEqualEpsilons(WAVE_HOST[kk], 1, 2)){
                    	scale_difx  = _scale_difx.fixedflag ?      ((void)(TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*max_bval/sde_max_bval), scale_difx) : scale_difx+TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*max_bval/sde_max_bval;
                    	scale_dify  = _scale_dify.fixedflag ?      ((void)(TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*max_bval/sde_max_bval), scale_dify) : scale_dify+TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*max_bval/sde_max_bval;
                    	scale_difz  = _scale_difz.fixedflag ?      ((void)(TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*max_bval/sde_max_bval), scale_difz) : scale_difz+TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*max_bval/sde_max_bval;
		    } else if (floatsAlmostEqualEpsilons(WAVE_HOST[kk], 3, 2)) {
                   	scale_difx  = _scale_difx.fixedflag ?      ((void)(TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*max_bval/ide_max_bval), scale_difx) : scale_difx+TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*max_bval/ide_max_bval;
                    	scale_dify  = _scale_dify.fixedflag ?      ((void)(TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*max_bval/ide_max_bval), scale_dify) : scale_dify+TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*max_bval/ide_max_bval;
                    	scale_difz  = _scale_difz.fixedflag ?      ((void)(TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*max_bval/ide_max_bval), scale_difz) : scale_difz+TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*max_bval/ide_max_bval;
		    }
 		    /* end edit */
                    if ( weighted_avg_debug == PSD_ON ) 
                    {
                        fprintf(fp_grad,"TENSOR_HOST[0][%d]=%f, TENSOR_HOST[1][%d]=%f, TENSOR_HOST[2][%d]=%f\n",
                                kk,TENSOR_HOST[0][kk],kk,TENSOR_HOST[1][kk],kk,
                                TENSOR_HOST[2][kk]);
                        fprintf(fp_grad,"scale_difx=%f,scale_dify=%f,scale_difz=%f\n",
                                scale_difx,scale_dify,scale_difz);
                    }
                }
                scale_difx = _scale_difx.fixedflag ?      ((void)((opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0))), scale_difx) : scale_difx/(opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0));
                scale_difx  = _scale_difx.fixedflag ?  ((void)(sqrt(scale_difx)), scale_difx) : sqrt(scale_difx);
                scale_dify = _scale_dify.fixedflag ?      ((void)((opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0))), scale_dify) : scale_dify/(opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0));
                scale_dify  = _scale_dify.fixedflag ?  ((void)(sqrt(scale_dify)), scale_dify) : sqrt(scale_dify);
                scale_difz = _scale_difz.fixedflag ?      ((void)((opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0))), scale_difz) : scale_difz/(opdifnumdirs+opdifnumt2+(rpg_in_scan_flag?rpg_in_scan_num:0));
                scale_difz  = _scale_difz.fixedflag ?  ((void)(sqrt(scale_difz)), scale_difz) : sqrt(scale_difz);
            }
            else
            {
                int counter = 0;
                /* Account for Distortion Correction hidden t2 passes first */
                for( kk=0; kk<(rpg_in_scan_flag?rpg_in_scan_num:0); kk++)
                {
                    /* No diff grads */
                    if ( weighted_avg_debug == PSD_ON ) 
                    {
                        fprintf(fp_grad,"Adding zero amplitude gradients for RPG pass %d\n", kk);
                        fprintf(fp_grad,"scale_difx=%f,scale_dify=%f,scale_difz=%f\n",
                                scale_difx,scale_dify,scale_difz);
                    }
                    counter += (int)1; /* 1NEX*/
                }
                for( kk=0; kk<opdifnumt2; kk++)
                {
                    scale_difx  = _scale_difx.fixedflag ?      ((void)(TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*opdifnext2), scale_difx) : scale_difx+TENSOR_HOST[0][kk]*TENSOR_HOST[0][kk]*opdifnext2;
                    scale_dify  = _scale_dify.fixedflag ?      ((void)(TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*opdifnext2), scale_dify) : scale_dify+TENSOR_HOST[1][kk]*TENSOR_HOST[1][kk]*opdifnext2;
                    scale_difz  = _scale_difz.fixedflag ?      ((void)(TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*opdifnext2), scale_difz) : scale_difz+TENSOR_HOST[2][kk]*TENSOR_HOST[2][kk]*opdifnext2;
                    if ( weighted_avg_debug == PSD_ON ) 
                    {
                        fprintf(fp_grad,"TENSOR_HOST[0][%d]=%f, TENSOR_HOST[1][%d]=%f, TENSOR_HOST[2][%d]=%f\n",
                                kk,TENSOR_HOST[0][kk],kk,TENSOR_HOST[1][kk],kk,
                                TENSOR_HOST[2][kk]);
                        fprintf(fp_grad,"scale_difx=%f,scale_dify=%f,scale_difz=%f\n",
                                scale_difx,scale_dify,scale_difz);
                    }
                    counter += (int)opdifnext2;
                }
                for( kk=0; kk<opnumbvals; kk++)
                {
                    int ii;
                    for(ii = 0; ii<opdifnumdirs; ii++)
                    {
                        scale_difx  = _scale_difx.fixedflag ?     
                                        ((void)(TENSOR_HOST[0][ii+opdifnumt2]*TENSOR_HOST[0][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk]), scale_difx) : scale_difx+TENSOR_HOST[0][ii+opdifnumt2]*TENSOR_HOST[0][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk];
                        scale_dify  = _scale_dify.fixedflag ?     
                                        ((void)(TENSOR_HOST[1][ii+opdifnumt2]*TENSOR_HOST[1][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk]), scale_dify) : scale_dify+TENSOR_HOST[1][ii+opdifnumt2]*TENSOR_HOST[1][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk];
                        scale_difz  = _scale_difz.fixedflag ?     
                                        ((void)(TENSOR_HOST[2][ii+opdifnumt2]*TENSOR_HOST[2][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk]), scale_difz) : scale_difz+TENSOR_HOST[2][ii+opdifnumt2]*TENSOR_HOST[2][ii+opdifnumt2]*diff_bv_weight[kk]*difnextab[kk];
                        if ( weighted_avg_debug == PSD_ON ) 
                        {
                            fprintf(fp_grad,"TENSOR_HOST[0][%d]=%f, TENSOR_HOST[1][%d]=%f, TENSOR_HOST[2][%d]=%f\n",
                                    kk,TENSOR_HOST[0][kk],kk,TENSOR_HOST[1][kk],kk,TENSOR_HOST[2][kk]);
                            fprintf(fp_grad,"diff_bv_weight[%d]=%f\n", kk,diff_bv_weight[kk]);
                            fprintf(fp_grad,"scale_difx=%f,scale_dify=%f,scale_difz=%f\n",
                                    scale_difx,scale_dify,scale_difz);
                        }
                        counter += (int)difnextab[kk];
                    }
                }
                scale_difx = _scale_difx.fixedflag ?    ((void)(IMax(2,counter,1)), scale_difx) : scale_difx/IMax(2,counter,1);
                scale_difx  = _scale_difx.fixedflag ?  ((void)(sqrt(scale_difx)), scale_difx) : sqrt(scale_difx);
                scale_dify = _scale_dify.fixedflag ?    ((void)(IMax(2,counter,1)), scale_dify) : scale_dify/IMax(2,counter,1);
                scale_dify  = _scale_dify.fixedflag ?  ((void)(sqrt(scale_dify)), scale_dify) : sqrt(scale_dify);
                scale_difz = _scale_difz.fixedflag ?    ((void)(IMax(2,counter,1)), scale_difz) : scale_difz/IMax(2,counter,1);
                scale_difz  = _scale_difz.fixedflag ?  ((void)(sqrt(scale_difz)), scale_difz) : sqrt(scale_difz);
            }
            
            if ( weighted_avg_debug == PSD_ON ) 
            {
                    fprintf(fp_grad,"opdifnumdirs=%d, opdifnumt2=%d, opnumbvals=%d\n",
                            opdifnumdirs,opdifnumt2,opnumbvals);
                    fprintf(fp_grad,"scale_difx=%f, scale_dify=%f, scale_difz=%f\n\n\n",
                            scale_difx,scale_dify,scale_difz);
                    fclose(fp_grad);
            }
        } 
        else if (pgen_calc_bval_flag == PSD_OFF)
        {  /* weighted_avg_debug == PSD_OFF */                
            if (tensor_flag == PSD_OFF) 
            {
                if(opdfaxall >PSD_OFF)
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                    if(gradopt_diffall == PSD_ON)
                    {
                        scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                        scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                        scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                    }
                }
                else if (opdfaxx > PSD_OFF) 
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                }
                else if (opdfaxy > PSD_OFF) 
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(0.0), scale_difx) : 0.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                }
                else if (opdfaxz > PSD_OFF) 
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(0.0), scale_difx) : 0.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
                }
                else if((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
                }
            }
            else 
            {
                scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
            }
        }
        else  /* pgen_calc_bval ON */
        {
            if (tensor_flag == PSD_OFF)
            {
                if(opdfaxall >PSD_OFF)
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
                }
                else if (opdfaxx > PSD_OFF)
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                }
                else if (opdfaxy > PSD_OFF)
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(0.0), scale_difx) : 0.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(0.0), scale_difz) : 0.0;
                }
                else if (opdfaxz > PSD_OFF)
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(0.0), scale_difx) : 0.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(0.0), scale_dify) : 0.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
                }
                else if((opdfaxtetra > PSD_OFF) || (opdfax3in1 > PSD_OFF))
                {
                    scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                    scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                    scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
                }
            }
            else
            {
                scale_difx  = _scale_difx.fixedflag ?  ((void)(1.0), scale_difx) : 1.0;
                scale_dify  = _scale_dify.fixedflag ?  ((void)(1.0), scale_dify) : 1.0;
                scale_difz  = _scale_difz.fixedflag ?  ((void)(1.0), scale_difz) : 1.0;
            }
        }

        /* Obl 3in1 opt */
        if (obl_3in1_opt)
        {
            int i;

            if (obl_3in1_opt_debug)
            {
                printf("Obl3in1:  \n");
                printf("Obl3in1: weighted_avg_grad=%d pgen_calc_bval_flag=%d\n", weighted_avg_grad, pgen_calc_bval_flag);
                printf("Obl3in1: scale_difx=%f scale_dify=%f scale_difz=%f\n", scale_difx, scale_dify, scale_difz);
                printf("Obl3in1:  \n");
                printf("Obl3in1: Input logical MPG amplitude in each axis in G/cm.\n");
                printf("Obl3in1: norot_incdifx= %f norot_incdify= %f norot_incdifz= %f\n", norot_incdifx, norot_incdify, norot_incdifz);
            }

            gx_phys = norot_incdifx*scale_difx;
            gy_phys = norot_incdify*scale_dify;
            gz_phys = norot_incdifz*scale_difz;

            log_incdifx_scaled = inversRR[0]*gx_phys + inversRR[1]*gy_phys + inversRR[2]*gz_phys;
            log_incdify_scaled = inversRR[3]*gx_phys + inversRR[4]*gy_phys + inversRR[5]*gz_phys;
            log_incdifz_scaled = inversRR[6]*gx_phys + inversRR[7]*gy_phys + inversRR[8]*gz_phys;

            if (obl_3in1_opt_debug)
            {
                printf("Obl3in1: Calculated scaled logical MPG amplitude\n");
                printf("Obl3in1: log_incdifx_scaled= %f log_incdify_scaled= %f log_incdifz_scaled= %f\n", log_incdifx_scaled, log_incdify_scaled, log_incdifz_scaled);
            }

            for (i=0; i<num_dif; i++)
            {
                gx_log = norot_incdifx;
                gy_log = norot_incdify;
                gz_log = norot_incdifz;

                rotateToLogical(&gx_log, &gy_log, &gz_log, i);

                log_incdifx[i]=gx_log;
                log_incdify[i]=gy_log;
                log_incdifz[i]=gz_log;

                if (obl_3in1_opt_debug)
                {
                    printf("Obl3in1: Dir= %d\n",i);
                    printf("Obl3in1: Calculated logical MPG amplitude\n");
                    printf("Obl3in1: log_incdifx= %f  log_incdify= %f log_incdifz= %f\n",log_incdifx[i],log_incdify[i],log_incdifz[i]);
                }
            }

            agxdif_tmp = log_incdifx[0];
            agydif_tmp = log_incdify[0];
            agzdif_tmp = log_incdifz[0];
        }
        else
        {
            /* BJM: pulsegen on the host does not utilize the grad[].scale fields */
            /*      The actual amplitudes are used instead.  For the diffusion lobes, */
            /*      we can account for the frequency of occurance by scaling the amp */

            /* DTI */
            if (PSD_OFF == dualspinecho_flag)
            {
                agxdif_tmp = a_gxdl;
                agydif_tmp = a_gydl;
                agzdif_tmp = a_gzdl;
            }
            else 
            {
                agxdif_tmp = a_gxdl1;
                agydif_tmp = a_gydl1;
                agzdif_tmp = a_gzdl1;
            }
        }

        /* MRIge57853: Dont scale X for ultra Hi-B to protect against */
        /* power supply droop... */
        /* MRIge58521 - removed fix for 57853 since this is taken */
        /* into account with this fix */
        /* DTI */
        
        if (PSD_OFF == dualspinecho_flag)
        {
            /* x axis scaled - scale_difx = 1 (worst case)*/
            a_gxdl  = _a_gxdl.fixedflag ?  ((void)(gradx[GXDL_SLOT].num*a_gxdl*scale_difx), a_gxdl) : gradx[GXDL_SLOT].num*a_gxdl*scale_difx;
            a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;
            
            /* y axis scaled - scale_dify = 0*/
            a_gydl  = _a_gydl.fixedflag ?  ((void)(grady[GYDL_SLOT].num*a_gydl*scale_dify), a_gydl) : grady[GYDL_SLOT].num*a_gydl*scale_dify;
            a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;

            /* z axis scaled - scale_difz = 0*/
            a_gzdl  = _a_gzdl.fixedflag ?  ((void)(gradz[GZDL_SLOT].num*a_gzdl*scale_difz), a_gzdl) : gradz[GZDL_SLOT].num*a_gzdl*scale_difz;
            a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl; 

            /* Obl 3in1 opt */
            if (obl_3in1_opt)
            {
                if (pgen_calc_bval_flag)
                {
                    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(amp_difx_bverify), a_gxdl) : amp_difx_bverify;
                    a_gydl  = _a_gydl.fixedflag ?  ((void)(amp_dify_bverify), a_gydl) : amp_dify_bverify;
                    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(amp_difz_bverify), a_gzdl) : amp_difz_bverify;
                    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(amp_difx_bverify), a_gxdr) : amp_difx_bverify;
                    a_gydr  = _a_gydr.fixedflag ?  ((void)(amp_dify_bverify), a_gydr) : amp_dify_bverify;
                    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(amp_difz_bverify), a_gzdr) : amp_difz_bverify;
                }
                else
                {
                    a_gxdl  = _a_gxdl.fixedflag ?  ((void)(log_incdifx_scaled), a_gxdl) : log_incdifx_scaled;
                    a_gydl  = _a_gydl.fixedflag ?  ((void)(log_incdify_scaled), a_gydl) : log_incdify_scaled;
                    a_gzdl  = _a_gzdl.fixedflag ?  ((void)(log_incdifz_scaled), a_gzdl) : log_incdifz_scaled;
                    a_gxdr  = _a_gxdr.fixedflag ?  ((void)(log_incdifx_scaled), a_gxdr) : log_incdifx_scaled;
                    a_gydr  = _a_gydr.fixedflag ?  ((void)(log_incdify_scaled), a_gydr) : log_incdify_scaled;
                    a_gzdr  = _a_gzdr.fixedflag ?  ((void)(log_incdifz_scaled), a_gzdr) : log_incdifz_scaled;
                }
            }

            ia_gxdl  = _ia_gxdl.fixedflag ?     ((void)((int)(a_gxdl*(float)max_pg_iamp/loggrd.tx)), ia_gxdl) : (int)(a_gxdl*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr  = _ia_gxdr.fixedflag ?     ((void)((int)(a_gxdr*(float)max_pg_iamp/loggrd.tx)), ia_gxdr) : (int)(a_gxdr*(float)max_pg_iamp/loggrd.tx);
            
            ia_gydl  = _ia_gydl.fixedflag ?     ((void)((int)(a_gydl*(float)max_pg_iamp/loggrd.ty)), ia_gydl) : (int)(a_gydl*(float)max_pg_iamp/loggrd.ty);
            ia_gydr  = _ia_gydr.fixedflag ?     ((void)((int)(a_gydr*(float)max_pg_iamp/loggrd.ty)), ia_gydr) : (int)(a_gydr*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl  = _ia_gzdl.fixedflag ?     ((void)((int)(a_gzdl*(float)max_pg_iamp/loggrd.tz)), ia_gzdl) : (int)(a_gzdl*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr  = _ia_gzdr.fixedflag ?     ((void)((int)(a_gzdr*(float)max_pg_iamp/loggrd.tz)), ia_gzdr) : (int)(a_gzdr*(float)max_pg_iamp/loggrd.tz);
        }
        else 
        {
            a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(gradx[GXDL_SLOT].num*a_gxdl1*scale_difx), a_gxdl1) : gradx[GXDL_SLOT].num*a_gxdl1*scale_difx;
            a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-a_gxdl1), a_gxdr1) : -a_gxdl1;
            
            a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(gradx[GXDL_SLOT].num*a_gxdl2*scale_difx), a_gxdl2) : gradx[GXDL_SLOT].num*a_gxdl2*scale_difx;
            a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-a_gxdl2), a_gxdr2) : -a_gxdl2;

            /* y axis scaled */
            a_gydl1  = _a_gydl1.fixedflag ?  ((void)(grady[GYDL_SLOT].num*a_gydl1*scale_dify), a_gydl1) : grady[GYDL_SLOT].num*a_gydl1*scale_dify;
            a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-a_gydl1), a_gydr1) : -a_gydl1;
            
            a_gydl2  = _a_gydl2.fixedflag ?  ((void)(grady[GYDL_SLOT].num*a_gydl2*scale_dify), a_gydl2) : grady[GYDL_SLOT].num*a_gydl2*scale_dify;
            a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-a_gydl2), a_gydr2) : -a_gydl2;
            
            /* z axis scaled */
            a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(gradz[GZDL_SLOT].num*a_gzdl1*scale_difz), a_gzdl1) : gradz[GZDL_SLOT].num*a_gzdl1*scale_difz;
            a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-a_gzdl1), a_gzdr1) : -a_gzdl1; 
            
            a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(gradz[GZDL_SLOT].num*a_gzdl2*scale_difz), a_gzdl2) : gradz[GZDL_SLOT].num*a_gzdl2*scale_difz;
            a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-a_gzdl2), a_gzdr2) : -a_gzdl2; 
            
            /* Obl 3in1 opt */
            if (obl_3in1_opt)
            {
                if (pgen_calc_bval_flag)
                {
                    a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(amp_difx_bverify), a_gxdl1) : amp_difx_bverify;
                    a_gydl1  = _a_gydl1.fixedflag ?  ((void)(amp_dify_bverify), a_gydl1) : amp_dify_bverify;
                    a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(amp_difz_bverify), a_gzdl1) : amp_difz_bverify;
                    a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-amp_difx_bverify), a_gxdr1) : -amp_difx_bverify;
                    a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-amp_dify_bverify), a_gydr1) : -amp_dify_bverify;
                    a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-amp_difz_bverify), a_gzdr1) : -amp_difz_bverify;
                    a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(amp_difx_bverify), a_gxdl2) : amp_difx_bverify;
                    a_gydl2  = _a_gydl2.fixedflag ?  ((void)(amp_dify_bverify), a_gydl2) : amp_dify_bverify;
                    a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(amp_difz_bverify), a_gzdl2) : amp_difz_bverify;
                    a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-amp_difx_bverify), a_gxdr2) : -amp_difx_bverify;
                    a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-amp_dify_bverify), a_gydr2) : -amp_dify_bverify;
                    a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-amp_difz_bverify), a_gzdr2) : -amp_difz_bverify;
                }
                else
                {
                    a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(log_incdifx_scaled), a_gxdl1) : log_incdifx_scaled;
                    a_gydl1  = _a_gydl1.fixedflag ?  ((void)(log_incdify_scaled), a_gydl1) : log_incdify_scaled;
                    a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(log_incdifz_scaled), a_gzdl1) : log_incdifz_scaled;
                    a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-log_incdifx_scaled), a_gxdr1) : -log_incdifx_scaled;
                    a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-log_incdify_scaled), a_gydr1) : -log_incdify_scaled;
                    a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-log_incdifz_scaled), a_gzdr1) : -log_incdifz_scaled;
                    a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(log_incdifx_scaled), a_gxdl2) : log_incdifx_scaled;
                    a_gydl2  = _a_gydl2.fixedflag ?  ((void)(log_incdify_scaled), a_gydl2) : log_incdify_scaled;
                    a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(log_incdifz_scaled), a_gzdl2) : log_incdifz_scaled;
                    a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-log_incdifx_scaled), a_gxdr2) : -log_incdifx_scaled;
                    a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-log_incdify_scaled), a_gydr2) : -log_incdify_scaled;
                    a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-log_incdifz_scaled), a_gzdr2) : -log_incdifz_scaled;
                }
            }

            ia_gxdl1  = _ia_gxdl1.fixedflag ?     ((void)((int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx)), ia_gxdl1) : (int)(a_gxdl1*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr1  = _ia_gxdr1.fixedflag ?     ((void)((int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx)), ia_gxdr1) : (int)(a_gxdr1*(float)max_pg_iamp/loggrd.tx);
        
            ia_gxdl2  = _ia_gxdl2.fixedflag ?     ((void)((int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx)), ia_gxdl2) : (int)(a_gxdl2*(float)max_pg_iamp/loggrd.tx);
            ia_gxdr2  = _ia_gxdr2.fixedflag ?     ((void)((int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx)), ia_gxdr2) : (int)(a_gxdr2*(float)max_pg_iamp/loggrd.tx);

            ia_gydl1  = _ia_gydl1.fixedflag ?     ((void)((int)(a_gydl1*(float)max_pg_iamp/loggrd.ty)), ia_gydl1) : (int)(a_gydl1*(float)max_pg_iamp/loggrd.ty);
            ia_gydr1  = _ia_gydr1.fixedflag ?     ((void)((int)(a_gydr1*(float)max_pg_iamp/loggrd.ty)), ia_gydr1) : (int)(a_gydr1*(float)max_pg_iamp/loggrd.ty);
            
            ia_gydl2  = _ia_gydl2.fixedflag ?     ((void)((int)(a_gydl2*(float)max_pg_iamp/loggrd.ty)), ia_gydl2) : (int)(a_gydl2*(float)max_pg_iamp/loggrd.ty);
            ia_gydr2  = _ia_gydr2.fixedflag ?     ((void)((int)(a_gydr2*(float)max_pg_iamp/loggrd.ty)), ia_gydr2) : (int)(a_gydr2*(float)max_pg_iamp/loggrd.ty);

            ia_gzdl1  = _ia_gzdl1.fixedflag ?     ((void)((int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz)), ia_gzdl1) : (int)(a_gzdl1*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr1  = _ia_gzdr1.fixedflag ?     ((void)((int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz)), ia_gzdr1) : (int)(a_gzdr1*(float)max_pg_iamp/loggrd.tz);
            
            ia_gzdl2  = _ia_gzdl2.fixedflag ?     ((void)((int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz)), ia_gzdl2) : (int)(a_gzdl2*(float)max_pg_iamp/loggrd.tz);
            ia_gzdr2  = _ia_gzdr2.fixedflag ?     ((void)((int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz)), ia_gzdr2) : (int)(a_gzdr2*(float)max_pg_iamp/loggrd.tz);  
        }

        /* Set the amps back that are scaled */
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            /* x-axis scaled */
            a_gxdl  = _a_gxdl.fixedflag ?  ((void)(agxdif_tmp), a_gxdl) : agxdif_tmp;
            a_gxdr  = _a_gxdr.fixedflag ?  ((void)(a_gxdl), a_gxdr) : a_gxdl;

            /* y axis scaled */
            a_gydl  = _a_gydl.fixedflag ?  ((void)(agydif_tmp), a_gydl) : agydif_tmp;
            a_gydr  = _a_gydr.fixedflag ?  ((void)(a_gydl), a_gydr) : a_gydl;

            /* z axis scaled */
            a_gzdl  = _a_gzdl.fixedflag ?  ((void)(agzdif_tmp), a_gzdl) : agzdif_tmp;
            a_gzdr  = _a_gzdr.fixedflag ?  ((void)(a_gzdl), a_gzdr) : a_gzdl;
        } 
        else 
        {
            a_gxdl1  = _a_gxdl1.fixedflag ?  ((void)(agxdif_tmp), a_gxdl1) : agxdif_tmp;
            a_gxdr1  = _a_gxdr1.fixedflag ?  ((void)(-a_gxdl1), a_gxdr1) : -a_gxdl1;

            a_gydl1  = _a_gydl1.fixedflag ?  ((void)(agydif_tmp), a_gydl1) : agydif_tmp;
            a_gydr1  = _a_gydr1.fixedflag ?  ((void)(-a_gydl1), a_gydr1) : -a_gydl1;

            a_gzdl1  = _a_gzdl1.fixedflag ?  ((void)(agzdif_tmp), a_gzdl1) : agzdif_tmp;
            a_gzdr1  = _a_gzdr1.fixedflag ?  ((void)(-a_gzdl1), a_gzdr1) : -a_gzdl1;

            a_gxdl2  = _a_gxdl2.fixedflag ?  ((void)(agxdif_tmp), a_gxdl2) : agxdif_tmp;
            a_gxdr2  = _a_gxdr2.fixedflag ?  ((void)(-a_gxdl2), a_gxdr2) : -a_gxdl2;

            a_gydl2  = _a_gydl2.fixedflag ?  ((void)(agydif_tmp), a_gydl2) : agydif_tmp;
            a_gydr2  = _a_gydr2.fixedflag ?  ((void)(-a_gydl2), a_gydr2) : -a_gydl2;

            a_gzdl2  = _a_gzdl2.fixedflag ?  ((void)(agzdif_tmp), a_gzdl2) : agzdif_tmp;
            a_gzdr2  = _a_gzdr2.fixedflag ?  ((void)(-a_gzdl2), a_gzdr2) : -a_gzdl2;
        }
    }

    ia_incdifx  = _ia_incdifx.fixedflag ?     ((void)((int)(incdifx*(float)max_pg_iamp/loggrd.tx)), ia_incdifx) : (int)(incdifx*(float)max_pg_iamp/loggrd.tx);
    ia_incdify  = _ia_incdify.fixedflag ?     ((void)((int)(incdify*(float)max_pg_iamp/loggrd.ty)), ia_incdify) : (int)(incdify*(float)max_pg_iamp/loggrd.ty);
    ia_incdifz  = _ia_incdifz.fixedflag ?     ((void)((int)(incdifz*(float)max_pg_iamp/loggrd.tz)), ia_incdifz) : (int)(incdifz*(float)max_pg_iamp/loggrd.tz);
    /* maybe granty unsure */

	printf("loggrd.tx = %f\n",loggrd.tx);
    printf("loggrd.tx_xyz = %f\n",loggrd.tx_xyz);
    fflush(stdout);	
    /*
     * Rio diffusion will generate multi-TR cornerPoints in the MAXIMUM_POWER mode
     */
    if ((pgen_calc_bval_flag == PSD_OFF) && (MAXIMUM_POWER == encode_mode) &&
        (isRioSystem()) && (opdiffuse == PSD_ON))
    {
        int ia_incdifx_tmp, ia_incdify_tmp, ia_incdifz_tmp, sindex, ii;

    ia_incdifx_tmp = (int)(agxdif_tmp * (float)max_pg_iamp/ loggrd.tx);
    ia_incdify_tmp = (int)(agydif_tmp * (float)max_pg_iamp/ loggrd.ty);
    ia_incdifz_tmp = (int)(agzdif_tmp * (float)max_pg_iamp/ loggrd.tz);

        if (diff_order_flag == 1)
    {
            if (opdfaxtetra >= PSD_ON || optensor >= PSD_ON || opdfaxall >= PSD_ON)
        {
                for(ii = 0; ii<num_iters; ii++)
                {
                    if (PSD_ON == tensor_host_sort_flag)
                    {
                        sindex = sort_index[ii];
                    }
                    else
                    {
                        sindex = ii+opdifnumt2;
                    }
                    xamp_iters[ii] = (int) (ia_incdifx_tmp * TENSOR_HOST[0][sindex]);
                    yamp_iters[ii] = (int) (ia_incdify_tmp * TENSOR_HOST[1][sindex]);
                    zamp_iters[ii] = (int) (ia_incdifz_tmp * TENSOR_HOST[2][sindex]);
                }
            }
        }
        else /*diff_order_flag == 2*/
        {
            if (opdfaxtetra >= PSD_ON || optensor >= PSD_ON || opdfaxall >= PSD_ON)
            {
                int index_t2;
                if (opdifnumt2 > 0)
                {
                    index_t2 = opdifnumt2-1;
                }else{
                    index_t2 = 0;
                }

                for(ii = 0; ii<num_iters; ii++)
                {
                    if (PSD_ON == tensor_host_sort_flag)
                    {
                        sindex = sort_index[ii];
                    }
                    else
                    {
                        sindex = ii + index_t2;
                    }
                    xamp_iters[ii] = (int) (ia_incdifx_tmp * TENSOR_HOST[0][sindex]);
                    yamp_iters[ii] = (int) (ia_incdify_tmp * TENSOR_HOST[1][sindex]);
                    zamp_iters[ii] = (int) (ia_incdifz_tmp * TENSOR_HOST[2][sindex]);
                }
            }
        }
        cur_num_iters = num_iters; /*multi-TR for maximum power mode in generating cp file*/
    }
    
    if (diff_order_debug == PSD_ON)
    {
        FILE *fp= NULL;
#ifdef PSD_HW
        const char *dir_log = "/usr/g/service/log";
#else
        const char *dir_log = ".";
#endif
        char fname[255];

        sprintf(fname, "%s/diff_order_xyzamp_iters.txt", dir_log);

        if (num_iters>0)
        {
            if ( NULL != (fp = fopen(fname, "w")) )
            {
                int ii;
                fprintf(fp, "num_iters: %d\n", num_iters);
                for(ii = 0; ii<num_iters; ii++)
                {
                    fprintf(fp, "xamp_iters[%d]=%d\t",ii,xamp_iters[ii]);
                    fprintf(fp, "yamp_iters[%d]=%d\t",ii,yamp_iters[ii]);
                    fprintf(fp, "zamp_iters[%d]=%d\n",ii,zamp_iters[ii]);
                }
                fclose(fp);
            }
        }
    }

    ia_gy1  = _ia_gy1.fixedflag ?  ((void)(endview_iamp), ia_gy1) : endview_iamp; /* GEHmr01804 */

    if (eoskillers == PSD_ON) {
	ia_gxk  = _ia_gxk.fixedflag ?     ((void)((int)(a_gxk*(float)max_pg_iamp/loggrd.tx)), ia_gxk) : (int)(a_gxk*(float)max_pg_iamp/loggrd.tx);
	ia_gyk  = _ia_gyk.fixedflag ?     ((void)((int)(a_gyk*(float)max_pg_iamp/loggrd.ty)), ia_gyk) : (int)(a_gyk*(float)max_pg_iamp/loggrd.ty);
	ia_gzk  = _ia_gzk.fixedflag ?     ((void)((int)(a_gzk*(float)max_pg_iamp/loggrd.tz)), ia_gzk) : (int)(a_gzk*(float)max_pg_iamp/loggrd.tz);
    }
    ia_rf1  = _ia_rf1.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RF1_SLOT].amp)), ia_rf1) : max_pg_iamp*(*rfpulse[RF1_SLOT].amp);
    ia_rf2  = _ia_rf2.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RF2_SLOT].amp)), ia_rf2) : max_pg_iamp*(*rfpulse[RF2_SLOT].amp);
  
    /* SVBranch: HCSDM00259122  - FOCUS walk sat */
    if (walk_sat_flag && rfov_flag) walk_sat_scaleRF();   

    SpSatIAmp();

    if (cs_sat == PSD_ON) {
	ia_rfcssat  = _ia_rfcssat.fixedflag ?    ((void)(max_pg_iamp*(*rfpulse[RFCSSAT_SLOT].amp)), ia_rfcssat) : max_pg_iamp*(*rfpulse[RFCSSAT_SLOT].amp);
    }
  
    /* BJM: Omega Freq Mod Pulses */
    a_omega  = _a_omega.fixedflag ?  ((void)(1), a_omega) : 1;
    ia_omega  = _ia_omega.fixedflag ?  ((void)((a_omega*max_pg_iamp)/loggrd.tz), ia_omega) : (a_omega*max_pg_iamp)/loggrd.tz;

    return SUCCESS;
}   /* end calcPulseParams() */

/* t1flair_stir */

/* epi_t1flair_stir */
STATUS T1flair_setup( void )
{
    /* for Fat Suppression */
    autoti_model  = _autoti_model.fixedflag ?  ((void)(T1FLAIR_EFFECTIVE_TR_MODEL_FAT), autoti_model) : T1FLAIR_EFFECTIVE_TR_MODEL_FAT; 
    
    if (t1flair_flag)
    {
        /* epi_t1flair_stir */
        t1flair_slice_uniformity_flag  = _t1flair_slice_uniformity_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_slice_uniformity_flag) : PSD_OFF;
        req_edge_slice_enh_flag  = _req_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), req_edge_slice_enh_flag) : PSD_OFF;
        act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), act_edge_slice_enh_flag) : PSD_OFF;
        force_odd_even_slquant  = _force_odd_even_slquant.fixedflag ?  ((void)(0), force_odd_even_slquant) : 0;
        t1flair_seqtime_method  = _t1flair_seqtime_method.fixedflag ?  ((void)(ANALYTICAL_SEQTIME), t1flair_seqtime_method) : ANALYTICAL_SEQTIME;
        t1flair_autotr_flag  = _t1flair_autotr_flag.fixedflag ?  ((void)(PSD_ON), t1flair_autotr_flag) : PSD_ON;
    }
    else
    {
        /* Reset internal CVs for non T1Flair PSD */
        t1flair_slice_uniformity_flag  = _t1flair_slice_uniformity_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_slice_uniformity_flag) : PSD_OFF;
        req_edge_slice_enh_flag  = _req_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), req_edge_slice_enh_flag) : PSD_OFF;
        act_edge_slice_enh_flag  = _act_edge_slice_enh_flag.fixedflag ?  ((void)(PSD_OFF), act_edge_slice_enh_flag) : PSD_OFF;
        force_odd_even_slquant  = _force_odd_even_slquant.fixedflag ?  ((void)(0), force_odd_even_slquant) : 0;
        t1flair_autotr_flag  = _t1flair_autotr_flag.fixedflag ?  ((void)(PSD_OFF), t1flair_autotr_flag) : PSD_OFF;
    }

    return SUCCESS;
}


STATUS T1flair_options( void )
{
    if ((PSD_ON == t1flair_flag) || (PSD_ON == ir_prep_manual_tr_mode))
    {
        avminti = IMax(2, avminti_t1flair, T1FLAIR_MIN_TI);
        avmaxti = IMin(2, avmaxti_t1flair, T1FLAIR_MAX_TI);

        if ( (exist( opti ) < avminti) && (exist( opautoti ) == PSD_OFF) && (existcv( opti )) )
        {
            epic_error( use_ermes, "Minimum TI is %-d.",
                        EM_PSD_TI_OUT_OF_RANGE1, 1, INT_ARG, avminti/ 1000 );

            return ADVISORY_FAILURE;
        }

        if ( (exist( opti ) > avmaxti) && (existcv( opti )) )
        {
            epic_error( use_ermes, "Maximum TI is %-d.",
                        EM_PSD_TI_OUT_OF_RANGE2, 1, INT_ARG, avmaxti/ 1000 );

            return ADVISORY_FAILURE;
        }
    }

    return SUCCESS;
}





STATUS 
ChemSatEval( INT *time_cssat )
{
    FLOAT target_amp_x, target_amp_y, target_amp_z;
    INT csxkiller_flag, cszkiller_flag;
    float riseTimeX,riseTimeY,riseTimeZ;
#ifdef CSYKILLERA
    INT csyakiller_flag;
#endif /* CSYKILLERA */

    if(cfpwrmontyp == PMTYP_VMX) {
        csat_sys_type  = _csat_sys_type.fixedflag ?  ((void)(1), csat_sys_type) : 1;
        rfupa = csat_rfupa;
    }

    fatFlag  = _fatFlag.fixedflag ?  ((void)(PSD_OFF), fatFlag) : PSD_OFF;

    if ( exist (opfat) || exist (opfatcl) || exist (opspecir) ) { 
        fatFlag  = _fatFlag.fixedflag ?  ((void)(PSD_ON), fatFlag) : PSD_ON;
    } 

    /* pulse widths need to be set up in ChemSatEval to allow for 
       possible pulse type switching */

    /* ****************************************************** *
     * Added to support the change of the rf flip angle setup *
     * the actual flip angle of the ChemSat RF pulse, SGT     *
     * ****************************************************** */
    if (cffield == B0_15000) {
/* FATSAT FACTOR addition - HH June 2005 */
        flip_sat  = _flip_sat.fixedflag ?    ((void)(OVERDRIVE_FA_1_5T*acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : OVERDRIVE_FA_1_5T*acos(1.0-fatsat_factor)/acos(0.0);
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_1_5T), flip_satcfh) : OVERDRIVE_FA_1_5T;
    } else if (cffield == B0_10000) {
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_1_0T), flip_sat) : OVERDRIVE_FA_1_0T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_1_0T), flip_satcfh) : OVERDRIVE_FA_1_0T;
    } else if (cffield==B0_2000 || cffield==B0_5000 || cffield == B0_3500) { /* MFO,Hino, Feb/02/00 MM */
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_0_5T), flip_sat) : OVERDRIVE_FA_0_5T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_0_5T), flip_satcfh) : OVERDRIVE_FA_0_5T;
    } else if (cffield == B0_40000) {
        /* REDFLAG : Using 1.5 T values (CHANGE !!!) */
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_4_0T), flip_sat) : OVERDRIVE_FA_4_0T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_4_0T), flip_satcfh) : OVERDRIVE_FA_4_0T;
        DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else if (cffield == B0_30000) {
        /* REDFLAG : Using 1.5 T values (CHANGE !!!) */
/* FATSAT FACTOR addition - HH June 2005 */
        flip_sat  = _flip_sat.fixedflag ?    ((void)(OVERDRIVE_FA_3_0T*acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : OVERDRIVE_FA_3_0T*acos(1.0-fatsat_factor)/acos(0.0);
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_3_0T), flip_satcfh) : OVERDRIVE_FA_3_0T;
        DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else if (cffield == B0_7000) {
        flip_sat  = _flip_sat.fixedflag ?  ((void)(OVERDRIVE_FA_0_7T), flip_sat) : OVERDRIVE_FA_0_7T;
        flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(OVERDRIVE_FA_0_7T), flip_satcfh) : OVERDRIVE_FA_0_7T;
        DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
    } else {
        SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
    }

    /* MRIge46643. The new optimized fat sat recalculates 
       the optimal flip angle for the chemsat pulse in ChemSatFlip.
       In cases where the sequence is limited by SAR (eg. ssfse), we need to
       over-estimate the flip angle before calculating the maxseqsar time  
       such that the actual SAR calculated in powermon_b1scale  
       never exceeds the safety limit. See SPR for details.
       - PRA/RJF 26May99 */

    /* Note, the condition must also check that it is not water suppression */ 
    /* flip_sat is initialized to 180.0 for new chemsat only, not for classic */
    /* MRIge85932 : Added oppseq in the logic to ensure only Spin Echo scans
       set flip_sat to 180. Gradient Echo scans do not have the new chemsat */

    if ( (exist(oppseq) == PSD_SE) && (exist(opfat) == PSD_ON) && (exist(opepi) == PSD_OFF) ) { 
        flip_sat  = _flip_sat.fixedflag ?   ((void)(180.0), flip_sat) : 180.0; 
    } 
 
    if( (cffield == B0_5000) || (cffield == B0_2000) || (cffield == B0_3500)) {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CSMIN8_PULSE), ChemSatPulse) : CSMIN8_PULSE;
    } else if(cffield > B0_15000) {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS3T_PULSE), ChemSatPulse) : CS3T_PULSE;		/*3T/4T default *YH*/
    } else {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CSM_PULSE), ChemSatPulse) : CSM_PULSE;
    }

    /* MRIhc26321 */ 
    /* AMR - FOR MRIhc27960 */
    if( (cffield >= B0_15000) && ( (PSD_ON == exist(opfatcl)) || (PSD_ON == exist(opfat)) )
        && (PSD_ON == exist(opcube)) )
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_ON), aspir_flag) : PSD_ON;
    }
    else if ((cffield >= B0_15000) && (PSD_ON==exist(opspecir)))
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_ON), aspir_flag) : PSD_ON;
    }
    else
    {
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_OFF), aspir_flag) : PSD_OFF;
    }

    if((cfrfmpwh < 20000) && (cfrfmpwb < 20000))
        aspir_flag  = _aspir_flag.fixedflag ?  ((void)(PSD_OFF), aspir_flag) : PSD_OFF;

    if(aspir_flag)
    {
       flip_sat  = _flip_sat.fixedflag ?  ((void)(180), flip_sat) : 180;
       flip_satcfh  = _flip_satcfh.fixedflag ?  ((void)(180), flip_satcfh) : 180;
       if ((cfrfmpwh>=40000) && (cfrfmpwb>=40000))
       {
           ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS_HSLS), ChemSatPulse) : CS_HSLS;       /* 40ms */
       }
       else if ((cfrfmpwh>=20000) && (cfrfmpwb>=20000))
       {   
           ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(CS_HS_20MS), ChemSatPulse) : CS_HS_20MS;
       }
       else
       {
          epic_error(use_ermes, "%s is incompatible with %s",
                     EM_PSD_INCOMPATIBLE, EE_ARGS(2), 
                     STRING_ARG, "ASPIR",
                     STRING_ARG, "the RF amplifier");
          return FAILURE;
       }
    } 
    /* AMR - FOR MRIhc27960 */
    else
    {
        aspir_cfoffset  = _aspir_cfoffset.fixedflag ?  ((void)(0), aspir_cfoffset) : 0;
        aspir_delay     = _aspir_delay.fixedflag ?  ((void)(0), aspir_delay) : 0;
    }
   
    /* FEC : Exploiting linear relationship with field Strength */

    fStrength = _fStrength.fixedflag ? ((void)(cffield), fStrength) : cffield;
    if (cffield==B0_2000) {
        fStrength = _fStrength.fixedflag ? ((void)(B0_5000), fStrength) : B0_5000;      /* ChemSat is not done in 0.2T systems !!! */
    }

/* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
/* HCSDM00403560: use DB_CS_PULSE on abdomen for duo_chemsat technique */
    if (((isCategoryMatchForAnatomy(opanatomy,ATTRIBUTE_CATEGORY_ABDOMEN) || 
        isCategoryMatchForAnatomy(opanatomy,ATTRIBUTE_CATEGORY_PELVIS)) && 
        (DB_DUO_CS == DB_flag)) || (DB_FE == DB_flag) || (DB_PE == DB_flag) || (DB_SS == DB_flag))
    {
        ChemSatPulse  = _ChemSatPulse.fixedflag ?  ((void)(DB_CS_PULSE), ChemSatPulse) : DB_CS_PULSE;
    }

    const float fsScale = (float)B0_15000/ (float)fStrength; 

    switch (ChemSatPulse) {

 
/* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    case DB_CS_PULSE:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_EFFWIDTH_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].area = SAR_AREA_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_MAX_B1_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_NOM_FA_MULTIBAND_FATSAT;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_NOM_PW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].nom_bw = SAR_NOM_BW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].isodelay = ISODELAY_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_EFFWIDTH_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AREA_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_MAX_B1_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_NOM_FA_MULTIBAND_FATSAT;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_NOM_PW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = SAR_NOM_BW_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].isodelay = ISODELAY_MULTIBAND_FATSAT;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;
        bw_ramp  = _bw_ramp.fixedflag ?  ((void)(BW_RAMP_MULTIBAND_FATSAT), bw_ramp) : BW_RAMP_MULTIBAND_FATSAT;

        if( (DB_DUO_CS == DB_flag) )
        {
            *rfpulse[RFCSSAT_SLOT].act_fa = sqrt(0.5 * (pow(DUO_END_FIRST_FA, 2) + pow(DUO_END_SECOND_FA, 2)));
        }

        break;
 
    case SINC_PULSE:
    default:

        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_SINC1;

        rfpulse[RFCSSAT_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RFCSSAT_SLOT].area = SAR_ASINC1;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RFCSSAT_SLOT].nom_fa = 90.0;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = 3200 ;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_ASINC1;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = 90.0;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = 3200 ;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;


        break;

    case CSM_PULSE:
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSM_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSM_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSM_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSM_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSM_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSM_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSM_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSM_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSM_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSM_NOM_PW;
        rfpulse[RFCSSAT_SLOT].nom_bw = NOM_BW_CSM;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSM_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSM_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSM_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSM_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSM_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSM_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSM_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSM_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSM_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSM_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = NOM_BW_CSM;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;

        /* *********************************************************** *
         * There is a major change here. Deleted all the overdrive     *
         * staff. defined CVs flip_sat and flip_satcfh. In the         *
         * ChenSatEval() subroutine, they both equal to the OVERDRIVE  *
         * value. flip_sat will be re-calculated in the new subroutine *
         * ChenSatFlip according to the scan protocol. flip_sat and    *
         * flip_satcfh will not be the same in the new optimized       *
         * ChemSat implementation. The act_fa field is set to flip_sat *
         * directly. flip_rfsat is set to act_fa inside the structure  *
         * directly. SGT                                               *
         * *********************************************************** */
        *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = flip_satcfh;

        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
             (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        break;

    case CSMIN8_PULSE:
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSMIN8_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSMIN8_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSMIN8_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSMIN8_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSMIN8_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSMIN8_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSMIN8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSMIN8_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSMIN8_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSMIN8_NOM_PW;
        rfpulse[RFCSSAT_SLOT].nom_bw = NOM_BW_CSMIN8;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSMIN8_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSMIN8_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSMIN8_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSMIN8_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSMIN8_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSMIN8_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSMIN8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSMIN8_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSMIN8_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSMIN8_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = NOM_BW_CSMIN8;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;

        if ( (((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
              ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D)))  ||
             (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
              (exist(opimode)==PSD_3D)) ) {

            if( (cffield == B0_5000) || (cffield == B0_2000) || (cffield == B0_3500)) {
                *rfpulse[RFCSSAT_SLOT].act_fa = 110.0;
                *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 110.0;
            } else {
                *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
                *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
            }
        }

        break;

    case CSMAX8_PULSE:
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CSMAX8_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CSMAX8_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CSMAX8_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CSMAX8_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CSMAX8_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CSMAX8_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CSMAX8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CSMAX8_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CSMAX8_NOM_FLIP;
        *rfpulse[RFCSSAT_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CSMAX8_NOM_PW;
        rfpulse[RFCSSAT_SLOT].nom_bw = NOM_BW_CSMAX8;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CSMAX8_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CSMAX8_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CSMAX8_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CSMAX8_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CSMAX8_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CSMAX8_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CSMAX8_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CSMAX8_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CSMAX8_NOM_FLIP;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 90.0;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CSMAX8_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = NOM_BW_CSMAX8;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;

        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) 
             && (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        break;

    case CS3T_PULSE:				/*YH*/
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCS3T), res_rfcssat) : RES_RFCS3T;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_CS3T_ABS_WIDTH;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_CS3T_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_CS3T_AREA;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_CS3T_DUTY_CYC;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_CS3T_MAX_PW;
        rfpulse[RFCSSAT_SLOT].max_b1 = SAR_CS3T_MAX_B1;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = SAR_CS3T_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = SAR_CS3T_MAX_RMS_B1;
        rfpulse[RFCSSAT_SLOT].nom_fa = SAR_CS3T_NOM_FLIP;
        rfpulse[RFCSSAT_SLOT].nom_pw = SAR_CS3T_NOM_PW;
        rfpulse[RFCSSAT_SLOT].nom_bw = NOM_BW_CS3T;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_CS3T_ABS_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_CS3T_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_CS3T_AREA;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_CS3T_DUTY_CYC;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_CS3T_MAX_PW;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = SAR_CS3T_MAX_B1;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = SAR_CS3T_MAX_INT_B1_SQ;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = SAR_CS3T_MAX_RMS_B1;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = SAR_CS3T_NOM_FLIP;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = SAR_CS3T_NOM_PW;
        rfpulse[RFCSSAT_CFH_SLOT].nom_bw = NOM_BW_CS3T;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = flip_satcfh;

        if ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) 
             && (exist(opfast)==PSD_ON) ) {
            *rfpulse[RFCSSAT_SLOT].act_fa = 100.0;
            *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 100.0;
        }

        if( (DB_DUO_CS == DB_flag) )
        {
            *rfpulse[RFCSSAT_SLOT].act_fa = sqrt(0.5 * (pow(DUO_END_FIRST_FA, 2) + pow(DUO_END_SECOND_FA, 2)));
        }

        break;

    case CS_HS:	
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_rfcssat) : RES_RFHS;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_HS;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_HS_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_AHS;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_HS;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_HS;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_HS;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_HS;
        rfpulse[RFCSSAT_SLOT].nom_fa = NOM_FLIP_HS;
        rfpulse[RFCSSAT_SLOT].nom_pw = NOM_PW_HS;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_HS;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_HS_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AHS;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_HS;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_HS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = NOM_FLIP_HS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = NOM_PW_HS;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = 180;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 180;
        break;

    case CS_HS_20MS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_rfcssat) : RES_RFHS_20MS;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RFCSSAT_SLOT].area = SAR_AHS_20MS;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;
        rfpulse[RFCSSAT_SLOT].nom_fa = NOM_FLIP_HS_20MS;
        rfpulse[RFCSSAT_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_HS_EFF_WIDTH_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AHS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = NOM_FLIP_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = NOM_PW_HS_20MS;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = 180;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 180;
        break;

    case CS_HSLS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHSLS), res_rfcssat) : RES_RFHSLS;
        rfpulse[RFCSSAT_SLOT].abswidth = SAR_ABS_HSLS;
        rfpulse[RFCSSAT_SLOT].effwidth = SAR_HSLS_EFF_WIDTH;
        rfpulse[RFCSSAT_SLOT].area = SAR_AHSLS;
        rfpulse[RFCSSAT_SLOT].dtycyc = SAR_DTYCYC_HSLS;
        rfpulse[RFCSSAT_SLOT].maxpw = SAR_MAXPW_HSLS;
        rfpulse[RFCSSAT_SLOT].max_b1 = MAX_B1_HSLS;
        rfpulse[RFCSSAT_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HSLS;
        rfpulse[RFCSSAT_SLOT].max_rms_b1 = MAX_RMS_B1_HSLS;
        rfpulse[RFCSSAT_SLOT].nom_fa = NOM_FLIP_HSLS;
        rfpulse[RFCSSAT_SLOT].nom_pw = NOM_PW_HSLS;
        rfpulse[RFCSSAT_SLOT].reference = 0;
        rfpulse[RFCSSAT_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_SLOT].apply_as_hadamard_factor = 1;
        rfpulse[RFCSSAT_CFH_SLOT].abswidth = SAR_ABS_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].effwidth = SAR_HSLS_EFF_WIDTH;
        rfpulse[RFCSSAT_CFH_SLOT].area = SAR_AHSLS;
        rfpulse[RFCSSAT_CFH_SLOT].dtycyc = SAR_DTYCYC_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].maxpw = SAR_MAXPW_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].max_b1 = MAX_B1_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].max_rms_b1 = MAX_RMS_B1_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_fa = NOM_FLIP_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].nom_pw = NOM_PW_HSLS;
        rfpulse[RFCSSAT_CFH_SLOT].reference = 0;
        rfpulse[RFCSSAT_CFH_SLOT].extgradfile = 1;
        rfpulse[RFCSSAT_CFH_SLOT].apply_as_hadamard_factor = 1;
        *rfpulse[RFCSSAT_SLOT].act_fa = 180;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = 180;
        break;

    }

    switch(ChemSatPulse)
    {
    case SINC_PULSE:
    default:
        switch((int ) cffield) {
        case B0_5000:
        case B0_3500: /* MFO,Hino, Feb/02/00 MM */
        case B0_2000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(600), res_rfcssat) : 600;
            break;
        case B0_15000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; /* default 1.5T value */
            break;
        case B0_10000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(300), res_rfcssat) : 300;
            break;
        case B0_40000:
            /* REDFLAG : Using same value as 1.5T. */
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; 
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        case B0_30000:
            /* REDFLAG : Using same value as 1.5T. */
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(200), res_rfcssat) : 200; 
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        case B0_7000:
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(300), res_rfcssat) : 300;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
            break;
        default:
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
        pw_rfcssat  = _pw_rfcssat.fixedflag ?    ((void)(RNEAREST_RF((int)(fsScale*16000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(fsScale*16000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((pw_rfcssat>>1))), cs_isodelay) : RDN_RF((pw_rfcssat>>1));         /* Divide by 2 */

        break;

    case CSM_PULSE:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSM), res_rfcssat) : RES_RFCSM;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?    ((void)(RNEAREST_RF((int)(fsScale*16000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(fsScale*16000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(3.16957)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(3.16957)));
        bw_rfcssat  = _bw_rfcssat.fixedflag ?  ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        break;



/* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    case DB_CS_PULSE:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_MULTIBAND_FATSAT), res_rfcssat) : RES_MULTIBAND_FATSAT;
        if (B0_30000 == cffield)
        {
            pw_rfcssat   = _pw_rfcssat.fixedflag ?  ((void)(PW_MULTIBAND_FATSAT_3T), pw_rfcssat) : PW_MULTIBAND_FATSAT_3T;
        }
        else
        {
            pw_rfcssat   = _pw_rfcssat.fixedflag ?  ((void)(PW_MULTIBAND_FATSAT), pw_rfcssat) : PW_MULTIBAND_FATSAT;
        }

        bw_rfcssat_nom  = _bw_rfcssat_nom.fixedflag ?     ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat_nom) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        bw_rfcssat_ramp  = _bw_rfcssat_ramp.fixedflag ?     ((void)(bw_ramp*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat_ramp) : bw_ramp*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        bw_rfcssat  = _bw_rfcssat.fixedflag ?    ((void)(bw_rfcssat_nom+bw_rfcssat_ramp), bw_rfcssat) : bw_rfcssat_nom+bw_rfcssat_ramp;
        cs_isodelay  = _cs_isodelay.fixedflag ?     ((void)(rfpulse[RFCSSAT_SLOT].isodelay*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), cs_isodelay) : rfpulse[RFCSSAT_SLOT].isodelay*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;

        if (B0_15000 == cffield)
        {
            DB_Chemical_Shift  = _DB_Chemical_Shift.fixedflag ?  ((void)(220.0), DB_Chemical_Shift) : 220.0;
        }
        else if (B0_30000 == cffield)
        {
            DB_Chemical_Shift  = _DB_Chemical_Shift.fixedflag ?  ((void)(440.0), DB_Chemical_Shift) : 440.0;
        }
        else
        {
            epic_error(0,"DB_Chemical_Shift is not defined.",0,EE_ARGS(0));
            return FAILURE;
        }

        if(bw_rfcssat - bw_rfcssat_ramp < DB_Chemical_Shift)
        {
            epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),STRING_ARG,"ChemSatEval");
            return FAILURE; 
        }
        else if(PSD_ON == DBgrad_flag)
        {
            dbbandlocx1  = _dbbandlocx1.fixedflag ?    
                             ((void)(scan_info[0].oprloc+scan_info[0].oprloc_shift+(get_act_freq_fov()*(0.5+DB_Buffer_X))), dbbandlocx1) : scan_info[0].oprloc+scan_info[0].oprloc_shift+(get_act_freq_fov()*(0.5+DB_Buffer_X));
            dbbandlocx2  = _dbbandlocx2.fixedflag ?    
                             ((void)(scan_info[0].oprloc+scan_info[0].oprloc_shift-(get_act_freq_fov()*(0.5+DB_Buffer_X))), dbbandlocx2) : scan_info[0].oprloc+scan_info[0].oprloc_shift-(get_act_freq_fov()*(0.5+DB_Buffer_X));
            dbbandlocy1  = _dbbandlocy1.fixedflag ?    
                             ((void)(scan_info[0].opphasoff+scan_info[0].opphasoff_shift+(get_act_phase_fov()*(0.5+DB_Buffer_Y))), dbbandlocy1) : scan_info[0].opphasoff+scan_info[0].opphasoff_shift+(get_act_phase_fov()*(0.5+DB_Buffer_Y));
            dbbandlocy2  = _dbbandlocy2.fixedflag ?    
                             ((void)(scan_info[0].opphasoff+scan_info[0].opphasoff_shift-(get_act_phase_fov()*(0.5+DB_Buffer_Y))), dbbandlocy2) : scan_info[0].opphasoff+scan_info[0].opphasoff_shift-(get_act_phase_fov()*(0.5+DB_Buffer_Y));
            dbbandlocz1  = _dbbandlocz1.fixedflag ?    
                             ((void)(scan_info[(int)(opslquant/2.0)].optloc+scan_info[(int)(opslquant/2.0)].optloc_shift+((opslthick+opslspace)*opslquant)), dbbandlocz1) : scan_info[(int)(opslquant/2.0)].optloc+scan_info[(int)(opslquant/2.0)].optloc_shift+((opslthick+opslspace)*opslquant);
            dbbandlocz2  = _dbbandlocz2.fixedflag ?    
                             ((void)(scan_info[(int)(opslquant/2.0)].optloc+scan_info[(int)(opslquant/2.0)].optloc_shift-((opslthick+opslspace)*opslquant)), dbbandlocz2) : scan_info[(int)(opslquant/2.0)].optloc+scan_info[(int)(opslquant/2.0)].optloc_shift-((opslthick+opslspace)*opslquant);
    
            dbsatthickx  = _dbsatthickx.fixedflag ?            ((void)((float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocx1-dbbandlocx2)/(DB_Chemical_Shift-bw_rfcssat_ramp)), dbsatthickx) : (float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocx1-dbbandlocx2)/(DB_Chemical_Shift-bw_rfcssat_ramp);
            dbcenterlocx1  = _dbcenterlocx1.fixedflag ?         ((void)((float)dbbandlocx1+dbsatthickx*(0.5-DB_shift_ratio)), dbcenterlocx1) : (float)dbbandlocx1+dbsatthickx*(0.5-DB_shift_ratio);
            dbcenterlocx2  = _dbcenterlocx2.fixedflag ?         ((void)((float)dbbandlocx2-dbsatthickx*(0.5-DB_shift_ratio)), dbcenterlocx2) : (float)dbbandlocx2-dbsatthickx*(0.5-DB_shift_ratio);
            dbsatthicky  = _dbsatthicky.fixedflag ?            ((void)((float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocy1-dbbandlocy2)/(DB_Chemical_Shift-bw_rfcssat_ramp)), dbsatthicky) : (float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocy1-dbbandlocy2)/(DB_Chemical_Shift-bw_rfcssat_ramp);
            dbcenterlocy1  = _dbcenterlocy1.fixedflag ?         ((void)((float)dbbandlocy1+dbsatthicky*(0.5-DB_shift_ratio)), dbcenterlocy1) : (float)dbbandlocy1+dbsatthicky*(0.5-DB_shift_ratio);
            dbcenterlocy2  = _dbcenterlocy2.fixedflag ?         ((void)((float)dbbandlocy2-dbsatthicky*(0.5-DB_shift_ratio)), dbcenterlocy2) : (float)dbbandlocy2-dbsatthicky*(0.5-DB_shift_ratio);
            dbsatthickz  = _dbsatthickz.fixedflag ?            ((void)((float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocz1-dbbandlocz2)/(DB_Chemical_Shift-bw_rfcssat_ramp)), dbsatthickz) : (float)bw_rfcssat*DB_ChemShift*fabs(dbbandlocz1-dbbandlocz2)/(DB_Chemical_Shift-bw_rfcssat_ramp);
            dbcenterlocz1  = _dbcenterlocz1.fixedflag ?         ((void)((float)dbbandlocz1+dbsatthickz*(0.5-DB_shift_ratio)), dbcenterlocz1) : (float)dbbandlocz1+dbsatthickz*(0.5-DB_shift_ratio);
            dbcenterlocz2  = _dbcenterlocz2.fixedflag ?         ((void)((float)dbbandlocz2-dbsatthickz*(0.5-DB_shift_ratio)), dbcenterlocz2) : (float)dbbandlocz2-dbsatthickz*(0.5-DB_shift_ratio);

            if (DB_FE == DB_flag)
            {
                if (ampslice(_a_dbgxrfcssat.fixedflag ? (_temp705_a_dbgxrfcssat=a_dbgxrfcssat,&_temp705_a_dbgxrfcssat) : &a_dbgxrfcssat, bw_rfcssat, dbsatthickx, 1.0, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgxrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
                    return FAILURE;
                }

                if (optramp(_pw_dbgxrfcssata.fixedflag ? (_temp706_pw_dbgxrfcssata=pw_dbgxrfcssata,&_temp706_pw_dbgxrfcssata) : &pw_dbgxrfcssata, a_dbgxrfcssat, loggrd.tx_xyz,
                            loggrd.xrt, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgxrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "optramp");
                    return FAILURE;
                }
                pw_dbgxrfcssatd  = _pw_dbgxrfcssatd.fixedflag ?  ((void)(pw_dbgxrfcssata), pw_dbgxrfcssatd) : pw_dbgxrfcssata;
                pw_dbgxrfcssat  = _pw_dbgxrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgxrfcssat) : pw_rfcssat;
                a_dbgxrfcssat  = _a_dbgxrfcssat.fixedflag ?    ((void)((-1.0)*a_dbgxrfcssat), a_dbgxrfcssat) : (-1.0)*a_dbgxrfcssat;
                off_rfcssat1  = _off_rfcssat1.fixedflag ?       ((void)(GAM*a_dbgxrfcssat*dbcenterlocx1/10.0), off_rfcssat1) : GAM*a_dbgxrfcssat*dbcenterlocx1/10.0;
                off_rfcssat2  = _off_rfcssat2.fixedflag ?         ((void)((-1.0)*GAM*a_dbgxrfcssat*dbcenterlocx2/10.0), off_rfcssat2) : (-1.0)*GAM*a_dbgxrfcssat*dbcenterlocx2/10.0;
    
                pw_dbgyrfcssata  = _pw_dbgyrfcssata.fixedflag ?  ((void)(pw_dbgxrfcssata), pw_dbgyrfcssata) : pw_dbgxrfcssata;
                pw_dbgyrfcssatd  = _pw_dbgyrfcssatd.fixedflag ?  ((void)(pw_dbgyrfcssata), pw_dbgyrfcssatd) : pw_dbgyrfcssata;
                pw_dbgyrfcssat  = _pw_dbgyrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgyrfcssat) : pw_rfcssat;
                a_dbgyrfcssat  = _a_dbgyrfcssat.fixedflag ?  ((void)(0), a_dbgyrfcssat) : 0;
    
                pw_dbgzrfcssata  = _pw_dbgzrfcssata.fixedflag ?  ((void)(pw_dbgxrfcssata), pw_dbgzrfcssata) : pw_dbgxrfcssata;
                pw_dbgzrfcssatd  = _pw_dbgzrfcssatd.fixedflag ?  ((void)(pw_dbgzrfcssata), pw_dbgzrfcssatd) : pw_dbgzrfcssata;
                pw_dbgzrfcssat  = _pw_dbgzrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgzrfcssat) : pw_rfcssat;
                a_dbgzrfcssat  = _a_dbgzrfcssat.fixedflag ?  ((void)(0), a_dbgzrfcssat) : 0;
            }
            if (DB_PE == DB_flag)
            {
                if (ampslice(_a_dbgyrfcssat.fixedflag ? (_temp707_a_dbgyrfcssat=a_dbgyrfcssat,&_temp707_a_dbgyrfcssat) : &a_dbgyrfcssat, bw_rfcssat, dbsatthicky, 1.0, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgyrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
                    return FAILURE;
                }
    
                if (optramp(_pw_dbgyrfcssata.fixedflag ? (_temp708_pw_dbgyrfcssata=pw_dbgyrfcssata,&_temp708_pw_dbgyrfcssata) : &pw_dbgyrfcssata, a_dbgyrfcssat, loggrd.ty_xyz,
                            loggrd.yrt, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgyrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "optramp");
                    return FAILURE;
                }
                pw_dbgyrfcssatd  = _pw_dbgyrfcssatd.fixedflag ?  ((void)(pw_dbgyrfcssata), pw_dbgyrfcssatd) : pw_dbgyrfcssata;
                pw_dbgyrfcssat  = _pw_dbgyrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgyrfcssat) : pw_rfcssat;
                a_dbgyrfcssat  = _a_dbgyrfcssat.fixedflag ?    ((void)((-1.0)*a_dbgyrfcssat), a_dbgyrfcssat) : (-1.0)*a_dbgyrfcssat;
                off_rfcssat1  = _off_rfcssat1.fixedflag ?       ((void)(GAM*a_dbgyrfcssat*dbcenterlocy1/10.0), off_rfcssat1) : GAM*a_dbgyrfcssat*dbcenterlocy1/10.0;
                off_rfcssat2  = _off_rfcssat2.fixedflag ?         ((void)((-1.0)*GAM*a_dbgyrfcssat*dbcenterlocy2/10.0), off_rfcssat2) : (-1.0)*GAM*a_dbgyrfcssat*dbcenterlocy2/10.0;
    
                pw_dbgxrfcssata  = _pw_dbgxrfcssata.fixedflag ?  ((void)(pw_dbgyrfcssata), pw_dbgxrfcssata) : pw_dbgyrfcssata;
                pw_dbgxrfcssatd  = _pw_dbgxrfcssatd.fixedflag ?  ((void)(pw_dbgxrfcssata), pw_dbgxrfcssatd) : pw_dbgxrfcssata;
                pw_dbgxrfcssat  = _pw_dbgxrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgxrfcssat) : pw_rfcssat;
                a_dbgxrfcssat  = _a_dbgxrfcssat.fixedflag ?  ((void)(0), a_dbgxrfcssat) : 0;
    
                pw_dbgzrfcssata  = _pw_dbgzrfcssata.fixedflag ?  ((void)(pw_dbgyrfcssata), pw_dbgzrfcssata) : pw_dbgyrfcssata;
                pw_dbgzrfcssatd  = _pw_dbgzrfcssatd.fixedflag ?  ((void)(pw_dbgzrfcssata), pw_dbgzrfcssatd) : pw_dbgzrfcssata;
                pw_dbgzrfcssat  = _pw_dbgzrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgzrfcssat) : pw_rfcssat;
                a_dbgzrfcssat  = _a_dbgzrfcssat.fixedflag ?  ((void)(0), a_dbgzrfcssat) : 0;
            }
            if (DB_SS == DB_flag)
            {
                if (ampslice(_a_dbgzrfcssat.fixedflag ? (_temp709_a_dbgzrfcssat=a_dbgzrfcssat,&_temp709_a_dbgzrfcssat) : &a_dbgzrfcssat, bw_rfcssat, dbsatthickz, 1.0, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgzrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
                    return FAILURE;
                }
    
                if (optramp(_pw_dbgzrfcssata.fixedflag ? (_temp710_pw_dbgzrfcssata=pw_dbgzrfcssata,&_temp710_pw_dbgzrfcssata) : &pw_dbgzrfcssata, a_dbgzrfcssat, loggrd.tz_xyz,
                            loggrd.zrt, TYPDEF) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed for dbgzrfcssat", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "optramp");
                    return FAILURE;
                }
                pw_dbgzrfcssatd  = _pw_dbgzrfcssatd.fixedflag ?  ((void)(pw_dbgzrfcssata), pw_dbgzrfcssatd) : pw_dbgzrfcssata;
                pw_dbgzrfcssat  = _pw_dbgzrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgzrfcssat) : pw_rfcssat;
                a_dbgzrfcssat  = _a_dbgzrfcssat.fixedflag ?    ((void)((-1.0)*a_dbgzrfcssat), a_dbgzrfcssat) : (-1.0)*a_dbgzrfcssat;
                off_rfcssat1  = _off_rfcssat1.fixedflag ?       ((void)(GAM*a_dbgzrfcssat*dbcenterlocz1/10.0), off_rfcssat1) : GAM*a_dbgzrfcssat*dbcenterlocz1/10.0;
                off_rfcssat2  = _off_rfcssat2.fixedflag ?         ((void)((-1.0)*GAM*a_dbgzrfcssat*dbcenterlocz2/10.0), off_rfcssat2) : (-1.0)*GAM*a_dbgzrfcssat*dbcenterlocz2/10.0;
    
                pw_dbgyrfcssata  = _pw_dbgyrfcssata.fixedflag ?  ((void)(pw_dbgzrfcssata), pw_dbgyrfcssata) : pw_dbgzrfcssata;
                pw_dbgyrfcssatd  = _pw_dbgyrfcssatd.fixedflag ?  ((void)(pw_dbgyrfcssata), pw_dbgyrfcssatd) : pw_dbgyrfcssata;
                pw_dbgyrfcssat  = _pw_dbgyrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgyrfcssat) : pw_rfcssat;
                a_dbgyrfcssat  = _a_dbgyrfcssat.fixedflag ?  ((void)(0), a_dbgyrfcssat) : 0;
    
                pw_dbgxrfcssata  = _pw_dbgxrfcssata.fixedflag ?  ((void)(pw_dbgzrfcssata), pw_dbgxrfcssata) : pw_dbgzrfcssata;
                pw_dbgxrfcssatd  = _pw_dbgxrfcssatd.fixedflag ?  ((void)(pw_dbgxrfcssata), pw_dbgxrfcssatd) : pw_dbgxrfcssata;
                pw_dbgxrfcssat  = _pw_dbgxrfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_dbgxrfcssat) : pw_rfcssat;
                a_dbgxrfcssat  = _a_dbgxrfcssat.fixedflag ?  ((void)(0), a_dbgxrfcssat) : 0;
            }
        }
            
        break;
        
    case CSMIN8_PULSE:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSMIN8), res_rfcssat) : RES_RFCSMIN8;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?    ((void)(RNEAREST_RF((int)(fsScale*8000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(fsScale*8000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(1.8957346)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(1.8957346)));
        bw_rfcssat  = _bw_rfcssat.fixedflag ?  ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        break;

    case CSMAX8_PULSE:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCSMAX8), res_rfcssat) : RES_RFCSMAX8;
        pw_rfcssat   = _pw_rfcssat.fixedflag ?    ((void)(RNEAREST_RF((int)(fsScale*8000),res_rfcssat)), pw_rfcssat) : RNEAREST_RF((int)(fsScale*8000),res_rfcssat);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((int)(pw_rfcssat/(1.7857143)))), cs_isodelay) : RDN_RF((int)(pw_rfcssat/(1.7857143)));
        bw_rfcssat  = _bw_rfcssat.fixedflag ?  ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        break;

    case CS3T_PULSE:				/*new pulse for 3T/4T	*YH*/
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFCS3T), res_rfcssat) : RES_RFCS3T;	/*200*/
        pw_rfcssat   = _pw_rfcssat.fixedflag ?    ((void)(RNEAREST_RF((int)(fsScale*16000),res_rfcssat*4)), pw_rfcssat) : RNEAREST_RF((int)(fsScale*16000),res_rfcssat*4);
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF((pw_rfcssat>>1))), cs_isodelay) : RDN_RF((pw_rfcssat>>1));         /* Divide by 2 */
        bw_rfcssat  = _bw_rfcssat.fixedflag ?  ((void)(rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat), bw_rfcssat) : rfpulse[RFCSSAT_SLOT].nom_bw*rfpulse[RFCSSAT_SLOT].nom_pw/pw_rfcssat;
        break;

    case CS_HS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_rfcssat) : RES_RFHS;
        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(NOM_PW_HS), pw_rfcssat) : NOM_PW_HS;
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF(pw_rfcssat>>1)), cs_isodelay) : RDN_RF(pw_rfcssat>>1);
        res_omega_hs_rfcssat  = _res_omega_hs_rfcssat.fixedflag ?  ((void)(RES_RFHS), res_omega_hs_rfcssat) : RES_RFHS;
        pw_omega_hs_rfcssat  = _pw_omega_hs_rfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_omega_hs_rfcssat) : pw_rfcssat;
        a_omega_hs_rfcssat  = _a_omega_hs_rfcssat.fixedflag ?  ((void)(-1.0), a_omega_hs_rfcssat) : -1.0;
        ia_omega_hs_rfcssat  = _ia_omega_hs_rfcssat.fixedflag ?  ((void)(-max_pg_iamp), ia_omega_hs_rfcssat) : -max_pg_iamp;
        break;

    case CS_HS_20MS:
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_rfcssat) : RES_RFHS_20MS;
        pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(NOM_PW_HS_20MS), pw_rfcssat) : NOM_PW_HS_20MS;
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF(pw_rfcssat>>1)), cs_isodelay) : RDN_RF(pw_rfcssat>>1);
        res_omega_hs_rfcssat  = _res_omega_hs_rfcssat.fixedflag ?  ((void)(RES_RFHS_20MS), res_omega_hs_rfcssat) : RES_RFHS_20MS;
        pw_omega_hs_rfcssat  = _pw_omega_hs_rfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_omega_hs_rfcssat) : pw_rfcssat;
        a_omega_hs_rfcssat  = _a_omega_hs_rfcssat.fixedflag ?  ((void)(-1.0), a_omega_hs_rfcssat) : -1.0;
        ia_omega_hs_rfcssat  = _ia_omega_hs_rfcssat.fixedflag ?  ((void)(-max_pg_iamp), ia_omega_hs_rfcssat) : -max_pg_iamp;
        break;
    
    case CS_HSLS:
        res_rfcssat    = _res_rfcssat.fixedflag ?  ((void)(RES_RFHSLS), res_rfcssat) : RES_RFHSLS;
        pw_rfcssat     = _pw_rfcssat.fixedflag ?  ((void)(NOM_PW_HSLS), pw_rfcssat) : NOM_PW_HSLS;
        cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(RDN_RF(pw_rfcssat>>1)), cs_isodelay) : RDN_RF(pw_rfcssat>>1);
        res_omega_hs_rfcssat  = _res_omega_hs_rfcssat.fixedflag ?  ((void)(RES_RFHSLS), res_omega_hs_rfcssat) : RES_RFHSLS;
        pw_rfcssatcfh  = _pw_rfcssatcfh.fixedflag ?  ((void)(pw_rfcssat), pw_rfcssatcfh) : pw_rfcssat;
        pw_omega_hs_rfcssat  = _pw_omega_hs_rfcssat.fixedflag ?  ((void)(pw_rfcssat), pw_omega_hs_rfcssat) : pw_rfcssat;
        a_omega_hs_rfcssat  = _a_omega_hs_rfcssat.fixedflag ?  ((void)(-1.0), a_omega_hs_rfcssat) : -1.0;
        ia_omega_hs_rfcssat  = _ia_omega_hs_rfcssat.fixedflag ?  ((void)(-max_pg_iamp), ia_omega_hs_rfcssat) : -max_pg_iamp;
        break;

    }
    pw_rfcssatcfh  = _pw_rfcssatcfh.fixedflag ?  ((void)(pw_rfcssat), pw_rfcssatcfh) : pw_rfcssat;  /* MRIhc06663: set cfh cssat pulse */

    if (selectiveChemsat)
    {
        /* empirically determined to have optimum IQ benefit to minimize
         * MT effect and still ensure adequate FAT suppression. Used
         * with 3dtof */ 
        if (B0_30000 == cffield)
        {
            offset_rfchemsat  = _offset_rfchemsat.fixedflag ?  ((void)(SELECTIVE_OFFSET_3T), offset_rfchemsat) : SELECTIVE_OFFSET_3T;
        }
        else
        {
            offset_rfchemsat  = _offset_rfchemsat.fixedflag ?  ((void)(SELECTIVE_OFFSET_15T), offset_rfchemsat) : SELECTIVE_OFFSET_15T;
        }
        pw_gzrfcs  = _pw_gzrfcs.fixedflag ?  ((void)(pw_rfcssat), pw_gzrfcs) : pw_rfcssat;

        a_gzrfcs  = _a_gzrfcs.fixedflag ?  ((void)(offset_rfchemsat/SELECTIVE_OFFSET_DIST/GAM), a_gzrfcs) : offset_rfchemsat/SELECTIVE_OFFSET_DIST/GAM;
        
        pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?    ((void)(RUP_GRD((int)((loggrd.zrt)/(loggrd.zfs)*a_gzrfcs))), pw_gzrfcsa) : RUP_GRD((int)((loggrd.zrt)/(loggrd.zfs)*a_gzrfcs));
        if (pw_gzrfcsa < MIN_PLATEAU_TIME)
           pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?  ((void)(MIN_PLATEAU_TIME), pw_gzrfcsa) : MIN_PLATEAU_TIME; 
        pw_gzrfcsd  = _pw_gzrfcsd.fixedflag ?  ((void)(pw_gzrfcsa), pw_gzrfcsd) : pw_gzrfcsa;
    }
    else
    {
      pw_gzrfcsa  = _pw_gzrfcsa.fixedflag ?  ((void)(0), pw_gzrfcsa) : 0;
      pw_gzrfcsd  = _pw_gzrfcsd.fixedflag ?  ((void)(0), pw_gzrfcsd) : 0;
      a_gzrfcs  = _a_gzrfcs.fixedflag ?  ((void)(0.0), a_gzrfcs) : 0.0;
      pw_gzrfcs  = _pw_gzrfcs.fixedflag ?  ((void)(0), pw_gzrfcs) : 0;

    }
    /* Exception for 0.2T and 0.5T field Strengths */
    /* MFO,Hino, Feb/02/00 MM */
    if ((ChemSatPulse==CSMIN8_PULSE) && (cffield==B0_2000 || cffield==B0_5000 || cffield==B0_3500)) {
        if ( (((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
              ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D))) ||
             (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
              (exist(opimode)==PSD_3D)) ) {
            pw_rfcssat  = _pw_rfcssat.fixedflag ?  ((void)(16000), pw_rfcssat) : 16000;
            cs_isodelay  = _cs_isodelay.fixedflag ?    ((void)(8440), cs_isodelay) : 8440;
            pw_rfcssatcfh  = _pw_rfcssatcfh.fixedflag ?  ((void)(16000), pw_rfcssatcfh) : 16000;
        }
    }

	
    if ( (PSD_ON == fatFlag) || (exist(opwater) == PSD_ON)) {

        csxkiller_flag=cszkiller_flag=0;
        area_gxkcs = _area_gxkcs.fixedflag ? ((void)(3450), area_gxkcs) : 3450;
        area_gykcs = _area_gykcs.fixedflag ? ((void)(3220), area_gykcs) : 3220;

        /* SVBranch HCSDM00091804: Duo Chemical Saturation */
        if (PSD_ON == duo_cs_flag)
        {
                killer_scale  = _killer_scale.fixedflag ?  ((void)(0.73), killer_scale) : 0.73;                 /* value set to 0.73 to block pathway of stimulted echoes */ 
                area_gykcs  = _area_gykcs.fixedflag ?   ((void)(3220/killer_scale), area_gykcs) : 3220/killer_scale;    /* here we want to increase the killer for 1st ChemSat pulse. */
                               	                     /* Second ChemSat pulse killer will remain the same. WXC */
        }
        else
        {
               area_gykcs  = _area_gykcs.fixedflag ?  ((void)(3220), area_gykcs) : 3220;
        }

	/* need more crusher for ASPIR when combined with spatial sats : RFB 23-Jan-07 */
        if (aspir_flag)
            area_gykcs = _area_gykcs.fixedflag ? ((void)(6440), area_gykcs) : 6440;

#ifdef  ADDYCRUSHER

        /*  Increase the area of gykcs for high resolution 
            fsemaster or SE scans. AC, MRIge83262 */

        if((PSD_SE == exist(oppseq)) && (PSD_ON == fatFlag)) { 

            /* If the area of gy1 trapezoid is large compare to area_gykcs,
               we need to set the area of gykcs fat sat killer pulse to %20
               more of gy1 area (area_gykcs= 1.2 * area_gy1grad). Relevant SPRs:
               MRIge79885 (9.2) and MRIge79887(mgd).  AC */

            float area_gy1gradse = 0.0;

            area_gy1gradse = fabs(((a_gy1a + a_gy1b) * pw_gy1a/2.0)+ ((a_gy1a + a_gy1b)/2.0)*pw_gy1);

            if (area_gykcs < (1.2 * area_gy1gradse)) {
                area_gykcs = _area_gykcs.fixedflag ?    ((void)(1.2*area_gy1gradse), area_gykcs) : 1.2*area_gy1gradse;
            }
        }

#endif

        area_gyakcs = _area_gyakcs.fixedflag ? ((void)(2470), area_gyakcs) : 2470;
        area_gzkcs = _area_gzkcs.fixedflag ? ((void)(3450), area_gzkcs) : 3450;
        target_amp_x = 0.0;
        target_amp_y = loggrd.ty/csk_derate_factor;
        target_amp_z = 0.0;

        /* HCSDM00277862: Incease crushers to minimize artifacts from uncrushed signal */
        if ( ((PSD_TOF == exist(oppseq)) || (PSD_TOFSP == exist(oppseq))) &&
             (PSD_3D == exist(opimode)) && (PSD_OFF ==exist(opfast)) )
        {
            area_gxkcs  = _area_gxkcs.fixedflag ?  ((void)(6800), area_gxkcs) : 6800;
            area_gykcs  = _area_gykcs.fixedflag ?  ((void)(6800), area_gykcs) : 6800;
            area_gzkcs  = _area_gzkcs.fixedflag ?  ((void)(6800), area_gzkcs) : 6800;
        }

#ifdef CSXKILLER
    	csxkiller_flag=1;
#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
        if(duo_cs_flag)
        {
            cszkiller_flag=1;
            area_gzkcs  = _area_gzkcs.fixedflag ?  ((void)(area_gykcs), area_gzkcs) : area_gykcs;
        }
        else
        {
            cszkiller_flag = 0;
        }
#else

    	cszkiller_flag=1;
#endif
#endif

#ifdef CSYKILLERA
    	csyakiller_flag=1;
#endif
	
        if( (csxkiller_flag==1) && (cszkiller_flag==0) ) 
        {
            target_amp_x = loggrd.tx_xy/csk_derate_factor;
            target_amp_y = loggrd.ty_xy/csk_derate_factor;
        }

        if( (csxkiller_flag==0) && (cszkiller_flag==1) ) 
        {
            target_amp_y = loggrd.ty_yz/csk_derate_factor;
            target_amp_z = loggrd.tz_yz/csk_derate_factor;
        }

        if( (csxkiller_flag==1) && (cszkiller_flag==1) ) 
        {
            target_amp_x = loggrd.tx_xyz/csk_derate_factor;
            target_amp_y = loggrd.ty_xyz/csk_derate_factor;
            target_amp_z = loggrd.tz_xyz/csk_derate_factor;
        }

        if(silent_mode)
         {
             if(csxkiller_flag==1)
             {
                 riseTimeX = RUP_GRD(loggrd.tx/(float )(silent_slew_rate/10) *1000*csk_derate_factor);
             }
             else
             {
                 riseTimeX = RUP_GRD(loggrd.tx/(float )(silent_slew_rate/10) *1000);
             }
             riseTimeY = RUP_GRD(loggrd.ty/(float )(silent_slew_rate/10) *1000*csk_derate_factor);
             if(cszkiller_flag==1)
             {
                 riseTimeZ = RUP_GRD(loggrd.tz/(float )(silent_slew_rate/10) *1000*csk_derate_factor);
             }
             else
             {
                 riseTimeZ = RUP_GRD(loggrd.tz/(float )(silent_slew_rate/10) *1000);
             }
         }
         else
         {
             riseTimeX = loggrd.xrt*csk_derate_factor;
             riseTimeY = loggrd.yrt*csk_derate_factor;
             riseTimeZ = loggrd.zrt*csk_derate_factor;
         }

        if ((amppwgradmethod(&grady[GYKCS_SLOT], area_gykcs, target_amp_y,
                             0.0, 0.0,riseTimeY,
                             MIN_PLATEAU_TIME))==FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amppwgradmethod:gykcs");
            return FAILURE;
        }

        grady[GYKCS_SLOT].num = 1;
        grady[GYKCS_SLOT].powscale = loggrd.yfs/target_amp_y;

#ifdef CSXKILLER
         
        if ((amppwgradmethod(&gradx[GXKCS_SLOT], area_gxkcs, target_amp_x,
                             0.0, 0.0,riseTimeX,
                             MIN_PLATEAU_TIME))==FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amppwgradmethod:gxkcs");
            return FAILURE;
        }

        gradx[GXKCS_SLOT].num = 1;
        gradx[GXKCS_SLOT].powscale = loggrd.xfs/target_amp_x;  /*  QT*/

#endif

#ifdef CSYKILLERA
        
        if ((amppwgradmethod(&grady[GYKCS_SLOT], area_gyakcs, target_amp_y,
                             0.0, 0.0,riseTimeY,
                             MIN_PLATEAU_TIME)) == FAILURE) {
            epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,
                       "amppwgradmethod:gyakcs");
            return FAILURE;
        }
 
        grady[GYKCS_SLOT].num = 1;
        grady[GYKCS_SLOT].powscale = loggrd.yfs/target_amp_y;  /* QT*/
 
#endif
 
/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
        if(duo_cs_flag)
        {
            if ((amppwgradmethod(&gradz[GZKCS_SLOT], area_gzkcs, target_amp_z,
                             0.0, 0.0,loggrd.zrt,MIN_PLATEAU_TIME))==FAILURE) {
                epic_error(use_ermes, "%s failed in ChemSatEval",
                           EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,
                           "amppwgradmethod:gzkcs");
                return FAILURE;
            }

            gradz[GZKCS_SLOT].num = 1;
            gradz[GZKCS_SLOT].powscale = loggrd.xfs/target_amp_z;  /* QT*/

        }
        else
        {
            gradz[GZKCS_SLOT].num = 0;
        }
#else 
        if ((amppwgradmethod(&gradz[GZKCS_SLOT], area_gzkcs, target_amp_z,
                             0.0, 0.0, riseTimeZ,
                             MIN_PLATEAU_TIME))==FAILURE) {
    	    epic_error(use_ermes, "%s failed in ChemSatEval",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,
                       "amppwgradmethod:gzkcs");
    	    return FAILURE;
        }
 
        gradz[GZKCS_SLOT].num = 1;
        gradz[GZKCS_SLOT].powscale = loggrd.xfs/target_amp_z;  /* QT*/
#endif 
#endif
/* HCSDM00404382: set number of cssat pulses to 2 when DB_DUO_CS is on */
        if (DB_DUO_CS == DB_flag)
        {
           rfpulse[RFCSSAT_SLOT].num = 2;
        }
        else
        {
           rfpulse[RFCSSAT_SLOT].num = 1;
        }
 
        *time_cssat = RUP_GRD(-rfupa + CHEM_SSP_FREQ_TIME + pw_rfcssat + 
                              IMax(3,
                                   pw_gxkcsa+ pw_gxkcs+pw_gxkcsd,
                                   pw_gykcsa+ pw_gykcs+pw_gykcsd,
                                   pw_gzkcsa+ pw_gzkcs+pw_gzkcsd) +
                                   exist(pw_dbgxrfcssata)+ exist(pw_dbgxrfcssatd)    /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
                              );

        if (aspir_flag)
        {
           if(PSD_ON==exist(opspecir))
           {
               if((PSD_SE == exist(oppseq)) && (opimode == PSD_2D) && (opfast == PSD_ON) && (opssfse == PSD_OFF) ) /* 2D FSE Aspir */
               {
                   aspir_minti = _aspir_minti.fixedflag ?  
                                           
                                                
                                                
                                         ((void)(RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+GRAD_UPDATE_TIME)), aspir_minti) : RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+GRAD_UPDATE_TIME);
                   /* For 2DFSE, chem sat is part of FSE sequence, no
                    * need to include the time_ssi.  */
                   aspir_minti  = _aspir_minti.fixedflag ?      ((void)(aspir_minti+cs_delay+sp_sattime), aspir_minti) : aspir_minti+cs_delay+sp_sattime; /* more accurate to include the excitation RF pulse delay time */
		   aspir_minti  = _aspir_minti.fixedflag ?    ((void)(IMax(2,aspir_minti,FSE_ASPIR_MIN_TI)), aspir_minti) : IMax(2,aspir_minti,FSE_ASPIR_MIN_TI); /*MCARL: Moved this line up to be specific for aspir in accordance to Lings commend*/
               }
               else
               {
                   aspir_minti = _aspir_minti.fixedflag ?  
                                           
                                                
                                                
                                           ((void)(RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+time_ssi+GRAD_UPDATE_TIME)), aspir_minti) : RUP_GRD(cs_isodelay+IMax(3,pw_gxkcsa+pw_gxkcs+pw_gxkcsd,pw_gykcsa+pw_gykcs+pw_gykcsd,pw_gzkcsa+pw_gzkcs+pw_gzkcsd)+time_ssi+GRAD_UPDATE_TIME);
               }
               
               if (exist(opti)>aspir_minti) 
               {
                   aspir_delay = _aspir_delay.fixedflag ? ((void)(RUP_GRD(exist(opti)-aspir_minti)), aspir_delay) : RUP_GRD(exist(opti)-aspir_minti); 
               } else {
                   aspir_delay = _aspir_delay.fixedflag ? ((void)(0), aspir_delay) : 0; 
               }
           }
           *time_cssat += aspir_delay;
        }
 
        cs_sat  = _cs_sat.fixedflag ?  ((void)(1), cs_sat) : 1;
 
        rfpulse[RFCSSAT_SLOT].activity = PSD_APS2_ON + PSD_MPS2_ON +
            PSD_SCAN_ON;

        rfpulse[RFCSSAT_CFH_SLOT].activity = PSD_CFH_ON;

    } else {
    
        /* If no water or fat suppression requested */

        grady[GYKCS_SLOT].num = 0;

#ifdef CSXKILLER
        gradx[GXKCS_SLOT].num = 0;
#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
        if(duo_cs_flag)
        {
            gradz[GZKCS_SLOT].num = 0;
        }
#else
        gradz[GZKCS_SLOT].num = 0;
#endif
#endif
        rfpulse[RFCSSAT_SLOT].num = 0;
        cs_sat  = _cs_sat.fixedflag ?  ((void)(0), cs_sat) : 0;
        *time_cssat = 0;
        rfpulse[RFCSSAT_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFCSSAT_CFH_SLOT].activity = PSD_PULSE_OFF;
    }



    if ( ( ( ((exist(oppseq)==PSD_GE)||(exist(oppseq)==PSD_SPGR)) &&
             ((exist(opfast)==PSD_ON) || (exist(opimode)==PSD_3D)))  ||
           (((exist(oppseq)==PSD_TOF)||(exist(oppseq)==PSD_TOFSP)) &&
            (exist(opimode)==PSD_3D)) ) && ((cffield == B0_5000) || 
                                            (cffield == B0_2000) ||(cffield == B0_3500)) && 
         (ChemSatPulse == CSMIN8_PULSE) ) {

        if (opwater == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(FWCHEMSHIFT_HALF_TESLA_FAST), off_rfcssat) : FWCHEMSHIFT_HALF_TESLA_FAST;
        }

        if ( fatFlag == PSD_ON ) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)(-FWCHEMSHIFT_HALF_TESLA_FAST), off_rfcssat) : -FWCHEMSHIFT_HALF_TESLA_FAST;
        } 


    } else { 

        if (opwater == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)((int)SDL_GetChemicalShift(cffield)), off_rfcssat) : (int)SDL_GetChemicalShift(cffield);
        }

        if ( fatFlag == PSD_ON) {
            off_rfcssat  = _off_rfcssat.fixedflag ?  ((void)((int)(-SDL_GetChemicalShift(cffield))), off_rfcssat) : (int)(-SDL_GetChemicalShift(cffield));
            if (CS_HS == ChemSatPulse )
            {
               off_rfcssat  = _off_rfcssat.fixedflag ?     ((void)((int)(-((NOM_BW_HS+SDL_GetChemicalShift(cffield))/2))), off_rfcssat) : (int)(-((NOM_BW_HS+SDL_GetChemicalShift(cffield))/2));
            } 
            else if (CS_HS_20MS == ChemSatPulse )
            {
               off_rfcssat  = _off_rfcssat.fixedflag ?     ((void)((int)(-((NOM_BW_HS_20MS+SDL_GetChemicalShift(cffield))/2))), off_rfcssat) : (int)(-((NOM_BW_HS_20MS+SDL_GetChemicalShift(cffield))/2));
            } 
            else if (CS_HSLS == ChemSatPulse)
            {
                off_rfcssat  = _off_rfcssat.fixedflag ?     ((void)((int)(-((NOM_BW_HSLS+SDL_GetChemicalShift(cffield))/2))), off_rfcssat) : (int)(-((NOM_BW_HSLS+SDL_GetChemicalShift(cffield))/2));
            }
            else if (DB_CS_PULSE == ChemSatPulse )  /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
            {
                off_rfcssat  = _off_rfcssat.fixedflag ?       ((void)(-1.0*((bw_rfcssat_nom+SDL_GetChemicalShift(cffield))/2)), off_rfcssat) : -1.0*((bw_rfcssat_nom+SDL_GetChemicalShift(cffield))/2);
            }
        }

    }

    if((cffield >= B0_30000) && (TX_COIL_BODY == getTxCoilType()) && (aspir_flag == 1) )
    {
        double energy_b1_limit;
        double act_b1_rfcssat;
        double dummy_scale = 1.0;
        double NewFA;
        double initFA;

        if( SUCCESS !=  pulseEnergyB1Limit(&energy_b1_limit, &rfpulse[RFCSSAT_SLOT]) )
        {
            epic_error( use_ermes, "Support routine %s failed.",
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "pulseEnergyB1Limit" );
            return FAILURE;
        }

        if( SUCCESS !=  calcB1Val(&act_b1_rfcssat, &dummy_scale, &rfpulse[RFCSSAT_SLOT],
                                  RFCSSAT_SLOT, (UCHAR)1, use_ermes) )
        {
            epic_error( use_ermes, "Support routine %s failed.",
                        EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                        STRING_ARG, "calcB1Val_aspir" );
            return FAILURE;
        }

        initFA =  *rfpulse[RFCSSAT_SLOT].act_fa;
        NewFA= FMin(2, initFA, floor((energy_b1_limit/act_b1_rfcssat)* (*rfpulse[RFCSSAT_SLOT].act_fa)));
        *rfpulse[RFCSSAT_SLOT].act_fa = NewFA;
        *rfpulse[RFCSSAT_CFH_SLOT].act_fa = NewFA;

        if (fa_scale_debug == PSD_ON)
        {
            FILE *fp;
            fp = fopen("/usr/g/service/log/fa_scale","ab");

            if (NULL != fp)
            {
                fprintf(fp,"\n ************** ASPIR Scaling **********************");
                fprintf(fp,"\n Initial FA    =%f ", initFA);
                fprintf(fp,"\n Actual B1     =%f ", act_b1_rfcssat);
                fprintf(fp,"\n EnergyB1Limit =%f ", energy_b1_limit);
                fprintf(fp,"\n New FA        =%f ", *rfpulse[RFCSSAT_SLOT].act_fa);
                fprintf(fp,"\n ************** End ********************************");
                fclose(fp);
            }
        }
    }
    return SUCCESS;
}

/* Fat component */
/* 0: Fat component CH3 */
/* 1: Fat component (CH2)n */
/* 2: Fat component O=C-C-CH2-CH2 */
/* 3: Fat component C=C-CH2 */
/* 4: Fat component O=C-CH2 */
/* 5: Fat component C-CH2-C= */
/* 6: Fat component CH2O (right) */
/* 7: Fat component CH2O (left) */
/* 8: Fat component CH=CH and CHO */
float chemsat_amp[9] = { 0.26, 1.00, 0.10, 0.21, 0.11, 0.05, 0.04, 0.04, 0.15 };
float chemsat_T2[9] = { 227.0, 107.0, 43.0, 67.0, 71.0, 183.0, 36.0, 36.0, 137.0 }; /* T2 in ms */
/*MCARL: ASPIR needs more up-to-date values for both 1.5T and 3T*/
float chemsat_amp_Adipose[9] = { 0.15, 1.00, 0.10, 0.136, 0.10, 0.024, 0.033, 0.033, 0.11 };
float chemsat_T1_1p5T[9] = { 577.0, 226.0, 185.0, 209.0, 210.0, 245.0, 237.0, 242.0, 204.0 };
float chemsat_T1_3T[9] = { 543.0, 280.0, 240.0, 249.0, 202.0, 284.0, 154.0, 154.0, 421.0 };

STATUS setupFatComponentT1( float* T1 )
{
    /* initialization for T1 value of 9 Fat componnent */
    for( int i = 0; i < 9; i++ )
    {
        if( PSD_ON == phantom_test_flag )
        {
            T1[i] = phantom_fat_T1;
        }
        else if( cffield > B0_15000 )
        {
            T1[i] = chemsat_T1_3T[i];
        }
        else
        {
            T1[i] = chemsat_T1_1p5T[i];
        }
    }

    if( (NULL == T1) )
    {
        epic_error(0, "Fat component parameter is not valid", 0, EE_ARGS(0));
        return FAILURE;
    }

    return SUCCESS;
}



/* ********************************************************** *
 * Subroutine get called in each psd to calculate the optimal *
 * sat flip angle in the SCAN entry. SGT                      *
 * ********************************************************** */
STATUS
ChemSatFlip( INT delay_time,
             INT tetime,
             INT rc_time,
             INT slquant,
             INT tr_time )
{
    int i,j;
    int flip;
    float seq_time;
    float angle;
    float *amp = chemsat_amp;
    float T1[9];
    float *T2 = chemsat_T2;
    float Mz;
    float EE[9];
    float ER[9];
    float ES[9];
    float factor[9];
    float signal_fat;
    float previous_signal;
    float scale = 0.001;
    float T1_inv[9];
    float T2_inv[9];

    if( setupFatComponentT1(T1) == FAILURE )
    {
        epic_error(0, "Error to set up T1 fat components", 0, EE_ARGS(0));
        return FAILURE;
    }
    /* Sequence time equals tr_time divided by slquant */
    seq_time = (float)(tr_time)/(float)slquant;

    /* Check to make sure all the parameters are valid */
    if ((delay_time <0) ||( tetime < 0) || (rc_time < 0)) {
        epic_error(0,"ChemSatFlip time parameters invalid",0,EE_ARGS(0));
        return FAILURE;
    }

    for (i=0; i<9; i++) {
        T1_inv[i] = 1.0/T1[i]*scale;
        T2_inv[i] = 1.0/T2[i]*scale;

#ifndef __linux__
        EE[i] = fexp(-(float)tetime*T2_inv[i]);
        ES[i] = fexp(-(float)delay_time*T1_inv[i]);
        ER[i] = fexp(-(float)seq_time*T1_inv[i]);
#else
        EE[i] = exp(-(float)tetime*T2_inv[i]);
        ES[i] = exp(-(float)delay_time*T1_inv[i]);
        ER[i] = exp(-(float)seq_time*T1_inv[i]);
#endif
    }

    /* ************************************************** *
     * If cannot find optimal ChemSat flip angle between  *
     * 90 and 180 degrees, then the optimal flip angle is *
     * 180 degree ChemSat RF pulse.                       *
     * ************************************************** */
    flip_sat  = _flip_sat.fixedflag ?  ((void)(180.0), flip_sat) : 180.0;
    previous_signal = 1.0;

    for (flip=90; flip<=180; flip++)
    {
        /* Initialize the fat signal to 0 */
        signal_fat = 0.0;

        for (i=0; i<9; i++)
        {
            if (i<6)
                angle = ((float)flip)*PI/180.0;
            else
                angle = 0.0;

#ifndef __linux__
            factor[i] = fcos(angle);
#else
            factor[i] = cos(angle);
#endif

            /* *********************************************** *
             * Assuming at the TE time, the Mz of the fat is   *
             * zero. At the time of the next ChemSat RF pulse, *
             * the Mz is calculated.                           *
             * *********************************************** */
#ifndef __linux__
            Mz = 1.0 - fexp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#else
            Mz = 1.0 - exp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#endif


            /* ************************************************* *
             * Next, slquant-1 number of ChemSat RF pulses with  *
             * interval of seq_time time are played. At the time *
             * of the ChemSat RF pulse the for current slice.    *
             * ************************************************* */
            for (j=0; j<slquant-1; j++)
                Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];

            /* At the 90 degree excitation RF pulse */
            Mz = 1.0 + (Mz*factor[i] - 1.0)*ES[i];

            signal_fat += amp[i]*EE[i]*Mz;
        }


        /* ******************************************************* *
         * Find out the flip angle that gives the optimal ChemSat. *
         * Based on MR physics, we only need to search for flip    *
         * angles between 90 and 180 degree.                       *
         * ******************************************************* */
        if ((previous_signal >= 0) && (signal_fat < 0))
        {
            flip_sat  = _flip_sat.fixedflag ?  ((void)((float)(flip-1)), flip_sat) : (float)(flip-1);
            break;
        }

        previous_signal = signal_fat;
    }

    if ( (CS_HS != ChemSatPulse) && (CS_HS_20MS != ChemSatPulse) )
    {
       /* FATSAT FACTOR addition - HH June 2005 */
       flip_sat  = _flip_sat.fixedflag ?    ((void)(acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : flip_sat*acos(1.0-fatsat_factor)/acos(0.0);
       /* Set the calculated flip angle to the RF structure */
       *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
    }

    return SUCCESS;
}

/* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
/* ************************************************************* *
 * This subroutine is for Multi-Band Fat Sat pulses.             *
 * Subroutine get called in each psd to calculate the optimal    *
 * sat flip angle for ChemSat pulse 1 (flip_final_1) and ChemSat *
 * pulse 2 (flip_final_2) in the SCAN entry. LH                  *
 * ************************************************************* */
STATUS
DBFlip( INT delay_time,
        INT tetime,
        INT rc_time,
        INT slquant,
        INT tr_time,
        INT sattime)
{
    int i,j;
    float seq_time;
    float angle_1;
    float angle_2;
    float *amp = chemsat_amp;
    float T1[9];
    float *T2 = chemsat_T2;
    float Mz1;
    float Mz2;
    float EE[9];
    float ER[9];
    float ES[9];
    float ECS[9];
    float factor_1[9];
    float factor_2[9];
    float signal_fat_1;
    float signal_fat_2;
    float signal_fat_diff;
    float previous_signal_diff;
    float flip_sat_1;

    if( setupFatComponentT1(T1) == FAILURE )
    {
        epic_error(0, "Error to set up T1 fat components", 0, EE_ARGS(0));
        return FAILURE;
    }
    /* Sequence time equals tr_time divided by slquant */
    seq_time = (float)(tr_time)/(float)slquant;

    /* Check to make sure all the parameters are valid */
    if ((delay_time <0) ||( tetime < 0) || (rc_time < 0)) {
        epic_error(0,"DBFlip time parameters invalid",0,EE_ARGS(0));
        return FAILURE;
    }

    flip_final_1  = _flip_final_1.fixedflag ?  ((void)(97.0), flip_final_1) : 97.0;
    flip_final_2  = _flip_final_2.fixedflag ?  ((void)(90.0), flip_final_2) : 90.0;        /* Flip angle for the 2nd pulse is set to constant of 90 */
    previous_signal_diff = 2.0;

    for (flip_sat_1=60; flip_sat_1<=180; flip_sat_1++)
    {
        /* Initialize the fat signal to 0 */
        signal_fat_1 = 0.0;
        signal_fat_2 = 0.0;
        signal_fat_diff = 0.0;

        for (i=0; i<9; i++)
        {
#ifndef __linux__
            EE[i] = fexp(-(float)tetime/(T2[i]*1000.0));
            ES[i] = fexp(-(float)delay_time/(T1[i]*1000.0));
            ER[i] = fexp(-(float)seq_time/(T1[i]*1000.0));
            ECS[i] = fexp(-((float)sattime+(float)delay_time)/(T1[i]*1000.0));
#else
            EE[i] = exp(-(float)tetime/(T2[i]*1000.0));
            ES[i] = exp(-(float)delay_time/(T1[i]*1000.0));
            ER[i] = exp(-(float)seq_time/(T1[i]*1000.0));
            ECS[i] = exp(-((float)sattime+(float)delay_time)/(T1[i]*1000.0));
#endif
            if (i<6)
            {
                angle_1 = ((float)flip_sat_1)*PI/180.0;
                angle_2 = ((float)flip_final_2)*PI/180.0;
            }
            else
            {
                angle_1 = 0.0;
                angle_2 = 0.0;
            }
#ifndef __linux__
            factor_1[i] = fcos(angle_1);
            factor_2[i] = fcos(angle_2);
#else
            factor_1[i] = cos(angle_1);
            factor_2[i] = cos(angle_2);
#endif
            /* *********************************************** *
             * Assuming at the TE time, the Mz of the fat is   *
             * zero. At the time of the next ChemSat RF pulse, *
             * the Mz is calculated.                           *
             * *********************************************** */
#ifndef __linux__
            Mz1 = 1.0 - fexp(-(seq_time-rc_time-delay_time-sattime)/(T1[i]*1000.0));
            Mz2 = 1.0 - fexp(-(seq_time-rc_time-delay_time)/(T1[i]*1000.0));
#else
            Mz1 = 1.0 - exp(-(seq_time-rc_time-delay_time-sattime)/(T1[i]*1000.0));
            Mz2 = 1.0 - exp(-(seq_time-rc_time-delay_time)/(T1[i]*1000.0));
#endif
            /* ************************************************* *
             * Next, slquant-1 number of ChemSat RF pulses with  *
             * interval of seq_time time are played. At the time *
             * of the ChemSat RF pulse the for current slice.    *
             * ************************************************* */
            for (j=0; j<slquant-1; j++)
            {
                Mz1 = 1.0 + (Mz1*factor_1[i] - 1.0)*ER[i];
                Mz2 = 1.0 + (Mz2*factor_2[i] - 1.0)*ER[i];
            }
            /* At the 90 degree excitation RF pulse */
            Mz1 = 1.0 + (Mz1*factor_1[i] - 1.0)*ECS[i];
            Mz2 = 1.0 + (Mz2*factor_2[i] - 1.0)*ES[i];

            signal_fat_1 += amp[i] * EE[i] * Mz1;
            signal_fat_2 += amp[i] * EE[i] * Mz2;

        }

        /* ****************************************************** *
         * Find the flip angle for the first pulse to provide the *
         * imost homogeneous fat signal in ROI                    *
         * ****************************************************** */
        signal_fat_diff = fabs(signal_fat_1-signal_fat_2);

        if (previous_signal_diff > signal_fat_diff)
        {
            flip_final_1  = _flip_final_1.fixedflag ?  ((void)((float)flip_sat_1), flip_final_1) : (float)flip_sat_1;
            previous_signal_diff = signal_fat_diff;
        }
    }

    return SUCCESS;
}


/* ********************************************************** *
 * Subroutine get called in classic T2flair to calculate the  *
 * sat flip angle in the SCAN entry.  Take the optimal sat    *
 * flip angle of the last slice in one group as the final     *
 * optimal sat flip angle.  HS                                *
 * ********************************************************** */
STATUS
ChemSatFlip_T2flair( INT delay_time,
                     INT tetime,
                     INT rc_time,
                     INT slquant1,
                     INT tr_time,
                     INT packs,
                     INT ti_time,
                     INT seq_time,
                     INT ignore_ir )
{
    int i,j,p;
    int flip;
    float angle;
    float *amp = chemsat_amp;
    float T1[9];
    float *T2 = chemsat_T2;
    float Mz;
    float EE[9];
    float ER[9];
    float ES[9];
    float factor[9];
    float signal_fat;
    float previous_signal;
    float scale = 0.001;
    float T1_inv[9];
    float T2_inv[9];

    if( setupFatComponentT1(T1) == FAILURE )
    {
        epic_error(0, "Error to set up T1 fat components", 0, EE_ARGS(0));
        return FAILURE;
    }
    /* Check to make sure all the parameters are valid */
    if ((delay_time <0) ||( tetime < 0) || (rc_time < 0) || (ti_time<0) || (seq_time<0)) {
        epic_error(0,"ChemSatFlip_T2flair time parameters invalid",0,EE_ARGS(0));
        return FAILURE;
    }

    for (i=0; i<9; i++) {
        T1_inv[i] = 1.0/T1[i]*scale;
        T2_inv[i] = 1.0/T2[i]*scale;

#ifndef __linux__
        EE[i] = fexp(-(float)tetime*T2_inv[i]);
        ES[i] = fexp(-(float)delay_time*T1_inv[i]);
        ER[i] = fexp(-(float)seq_time*T1_inv[i]);
#else
        EE[i] = exp(-(float)tetime*T2_inv[i]);
        ES[i] = exp(-(float)delay_time*T1_inv[i]);
        ER[i] = exp(-(float)seq_time*T1_inv[i]);
#endif
    }

    /* ************************************************** *
     * If cannot find optimal ChemSat flip angle between  *
     * 90 and 180 degrees, then the optimal flip angle is *
     * 180 degree ChemSat RF pulse.                       *
     * ************************************************** */
    flip_sat  = _flip_sat.fixedflag ?  ((void)(180.0), flip_sat) : 180.0;
    previous_signal = 1.0;

    for (flip=90; flip<=180; flip++)
    {
        /* Initialize the fat signal to 0 */
        signal_fat = 0.0;

        for (i=0; i<9; i++)
        {
            if (i<6)
                angle = ((float)flip)*PI/180.0;
            else
                angle = 0.0;

#ifndef __linux__
            factor[i] = fcos(angle);
#else
            factor[i] = cos(angle);
#endif

            /* ************************************************ *
             * Assuming at the TE time of the last slice in the *
             * group, the Mz of the fat is zero. At the time of *
             * the end of the sequence, the Mz is calculated.   *
             * ************************************************ */
#ifndef __linux__
            Mz = 1.0 - fexp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#else
            Mz = 1.0 - exp(-(seq_time-rc_time-delay_time)*T1_inv[i]);
#endif

            /* Will experience packs-1 acquisition groups */
            for (p=0; p<packs-1; p++) {
                /* Next, after a waiting period, next slquant1 number  *
                 * of ChemSat RF pulses with interval of seq_time time *
                 * are played. At the time of the ChemSat RF pulse for *
                 * the first slice of the next group.                  *
                 * *************************************************** */
#ifndef __linux__
                 Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#else
                 Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#endif

                /* ************************************************* *
                 * Next, slquant1 number of ChemSat RF pulses with   *
                 * interval of seq_time time are played. At the time *
                 * of the end of the next group.                     *
                 * ************************************************* */
                for (j=0; j<slquant1; j++)
                    Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];
            }

            /* Next, handle the inversion pulse of the slice */
            if (ignore_ir == 0) {
#ifndef __linux__
                /* At the beginning of the inversion pulse */
                Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-ti_time-seq_time+delay_time)*T1_inv[i]);
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (-Mz-1.0)*fexp(-(ti_time-delay_time-(slquant1-1)*seq_time)*T1_inv[i]);
#else
                /* At the beginning of the inversion pulse */
                Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-ti_time-seq_time+delay_time)*T1_inv[i]);
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (-Mz-1.0)*exp(-(ti_time-delay_time-(slquant1-1)*seq_time)*T1_inv[i]);
#endif
            } else {
#ifndef __linux__
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (Mz-1.0)*fexp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#else
                /* At the beginning of the group where the current last slice is. */
                Mz = 1.0 + (Mz-1.0)*exp(-(tr_time/(float)packs-slquant1*seq_time)*T1_inv[i]);
#endif
            }

            /* ************************************************* *
             * Next, slquant1-1 number of ChemSat RF pulses with  *
             * interval of seq_time time are played. At the time *
             * of the ChemSat RF pulse the for current slice.    *
             * ************************************************* */
            for (j=0; j<slquant1-1; j++)
                Mz = 1.0 + (Mz*factor[i] - 1.0)*ER[i];

            /* At the 90 degree excitation RF pulse */
            Mz = 1.0 + (Mz*factor[i] - 1.0)*ES[i];

            signal_fat += amp[i]*EE[i]*Mz;
        }

        /* ******************************************************* *
         * Find out the flip angle that gives the optimal ChemSat. *
         * Based on MR physics, we only need to search for flip    *
         * angles between 90 and 180 degree.                       *
         * ******************************************************* */
        if ((previous_signal >= 0) && (signal_fat < 0))
        {
            flip_sat  = _flip_sat.fixedflag ?  ((void)((float)(flip-1)), flip_sat) : (float)(flip-1);
            break;
        }
        previous_signal = signal_fat;
    }

    if ( (CS_HS != ChemSatPulse) && (CS_HS_20MS != ChemSatPulse) )
    {
       /* FATSAT FACTOR addition - HH June 2005 */
       flip_sat  = _flip_sat.fixedflag ?    ((void)(acos(1.0-fatsat_factor)/acos(0.0)), flip_sat) : flip_sat*acos(1.0-fatsat_factor)/acos(0.0);
       /* Set the calculated flip angle to the RF structure */
       *rfpulse[RFCSSAT_SLOT].act_fa = flip_sat;
    }

    return SUCCESS;
}

/* ********************************************************** *
 * MCARL: Subroutine get called in 2DFSE to calculate the            *
 * null TI for aspir chem sat for 2D fsemaster                *
 * ********************************************************** */
int Calc_Aspir_Null_TI_2DFSE(int tr, int slicesperacq, int TETL, float Qfactor, float aspir_null_level)
{

    float *proton = chemsat_amp_Adipose;
    float T1[9];

    int nfat = 9;
    int nfat0 = 6;
    float mz_fat[9];
    float proton2[9];
    float SzTheoryCompNoIR[9];

    int i,j,k;    
    int counter = 0;
    float mz_fat_total = 0.0;
    float SzTheoryNoIR = 0.0;
    float minsig = 0.0;
    float minsigRef = 0.0;
    float tp = 0.0;
    float aspir_null_level2 = 0.0;
    int ti_min = FSE_ASPIR_MIN_TI/1000; /*in ms */
    int ti_max = FSE_ASPIR_MAX_TI/1000; /*in ms */
    int tisize = 0;
    int optTI = 0;
    tisize = ti_max-ti_min+1;

    float N = 0.0;
    float TItest = 0.0;
    float Tx = 0.0;
    float trtime = 0.0; /*in ms */
    float etltime = 0.0; /*in ms */
    int tround = 0;
    float EI = 0.0;
    float ERN = 0.0;
    float Ex = 0.0;
    float Ey = 0.0;
    float TR_PerSlice = 0.0;
    float SumTerm = 0.0;

    if( setupFatComponentT1(T1) == FAILURE )
    {
        epic_error(0, "Error to set up T1 fat components", 0, EE_ARGS(0));
        return FAILURE;
    }
    N = (float)slicesperacq;
    trtime = ceil(tr/1000.0); /*now in ms*/
    etltime = ceil(TETL/1000.0); /*now in ms*/

    /* auto TR mode, round up to avoid infinite cveval loop */
    if (piautotrmode != PSD_AUTO_TR_MODE_MANUAL_TR) 
    {
        tround = sqrt(trtime)/2;
        tround = (tround>15)?tround:15;
        trtime = (int)(ceil(trtime/tround)+0.1)*tround;
    }

    TR_PerSlice=trtime/N;

    tp = 0;
    for (j=0; j<nfat; j++)
    {
        tp += proton[j];
    }
    for (j=0; j<nfat; j++)
    {
        proton2[j] = proton[j]/tp;
    }

    /*MCARL: Calculate the steady-state fat signal level w/o fat suppression. This is usually very close to 1, but in case it is lower (low TR high etltime).*/
    /*The only time this may become important is when the steady-state fat signal equals <<1 (e.g. SzTheoryNoIR=0.5) and the user wants bright fat*/
    /*(e.g. aspir_null_level=0.7). In that case the algorythm tries to find the TI when the fat signal equals to 0.7, but cannot find it.*/ 
    /*In reality we want to find the TI when the fat signal is 70% (0.7) of the steady state fat signal (0.5) -> 0.5*0.7 (see aspir_null_level2 below)*/
    for (j=0; j<nfat; j++)
    {
        Ey = exp(-(trtime-etltime)/T1[j]);
        SzTheoryCompNoIR[j] = proton2[j]*(1-Ey);
    }
    SzTheoryNoIR=0;
    for (j=0; j<nfat; j++)
    {
        SzTheoryNoIR += SzTheoryCompNoIR[j];
    }
    aspir_null_level2 = aspir_null_level*SzTheoryNoIR;

    /*MCARL: Initial coarse search by 10ms increments for faster calculation. I found similar or faster convergence than a binary search (bc most TI values are much less than FSE_ASPIR_MAX_TI)*/
    int step=10;
    minsig = 1000000;
    minsigRef = 1000000;
    i=0;
    counter=0;  
    while ((i < tisize) && (fabs(minsig-minsigRef)<0.000001))
    {
        TItest=i+ti_min;
        Tx=TR_PerSlice-TItest-etltime;
        for (j=0; j<nfat; j++)
        {
            mz_fat[j] = 0;
        }
        mz_fat_total = 0;
        for (j=0; j<nfat0; j++) /*the fat components that were inverted*/
        {
            EI=exp(-TItest/T1[j]);
            ERN=exp(-TR_PerSlice/T1[j]);
            Ex=exp(-Tx/T1[j]);	    
            SumTerm=0; 
            if (N>2)
            {
                for (k=1;k<=N-2; k++)
                {   
                    SumTerm += (pow(Qfactor,k+1)+pow(Qfactor,k))*pow(-ERN,k); /*MCARL: steady state formular*/
                }
            }
            mz_fat[j] = proton2[j]*(-((1-Ex)*pow(Qfactor,N)*pow(-ERN,N-1)+(Qfactor+pow(-Qfactor*ERN,N-1)+SumTerm))*EI+(1-EI)); /*MCARL: steady state formular*/
            if (floatsAlmostEqualEpsilons(N, 1.0f, 2))
            {
                mz_fat[j] = proton2[j]*(-((1-Ex)*pow(Qfactor,N)*pow(-ERN,N-1))*EI+(1-EI)); /*MCARL: steady state formular*/
            }
        }
        for (j=nfat0; j<nfat; j++) /*the fat components that were not inverted*/
        {
            Ey=exp(-(trtime-etltime)/T1[j]);
            mz_fat[j] = proton2[j]*(1-Ey);
        }
        for (j=0;j<nfat; j++)
        {
            mz_fat_total += mz_fat[j];
        }

        if(fabs(mz_fat_total-aspir_null_level2)<minsig)
        {
            optTI = TItest*1000;
            minsig = fabs(mz_fat_total-aspir_null_level2);
        }
        minsigRef = fabs(mz_fat_total-aspir_null_level2);
        i=i+step;
        counter=counter+1;
    }
    i=i-step;

    ti_max=ti_min+i;
    ti_min=ti_min+i-2*step;

    /*MCARL: Make sure we are still inside the bounds of TI*/
    if (ti_min<FSE_ASPIR_MIN_TI/1000)
    {
        ti_min=FSE_ASPIR_MIN_TI/1000;
        ti_max=FSE_ASPIR_MIN_TI/1000+step;
    }
    if (ti_max>FSE_ASPIR_MAX_TI/1000)
    {
        ti_max=FSE_ASPIR_MAX_TI/1000;
        ti_min=FSE_ASPIR_MAX_TI/1000-step;
    }    
    tisize = ti_max-ti_min+1;

    /*MCARL: Now do fine search*/
    minsig = 1000000;
    minsigRef = 1000000;
    i=0;
    while ((i < tisize) && (fabs(minsig-minsigRef)<0.000001))
    {
        TItest=i+ti_min;
        Tx=TR_PerSlice-TItest-etltime;
        for (j=0; j<nfat; j++)
        {
            mz_fat[j] = 0;
        }
        mz_fat_total = 0;
        for (j=0; j<nfat0; j++) /*the fat components that were inverted*/
        {
            EI=exp(-TItest/T1[j]);
            ERN=exp(-TR_PerSlice/T1[j]);
            Ex=exp(-Tx/T1[j]);	    
            SumTerm=0; 
            if (N>2)
            {
                for (k=1;k<=N-2; k++)   
                {
                    SumTerm += (pow(Qfactor,k+1)+pow(Qfactor,k))*pow(-ERN,k);
                }
            }
            mz_fat[j] = proton2[j]*(-((1-Ex)*pow(Qfactor,N)*pow(-ERN,N-1)+(Qfactor+pow(-Qfactor*ERN,N-1)+SumTerm))*EI+(1-EI));
            if (floatsAlmostEqualEpsilons(N, 1.0, 2))
            {
                mz_fat[j] = proton2[j]*(-((1-Ex)*pow(Qfactor,N)*pow(-ERN,N-1))*EI+(1-EI));
            }
        }
        for (j=nfat0; j<nfat; j++) /*the fat components that were not inverted*/
        {
            Ey=exp(-(trtime-etltime)/T1[j]);
            mz_fat[j] = proton2[j]*(1-Ey);
        }
        for (j=0; j<nfat; j++)
        {
            mz_fat_total += mz_fat[j];
        }

        if(fabs(mz_fat_total-aspir_null_level2)<minsig)
        {
            optTI = TItest*1000;
            minsig = fabs(mz_fat_total-aspir_null_level2);
        }
        minsigRef = fabs(mz_fat_total-aspir_null_level2);
        i=i+1;
        counter=counter+1;
    }

    return optTI;
}

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
/* ********************************************************** *
 * This subroutine is for duo ChemSat pulses.                 *
 * Subroutine get called in each psd to calculate the optimal *
 * sat flip angle for ChemSat pulse 1 (flip_final_1) and ChemSat  *
 * pulse 2 (flip_final_2) in the SCAN entry. WXC                      *
 * ********************************************************** */
STATUS
ChemSatFlip_duo( INT delay_time,
                 INT tetime,
                 INT rc_time,
                 INT slquant,
                 INT tr_time, 
                 INT sattime  )
{
    int i = 0;                                          /* loop counter */
    int start_cs1 = DUO_START_FIRST_FA;                 /* start angle for 1st flip angle search*/
    int end_cs1 = DUO_END_FIRST_FA;                     /* end angle for 1st flip angle search*/
    int flip_cs1 = 1;                                   /* 1st flip angle */
    float flip_cs2[DUO_NUM_FLIP+1] = {0};               /* 2nd flip angle list which could achieve fat suppression */
    int remnant_signal_flags[DUO_NUM_FLIP+1] = {0};     /* list of flag for non-signal zero simulation results*/
    int cs1_stock[3] = {1, 1, 1};                       /* strage of bisection search for flip angle 1*/
    float cs2_stock[3] = {90.0, 90.0, 90.0};            /* strage of bisection search for flip angle 2*/
    float cs2_cs1 = 90.0;                               /* the ratio of flip_cs2/flip_cs1 for comb_fa1 and flip_cs2 */
    float dcs2_dcs1 = 0.0;                              /* the ratio of diff(flip_cs2)/diff(flip_cs1) */
    float tan_ang_obj_func = 90.0;                      /* the objective function to find the straight line tangent to a curve of flip1 and flip2 */
    float tan_ang_obj_func_pre = 180.0;                 /* the objective function for previous */
    FILE* fp;                                           /* file pointer for ChemSat pulse profile.*/
    double spec_prof[DUO_LIPID_COMP*DUO_SPECPROF_RANGE];/* Spectral profile of the ChemSat RF pulse. */
    float flip1_delta = -15.0;                          /* angle shift of flip_final_1 for DB_CS_PULSE */
    float round_error = 0.000001;                       /* to avoid rounding errors */
    float delta_signal = 0.0;                           /* amount of fat signal to be lelf correspoding to fatsat efficiency*/

    /* At the beginning, will check if this function is called with same parameters. */
    /* If it's ture. Will return with backup value. WXC */
    if ((delay_time_bkp == delay_time) &&  
        (tetime_bkp == tetime) &&
        (rc_time_bkp == rc_time) &&
        (slquant_bkp == slquant) &&
        (tr_time_bkp == tr_time) &&
        (sattime_bkp == sattime) &&
        (flip_final_1_bkp == flip_final_1) &&
        (flip_final_2_bkp == flip_final_2) &&
        (flip_final_1_bkp < DUO_NUM_FLIP) &&
        (flip_final_1_bkp > 0) &&
        floatsAlmostEqualEpsilons(fatsat_factor_bkp, fatsat_factor, 2)
       )
    {
        return SUCCESS;
    }

    /* update the back up data. flip_final_1_bkp and flip_final_2_bkp will be updated at the end. WXC */
    delay_time_bkp  = _delay_time_bkp.fixedflag ?  ((void)(delay_time), delay_time_bkp) : delay_time;
    tetime_bkp  = _tetime_bkp.fixedflag ?  ((void)(tetime), tetime_bkp) : tetime;
    rc_time_bkp  = _rc_time_bkp.fixedflag ?  ((void)(rc_time), rc_time_bkp) : rc_time;
    slquant_bkp  = _slquant_bkp.fixedflag ?  ((void)(slquant), slquant_bkp) : slquant;
    tr_time_bkp  = _tr_time_bkp.fixedflag ?  ((void)(tr_time), tr_time_bkp) : tr_time;
    sattime_bkp  = _sattime_bkp.fixedflag ?  ((void)(sattime), sattime_bkp) : sattime;
    fatsat_factor_bkp  = _fatsat_factor_bkp.fixedflag ?  ((void)(fatsat_factor), fatsat_factor_bkp) : fatsat_factor;
    /* read in spectral profile of the ChemSat RF pulse */
    fp = fopen("/usr/g/bin/SpecProf_duocs.dat", "r");
    if (NULL == fp)
    {
        epic_error(0, "Error occured when try to open Spectral Profile document.",0,EE_ARGS(0));
        tetime_bkp  = _tetime_bkp.fixedflag ?  ((void)(-1), tetime_bkp) : -1;
        rc_time_bkp  = _rc_time_bkp.fixedflag ?  ((void)(-1), rc_time_bkp) : -1;
        slquant_bkp  = _slquant_bkp.fixedflag ?  ((void)(-1), slquant_bkp) : -1;
        tr_time_bkp  = _tr_time_bkp.fixedflag ?  ((void)(-1), tr_time_bkp) : -1;
        sattime_bkp  = _sattime_bkp.fixedflag ?  ((void)(-1), sattime_bkp) : -1;
        return FAILURE;
    }

    for ( i=0; i<DUO_LIPID_COMP*DUO_SPECPROF_RANGE; i++)
    {
        fscanf(fp, "%lf", spec_prof+i);
    }
    fclose(fp);

    if (w_debug_flag)
    {
        /* output for debug */
        if( NULL == (fp = fopen("/usr/g/service/log/RF_Profile_duocs.txt", "w")))
        {
                epic_error(0, "Error occured when try to open Spectral Profile document.",0,EE_ARGS(0));
                return FAILURE;
        }
        for ( i=0; i<DUO_LIPID_COMP*DUO_SPECPROF_RANGE; i++)
        {
                fprintf(fp, "%lf", *(spec_prof+i));
                fprintf(fp, "\t");
        }
        fclose(fp);
    }

    /* Set initial list of flip1 and flip2 for comming bisection search */
    flip_cs1 = start_cs1;
    flip_cs2[flip_cs1] = ChemSatFlip_duo_sub(delay_time, tetime, rc_time, slquant, tr_time, sattime, flip_cs1, delta_signal,remnant_signal_flags, spec_prof);
    if( fatsat_factor < 1.0 )
    {
        /* delta_signal is calcurated from flip_cs1 = 1 and flip_cs2_base.
         * this process is to keep fatsat_factor effect of duo chemsat as sigle chemsat is */
        int flip_cs2_base = (int)(flip_cs2[flip_cs1] * acos(1.0 - fatsat_factor)/ acos(0.0) + 0.5);
        flip_cs2[flip_cs1] = (float)flip_cs2_base;
        delta_signal = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, flip_cs1, flip_cs2_base, spec_prof);
    }
    else
    {
        /* delta_signal is zero when fatsat_factor == 1 */
        delta_signal = 0.0;
    }

    cs1_stock[0] = flip_cs1;
    cs2_stock[0] = flip_cs2[flip_cs1];

    flip_cs1 = (int)((start_cs1 + end_cs1)/ 2);
    flip_cs2[flip_cs1] = ChemSatFlip_duo_sub(delay_time, tetime, rc_time, slquant, tr_time, sattime, flip_cs1, delta_signal, remnant_signal_flags, spec_prof);
    cs1_stock[1] = flip_cs1;
    cs2_stock[1] = flip_cs2[flip_cs1];

    flip_cs1 = end_cs1;
    flip_cs2[flip_cs1] = ChemSatFlip_duo_sub(delay_time, tetime, rc_time, slquant, tr_time, sattime, flip_cs1, delta_signal,remnant_signal_flags,spec_prof);
    cs1_stock[2] = flip_cs1;
    cs2_stock[2] = flip_cs2[flip_cs1];
        
    /* Below will find out the one with best B1 inhomo immuity. *
     * B1-inhomogeneity will change the actual flip angle of rf pulses proportionally. *
     * That is, for example, if flipCS1 is down 5%, flipCS2 will down 5% too.          *
     * We hope the changed flip angles are still in the plot, or at least as close to the plot as possible. *
     * So the best choice will be the one at which the slew-rate of the plot is equal to (flipCS1 / flipCS2). 
     * Following search will find out the minimum angle between tangential line of the curve and flip1/flip2 straight line. */
    if( (cs2_stock[0] < cs2_stock[1]) )
    {
        /* Start to search to find the best B1 inhomo immuity*/
        while( ((cs1_stock[1] - cs1_stock[0]) >= 2) || ((cs1_stock[2] - cs1_stock[1]) >= 2) )
        {
            for( i = 0; i < 2; i++ )
            {
                flip_cs1 = floor((cs1_stock[i] + cs1_stock[i + 1])/ 2.0f);
                if( floatsAlmostEqualEpsilons(flip_cs2[flip_cs1], 0.0, 2) )
                {
                    flip_cs2[flip_cs1] = ChemSatFlip_duo_sub(delay_time, tetime, rc_time, slquant, tr_time, sattime, flip_cs1, delta_signal, remnant_signal_flags, spec_prof);
                }

                if( flip_cs1 != cs1_stock[i] )
                {
                    if( (remnant_signal_flags[cs1_stock[1]]) ||
                        (remnant_signal_flags[flip_cs1] && remnant_signal_flags[cs1_stock[2]]) )
                    {
                        /* above two condition, the stock lists are shifted unconditionally*/
                        cs1_stock[2] = cs1_stock[1];
                        cs2_stock[2] = cs2_stock[1];
                        cs1_stock[i + 1] = flip_cs1;
                        cs2_stock[i + 1] = flip_cs2[flip_cs1];
                        break;
                    }

                    cs2_cs1 = flip_cs2[flip_cs1]/ flip_cs1;
                    dcs2_dcs1 = (cs2_stock[i] - flip_cs2[flip_cs1])/ (cs1_stock[i] - flip_cs1 + round_error);
                    tan_ang_obj_func_pre = ((cs2_cs1 - dcs2_dcs1)/ (1 + cs2_cs1 * dcs2_dcs1));

                    if( remnant_signal_flags[cs1_stock[i+1]] )
                    {
                        /* if cs1_stock[i+1] is non-signal zero point,
                         * the ratio of diff(flip_cs2)/diff(flip_cs1) is set as the maximum values */
                        dcs2_dcs1 = 180.0;
                    }
                    else
                    {
                        dcs2_dcs1 = (flip_cs2[flip_cs1] - cs2_stock[i+1])/ (flip_cs1 - cs1_stock[i+1] + round_error);
                    }

                    tan_ang_obj_func = ((cs2_cs1 - dcs2_dcs1)/ (1 + cs2_cs1 * dcs2_dcs1));

                    if( (tan_ang_obj_func < 0 && tan_ang_obj_func_pre >= 0 ) )
                    {
                        /* center point of search is set as flip_cs1 */
                        cs1_stock[2 * (1 - i)] = cs1_stock[1];
                        cs2_stock[2 * (1 - i)] = cs2_stock[1];
                        cs1_stock[1] = flip_cs1;
                        cs2_stock[1] = flip_cs2[flip_cs1];
                    }
                    else if (tan_ang_obj_func >= 0)
                    {
                        /* center point of search is shifted to higher flip1 direction */
                        cs1_stock[0] = cs1_stock[1];
                        cs2_stock[0] = cs2_stock[1];
                        cs1_stock[i] = flip_cs1;
                        cs2_stock[i] = flip_cs2[flip_cs1];
                    }
                    else
                    {
                        /* center point of search is shifted to lower flip1 direction */
                        cs1_stock[2] = cs1_stock[1];
                        cs2_stock[2] = cs2_stock[1];
                        cs1_stock[i+1] = flip_cs1;
                        cs2_stock[i+1] = flip_cs2[flip_cs1];
                    }
                }
            }
        }

        if(floatsAlmostEqualEpsilons(cs2_stock[1], flip_cs2[start_cs1], 2)) 
        {
            flip_final_1  = _flip_final_1.fixedflag ?  ((void)(start_cs1), flip_final_1) : start_cs1;
            flip_final_2  = _flip_final_2.fixedflag ?    ((void)((int)(flip_cs2[start_cs1]+0.5)), flip_final_2) : (int)(flip_cs2[start_cs1]+0.5);
        }
        else
        {
            flip_final_1  = _flip_final_1.fixedflag ?    ((void)((int)(cs1_stock[1]+0.5)), flip_final_1) : (int)(cs1_stock[1]+0.5);
            flip_final_2  = _flip_final_2.fixedflag ?    ((void)((int)(cs2_stock[1]+0.5)), flip_final_2) : (int)(cs2_stock[1]+0.5);
        }
    }
    else
    {
        flip_final_1  = _flip_final_1.fixedflag ?  ((void)(start_cs1), flip_final_1) : start_cs1;
        flip_final_2  = _flip_final_2.fixedflag ?    ((void)((int)(flip_cs2[start_cs1]+0.5)), flip_final_2) : (int)(flip_cs2[start_cs1]+0.5);
    }

    /* input all flip1 and flip2 for debug */
    if( w_debug_flag )
    {
        if( NULL == (fp = fopen("/usr/g/service/log/Duo_Final_Flip.txt", "w")) )
        {
            epic_error(0, "Error occured when try to open Duo_Final_Flip.txt.", 0, EE_ARGS(0));
            return FAILURE;
        }
        for( i = 1; i <= 90; i++ )
        {
            if( floatsAlmostEqualEpsilons(flip_cs2[i], 0.0, 2 ))
            {
                flip_cs2[i] = ChemSatFlip_duo_sub(delay_time, tetime, rc_time, slquant, tr_time, sattime, i, delta_signal, remnant_signal_flags, spec_prof);
            }
            fprintf(fp, "flip1 = %d, flip2 = %f\n", i, flip_cs2[i]);
        }
        fclose(fp);
    }

    /* HCSDM00406843: when DB_CS_PULSE is on, flip1 plus flip1_delta */
    if( (DB_CS_PULSE == ChemSatPulse) && (PSD_ON == exist(oprtcgate)) && (existcv(oprtcgate)) )
    {
        flip_final_1  = _flip_final_1.fixedflag ?    ((void)(flip_final_1+flip1_delta), flip_final_1) : flip_final_1+flip1_delta;
    }

    if( w_debug_flag )
    {
        /* output for debug */
        if( NULL == (fp = fopen("/usr/g/service/log/FINAL.txt", "w")) )
        {
            epic_error(0, "Error occured when try to open FINAL.txt.", 0, EE_ARGS(0));
            return FAILURE;
        }
        fprintf(fp, "final 1 = %d, final 2 = %d", flip_final_1, flip_final_2);
        fprintf(fp, "\n");
        fclose(fp);
    }

    flip_final_1_bkp  = _flip_final_1_bkp.fixedflag ?  ((void)(flip_final_1), flip_final_1_bkp) : flip_final_1;
    flip_final_2_bkp  = _flip_final_2_bkp.fixedflag ?  ((void)(flip_final_2), flip_final_2_bkp) : flip_final_2;

    *rfpulse[RFCSSAT_SLOT].act_fa = sqrt(0.5 * (pow(flip_final_1, 2) + pow(flip_final_2, 2))); /* HCSDM00404382 */

    return SUCCESS;

}/* end of ChemSatFlip_duo */

/* ChemSatFlip_duo_sub is called by ChemSatFlip_duo. It calculates the optimized value for second ChemSat pusle for fat saturation. */
/* The calculated value is returned to the function ChemSatFlip_duo. */
float
ChemSatFlip_duo_sub(int delay_time,int tetime,int rc_time,int slquant,int tr_time, int sattime, int alpha, float delta_signal, int* remnant_signal_flags, double* SpecProf)
{
    int beta1 = DUO_START_SECOND_FA;
    int beta2 = DUO_END_SECOND_FA;
    int beta3 = (int)((DUO_START_SECOND_FA + DUO_END_SECOND_FA)/ 2);
    float duo_beta = DUO_END_SECOND_FA;

    float fat_signal_1 = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, alpha, beta1, SpecProf) - delta_signal;
    float fat_signal_2 = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, alpha, beta2, SpecProf) - delta_signal;
    float fat_signal_3 = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, alpha, beta3, SpecProf) - delta_signal;

    if( fat_signal_1 * fat_signal_2 <= 0.0 )
    {
        remnant_signal_flags[alpha] = 0;
        while( ((fat_signal_1 * fat_signal_2) <= 0.0) && ((beta2 - beta1) >= 2.0) )
        {
            if( (fat_signal_1 * fat_signal_3) > 0.0 )
            {
                beta1 = beta3;
                fat_signal_1 = fat_signal_3;
            }
            else
            {
                beta2 = beta3;
                fat_signal_2 = fat_signal_3;
            }
            beta3 = (int)((beta1 + beta2)/ 2);
            fat_signal_3 = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, alpha, beta3, SpecProf) - delta_signal;
        }
        if( (fat_signal_1 * fat_signal_2) < 0 )
        {
            duo_beta = beta1 + (beta2 - beta1) * fat_signal_1/ (fat_signal_1 - fat_signal_2);
        }
    }
    else /* no signal zero point. duo_beta is selected at minimum fat_signal*/
    {
        remnant_signal_flags[alpha] = 1;
        while( (beta2 - beta1) >= 2.0 )
        {
            if( ((fat_signal_3 - fat_signal_2) >= 0.0) && (fat_signal_3 > 0.0) )
            {
                beta1 = beta3;
                fat_signal_1 = fat_signal_3;
            }
            else
            {
                beta2 = beta3;
                fat_signal_2 = fat_signal_3;
            }
            beta3 = (int)((beta1 + beta2)/ 2);
            fat_signal_3 = Signal_fat_duo(delay_time, tetime, rc_time, slquant, tr_time, sattime, alpha, beta3, SpecProf) - delta_signal;
        }
        if( (fat_signal_1) <= fat_signal_2 )
        {
            duo_beta = beta1;
        }
        else
        {
            duo_beta = beta2;
        }
    }
    return duo_beta;
} /* end of ChemSatFlip_duo_sub */

/* Signal_fat_duo is called by ChemSatFlip_duo_sub. It calculates the fat signal for given flip1 and flip2. */
/* The calculated value is returned to the function ChemSatFlip_duo_sub. */
float
Signal_fat_duo(int delay_time,int tetime,int rc_time,int slquant,int tr_time, int sattime, int alpha, int beta, double* SpecProf)
{
    int i,j;
    float seq_time;
    float *amp = chemsat_amp;
    float T1[9];
    float *T2 = chemsat_T2;
    float Mz;
    float EE[9];
    float ER[9];
    float ES[9];
    float ECS[9];     /* represent time between 2 chem sat pulses */
    float angle1;
    float angle2;
    float factor1[9];
    float factor2[9];
    float signal_fat; /* return signal_fat */

    if( setupFatComponentT1(T1) == FAILURE )
    {
        epic_error(0, "Error to set up T1 fat components", 0, EE_ARGS(0));
        return FAILURE;
    }
    /* Sequence time equals tr_time divided by slquant */
    seq_time = (float)tr_time/(float)slquant;

    /* signal_fat initialization */
    signal_fat = 0.0;
    /* calculate signal of nine fat components */
    for (i = 0; i < 9; i++)
        {
#ifndef __linux__
                EE[i] = fexp(-(float)(tetime)/(T2[i]*1000.0));
                ES[i] = fexp(-(float)delay_time/(T1[i]*1000.0));
                /* ER represent time from 2nd cs pulse to next 1st cs pulse. */
                ER[i] = fexp(-((float)seq_time-sattime)/(T1[i]*1000.0));
                ECS[i] = fexp(-(float)sattime/(T1[i]*1000.0));
#else
                EE[i] = exp(-(float)(tetime)/(T2[i]*1000.0));
                ES[i] = exp(-(float)delay_time/(T1[i]*1000.0));
                /* ER represent time from 2nd cs pulse to next 1st cs pulse. */
                ER[i] = exp(-((float)seq_time-sattime)/(T1[i]*1000.0));
                ECS[i] = exp(-(float)sattime/(T1[i]*1000.0));
#endif
                /* HCSDM00403560:When use DB_CS_PULSE,factor1 & factor2 can be calculated this way */
                if ( DB_CS_PULSE == ChemSatPulse )
                {
                     if (i<6)
                     {
                         angle1 = ((float)alpha)*PI/180.0;
                         angle2 = ((float)beta)*PI/180.0;
                     }
                     else
                     {
                         angle1 = 0.0;
                         angle2 = 0.0;
                     }
#ifndef __linux__
                     factor1[i] = fcos(angle1);
                     factor2[i] = fcos(angle2);
#else
                     factor1[i] = cos(angle1);
                     factor2[i] = cos(angle2);
#endif
                }
                else
                {
                     /* use spectrol profile directly */
                     factor1[i] = SpecProf[i*180 + alpha-1];
                     factor2[i] = SpecProf[i*180 + beta-1];
                }

                /* *********************************************** *
                * Assuming at the TE time, the Mz of the fat is   *
                * zero. At the time of the next ChemSat RF pulse, *
                * the Mz is calculated.                           *
                * *********************************************** */
                /* till the first cs pulse*/
#ifndef __linux__
                Mz = 1.0 - fexp(-(seq_time-rc_time-delay_time-sattime)/(T1[i]*1000.0));
#else
                Mz = 1.0 - exp(-(seq_time-rc_time-delay_time-sattime)/(T1[i]*1000.0));
#endif
                /* ************************************************* *
                * Next, slquant-1 number of pair of ChemSat RF pulses
                * are played. The interval between cs pulse 1 and 2  *
                * is cs_sattime, time between cs pulse 2 and next cs
                * pulse 1 is seq_time - cs_sattime.
                * ************************************************* */
                for (j=1; j<slquant; j++)
                {
                        /* till second cs pulse */
                        Mz = 1.0 + (Mz*factor1[i] - 1.0)*ECS[i];
                        /* till next first cs pulse */
                        Mz = 1.0 + (Mz*factor2[i] - 1.0)*ER[i];
                }


                /* Here we are standing at a new TR for the same slice.
                  Mz before 2nd cs pulse */
                Mz = 1.0 + (Mz*factor1[i] - 1.0)*ECS[i];
                /* At the 90 degree excitation RF pulse */
                Mz = 1.0 + (Mz*factor2[i] - 1.0)*ES[i];

                /* fat signal can be computed thru: */
                signal_fat = signal_fat + amp[i]*EE[i]*Mz;
        }
    return signal_fat;
} /* end of Signal_fat_duo */


STATUS
ChemSatCheck( void )
{

    if ( ( fatFlag == PSD_ON )   && (exist(opwater) == PSD_ON) ) { 
        epic_error(use_ermes, "Fat and Water Suppression may not be selected together.",
                   EM_PSD_FW_INCOMPATIBLE,0);
        return FAILURE;
    }

    /* The following 3 conditions should not occur in product by design of the UI, but checked 
       for research handling and debug purposes only. No Error message database used. - RJF */

    if ( exist(opfat) && exist(opfatcl) && existcv(opfat) && existcv(opfatcl) ) { 
        epic_error ( 0, "Classic and New Fat Sat techniques are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }

    if ( exist(opfat) && exist(opspecir) && existcv(opfat) && existcv(opspecir) ) { 
        epic_error ( 0, "SPECIAL and Fat Selections are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }

    if ( exist(opfatcl) && exist(opspecir) && existcv(opfatcl) && existcv(opspecir) ) { 
        epic_error ( 0, "SPECIAL and Classic Fat Selections are mutually exclusive.", 
                     0, EE_ARGS(0) );
        return FAILURE;
    }
 
    return SUCCESS;

}
    
    

static char failstr[]  = "Support routine %s failed";

    /* Subroutine to set rf & gradient pulse structures.  */ 

void
sp_set_num_pulses( RF_PULSE *rf_struct,
                   GRAD_PULSE *grad_struct )
{
    rf_struct->num = 1;
    grad_struct->num = 1;

    /* Set activity masks. */
    rf_struct->activity += PSD_APS2_ON + PSD_MPS2_ON + PSD_SCAN_ON;
    
    return;
}

  /* Set rf pulse structure for each sat */

void
sp_set_rfpulse( INT pulse_type,
                RF_PULSE *rf_struct,
                INT *resoln,
                INT *pw_rf,
                INT *bw_rf,
                INT sat_band_type)
{
    switch (pulse_type)
    {
    case SINC_SAT:
        if (*pw_rf == 4800 )
            *resoln = RES_SLRSAT;
        else 
            *resoln = RES_NVRGSAT;
        /*            *pw_rf = 3.2ms;*/
        rf_struct->max_b1 = MAX_B1_SINC1_90;
        rf_struct->max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rf_struct->max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rf_struct->effwidth = SAR_PSINC1;
        *bw_rf = (int)(4.*((float)1000000/(float)*pw_rf));
	break;

    case SLR_SAT:
        *resoln = RES_SLRSAT;
        /*            *pw_rf = 4.0ms;*/
        rf_struct->effwidth = SAR_PSLR;
        *bw_rf = (int)(1227.*((float)4000/(float)*pw_rf));
        break;

    case SLR_CSAT:
        *resoln = RES_SLRCSAT;
        *bw_rf = (int)((rf_struct->nom_bw * rf_struct->nom_pw )/ (float) *pw_rf);
        break;

    default:
        break;
    }
    return;
}

/* Subroutine to determine slice select parameters for sat pulses */

STATUS
sp_set_slice_select( INT *pw_slice_select,
                     INT * pw_slice_select_a,
                     INT *pw_slice_select_d,
                     INT pw_rf,
                     FLOAT *amp_slice_select,
                     INT *bw_rf,
                     DOUBLE thickness,
                     DOUBLE targetamp,
                     INT target_rt,
                     INT pulse_type )
{
    *pw_slice_select = pw_rf;
    switch (pulse_type) 
    {

    case SINC_SAT:
	*bw_rf = (int)(4.*((float)1000000/(float)pw_rf));
	break;
	
    case SLR_SAT:
	*bw_rf = (int)(1227.*((float)4000/(float)pw_rf));
        break;

    case SLR_CSAT:
        *bw_rf = (int) ( (float) (12000.0*1000)/ (float) pw_rf );
	break;
	
    default:
	break;
    }
    /* Slice select gradient amplitude for the sat pulse. */
    if (ampslice(amp_slice_select, *bw_rf, thickness, gsat_scale, TYPDEF)
        == FAILURE) 
    {
        epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "ampslice");
        return FAILURE;
    }
    /* Now optimize those ramps. */
    if (optramp(pw_slice_select_a, *amp_slice_select,targetamp,
                target_rt,TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp");
        return FAILURE;
    }

    *pw_slice_select_d = *pw_slice_select_a;

    /* Pad out the attack ramp to allow time for the SSP packets. */
    /*    if (*pw_slice_select_a < 268)
     *pw_slice_select_a = 268;
     */
    /* vmx 3/13/95  YI */
    *pw_slice_select_a = IMax(2,*pw_slice_select_a,
                              RUP_GRD(minimumPreRfSspTime()) );
    /* end vmx */ 
    return (SUCCESS);
}


/* Reinitialize rfpulseInfo structure for given slot number.
   Required in case pulse switches from 4ms to 4.8ms on the fly
 */
STATUS
sp_initrfpulseInfo( RF_PULSE_INFO rfPulseInfo[],
                    INT pulse )
{
    rfPulseInfo[pulse].change = PSD_OFF;
    rfPulseInfo[pulse].newres = 0;

    return SUCCESS;
}

/* routine to determine if pulses require scaling or not. If yes, then
   slice select gradient and bandwidth are modified accordingly */

STATUS
sp_scalerfpulses( DOUBLE weight,
                  GRADIENT_COIL_E gcoiltype,
                  RF_PULSE *rfPulse,
                  INT numentry,
                  RF_PULSE_INFO *rfPulseInfo,
                  INT pulse )
{
    double derateb1;        /* Derated max B1 for patient weight */
    INT entry;              /* temp variable for entry loop */
    double safety_factor = 0.90;

    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed,
                    coilInfo, opncoils);
    
    if (numTxIndexUsed != 1)
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "sp_scalerfpulses");
        return FAILURE; 
    }

    /*
      Initialize pulse information structure to zeroes. This requires
      SpSatEval to come after scalerfpulses() in the PSD's. Since we are
      only working on a specific pulse in the structure we will not affect
      other pulses in the PSD.
    */
    /* Handle multiple calls to SpSatEval within 1 cveval call */
    /* Reset the Pulse Info Table to get correct scaling of SAT pulses for each
     * CVEAVL call*/
    rfPulseInfo->change = PSD_OFF;
    rfPulseInfo->newres = 0;

    for( entry = 0; entry < numentry; ++entry ) {

        /*************************************************************************
         * Use equation based on coil type, and patient weight.  If we do not use
         * head coil, then body is the transmit coil.             
         *************************************************************************/
        if( SDL_RFDerating_entry_sat( &derateb1, cffield, weight,
                                      txCoilInfo[txIndex[0]], gcoiltype,
                                      entry, 1.0 ) != SUCCESS )
        {
            return FAILURE;
        }
    
        derateb1 = FMin( 2, 24.0, derateb1 );
        derateb1 *= safety_factor;

        if( rfPulse->extgradfile )
        {
            return SUCCESS;
        }

        scalerfpulses2ut( derateb1, GRAD_UPDATE_TIME, rfPulse, entry,
		          pulse, rfPulseInfo, exciterUsed[0]);
    }

    return SUCCESS;
}

/* Compacts rotation matrices from scan into array used by the psd */

void
sp_get_rot_matrix( float *source,
                   long *dest)
{
    INT  i;

    for (i = 0; i < 9; ++i)
    {
        *dest++ = hostToRspRotMat(*source++);
    }
    return;
}

/* transfers rotation matrix to SCAN_INFO struct for use with obloptimize */

void
sp_get_scaninfo_matrix( float *source,
                        SCAN_INFO *dest )
{
    INT i;
    for (i=0; i<9; i++)
    {
        dest->oprot[i] = *source++;
    }
    return;
}

STATUS
sp_init_satloggrd( LOG_GRAD *sloggrd )
{
    PHYS_GRAD temp_phygrd;  /* dummy struct for calling inittargets */

    if( FAILURE == inittargets(sloggrd,&temp_phygrd) ) {
        return FAILURE;
    }

    return SUCCESS;
}

/* Eval sat code that determines how long sat pulses will take */

STATUS 
SpSatEval( INT *time_spsat )
{
    INT bw_rfsx1, 
        bw_rfsx2, 
        bw_rfsy1, 
        bw_rfsy2, 
        bw_rfsz1, 
        bw_rfsz2,
        bw_rfse1,
        bw_rfse2,
        bw_rfse3, 
        bw_rfse4, 
        bw_rfse5, 
        bw_rfse6;

    INT status;
    INT skip_next_sat;
    INT parallel_mask;
    INT explicit_sat_mask;
    INT array_index;
    INT i, j ;
    SCAN_INFO satscaninfo;
    GRADIENT_COIL_E gcoiltype = (GRADIENT_COIL_E)cfgcoiltype;

    /* calculate killer areas compatible to 5.4 */
    int sr17_scale;
    float killer_length;
#ifdef  ADDYCRUSHER
    float area_gy1grad = 0.0;
#endif /* ADDYCRUSHER */
    float sat_scale1,sat_scale2,sat_scale3,sat_scale4,sat_scale5,sat_scale6; 
    float sat_scalex1,sat_scalex2;
    float sat_scaley1,sat_scaley2;
    float sat_scalez1,sat_scalez2;

    /* vmx 3/13/95 YI */
    if( cfpwrmontyp == PMTYP_VMX ) 
    {
        spsat_sys_type  = _spsat_sys_type.fixedflag ?  ((void)(1), spsat_sys_type) : 1;
        rfupa = spsat_rfupa;
    }
    /* end vmx */

    /* Set the cyc_ variables for all of the rf pulses */
    /* cyc_rfs selected in SpSatinit. */
    cyc_rfsx1  = _cyc_rfsx1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsx1) : cyc_rfs;    /* Sinc cycles for default SAT */
    cyc_rfsx2  = _cyc_rfsx2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsx2) : cyc_rfs;
    cyc_rfsy1  = _cyc_rfsy1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsy1) : cyc_rfs;
    cyc_rfsy2  = _cyc_rfsy2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsy2) : cyc_rfs;
    cyc_rfsz1  = _cyc_rfsz1.fixedflag ?  ((void)(cyc_rfs), cyc_rfsz1) : cyc_rfs;
    cyc_rfsz2  = _cyc_rfsz2.fixedflag ?  ((void)(cyc_rfs), cyc_rfsz2) : cyc_rfs;

    cyc_rfse1  = _cyc_rfse1.fixedflag ?  ((void)(cyc_rfs), cyc_rfse1) : cyc_rfs;   /* Sinc cycles for explicit SAT */
    cyc_rfse2  = _cyc_rfse2.fixedflag ?  ((void)(cyc_rfs), cyc_rfse2) : cyc_rfs;
    cyc_rfse3  = _cyc_rfse3.fixedflag ?  ((void)(cyc_rfs), cyc_rfse3) : cyc_rfs;
    cyc_rfse4  = _cyc_rfse4.fixedflag ?  ((void)(cyc_rfs), cyc_rfse4) : cyc_rfs;
    cyc_rfse5  = _cyc_rfse5.fixedflag ?  ((void)(cyc_rfs), cyc_rfse5) : cyc_rfs;
    cyc_rfse6  = _cyc_rfse6.fixedflag ?  ((void)(cyc_rfs), cyc_rfse6) : cyc_rfs;

    sat_newgeo  = _sat_newgeo.fixedflag ?  ((void)(1), sat_newgeo) : 1;
    sat_rot_ex_num  = _sat_rot_ex_num.fixedflag ?  ((void)(0), sat_rot_ex_num) : 0;
    sat_rot_df_num  = _sat_rot_df_num.fixedflag ?  ((void)(0), sat_rot_df_num) : 0;

    for (i=0; i< 13; ++i)
        for (j = 0; j < 9; ++j)
            sat_rot_matrices[i][j] = 0;

    /* Check to see wether we allow ConCat Sat */
    if ((exist(opsat)==PSD_ON) && (exist(opileave)==PSD_OFF) && 
        (exist(opplane)!=PSD_OBL)) 
        piccsatnub = 1;
    else
        piccsatnub = 0;

    /* Turn off sat pulses in gradient and rf pulse structures if
       sat is deselected. */
    if ((exist(opsat) == PSD_OFF) || ((opsatx == PSD_OFF)&&(opsaty == PSD_OFF)
                                      &&(opsatz == PSD_OFF) && (opexsatmask == PSD_OFF)))
    {
        rfpulse[RFSX1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSX2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSY1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSY2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSZ1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSZ2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE1_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE2_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE3_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE4_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE5_SLOT].activity = PSD_PULSE_OFF;
        rfpulse[RFSE6_SLOT].activity = PSD_PULSE_OFF;

        gradx[GXRFSX1_SLOT].num = 0;
        gradx[GXRFSX2_SLOT].num = 0;
        grady[GYRFSY1_SLOT].num = 0;
        grady[GYRFSY2_SLOT].num = 0;
        gradz[GZRFSZ1_SLOT].num = 0;
        gradz[GZRFSZ2_SLOT].num = 0;
        gradz[GZRFSE1_SLOT].num = 0;
        gradz[GZRFSE2_SLOT].num = 0;
        gradz[GZRFSE3_SLOT].num = 0;
        gradz[GZRFSE4_SLOT].num = 0;
        gradz[GZRFSE5_SLOT].num = 0;
        gradz[GZRFSE6_SLOT].num = 0;

        grady[GYKSE1_SLOT].num = 0;
        grady[GYKSE2_SLOT].num = 0;
        grady[GYKSE3_SLOT].num = 0;
        grady[GYKSE4_SLOT].num = 0;
        grady[GYKSE5_SLOT].num = 0;
        grady[GYKSE6_SLOT].num = 0;
        grady[GYKSX1_SLOT].num = 0;
        grady[GYKSX2_SLOT].num = 0;
        grady[GYKSY1_SLOT].num = 0;
        grady[GYKSY2_SLOT].num = 0;
        grady[GYKSZ1_SLOT].num = 0;
        grady[GYKSZ2_SLOT].num = 0;

#ifdef SPSATXKILLER
        gradx[GXKSE1_SLOT].num = 0;
        gradx[GXKSE2_SLOT].num = 0;
        gradx[GXKSE3_SLOT].num = 0;
        gradx[GXKSE4_SLOT].num = 0;
        gradx[GXKSE5_SLOT].num = 0;
        gradx[GXKSE6_SLOT].num = 0;
        gradx[GXKSX1_SLOT].num = 0;
        gradx[GXKSX2_SLOT].num = 0;
        gradx[GXKSY1_SLOT].num = 0;
        gradx[GXKSY2_SLOT].num = 0;
        gradx[GXKSZ1_SLOT].num = 0;
        gradx[GXKSZ2_SLOT].num = 0;
#endif

        *time_spsat = 0;
        return (SUCCESS);
    }

    /*   KILLER GRADIENT AREAS FOR DEFAULT SAT

    Killer gradient areas depend on what combination of
    sat pulses are selected.  To maintain the same area
    as in 5.4, calculations are :

    area = (600us + 3ms) * amplitude from table below
    ((5.4 ramp time + 5.4 pulse width) * 5.4 amplitude)

    In addition, if sr17 mode, make sure that the target amplitude
    passed to amppwgrad is limited based on the amplitude values
    below in order to exactly simulate 5.4. 
         

    SAT X alone:    killer for x = .95
    SAT Y alone:    killer for y = .95
    SAT Z alone:    killer for z = .95
    SAT X & Y  :    killer for x = .5
    killer for y = .95
    SAT X & Z  :    killer for x = .5
    killer for z = .95
    SAT Y & Z  :    killer for y = .5
    killer for z = .95
    SAT X,Y,Z  :    killer for x = .5
    killer for y = .5
    killer for z = .95

    */


#ifdef  ADDYCRUSHER
    /* Calculate gy1 gradient area if satbands are selected - AC, MRIge83260 */

    if((PSD_SE == exist(oppseq)) && ((PSD_OFF != exist(opsatz)) || (PSD_OFF != exist(opsaty)) || (PSD_OFF != exist(opsatx))) ) {
                                    
        area_gy1grad = fabs(((a_gy1a * pw_gy1a + a_gy1b*pw_gy1d)/ 2.0)+ ((a_gy1a + a_gy1b)/2.0)*pw_gy1);
    }
#endif

    /* use the pulsewidths defined in 5.4 to calculate the total area */
    killer_length = 600   + 3000;

    /*JAH: MRIge54221 -- With default sats parallel to the slice and no other
      spatial saturation pulses and fat sat on, short TR, small yres,
      frequency direction flow compensated FSE sequences exhibit stripe
      artifacts unless the spatial sat crusher widths are increased.*/

    if((PSD_OFF != exist(opsat)) && (PSD_ON == exist(opfat))
       && ((PSD_OFF != exist(opsatz)) && (PSD_OFF == exist(opsaty))
           && (PSD_OFF == exist(opsatx))) && (PSD_SE == exist(oppseq))
       && (PSD_ON == exist(opfast)) && (PSD_ON == exist(opfcomp))
       && (1 == exist(opfcaxis)))
        killer_length = 1060   + 3000;

#ifdef  ADDYCRUSHER

    /* Set the killer_length area to 2.05 times gy1 grad area to kill the simulation echo path which occurs in high resolution spin echo based sequences - AC, MRIge83262 */

    if((PSD_SE == exist(oppseq)) && ((PSD_OFF != exist(opsatz)) || (PSD_OFF != exist(opsaty)) || (PSD_OFF != exist(opsatx))) ) {

    	if (killer_length < (2.05 * area_gy1grad)) {
            /* Set killer area to a new value to fix fine line artifacts in small FOVs, since
               some spsat crushers are using %50 of killer length, we multiply area_gy1grad by 2.0  AC */
            killer_length = 2.05 * area_gy1grad;
     	}
    }

    /* GEHmr03645 - Increase the crusher widths from 1060us+3ms to 4540, to fix stripe artifacts on SV. */
    /* The minimum crusher area I found necessary to crush the unwanted coherence at all Y-res values was 4310. 
       This translated to an increase in the variable killer_length is 4310/0.95 ~= 4540. Feb/05/2010 */
    if((PSD_OFF != exist(opsat)) && (PSD_ON == exist(opfat))
       && (((PSD_OFF != exist(opsatz)) && (PSD_OFF == exist(opsaty)) && (PSD_OFF == exist(opsatx))) || (opexsatmask > 0)) 
       && (PSD_SE == exist(oppseq)) && (PSD_ON == exist(opfast)) 
       && (PSD_ON == exist(opfcomp)) && (1 == exist(opfcaxis))) {
        killer_length = (4540 > (2.05*area_gy1grad))? 4540: (2.05*area_gy1grad);
    }
    
#endif


    /* find out if we are in sr17 mode */
    /*if (psd_getgradmode() == PSD_SR17)*/ /* MFO,Hino, Feb/02/00 MM */
    if ((psd_getgradmode() == PSD_SR17) || (psd_getgradmode() == PSD_SR25))
        sr17_scale = 1;
    else
        sr17_scale=0;

    /* initialize all scale factors to 1.0 */
    sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=1.0;
    sat_scalex1=sat_scalex2=sat_scaley1=sat_scaley2=sat_scalez1=sat_scalez2=1.0; 

    if ((exist(opsaty) != PSD_OFF)||(exist(opsatz) != PSD_OFF))
    {
        area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.5), area_gyksx1) : killer_length*0.5; 
        area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.5), area_gyksx2) : killer_length*0.5;
        area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
        area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
        if (sr17_scale) sat_scalex1=sat_scalex2 = 0.5;
    }
    else 
    {
        if (exist(opsatx) ==  PSD_SATPARA)
        {
            area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.5), area_gyksx1) : killer_length*0.5;
            area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.95), area_gyksx2) : killer_length*0.95;
            area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
            area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksx2) : -killer_length*0.95;
            if (sr17_scale)
	    {
                sat_scalex1= 0.5;
                sat_scalex2 = 0.95;
	    }
        }
        else
        {
            area_gyksx1  = _area_gyksx1.fixedflag ?  ((void)(killer_length*0.95), area_gyksx1) : killer_length*0.95;
	    area_gyksx2  = _area_gyksx2.fixedflag ?  ((void)(killer_length*0.95), area_gyksx2) : killer_length*0.95;
	    area_gxksx1  = _area_gxksx1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksx1) : -killer_length*0.95;
	    area_gxksx2  = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
            if (sr17_scale) sat_scalex1 = sat_scalex2 = 0.95;
        }
    }
    
    if (exist(opsatz) != PSD_OFF) 
    {
        area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.5), area_gyksy1) : killer_length*0.5;
        area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.5), area_gyksy2) : killer_length*0.5;
        area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
        area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
        if (sr17_scale) sat_scaley1 = sat_scaley2 = 0.5;
    }
    else 
    {
        if (exist(opsaty) == PSD_SATPARA)
        {
            area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.5), area_gyksy1) : killer_length*0.5;
            area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.95), area_gyksy2) : killer_length*0.95;
	    area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
	    area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksy2) : -killer_length*0.95;
            if (sr17_scale)
            {
		sat_scaley1 = 0.5;
            	sat_scaley2 = 0.95;
            }
        }
        else
        {
            area_gyksy1  = _area_gyksy1.fixedflag ?  ((void)(killer_length*0.95), area_gyksy1) : killer_length*0.95;
	    area_gyksy2  = _area_gyksy2.fixedflag ?  ((void)(killer_length*0.95), area_gyksy2) : killer_length*0.95;
	    area_gxksy1  = _area_gxksy1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksy1) : -killer_length*0.95;
	    area_gxksy2  = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
            if (sr17_scale) sat_scaley1 = sat_scaley2 = 0.95;
        }
    }
    
    if (exist(opsatz) == PSD_SATPARA)
    {
        area_gyksz1  = _area_gyksz1.fixedflag ?  ((void)(killer_length*0.5), area_gyksz1) : killer_length*0.5;
        area_gyksz2  = _area_gyksz2.fixedflag ?  ((void)(killer_length*0.95), area_gyksz2) : killer_length*0.95;
        area_gxksz1  = _area_gxksz1.fixedflag ?  ((void)(0.0), area_gxksz1) : 0.0;
        area_gxksz2  = _area_gxksz2.fixedflag ?  ((void)(-killer_length*0.95), area_gxksz2) : -killer_length*0.95;
        if (sr17_scale)
        {
	    sat_scalez1 = 0.5;
	    sat_scalez2 = 0.95;
        }
    }
    else
    {
        area_gyksz1  = _area_gyksz1.fixedflag ?  ((void)(killer_length*0.95), area_gyksz1) : killer_length*0.95;
        area_gyksz2  = _area_gyksz2.fixedflag ?  ((void)(killer_length*0.95), area_gyksz2) : killer_length*0.95;
        area_gxksz1  = _area_gxksz1.fixedflag ?  ((void)(-killer_length*0.95), area_gxksz1) : -killer_length*0.95;
        area_gxksz2  = _area_gxksz2.fixedflag ?  ((void)(0.0), area_gxksz2) : 0.0;
        if (sr17_scale) sat_scalez1 = sat_scalez2 = 0.95;
    }
    
    /* If any default sat are on, all explicit sat killers are .5 */
    if ((exist(opsatx) != PSD_OFF) || (exist(opsaty) != PSD_OFF) ||
	(exist(opsatz) != PSD_OFF))
    {
        area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.5), area_gykse1) : killer_length*0.5;
        area_gykse2  = _area_gykse2.fixedflag ?  ((void)(killer_length*0.5), area_gykse2) : killer_length*0.5;
        area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.5), area_gykse3) : killer_length*0.5;
        area_gykse4  = _area_gykse4.fixedflag ?  ((void)(killer_length*0.5), area_gykse4) : killer_length*0.5;
        area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.5), area_gykse5) : killer_length*0.5;
	area_gykse6  = _area_gykse6.fixedflag ?  ((void)(killer_length*0.5), area_gykse6) : killer_length*0.5; 

        area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
        area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
        area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
        area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
        area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
        area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;

        if (sr17_scale)
            sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=0.5;
    }
    else
    {
	/* If no default sats are on, the last explicit sat is set to .95
	   and rest are .5 */
        area_gykse1 = _area_gykse1.fixedflag ?  ((void)(killer_length*0.5), area_gykse1) : killer_length*0.5;
        area_gykse2 = _area_gykse2.fixedflag ?  ((void)(killer_length*0.5), area_gykse2) : killer_length*0.5;
        area_gykse3 = _area_gykse3.fixedflag ?  ((void)(killer_length*0.5), area_gykse3) : killer_length*0.5;
        area_gykse4 = _area_gykse4.fixedflag ?  ((void)(killer_length*0.5), area_gykse4) : killer_length*0.5;
        area_gykse5 = _area_gykse5.fixedflag ?  ((void)(killer_length*0.5), area_gykse5) : killer_length*0.5; 
        area_gykse6 = _area_gykse6.fixedflag ?  ((void)(killer_length*0.5), area_gykse6) : killer_length*0.5;
	
        area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
        area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
        area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
        area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
        area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
        area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;
	xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_OFF), xkiller_set) : PSD_OFF;
	
        if (sr17_scale)
            sat_scale1=sat_scale2=sat_scale3=sat_scale4=sat_scale5=sat_scale6=0.5;

	/* Fix for SPR 17235. When a Hadamard pulse is the last pulse in the
           sequence, both killers must be set to .95. Only one is used
           later. */
        if ((exist(opexsatmask) & PSD_EXPLICIT_6) == PSD_EXPLICIT_6)
        {
	    area_gykse6  = _area_gykse6.fixedflag ?  ((void)(killer_length*0.95), area_gykse6) : killer_length*0.95;
	    area_gxkse6  = _area_gxkse6.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse6) : -killer_length*0.95;
	    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            if (sr17_scale) sat_scale6 = 0.95;
            if ((exist(opexsatparal) & PSD_3_PARALLEL) == PSD_3_PARALLEL)
            {
                area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.95), area_gykse5) : killer_length*0.95;
		if (!floatsAlmostEqualEpsilons(area_gxkse6, 0.0, 2))
                {
		    area_gxkse5  = _area_gxkse5.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse5) : -killer_length*0.95;
		    area_gxkse6 = _area_gxkse6.fixedflag ? ((void)(0.0), area_gxkse6) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale5 = 0.95;
            }
        } 
        else if ((exist(opexsatmask) & PSD_EXPLICIT_5) == PSD_EXPLICIT_5)
        {
            area_gykse5  = _area_gykse5.fixedflag ?  ((void)(killer_length*0.95), area_gykse5) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse5  = _area_gxkse5.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse5) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale5= 0.95;
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_4) == PSD_EXPLICIT_4)
        {
            area_gykse4  = _area_gykse4.fixedflag ?  ((void)(killer_length*0.95), area_gykse4) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse4  = _area_gxkse4.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse4) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale4 = 0.95;
            if ((exist(opexsatparal) & PSD_2_PARALLEL) == PSD_2_PARALLEL)
            {
                area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.95), area_gykse3) : killer_length*0.95;
		if (!floatsAlmostEqualEpsilons(area_gxkse4, 0.0, 2))
                {
		    area_gxkse3  = _area_gxkse3.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse3) : -killer_length*0.95;
		    area_gxkse4  = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale3 = 0.95;
            }
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_3) == PSD_EXPLICIT_3)
        {
            area_gykse3  = _area_gykse3.fixedflag ?  ((void)(killer_length*0.95), area_gykse3) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse3  = _area_gxkse3.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse3) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale3 = 0.95;
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_2) == PSD_EXPLICIT_2)
        {
            area_gykse2  = _area_gykse2.fixedflag ?  ((void)(killer_length*0.95), area_gykse2) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse2  = _area_gxkse2.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse2) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale2 = 0.95;
            if ((exist(opexsatparal) & PSD_1_PARALLEL) == PSD_1_PARALLEL)
            {
                area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.95), area_gykse1) : killer_length*0.95;
		if (!floatsAlmostEqualEpsilons(area_gxkse2, 0.0, 2))
                {
		    area_gxkse1  = _area_gxkse1.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse1) : -killer_length*0.95;
		    area_gxkse2  = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
		    xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
                }
                if (sr17_scale) sat_scale1 = 0.95;
            } 
        }
        else if ((exist(opexsatmask) & PSD_EXPLICIT_1) == PSD_EXPLICIT_1)
        {
            area_gykse1  = _area_gykse1.fixedflag ?  ((void)(killer_length*0.95), area_gykse1) : killer_length*0.95;
	    if (xkiller_set==PSD_OFF)
            {
		area_gxkse1  = _area_gxkse1.fixedflag ?  ((void)(-killer_length*0.95), area_gxkse1) : -killer_length*0.95;
		xkiller_set  = _xkiller_set.fixedflag ?  ((void)(PSD_ON), xkiller_set) : PSD_ON;
            }
            if (sr17_scale) sat_scale1 = 0.95;
        }
    }

    /* set the areas to 0 if the XKILLER is not defined, a 0 area turns off pulsegen
       code and modifications */
#ifndef SPSATXKILLER
    area_gxksx1 = _area_gxksx1.fixedflag ?  ((void)(0.0), area_gxksx1) : 0.0;
    area_gxksx2 = _area_gxksx2.fixedflag ?  ((void)(0.0), area_gxksx2) : 0.0;
    area_gxksy1 = _area_gxksy1.fixedflag ?  ((void)(0.0), area_gxksy1) : 0.0;
    area_gxksy2 = _area_gxksy2.fixedflag ?  ((void)(0.0), area_gxksy2) : 0.0;
    area_gxksz1 = _area_gxksz1.fixedflag ?  ((void)(0.0), area_gxksz1) : 0.0;
    area_gxksz2 = _area_gxksz2.fixedflag ?  ((void)(0.0), area_gxksz2) : 0.0;
    area_gxkse1 = _area_gxkse1.fixedflag ?  ((void)(0.0), area_gxkse1) : 0.0;
    area_gxkse2 = _area_gxkse2.fixedflag ?  ((void)(0.0), area_gxkse2) : 0.0;
    area_gxkse3 = _area_gxkse3.fixedflag ?  ((void)(0.0), area_gxkse3) : 0.0;
    area_gxkse4 = _area_gxkse4.fixedflag ?  ((void)(0.0), area_gxkse4) : 0.0;
    area_gxkse5 = _area_gxkse5.fixedflag ?  ((void)(0.0), area_gxkse5) : 0.0;
    area_gxkse6 = _area_gxkse6.fixedflag ?  ((void)(0.0), area_gxkse6) : 0.0;
#endif

    satthickx1  = _satthickx1.fixedflag ?   ((void)((float)exist(opdfsathick1)), satthickx1) : (float)exist(opdfsathick1);
    satthickx2  = _satthickx2.fixedflag ?   ((void)((float)exist(opdfsathick2)), satthickx2) : (float)exist(opdfsathick2);
    satthicky1  = _satthicky1.fixedflag ?   ((void)((float)exist(opdfsathick3)), satthicky1) : (float)exist(opdfsathick3);
    satthicky2  = _satthicky2.fixedflag ?   ((void)((float)exist(opdfsathick4)), satthicky2) : (float)exist(opdfsathick4);
    satthickz1  = _satthickz1.fixedflag ?   ((void)((float)exist(opdfsathick5)), satthickz1) : (float)exist(opdfsathick5);
    satthickz2  = _satthickz2.fixedflag ?   ((void)((float)exist(opdfsathick6)), satthickz2) : (float)exist(opdfsathick6);

    /* If the debug flag is off then use the rotation matrices provided
       by scan for the explicit sat bands.  */ /* 3/13/95 YI */
    if (sat_debug == 0)
    {
        for (i=0; i<6; ++i)
        {
            sat_info[i][0] = eg_sat_rot[i][0];
            sat_info[i][1] = eg_sat_rot[i][3];
            sat_info[i][2] = eg_sat_rot[i][6];
            sat_info[i][3] = eg_sat_rot[i][1];
            sat_info[i][4] = eg_sat_rot[i][4];
            sat_info[i][5] = eg_sat_rot[i][7];
            sat_info[i][6] = eg_sat_rot[i][2];
            sat_info[i][7] = eg_sat_rot[i][5];
            sat_info[i][8] = eg_sat_rot[i][8];
        } 
    }
    /* For debugging purposing, disregard the rotation matrices from scan. */
    else
    {
        switch (sat_debug)
        {
            /* Calculate the rotation matrices from psc_info with LS's calculation */
            case 2:
                if (oppscvquant > 0)
                {
                    /* Set S and I sat bands with psc_info */
                    for (i=0; i<2; i++)
                    {
                        for (j=0; j<9; j++)
                        {
                            sat_info[i][j] = psc_info[0].oppscrot[j];
                        }
                    }

                    /* Set A and P sat bands by rotating psc_info 90 degrees along Y-axis */
                    for (i=2; i<4; i++)
                    {
                        sat_info[i][0] = -sat_info[0][2];
                        sat_info[i][1] = sat_info[0][1];
                        sat_info[i][2] = sat_info[0][0];
                        sat_info[i][3] = -sat_info[0][5];
                        sat_info[i][4] = sat_info[0][4];
                        sat_info[i][5] = sat_info[0][3];
                        sat_info[i][6] = -sat_info[0][8];
                        sat_info[i][7] = sat_info[0][7];
                        sat_info[i][8] = sat_info[0][6];
                    }

                    /* Set R and L sat bands by rotating psc_info 90 degrees along X-axis */
                    for (i=4; i<6; i++)
                    {
                        sat_info[i][0] = sat_info[0][0];
                        sat_info[i][1] = sat_info[0][2];
                        sat_info[i][2] = -sat_info[0][1];
                        sat_info[i][3] = sat_info[0][3];
                        sat_info[i][4] = sat_info[0][5];
                        sat_info[i][5] = -sat_info[0][4];
                        sat_info[i][6] = sat_info[0][6];
                        sat_info[i][7] = sat_info[0][8];
                        sat_info[i][8] = -sat_info[0][7];
                    }
                }
                break;

            /* Calculate the rotation matrices from psc_info with HS's calculation */
            case 3:
                if (oppscvquant > 0)
                {
                    /* Set S and I sat bands with psc_info */
                    for (i=0; i<2; i++)
                    {
                        for (j=0; j<9; j++)
                        {
                            sat_info[i][j] = psc_info[0].oppscrot[j];
                        }
                    }

                    /* Set A and P sat bands by rotating psc_info 90 degrees along Y-axis */
                    for (i=2; i<4; i++)
                    {
                        sat_info[i][0] = sat_info[0][2];
                        sat_info[i][1] = sat_info[0][1];
                        sat_info[i][2] = -sat_info[0][0];
                        sat_info[i][3] = sat_info[0][5];
                        sat_info[i][4] = sat_info[0][4];
                        sat_info[i][5] = -sat_info[0][3];
                        sat_info[i][6] = sat_info[0][8];
                        sat_info[i][7] = sat_info[0][7];
                        sat_info[i][8] = -sat_info[0][6];
                    }

                    /* Set R and L sat bands by rotating psc_info 90 degrees along X-axis */
                    for (i=4; i<6; i++)
                    {
                        sat_info[i][0] = sat_info[0][0];
                        sat_info[i][1] = -sat_info[0][2];
                        sat_info[i][2] = sat_info[0][1];
                        sat_info[i][3] = sat_info[0][3];
                        sat_info[i][4] = -sat_info[0][5];
                        sat_info[i][5] = sat_info[0][4];
                        sat_info[i][6] = sat_info[0][6];
                        sat_info[i][7] = -sat_info[0][8];
                        sat_info[i][8] = sat_info[0][7];
                    }
                }
                break;

            /* Set the rotation matrices with 27 rsp variables for AutoShim, has to be set in @rsp */
            case 4:
                break;

            /* Set the rotation matrices to the unit vector. */
            default:
                for (i = 0; i<6; ++i)
                {
                    for (j=0; j <9; ++j)
                    {
                        sat_info[i][j] = 0.0;
                    }
                    sat_info[i][8] = 1.0;
                } 
                break;
        } 
    }

    if (opfluorotrigger)
    {
        for (i = 0; i<6; ++i)
        {
            /* SAT along S/I direction */
            sat_info[i][0] = 1.0;
            sat_info[i][1] = 0.0;
            sat_info[i][2] = 0.0;
            sat_info[i][3] = 0.0;
            sat_info[i][4] = 1.0;
            sat_info[i][5] = 0.0;
            sat_info[i][6] = 0.0;
            sat_info[i][7] = 0.0;
            sat_info[i][8] = 1.0;
        }
    }

    *time_spsat = 0;

    /* If a sat axis is hadamard, its effective width is decreased by a 
       factor of 2 due to the cosine modultation.  Since its amplitude is
       doubled, and power is proportional to the square of the amplitude 
       but only directly proportional to the effective width, a hadamard 
       pulse has twice the SAR as a single sideband pulse. */

    /*********************************************************/
    /* Default SAT band RF and gradient pulse structures.

    Rf pulses   Gradients
    RFSX1         GXSX1    
    RFSX2         GXSX2   
    RFSY1         GYSY1  
    RFSY2         GYSY2 
    RFSZ1         GZSZ1
    RFSZ2         GZSZ2

    Explicit SAT band RF and gradient pulse structures.

    Rf pulses   Gradients
    RFSE1         GZSE1    
    RFSE2         GZSE2   
    RFSE3         GZSE3  
    RFSE4         GZSE4 
    RFSE5         GZSE5
    RFSE6         GZSE6
    *************************************************************/

    /* DEFAULT SAT RF PULSE STRUCTURES */
    rfpulse[RFSX1_SLOT].num = 0;                    
    rfpulse[RFSX1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSX2_SLOT].num = 0;                    
    rfpulse[RFSX2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSY1_SLOT].num = 0;
    rfpulse[RFSY1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSY2_SLOT].num = 0;
    rfpulse[RFSY2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSZ1_SLOT].num = 0;
    rfpulse[RFSZ1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSZ2_SLOT].num = 0;
    rfpulse[RFSZ2_SLOT].activity = PSD_PULSE_OFF;

    /* EXPLICIT SAT RF PULSE STRUCTURES */
    rfpulse[RFSE1_SLOT].num = 0;                    
    rfpulse[RFSE1_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE2_SLOT].num = 0;                    
    rfpulse[RFSE2_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE3_SLOT].num = 0;
    rfpulse[RFSE3_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE4_SLOT].num = 0;
    rfpulse[RFSE4_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE5_SLOT].num = 0;
    rfpulse[RFSE5_SLOT].activity = PSD_PULSE_OFF;
    rfpulse[RFSE6_SLOT].num = 0;
    rfpulse[RFSE6_SLOT].activity = PSD_PULSE_OFF;

    /* DEFAULT SAT X GRADIENT STRUCTURES */
    gradx[GXRFSX1_SLOT].num = 0;
    gradx[GXRFSX2_SLOT].num = 0;
      
    /* DEFAULT SAT Y GRADIENT STRUCTURES */
    grady[GYRFSY1_SLOT].num = 0;
    grady[GYRFSY2_SLOT].num = 0;

    /* DEFAULT SAT Z GRADIENT STRUCTURES */
    gradz[GZRFSZ1_SLOT].num = 0;
    gradz[GZRFSZ2_SLOT].num = 0;

    /* KILLERS FOR DEFAULT SAT GRADIENT STRUCTURES--ALWAYS ON Y */
    grady[GYKSX1_SLOT].num = 0;
    grady[GYKSX2_SLOT].num = 0;
    grady[GYKSY1_SLOT].num = 0;
    grady[GYKSY2_SLOT].num = 0;
    grady[GYKSZ1_SLOT].num = 0;
    grady[GYKSZ2_SLOT].num = 0;

    /* EXPLICIT SAT GRADIENT STRUCTURES */
    gradz[GZRFSE1_SLOT].num = 0;
    gradz[GZRFSE2_SLOT].num = 0;
    gradz[GZRFSE3_SLOT].num = 0;
    gradz[GZRFSE4_SLOT].num = 0;
    gradz[GZRFSE5_SLOT].num = 0;
    gradz[GZRFSE6_SLOT].num = 0;

    /* KILLERS FOR EXPLICIT SAT GRADIENT STRUCTURES--ALWAYS ON Y */
    grady[GYKSE1_SLOT].num = 0;
    grady[GYKSE2_SLOT].num = 0;
    grady[GYKSE3_SLOT].num = 0;
    grady[GYKSE4_SLOT].num = 0;
    grady[GYKSE5_SLOT].num = 0;
    grady[GYKSE6_SLOT].num = 0;

#ifdef SPSATXKILLER
    gradx[GXKSE1_SLOT].num = 0;
    gradx[GXKSE2_SLOT].num = 0;
    gradx[GXKSE3_SLOT].num = 0;
    gradx[GXKSE4_SLOT].num = 0;
    gradx[GXKSE5_SLOT].num = 0;
    gradx[GXKSE6_SLOT].num = 0;
    gradx[GXKSX1_SLOT].num = 0;
    gradx[GXKSX2_SLOT].num = 0;
    gradx[GXKSY1_SLOT].num = 0;
    gradx[GXKSY2_SLOT].num = 0;
    gradx[GXKSZ1_SLOT].num = 0;
    gradx[GXKSZ2_SLOT].num = 0;
#endif

    /* Scale all sat pulses to 1 initially. Scaling is done
       later on a per-entry point basis. */

    sat_rot_index  = _sat_rot_index.fixedflag ?  ((void)(0), sat_rot_index) : 0;
    array_index = 0;
    if ((opsatx != PSD_OFF) || (opsaty != PSD_OFF) || (opsatz != PSD_OFF) ||
        (opexsatmask != PSD_OFF))
    {
        /**********************************************************
          EXPLICIT SAT PROCESSING 

        opexsatmask = mask where each bit represents an explicit sat
                      band ( a limit of 6 bands are allowed)

       1. Check if sat band exists. 
       2. Initialize the rf & gradient pulse structures to the correct
          number of pulses
       3. Place rotation matrix for SAT band in array. Array contains
          rotation matrices in order of playout for SAT bands.
       4. Set up rf pulse structure for correct type of RF pulse
       5. Check if two explicit sat bands are parallel. If so, then a
          Hadamard RF pulse can be used to create both sat bands. 
          Initialize the rf & gradient pulse structures appropriately. 
          The next explicit sat band can be skipped since it has already
          been accounted for the in the Hadamard pulse.
       6. Compute the slice select amplitude. 
       7. Calculate the time needed to play out the sat pulses. 
          The sp_killerdelay occurs between the sat slice select and the 
          killer to accomodate the ISI & matrix update when all gradients 
          are zero. The rot_delay occurs after the killer to update
          rotation matrix when all gradients are zero.
       8. If the next pulse hasn't been accounted for via the Hadamard
          pulse, process the next pulse.

        ****************************************************************/

        parallel_mask = exist(opexsatparal);
        explicit_sat_mask = exist(opexsatmask);

        switch (sat_debug)
        {
            /* debug the shim vol information from psc_info */ /* 15-Feb-2015 HS */
            case 2:
            case 3:
            case 4:
                if (oppscvquant > 0)
                {
                    exsatthick1  = _exsatthick1.fixedflag ?   ((void)((float)psc_info[0].oppsclenz), exsatthick1) : (float)psc_info[0].oppsclenz;
                    exsatthick2  = _exsatthick2.fixedflag ?   ((void)((float)psc_info[0].oppsclenz), exsatthick2) : (float)psc_info[0].oppsclenz;
                    exsatthick3  = _exsatthick3.fixedflag ?   ((void)((float)psc_info[0].oppsclenx), exsatthick3) : (float)psc_info[0].oppsclenx;
                    exsatthick4  = _exsatthick4.fixedflag ?   ((void)((float)psc_info[0].oppsclenx), exsatthick4) : (float)psc_info[0].oppsclenx;
                    exsatthick5  = _exsatthick5.fixedflag ?   ((void)((float)psc_info[0].oppscleny), exsatthick5) : (float)psc_info[0].oppscleny;
                    exsatthick6  = _exsatthick6.fixedflag ?   ((void)((float)psc_info[0].oppscleny), exsatthick6) : (float)psc_info[0].oppscleny;
                }
                break;

            /* For other cases, use the thickness provided by scan for the explicit sat bands.  */
            default:
        exsatthick1  = _exsatthick1.fixedflag ?   ((void)((float)exist(opexsathick1)), exsatthick1) : (float)exist(opexsathick1);
        exsatthick2  = _exsatthick2.fixedflag ?   ((void)((float)exist(opexsathick2)), exsatthick2) : (float)exist(opexsathick2);
        exsatthick3  = _exsatthick3.fixedflag ?   ((void)((float)exist(opexsathick3)), exsatthick3) : (float)exist(opexsathick3);
        exsatthick4  = _exsatthick4.fixedflag ?   ((void)((float)exist(opexsathick4)), exsatthick4) : (float)exist(opexsathick4);
        exsatthick5  = _exsatthick5.fixedflag ?   ((void)((float)exist(opexsathick5)), exsatthick5) : (float)exist(opexsathick5);
        exsatthick6  = _exsatthick6.fixedflag ?   ((void)((float)exist(opexsathick6)), exsatthick6) : (float)exist(opexsathick6);
            break;
        }

        if (opfluorotrigger)
        {
            float temploc1, temploc2;

            temploc1= -0.5*(exist(opfov)+exist(opexsathick1)-20.0);
            temploc2= +0.5*(exist(opfov)+exist(opexsathick2)-20.0);

            if (temploc1 < -rtia3d_sat_pos )
                temploc1 = -rtia3d_sat_pos;

            if (temploc2 > rtia3d_sat_pos )
	        temploc2 = rtia3d_sat_pos;

            cvoverride( opexsatloc1, temploc1, PSD_FIX_ON, PSD_EXIST_ON); 
            cvoverride( opexsatloc2, temploc2 , PSD_FIX_ON, PSD_EXIST_ON); 
        }
    
        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_1) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE1_SLOT], &gradz[GZRFSE1_SLOT]);
            grady[GYKSE1_SLOT].num = 1;

            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) && 
                ((exist(opexsatparal) & PSD_1_PARALLEL) == PSD_1_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE1_SLOT,_pw_rfse1.fixedflag ? (_temp711_pw_rfse1=pw_rfse1,&_temp711_pw_rfse1) : &pw_rfse1,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[0][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[0][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp712_sat_newgeo=sat_newgeo,&_temp712_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }
            sp_set_rfpulse(vrgsat, &rfpulse[RFSE1_SLOT], _res_rfse1.fixedflag ? (_temp713_res_rfse1=res_rfse1,&_temp713_res_rfse1) : &res_rfse1,
                           _pw_rfse1.fixedflag ? (_temp714_pw_rfse1=pw_rfse1,&_temp714_pw_rfse1) : &pw_rfse1, &bw_rfse1, SAT_EXPLICIT);

            sat_rot_ex_indices[sat_rot_index] = 1;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_1_PARALLEL) != 0)
            {
                skip_next_sat = 1;

                rfpulse[RFSE1_SLOT].apply_as_hadamard_factor = 2;
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE1_SLOT],RFSE1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse1.fixedflag ? (_temp715_pw_gzrfse1=pw_gzrfse1,&_temp715_pw_gzrfse1) : &pw_gzrfse1, _pw_gzrfse1a.fixedflag ? (_temp716_pw_gzrfse1a=pw_gzrfse1a,&_temp716_pw_gzrfse1a) : &pw_gzrfse1a, 
                                         _pw_gzrfse1d.fixedflag ? (_temp717_pw_gzrfse1d=pw_gzrfse1d,&_temp717_pw_gzrfse1d) : &pw_gzrfse1d, pw_rfse1, _a_gzrfse1.fixedflag ? (_temp718_a_gzrfse1=a_gzrfse1,&_temp718_a_gzrfse1) : &a_gzrfse1, &bw_rfse1, exsatthick1,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE1_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE1_SLOT],area_gykse1,
                               loggrd.ty*sat_scale1,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse1");
                return FAILURE;
            }	
            grady[GYKSE1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale1);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse1a+pw_gykse1+pw_gykse1d), maxkiller_time) : pw_gykse1a+pw_gykse1+pw_gykse1d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse1, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE1_SLOT],area_gykse1,
                                   loggrd.ty_xy*sat_scale1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse1");
                    return FAILURE;
                }
                grady[GYKSE1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale1);

                gradx[GXKSE1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE1_SLOT],area_gxkse1,
                                   loggrd.tx_xy*sat_scale1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse1");
                    return FAILURE;
                }	
                gradx[GXKSE1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse1a+pw_gykse1+pw_gykse1d,pw_gxkse1a+pw_gxkse1+pw_gxkse1d)), maxkiller_time) : IMax(2,pw_gykse1a+pw_gykse1+pw_gykse1d,pw_gxkse1a+pw_gxkse1+pw_gxkse1d);
#endif
	    }

            *time_spsat += pw_gzrfse1a + pw_rfse1 +
                RUP_GRD(IMax(2,pw_gzrfse1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE2_SLOT], &gradz[GZRFSE2_SLOT]);
            grady[GYKSE2_SLOT].num = 1;

            sp_get_rot_matrix(&sat_info[1][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[1][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp719_sat_newgeo=sat_newgeo,&_temp719_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE2_SLOT], _res_rfse2.fixedflag ? (_temp720_res_rfse2=res_rfse2,&_temp720_res_rfse2) : &res_rfse2,
                           _pw_rfse2.fixedflag ? (_temp721_pw_rfse2=pw_rfse2,&_temp721_pw_rfse2) : &pw_rfse2, &bw_rfse2, SAT_EXPLICIT);

            sat_rot_ex_indices[sat_rot_index] = 2;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE2_SLOT],RFSE2_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse2.fixedflag ? (_temp722_pw_gzrfse2=pw_gzrfse2,&_temp722_pw_gzrfse2) : &pw_gzrfse2, _pw_gzrfse2a.fixedflag ? (_temp723_pw_gzrfse2a=pw_gzrfse2a,&_temp723_pw_gzrfse2a) : &pw_gzrfse2a, 
                                         _pw_gzrfse2d.fixedflag ? (_temp724_pw_gzrfse2d=pw_gzrfse2d,&_temp724_pw_gzrfse2d) : &pw_gzrfse2d, pw_rfse2, _a_gzrfse2.fixedflag ? (_temp725_a_gzrfse2=a_gzrfse2,&_temp725_a_gzrfse2) : &a_gzrfse2, &bw_rfse2, exsatthick2,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);

            gradz[GZRFSE2_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/
            if (status == FAILURE)
                return (FAILURE);


            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE2_SLOT],area_gykse2,
                               loggrd.ty*sat_scale2,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse2");
                return FAILURE;
            }	
          
	    grady[GYKSE2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale2);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse2a+pw_gykse2+pw_gykse2d), maxkiller_time) : pw_gykse2a+pw_gykse2+pw_gykse2d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse2, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE2_SLOT],area_gykse2,
                                   loggrd.ty_xy*sat_scale2,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse2");
                    return FAILURE;
                }
          
		grady[GYKSE2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale2);

                gradx[GXKSE2_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE2_SLOT],area_gxkse2,
                                   loggrd.tx_xy*sat_scale2,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse2");
                    return FAILURE;
                }	
          
		gradx[GXKSE2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale2);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse2a+pw_gykse2+pw_gykse2d,pw_gxkse2a+pw_gxkse2+pw_gxkse2d)), maxkiller_time) : IMax(2,pw_gykse2a+pw_gykse2+pw_gykse2d,pw_gxkse2a+pw_gxkse2+pw_gxkse2d);
#endif
	    }
            *time_spsat += pw_gzrfse2a + pw_rfse2 +
                RUP_GRD(IMax(2,pw_gzrfse2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }
     
     
        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_3) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE3_SLOT], &gradz[GZRFSE3_SLOT]);
            grady[GYKSE3_SLOT].num = 1;

            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                ((exist(opexsatparal) & PSD_2_PARALLEL) == PSD_2_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE3_SLOT,_pw_rfse3.fixedflag ? (_temp726_pw_rfse3=pw_rfse3,&_temp726_pw_rfse3) : &pw_rfse3,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[2][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[2][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp727_sat_newgeo=sat_newgeo,&_temp727_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE3_SLOT], _res_rfse3.fixedflag ? (_temp728_res_rfse3=res_rfse3,&_temp728_res_rfse3) : &res_rfse3,
                           _pw_rfse3.fixedflag ? (_temp729_pw_rfse3=pw_rfse3,&_temp729_pw_rfse3) : &pw_rfse3, &bw_rfse3, SAT_EXPLICIT);

            sat_rot_ex_indices[sat_rot_index] = 3;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_2_PARALLEL) != 0)
            {
                skip_next_sat = 1;
              
                rfpulse[RFSE3_SLOT].apply_as_hadamard_factor = 2;
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE3_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE3_SLOT],RFSE3_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse3.fixedflag ? (_temp730_pw_gzrfse3=pw_gzrfse3,&_temp730_pw_gzrfse3) : &pw_gzrfse3, _pw_gzrfse3a.fixedflag ? (_temp731_pw_gzrfse3a=pw_gzrfse3a,&_temp731_pw_gzrfse3a) : &pw_gzrfse3a, 
                                         _pw_gzrfse3d.fixedflag ? (_temp732_pw_gzrfse3d=pw_gzrfse3d,&_temp732_pw_gzrfse3d) : &pw_gzrfse3d, pw_rfse3, _a_gzrfse3.fixedflag ? (_temp733_a_gzrfse3=a_gzrfse3,&_temp733_a_gzrfse3) : &a_gzrfse3, &bw_rfse3, exsatthick3,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE3_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale  QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE3_SLOT],area_gykse3,
                               loggrd.ty*sat_scale3,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse3");
                return FAILURE;
            }	
            grady[GYKSE3_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale3);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse3a+pw_gykse3+pw_gykse3d), maxkiller_time) : pw_gykse3a+pw_gykse3+pw_gykse3d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse3, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE3_SLOT],area_gykse3,
                                   loggrd.ty_xy*sat_scale3,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse3");
                    return FAILURE;
                }
                grady[GYKSE3_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale3);

                gradx[GXKSE3_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE3_SLOT],area_gxkse3,
                                   loggrd.tx_xy*sat_scale3,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse3");
                    return FAILURE;
                }	
                gradx[GXKSE3_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale3);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse3a+pw_gykse3+pw_gykse3d,pw_gxkse3a+pw_gxkse3+pw_gxkse3d)), maxkiller_time) : IMax(2,pw_gykse3a+pw_gykse3+pw_gykse3d,pw_gxkse3a+pw_gxkse3+pw_gxkse3d);
#endif
	    }
            *time_spsat += pw_gzrfse3a + pw_rfse3 +
                RUP_GRD(IMax(2,pw_gzrfse3d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        grady[GYKSE4_SLOT].num = 0;
        if (((explicit_sat_mask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE4_SLOT], &gradz[GZRFSE4_SLOT]);
            grady[GYKSE4_SLOT].num = 1;
 
            sp_get_rot_matrix(&sat_info[3][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[3][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp734_sat_newgeo=sat_newgeo,&_temp734_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE4_SLOT], _res_rfse4.fixedflag ? (_temp735_res_rfse4=res_rfse4,&_temp735_res_rfse4) : &res_rfse4,
                           _pw_rfse4.fixedflag ? (_temp736_pw_rfse4=pw_rfse4,&_temp736_pw_rfse4) : &pw_rfse4, &bw_rfse4, SAT_EXPLICIT);

            sat_rot_ex_indices[sat_rot_index] = 4;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE4_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE4_SLOT],RFSE4_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse4.fixedflag ? (_temp737_pw_gzrfse4=pw_gzrfse4,&_temp737_pw_gzrfse4) : &pw_gzrfse4, _pw_gzrfse4a.fixedflag ? (_temp738_pw_gzrfse4a=pw_gzrfse4a,&_temp738_pw_gzrfse4a) : &pw_gzrfse4a, 
                                         _pw_gzrfse4d.fixedflag ? (_temp739_pw_gzrfse4d=pw_gzrfse4d,&_temp739_pw_gzrfse4d) : &pw_gzrfse4d, pw_rfse4, _a_gzrfse4.fixedflag ? (_temp740_a_gzrfse4=a_gzrfse4,&_temp740_a_gzrfse4) : &a_gzrfse4, &bw_rfse4, exsatthick4,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE4_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE4_SLOT],area_gykse4,
                               loggrd.ty*sat_scale4,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse4");
                return FAILURE;
            }	
            grady[GYKSE4_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale4);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse4a+pw_gykse4+pw_gykse4d), maxkiller_time) : pw_gykse4a+pw_gykse4+pw_gykse4d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse4, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE4_SLOT],area_gykse4,
                                   loggrd.ty_xy*sat_scale4,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse4");
                    return FAILURE;
                }
                grady[GYKSE4_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale4);

                gradx[GXKSE4_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE4_SLOT],area_gxkse4,
                                   loggrd.tx_xy*sat_scale4,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse4");
                    return FAILURE;
                }	
                gradx[GXKSE4_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale4);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse4a+pw_gykse4+pw_gykse4d,pw_gxkse4a+pw_gxkse4+pw_gxkse4d)), maxkiller_time) : IMax(2,pw_gykse4a+pw_gykse4+pw_gykse4d,pw_gxkse4a+pw_gxkse4+pw_gxkse4d);
#endif
	    }
            *time_spsat += pw_gzrfse4a + pw_rfse4 +
                RUP_GRD(IMax(2,pw_gzrfse4d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_5) != 0)
        {
            sp_set_num_pulses(&rfpulse[RFSE5_SLOT], &gradz[GZRFSE5_SLOT]);
            grady[GYKSE5_SLOT].num = 1;

            if ((opweight >= csweight) &&
                (TX_COIL_BODY == getTxCoilType()) &&
                ((exist(opexsatparal) & PSD_3_PARALLEL) == PSD_3_PARALLEL))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSE5_SLOT,_pw_rfse5.fixedflag ? (_temp741_pw_rfse5=pw_rfse5,&_temp741_pw_rfse5) : &pw_rfse5,rfpulseInfo);
            }

            sp_get_rot_matrix(&sat_info[4][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[4][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp742_sat_newgeo=sat_newgeo,&_temp742_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sat_rot_ex_indices[sat_rot_index] = 5;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE5_SLOT], _res_rfse5.fixedflag ? (_temp743_res_rfse5=res_rfse5,&_temp743_res_rfse5) : &res_rfse5,
                           _pw_rfse5.fixedflag ? (_temp744_pw_rfse5=pw_rfse5,&_temp744_pw_rfse5) : &pw_rfse5, &bw_rfse5, SAT_EXPLICIT);

            /* Can use Hadamard RF pulse */
            if ((parallel_mask & PSD_3_PARALLEL) != 0)
            {
                skip_next_sat = 1;
              
                rfpulse[RFSE5_SLOT].apply_as_hadamard_factor = 2;
            }

            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE5_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE5_SLOT],RFSE5_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse5.fixedflag ? (_temp745_pw_gzrfse5=pw_gzrfse5,&_temp745_pw_gzrfse5) : &pw_gzrfse5, _pw_gzrfse5a.fixedflag ? (_temp746_pw_gzrfse5a=pw_gzrfse5a,&_temp746_pw_gzrfse5a) : &pw_gzrfse5a, 
                                         _pw_gzrfse5d.fixedflag ? (_temp747_pw_gzrfse5d=pw_gzrfse5d,&_temp747_pw_gzrfse5d) : &pw_gzrfse5d, pw_rfse5, _a_gzrfse5.fixedflag ? (_temp748_a_gzrfse5=a_gzrfse5,&_temp748_a_gzrfse5) : &a_gzrfse5, &bw_rfse5, exsatthick5,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE5_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE5_SLOT],area_gykse5,
                               loggrd.ty*sat_scale5,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse5");
                return FAILURE;
            }	
            grady[GYKSE5_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale5);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse5a+pw_gykse5+pw_gykse5d), maxkiller_time) : pw_gykse5a+pw_gykse5+pw_gykse5d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse5, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE5_SLOT],area_gykse5,
                                   loggrd.ty_xy*sat_scale5,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse5");
                    return FAILURE;
                }
                grady[GYKSE5_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale5);

                gradx[GXKSE5_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE5_SLOT],area_gxkse5,
                                   loggrd.tx_xy*sat_scale5,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse5");
                    return FAILURE;
                }	
                gradx[GXKSE5_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale5);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse5a+pw_gykse5+pw_gykse5d,pw_gxkse5a+pw_gxkse5+pw_gxkse5d)), maxkiller_time) : IMax(2,pw_gykse5a+pw_gykse5+pw_gykse5d,pw_gxkse5a+pw_gxkse5+pw_gxkse5d);
#endif
	    }

            *time_spsat += pw_gzrfse5a + pw_rfse5 +
                RUP_GRD(IMax(2,pw_gzrfse5d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
        }


        grady[GYKSE6_SLOT].num = 0;
        if (((explicit_sat_mask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            sp_set_num_pulses(&rfpulse[RFSE6_SLOT], &gradz[GZRFSE6_SLOT]);
            grady[GYKSE6_SLOT].num = 1;


            sp_get_rot_matrix(&sat_info[5][0],
                              &sat_rot_matrices[array_index][0]);
            /* transfer sat_info to the structure obloptimize needs */
            sp_get_scaninfo_matrix(&sat_info[5][0],&satscaninfo);
            /* call opbloptimize with sat_scaninfo */
            if (obloptimize(&satloggrd, &phygrd, 
                            &satscaninfo, 1,
                            PSD_OBL, SAT_COAX, SAT_OBL_METHOD,
                            sat_obl_debug, _sat_newgeo.fixedflag ? (_temp749_sat_newgeo=sat_newgeo,&_temp749_sat_newgeo) : &sat_newgeo, cfsrmode)==FAILURE) {
                epic_error(use_ermes, failstr, EM_PSD_SUPPORT_FAILURE,
                           EE_ARGS(1), STRING_ARG, "obloptimize:sat");
                return FAILURE;
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSE6_SLOT], _res_rfse6.fixedflag ? (_temp750_res_rfse6=res_rfse6,&_temp750_res_rfse6) : &res_rfse6,
                           _pw_rfse6.fixedflag ? (_temp751_pw_rfse6=pw_rfse6,&_temp751_pw_rfse6) : &pw_rfse6, &bw_rfse6, SAT_EXPLICIT);

            sat_rot_ex_indices[sat_rot_index] = 6;
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;


            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSE6_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSE6_SLOT],RFSE6_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfse6.fixedflag ? (_temp752_pw_gzrfse6=pw_gzrfse6,&_temp752_pw_gzrfse6) : &pw_gzrfse6, _pw_gzrfse6a.fixedflag ? (_temp753_pw_gzrfse6a=pw_gzrfse6a,&_temp753_pw_gzrfse6a) : &pw_gzrfse6a, 
                                         _pw_gzrfse6d.fixedflag ? (_temp754_pw_gzrfse6d=pw_gzrfse6d,&_temp754_pw_gzrfse6d) : &pw_gzrfse6d, pw_rfse6, _a_gzrfse6.fixedflag ? (_temp755_a_gzrfse6=a_gzrfse6,&_temp755_a_gzrfse6) : &a_gzrfse6, &bw_rfse6, exsatthick6,
                                         satloggrd.tz,satloggrd.zrt,vrgsat);
            gradz[GZRFSE6_SLOT].powscale = satloggrd.zfs/satloggrd.tz;
            /* set .powscale    QT*/

            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if(amppwgradmethod(&grady[GYKSE6_SLOT],area_gykse6,
                               loggrd.ty*sat_scale6,0.0,0.0,
                               loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gykse6");
                return FAILURE;
            }	
            grady[GYKSE6_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scale6);
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gykse6a+pw_gykse6+pw_gykse6d), maxkiller_time) : pw_gykse6a+pw_gykse6+pw_gykse6d;


            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxkse6, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSE6_SLOT],area_gykse6,
                                   loggrd.ty_xy*sat_scale6,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gykse6");
                    return FAILURE;
                }
                grady[GYKSE6_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scale6);

                gradx[GXKSE6_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSE6_SLOT],area_gxkse6,
                                   loggrd.tx_xy*sat_scale6,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxkse6");
                    return FAILURE;
                }	
                gradx[GXKSE6_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scale6);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gykse6a+pw_gykse6+pw_gykse6d,pw_gxkse6a+pw_gxkse6+pw_gxkse6d)), maxkiller_time) : IMax(2,pw_gykse6a+pw_gykse6+pw_gykse6d,pw_gxkse6a+pw_gxkse6+pw_gxkse6d);
#endif
	    }

            *time_spsat += pw_gzrfse6a + pw_rfse6 +
                RUP_GRD(IMax(2,pw_gzrfse6d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	}
      
        sat_rot_ex_num  = _sat_rot_ex_num.fixedflag ?  ((void)(sat_rot_index), sat_rot_ex_num) : sat_rot_index; 

        /***************************************************************
        DEFAULT SAT PROCESSING 

       opsat<x,y,z> = 1   ==>  one direction SAT band
                      2   ==>  opposite direction SAT band
                      3   ==>  2 parallel SAT band with the same thickness
                                 can use Hadamard Rf pulse
                      4   ==>  2 parallel SAT bands but not same thickness 
                                 use two separate RF pulses

       1. Initialize the rf & gradient pulse structures to the correct
          number of pulses
       2. Set up rf pulse structure for correct type of RF pulse
       3. Save place in sat rotation matrix. Filled out during scan.
       4. If 2 sat bands are parallel but not the same thickness, two
          separate RF pulses are required. Initialize the rf & gradient
          pulse structures appropriately.
       5. If 2 sat bands are parallel with the same thickness, 1 haramard
          RF pulse can be used for both bands. Set the rf pulse structure
          appropriately.
       6. Compute the slice select amplitude. For the opsat case equal to
          4, 2 slice select gradients are needed.
       7. Calculate the time needed to play out the sat pulses. 
          The sp_killerdelay occurs between the sat slice select and the 
          killer to accomodate the ISI & matrix update when all gradients 
          are zero. The rot_delay occurs after the killer to update
          rotation matrix when all gradients are zero.
 
        **************************************************************/

        if (exist(opsatx) != PSD_OFF) 
        {
            sp_set_num_pulses(&rfpulse[RFSX1_SLOT], &gradx[GXRFSX1_SLOT]);
            grady[GYKSX1_SLOT].num = 1;
	  
            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsatx) == PSD_SATHAD) )
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSX1_SLOT,_pw_rfsx1.fixedflag ? (_temp756_pw_rfsx1=pw_rfsx1,&_temp756_pw_rfsx1) : &pw_rfsx1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSX1_SLOT], _res_rfsx1.fixedflag ? (_temp757_res_rfsx1=res_rfsx1,&_temp757_res_rfsx1) : &res_rfsx1, 
                           _pw_rfsx1.fixedflag ? (_temp758_pw_rfsx1=pw_rfsx1,&_temp758_pw_rfsx1) : &pw_rfsx1, &bw_rfsx1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;
	  
            /* 2 parallel SAT band w/distinct thickness => separate RF */
            if (exist(opsatx) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSX2_SLOT], &gradx[GXRFSX2_SLOT]);
                grady[GYKSX2_SLOT].num = 1;
	      
                sp_set_rfpulse(vrgsat, &rfpulse[RFSX2_SLOT], _res_rfsx2.fixedflag ? (_temp759_res_rfsx2=res_rfsx2,&_temp759_res_rfsx2) : &res_rfsx2,
                               _pw_rfsx2.fixedflag ? (_temp760_pw_rfsx2=pw_rfsx2,&_temp760_pw_rfsx2) : &pw_rfsx2, &bw_rfsx2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?   ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSX2_SLOT].num = 0;
                gradx[GXRFSX2_SLOT].num = 0;
                grady[GYKSX2_SLOT].num = 0;
            }
	  
	  
            /* 2 parallel SAT bands w/same thickness => Hadamard RF */
            if (exist(opsatx) == PSD_SATHAD)  
            { 
                /* Switch to Hadamard activity mask */
                rfpulse[RFSX1_SLOT].apply_as_hadamard_factor = 2;
            }
	  
            if (opsatx == PSD_SATNEG)
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
            else if (opsatx == PSD_SATPOS)
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx2), satthickdfx) : satthickx2;
            else
                satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSX1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSX1_SLOT],RFSX1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gxrfsx1.fixedflag ? (_temp761_pw_gxrfsx1=pw_gxrfsx1,&_temp761_pw_gxrfsx1) : &pw_gxrfsx1, _pw_gxrfsx1a.fixedflag ? (_temp762_pw_gxrfsx1a=pw_gxrfsx1a,&_temp762_pw_gxrfsx1a) : &pw_gxrfsx1a, _pw_gxrfsx1d.fixedflag ? (_temp763_pw_gxrfsx1d=pw_gxrfsx1d,&_temp763_pw_gxrfsx1d) : &pw_gxrfsx1d, 
                                         pw_rfsx1, _a_gxrfsx1.fixedflag ? (_temp764_a_gxrfsx1=a_gxrfsx1,&_temp764_a_gxrfsx1) : &a_gxrfsx1, &bw_rfsx1, satthickdfx,
                                         loggrd.tx,loggrd.xrt,vrgsat);
            gradx[GXRFSX1_SLOT].powscale = loggrd.xfs/loggrd.tx;
            /* set .powscale  QT*/
            if (status == FAILURE)
                return (FAILURE);
	  
            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSX1_SLOT],area_gyksx1,
                                loggrd.ty*sat_scalex1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksx1");
                return FAILURE;
            }	
	  
            if (opphysplane!=PSD_OBL)
                grady[GYKSX1_SLOT].powscale = 1.0;
            else
                grady[GYKSX1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalex1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksx1a+pw_gyksx1+pw_gyksx1d), maxkiller_time) : pw_gyksx1a+pw_gyksx1+pw_gyksx1d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxksx1, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSX1_SLOT],area_gyksx1,
                                   loggrd.ty_xy*sat_scalex1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksx1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSX1_SLOT].powscale = 1.0;
                else
                    grady[GYKSX1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalex1);

                gradx[GXKSX1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSX1_SLOT],area_gxksx1,
                                   loggrd.tx_xy*sat_scalex1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksx1");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSX1_SLOT].powscale = 1.0;
                else
                    gradx[GXKSX1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalex1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksx1a+pw_gyksx1+pw_gyksx1d,pw_gxksx1a+pw_gxksx1+pw_gxksx1d)), maxkiller_time) : IMax(2,pw_gyksx1a+pw_gyksx1+pw_gyksx1d,pw_gxksx1a+pw_gxksx1+pw_gxksx1d);
#endif
	    }

            *time_spsat += pw_gxrfsx1a + pw_rfsx1 +
                RUP_GRD(IMax(2,pw_gxrfsx1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsatx) == PSD_SATPARA)
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSX2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSX2_SLOT],RFSX2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gxrfsx2.fixedflag ? (_temp765_pw_gxrfsx2=pw_gxrfsx2,&_temp765_pw_gxrfsx2) : &pw_gxrfsx2, _pw_gxrfsx2a.fixedflag ? (_temp766_pw_gxrfsx2a=pw_gxrfsx2a,&_temp766_pw_gxrfsx2a) : &pw_gxrfsx2a, _pw_gxrfsx2d.fixedflag ? (_temp767_pw_gxrfsx2d=pw_gxrfsx2d,&_temp767_pw_gxrfsx2d) : &pw_gxrfsx2d, 
                                             pw_rfsx2, _a_gxrfsx2.fixedflag ? (_temp768_a_gxrfsx2=a_gxrfsx2,&_temp768_a_gxrfsx2) : &a_gxrfsx2, &bw_rfsx2, satthickx2,
                                             loggrd.tx,loggrd.xrt,vrgsat);
                gradx[GXRFSX2_SLOT].powscale = loggrd.xfs/loggrd.tx;
                /* set .powscale   QT*/
                if (status == FAILURE)
                    return (FAILURE);
	      
                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSX2_SLOT],area_gyksx2,
                                    loggrd.ty*sat_scalex2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksx2");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    grady[GYKSX2_SLOT].powscale = 1.0;
                else
                    grady[GYKSX2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalex2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksx2a+pw_gyksx2+pw_gyksx2d), maxkiller_time) : pw_gyksx2a+pw_gyksx2+pw_gyksx2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (!floatsAlmostEqualEpsilons(area_gxksx2, 0.0, 2))
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSX2_SLOT],area_gyksx2,
                                       loggrd.ty_xy*sat_scalex2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksx2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSX2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSX2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalex2);
		  
                    gradx[GXKSX2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSX2_SLOT],area_gxksx2,
                                       loggrd.tx_xy*sat_scalex2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksx2");
                        return FAILURE;
                    }	
                    if (opphysplane!=PSD_OBL)
                        gradx[GXKSX2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSX2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalex2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksx2a+pw_gyksx2+pw_gyksx2d,pw_gxksx2a+pw_gxksx2+pw_gxksx2d)), maxkiller_time) : IMax(2,pw_gyksx2a+pw_gyksx2+pw_gyksx2d,pw_gxksx2a+pw_gxksx2+pw_gxksx2d);
#endif
		}

                *time_spsat += pw_gxrfsx2a + pw_rfsx2 +
                    RUP_GRD(IMax(2,pw_gxrfsx2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	  
        }  /* end if opsatx */

        if (exist(opsaty) != PSD_OFF) 
        { 
            sp_set_num_pulses(&rfpulse[RFSY1_SLOT], &grady[GYRFSY1_SLOT]);
            grady[GYKSY1_SLOT].num = 1;
	  
            if ((opweight >= csweight) && 
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsaty) == PSD_SATHAD))
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSY1_SLOT,_pw_rfsy1.fixedflag ? (_temp769_pw_rfsy1=pw_rfsy1,&_temp769_pw_rfsy1) : &pw_rfsy1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSY1_SLOT], _res_rfsy1.fixedflag ? (_temp770_res_rfsy1=res_rfsy1,&_temp770_res_rfsy1) : &res_rfsy1, _pw_rfsy1.fixedflag ? (_temp771_pw_rfsy1=pw_rfsy1,&_temp771_pw_rfsy1) : &pw_rfsy1,
                           &bw_rfsy1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;
	  
            /* 2 parallel Sat bands w/distinct thickness => separate RF */
            if (exist(opsaty) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSY2_SLOT], &grady[GYRFSY2_SLOT]);
                grady[GYKSY2_SLOT].num = 1;
	      
                sp_set_rfpulse(vrgsat, &rfpulse[RFSY2_SLOT], _res_rfsy2.fixedflag ? (_temp772_res_rfsy2=res_rfsy2,&_temp772_res_rfsy2) : &res_rfsy2,
                               _pw_rfsy2.fixedflag ? (_temp773_pw_rfsy2=pw_rfsy2,&_temp773_pw_rfsy2) : &pw_rfsy2, &bw_rfsy2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSY2_SLOT].num = 0;
                grady[GYRFSY2_SLOT].num = 0;
                grady[GYKSY2_SLOT].num = 0;
            }
	  
	  
            /* 2 parallel Sat bands w/same thickness => Hadamard RF */
            if (exist(opsaty) == PSD_SATHAD)   
            { 
                /* Switch to Hadamard activity mask */
                rfpulse[RFSY1_SLOT].apply_as_hadamard_factor = 2;
            }
	  
            if (opsaty == PSD_SATNEG)
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
            else if (opsaty== PSD_SATPOS)
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky2), satthickdfy) : satthicky2;
            else
                satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSY1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSY1_SLOT],RFSY1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gyrfsy1.fixedflag ? (_temp774_pw_gyrfsy1=pw_gyrfsy1,&_temp774_pw_gyrfsy1) : &pw_gyrfsy1, _pw_gyrfsy1a.fixedflag ? (_temp775_pw_gyrfsy1a=pw_gyrfsy1a,&_temp775_pw_gyrfsy1a) : &pw_gyrfsy1a, _pw_gyrfsy1d.fixedflag ? (_temp776_pw_gyrfsy1d=pw_gyrfsy1d,&_temp776_pw_gyrfsy1d) : &pw_gyrfsy1d, 
                                         pw_rfsy1, _a_gyrfsy1.fixedflag ? (_temp777_a_gyrfsy1=a_gyrfsy1,&_temp777_a_gyrfsy1) : &a_gyrfsy1, &bw_rfsy1, satthickdfy,
                                         loggrd.ty,loggrd.yrt,vrgsat);
            grady[GYRFSY1_SLOT].powscale = loggrd.yfs/loggrd.ty;
            /* set .powscale   QT*/
	  
            if (status == FAILURE)
                return (FAILURE);

            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSY1_SLOT],area_gyksy1,
                                loggrd.ty*sat_scaley1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksy1");
                return FAILURE;
            }
            if (opphysplane!=PSD_OBL)
                grady[GYKSY1_SLOT].powscale = 1.0;
            else
                grady[GYKSY1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scaley1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksy1a+pw_gyksy1+pw_gyksy1d), maxkiller_time) : pw_gyksy1a+pw_gyksy1+pw_gyksy1d;

            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxksy1, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSY1_SLOT],area_gyksy1,
                                   loggrd.ty_xy*sat_scaley1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksy1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSY1_SLOT].powscale = 1.0;
                else
                    grady[GYKSY1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scaley1);

                gradx[GXKSY1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSY1_SLOT],area_gxksy1,
                                   loggrd.tx_xy*sat_scaley1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksy1");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSY1_SLOT].powscale = 1.0;
                else
                    gradx[GXKSY1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scaley1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksy1a+pw_gyksy1+pw_gyksy1d,pw_gxksy1a+pw_gxksy1+pw_gxksy1d)), maxkiller_time) : IMax(2,pw_gyksy1a+pw_gyksy1+pw_gyksy1d,pw_gxksy1a+pw_gxksy1+pw_gxksy1d);
#endif
	    }

            *time_spsat += pw_gyrfsy1a + pw_rfsy1 +
                RUP_GRD(IMax(2,pw_gyrfsy1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsaty) == PSD_SATPARA) 
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSY2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSY2_SLOT],RFSY2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gyrfsy2.fixedflag ? (_temp778_pw_gyrfsy2=pw_gyrfsy2,&_temp778_pw_gyrfsy2) : &pw_gyrfsy2, _pw_gyrfsy2a.fixedflag ? (_temp779_pw_gyrfsy2a=pw_gyrfsy2a,&_temp779_pw_gyrfsy2a) : &pw_gyrfsy2a, _pw_gyrfsy2d.fixedflag ? (_temp780_pw_gyrfsy2d=pw_gyrfsy2d,&_temp780_pw_gyrfsy2d) : &pw_gyrfsy2d, 
                                             pw_rfsy2, _a_gyrfsy2.fixedflag ? (_temp781_a_gyrfsy2=a_gyrfsy2,&_temp781_a_gyrfsy2) : &a_gyrfsy2, &bw_rfsy2, satthicky2,
                                             loggrd.ty,loggrd.yrt,vrgsat);
                grady[GYRFSY2_SLOT].powscale = loggrd.yfs/loggrd.ty;
                /* set .powscale   QT*/

                if (status == FAILURE)
                    return (FAILURE);

                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSY2_SLOT],area_gyksy2,
                                    loggrd.ty*sat_scaley2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksy2");
                    return FAILURE;
                }	
	      
                if (opphysplane!=PSD_OBL)
                    grady[GYKSY2_SLOT].powscale = 1.0;
                else
                    grady[GYKSY2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scaley2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksy2a+pw_gyksy2+pw_gyksy2d), maxkiller_time) : pw_gyksy2a+pw_gyksy2+pw_gyksy2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (!floatsAlmostEqualEpsilons(area_gxksy2, 0.0, 2))
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSY2_SLOT],area_gyksy2,
                                       loggrd.ty_xy*sat_scaley2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksy2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSY2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSY2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scaley2);
		  
                    gradx[GXKSY2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSY2_SLOT],area_gxksy2,
                                       loggrd.tx_xy*sat_scaley2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksy2");
                        return FAILURE;
                    }	
                    if (exist(opplane)!=PSD_OBL)
                        gradx[GXKSY2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSY2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scaley2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksy2a+pw_gyksy2+pw_gyksy2d,pw_gxksy2a+pw_gxksy2+pw_gxksy2d)), maxkiller_time) : IMax(2,pw_gyksy2a+pw_gyksy2+pw_gyksy2d,pw_gxksy2a+pw_gxksy2+pw_gxksy2d);
#endif
		}
                *time_spsat += pw_gyrfsy2a + pw_rfsy2 +
                    RUP_GRD(IMax(2,pw_gyrfsy2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	}  /* end of opsaty */

        if (exist(opsatz) != PSD_OFF) 
        {
            sp_set_num_pulses(&rfpulse[RFSZ1_SLOT],&gradz[GZRFSZ1_SLOT]);
            grady[GYKSZ1_SLOT].num = 1;
	  
            if ((opweight >= csweight) &&
                (TX_COIL_BODY == getTxCoilType()) &&
                (exist(opsatz) == PSD_SATHAD) )
            {
                SDL_InitSPSATRFPulseInfo(cffield,RFSZ1_SLOT,_pw_rfsz1.fixedflag ? (_temp782_pw_rfsz1=pw_rfsz1,&_temp782_pw_rfsz1) : &pw_rfsz1,rfpulseInfo);
            }

            sp_set_rfpulse(vrgsat, &rfpulse[RFSZ1_SLOT], _res_rfsz1.fixedflag ? (_temp783_res_rfsz1=res_rfsz1,&_temp783_res_rfsz1) : &res_rfsz1, 
                           _pw_rfsz1.fixedflag ? (_temp784_pw_rfsz1=pw_rfsz1,&_temp784_pw_rfsz1) : &pw_rfsz1, &bw_rfsz1, SAT_DEFAULT);
	  
            sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
            array_index += 2;

	  
            /* 2 parallel Sat pulses w/distinct thickness => separate RF */
            if (exist(opsatz) == PSD_SATPARA) 
            {
                sp_set_num_pulses(&rfpulse[RFSZ2_SLOT],&gradz[GZRFSZ2_SLOT]);
                grady[GYKSZ2_SLOT].num = 1;
                sp_set_rfpulse(vrgsat, &rfpulse[RFSZ2_SLOT], _res_rfsz2.fixedflag ? (_temp785_res_rfsz2=res_rfsz2,&_temp785_res_rfsz2) : &res_rfsz2,
                               _pw_rfsz2.fixedflag ? (_temp786_pw_rfsz2=pw_rfsz2,&_temp786_pw_rfsz2) : &pw_rfsz2, &bw_rfsz2, SAT_DEFAULT);
                sat_rot_index  = _sat_rot_index.fixedflag ?    ((void)(sat_rot_index+1), sat_rot_index) : sat_rot_index+1;
                array_index += 2;
            }
            else
            {
                rfpulse[RFSZ2_SLOT].num = 0;
                grady[GZRFSZ2_SLOT].num = 0;
                grady[GYKSZ2_SLOT].num = 0;
            }
	  
            /* 2 parallel Sat pulses w/same thickness => Hadamard Rf */
            if (exist(opsatz) == PSD_SATHAD) 
            { 
                /* Switch to Hadamard activity mask */
                rfpulse[RFSZ1_SLOT].apply_as_hadamard_factor = 2;
            }
	  
            if (opsatz == PSD_SATNEG)
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
            else if (opsatz == PSD_SATPOS)
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz2), satthickdfz) : satthickz2;
            else
                satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
	  
            /* perform rfpulse scaling */
            status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSZ1_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSZ1_SLOT],RFSZ1_SLOT);
            if (status == FAILURE)
                return (FAILURE);

            status = sp_set_slice_select(_pw_gzrfsz1.fixedflag ? (_temp787_pw_gzrfsz1=pw_gzrfsz1,&_temp787_pw_gzrfsz1) : &pw_gzrfsz1, _pw_gzrfsz1a.fixedflag ? (_temp788_pw_gzrfsz1a=pw_gzrfsz1a,&_temp788_pw_gzrfsz1a) : &pw_gzrfsz1a, _pw_gzrfsz1d.fixedflag ? (_temp789_pw_gzrfsz1d=pw_gzrfsz1d,&_temp789_pw_gzrfsz1d) : &pw_gzrfsz1d, 
                                         pw_rfsz1, _a_gzrfsz1.fixedflag ? (_temp790_a_gzrfsz1=a_gzrfsz1,&_temp790_a_gzrfsz1) : &a_gzrfsz1, &bw_rfsz1, satthickdfz,
                                         loggrd.tz,loggrd.zrt,vrgsat);
            gradz[GZRFSZ1_SLOT].powscale = loggrd.zfs/loggrd.tz;
            /* set .powscale    QT*/
            if (status == FAILURE)
                return (FAILURE);
	  
            /* call amppwgrad for killer pulse - use the loggrd structure
               since the rotation matrix changes back to this via ISI interrupt*/
            if (amppwgradmethod(&grady[GYKSZ1_SLOT],area_gyksz1,
                                loggrd.ty*sat_scalez1,0.0,0.0,
                                loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
            {
                epic_error(use_ermes, "%s failed in SpSat.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gyksz1");
                return FAILURE;
            }	
            if (opphysplane!=PSD_OBL)
                grady[GYKSZ1_SLOT].powscale = 1.0;
            else
                grady[GYKSZ1_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalez1);
	  
            maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksz1a+pw_gyksz1+pw_gyksz1d), maxkiller_time) : pw_gyksz1a+pw_gyksz1+pw_gyksz1d;
	  
            /* if both killers are on, adjust the targets so that obliques are
               handled correctly */
            if (!floatsAlmostEqualEpsilons(area_gxksz1, 0.0, 2))
	    {
#ifdef SPSATXKILLER
                if(amppwgradmethod(&grady[GYKSZ1_SLOT],area_gyksz1,
                                   loggrd.ty_xy*sat_scalez1,0.0,0.0,
                                   loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksz1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    grady[GYKSZ1_SLOT].powscale = 1.0;
                else
                    grady[GYKSZ1_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalez1);

                gradx[GXKSZ1_SLOT].num = 1;
                if(amppwgradmethod(&gradx[GXKSZ1_SLOT],area_gxksz1,
                                   loggrd.tx_xy*sat_scalez1,0.0,0.0,
                                   loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gxksz1");
                    return FAILURE;
                }
                if (opphysplane!=PSD_OBL)
                    gradx[GXKSZ1_SLOT].powscale = 1.0;
                else	
                    gradx[GXKSZ1_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalez1);

                maxkiller_time  = _maxkiller_time.fixedflag ?       
                                          ((void)(IMax(2,pw_gyksz1a+pw_gyksz1+pw_gyksz1d,pw_gxksz1a+pw_gxksz1+pw_gxksz1d)), maxkiller_time) : IMax(2,pw_gyksz1a+pw_gyksz1+pw_gyksz1d,pw_gxksz1a+pw_gxksz1+pw_gxksz1d);
#endif
	    }
            *time_spsat += pw_gzrfsz1a + pw_rfsz1 +
                RUP_GRD(IMax(2,pw_gzrfsz1d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
                pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                pw_rotupdate + isi_extra;
	  
            if (exist(opsatz) == PSD_SATPARA)
            {
                /* perform rfpulse scaling */
                status = sp_scalerfpulses(opweight,gcoiltype,&rfpulse[RFSZ2_SLOT],MAX_ENTRY_POINTS,&rfpulseInfo[RFSZ2_SLOT],RFSZ2_SLOT);
                if (status == FAILURE)
                    return (FAILURE);

                status = sp_set_slice_select(_pw_gzrfsz2.fixedflag ? (_temp791_pw_gzrfsz2=pw_gzrfsz2,&_temp791_pw_gzrfsz2) : &pw_gzrfsz2, _pw_gzrfsz2a.fixedflag ? (_temp792_pw_gzrfsz2a=pw_gzrfsz2a,&_temp792_pw_gzrfsz2a) : &pw_gzrfsz2a, _pw_gzrfsz2d.fixedflag ? (_temp793_pw_gzrfsz2d=pw_gzrfsz2d,&_temp793_pw_gzrfsz2d) : &pw_gzrfsz2d, 
                                             pw_rfsz2, _a_gzrfsz2.fixedflag ? (_temp794_a_gzrfsz2=a_gzrfsz2,&_temp794_a_gzrfsz2) : &a_gzrfsz2, &bw_rfsz2, satthickz2,
                                             loggrd.tz,loggrd.zrt,vrgsat);
                gradz[GZRFSZ2_SLOT].powscale = loggrd.zfs/loggrd.tz;
                /* set .powscale    QT*/
	      
                if (status == FAILURE)
                    return (FAILURE);
	      
                /* call amppwgrad for killer pulse - use the loggrd structure
                   since the rotation matrix changes back to this via ISI interrupt*/
                if (amppwgradmethod(&grady[GYKSZ2_SLOT],area_gyksz2,
                                    loggrd.ty*sat_scalez2,0.0,0.0,
                                    loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                {
                    epic_error(use_ermes, "%s failed in SpSat.",
                               EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gyksz2");
                    return FAILURE;
                }	
                if (opphysplane!=PSD_OBL)
                    grady[GYKSZ2_SLOT].powscale = 1.0;
                else
                    grady[GYKSZ2_SLOT].powscale = loggrd.yfs/(loggrd.ty*sat_scalez2);
	      
                maxkiller_time  = _maxkiller_time.fixedflag ?      ((void)(pw_gyksz2a+pw_gyksz2+pw_gyksz2d), maxkiller_time) : pw_gyksz2a+pw_gyksz2+pw_gyksz2d;
	      
                /* if both killers are on, adjust the targets so that obliques are
                   handled correctly */
                if (!floatsAlmostEqualEpsilons(area_gxksz2, 0.0, 2))
		{
#ifdef SPSATXKILLER
                    if(amppwgradmethod(&grady[GYKSZ2_SLOT],area_gyksz2,
                                       loggrd.ty_xy*sat_scalez2,0.0,0.0,
                                       loggrd.yrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gyksz2");
                        return FAILURE;
                    }
                    if (opphysplane!=PSD_OBL)
                        grady[GYKSZ2_SLOT].powscale = 1.0;
                    else
                        grady[GYKSZ2_SLOT].powscale = loggrd.yfs/(loggrd.ty_xy*sat_scalez2);
		  
                    gradx[GXKSZ2_SLOT].num = 1;
                    if(amppwgradmethod(&gradx[GXKSZ2_SLOT],area_gxksz2,
                                       loggrd.tx_xy*sat_scalez2,0.0,0.0,
                                       loggrd.xrt,MIN_PLATEAU_TIME) == FAILURE)
                    {
                        epic_error(use_ermes, "%s failed in SpSat.",
                                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                                   STRING_ARG, "amppwgrad:gxksz2");
                        return FAILURE;
                    }	
                    if (opphysplane!=PSD_OBL)
                        gradx[GXKSZ2_SLOT].powscale = 1.0;
                    else
                        gradx[GXKSZ2_SLOT].powscale = loggrd.xfs/(loggrd.tx_xy*sat_scalez2);
		  
                    maxkiller_time  = _maxkiller_time.fixedflag ?       
                                              ((void)(IMax(2,pw_gyksz2a+pw_gyksz2+pw_gyksz2d,pw_gxksz2a+pw_gxksz2+pw_gxksz2d)), maxkiller_time) : IMax(2,pw_gyksz2a+pw_gyksz2+pw_gyksz2d,pw_gxksz2a+pw_gxksz2+pw_gxksz2d);
#endif
		}
                *time_spsat += pw_gzrfsz2a + pw_rfsz2 +
                    RUP_GRD(IMax(2,pw_gzrfsz2d+rot_delay,pw_isisat+rfupd+psd_rf_wait+4  )) + 
		    pw_rotupdate + isi_extra + maxkiller_time +  pw_isisat - isi_satdelay +
                    pw_rotupdate + isi_extra;
            }
	  
	} /* end of opsatz */
        sat_rot_df_num  = _sat_rot_df_num.fixedflag ?    ((void)(sat_rot_index-sat_rot_ex_num), sat_rot_df_num) : sat_rot_index-sat_rot_ex_num;
      
        /* Covers worst case when an extra ISI is added at the beginning.
           This occurs for scans that move the sat pulses away from the
           beginning of the sequence. */
        *time_spsat += IMax(2, rot_delay + isi_extra + pw_isisat - isi_satdelay, pw_isisat + pw_rotupdate);
        *time_spsat = RUP_GRD(*time_spsat) ;
    } /* if opsat is selected */

#ifdef UNDEF
    if (opsat == PSD_ON)  
    {
        SHORT mask;

        printf("\n opsatx = %d", opsatx);
        printf("\n opsaty = %d", opsaty);
        printf("\n opsatz = %d", opsatz);
        printf("\n opexsatmask = %d", opexsatmask);
        printf("\n opexsatparal = %d", opexsatparal);
        if (opexsatmask != 0)
        {
            printf("\n opexsathick1 = %f",(float) opexsathick1);
            printf("\n opexsathick2 = %f", (float) opexsathick2);
            printf("\n opexsathick3 = %f",(float) opexsathick3);
            printf("\n opexsathick4 = %f",(float) opexsathick4);
            printf("\n opexsathick5 = %f",(float) opexsathick5);
            printf("\n opexsathick6 = %f",(float) opexsathick6);
            printf("\n opexsatloc1 = %f", (float) opexsatloc1);
            printf("\n opexsatloc2 = %f", (float) opexsatloc2);
            printf("\n opexsatloc3 = %f", (float) opexsatloc3);
            printf("\n opexsatloc4 = %f", (float) opexsatloc4);
            printf("\n opexsatloc5 = %f", (float) opexsatloc5);
            printf("\n opexsatloc6 = %f", (float) opexsatloc6);
        }

        if ((opsatx != PSD_SATOFF) || (opsaty != PSD_SATOFF) || (opsatz !=PSD_SATOFF))
        {
            printf("\n opdfsathick1 = %f", (float) opdfsathick1);
            printf("\n opdfsathick2 = %f", (float) opdfsathick2);
            printf("\n opdfsathick3 = %f", (float) opdfsathick3);
            printf("\n opdfsathick4 = %f", (float) opdfsathick4);
            printf("\n opdfsathick5 = %f", (float) opdfsathick5);
            printf("\n opdfsathick6 = %f", (float) opdfsathick6);
        }

        mask = 1;
        for(i=0;i<6;i++,mask = mask<<1)
        {
            if (opexsatmask & mask)
            {
                printf("\n Rotation matrix %d",i);
                for (j=0; j < 9; j=j+3)
                    printf("\n                      %4.2f    %4.2f     %4.2f",   
                           eg_sat_rot[i][j], eg_sat_rot[i][j+1],eg_sat_rot[i][j+2]);	
            }
        }
    }
#endif /* UNDEF */

    return SUCCESS;
}

/************************************************************************/

void
dump_sat_input(void)
{
    int i;
    int justified = 35;
    char file[BUFSIZ] = SPSAT_SCANNER_LOG_DIR;
    const char *filename = "spsat_host_sat_rot.log";
    FILE *fp;

    strcpy(file, SPSAT_SCANNER_LOG_DIR);
    strcat(file, filename);

    if ((fp = fopen(file, "w")) == NULL)
    {   
        strcpy(file, SPSAT_LOCAL_LOG_DIR);
        strcat(file, filename);

        if ((fp = fopen(file, "w")) == NULL)
        {
            printf("Error opening %s file\n",file);
            fflush(stdout);
            return;
        } 
    }

    fprintf(fp, "Host-provided Spatial Saturation info\n");

    for( i = 0; i < 6; ++i )
    {
        float location = 0.0;
        float thickness = 0.0;
        float RASnormal[3] = {0.0, 0.0, 0.0};
        float normal_dist = 0.0;
        int frequency = 0;
        char active[4] = "Off";

        switch( i )
        {
            case 0:
                location = opexsatloc1;
                thickness = opexsathick1;
                RASnormal[0] = exsat1_normth_R;
                RASnormal[1] = exsat1_normth_A;
                RASnormal[2] = exsat1_normth_S;
                normal_dist = exsat1_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_1 ? "On": "Off" );
                frequency = off_rfse1;
                break;
            case 1:
                location = opexsatloc2;
                thickness = opexsathick2;
                RASnormal[0] = exsat2_normth_R;
                RASnormal[1] = exsat2_normth_A;
                RASnormal[2] = exsat2_normth_S;
                normal_dist = exsat2_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_2 ? "On": "Off" );
                frequency = off_rfse2;
                break;
            case 2:
                location = opexsatloc3;
                thickness = opexsathick3;
                RASnormal[0] = exsat3_normth_R;
                RASnormal[1] = exsat3_normth_A;
                RASnormal[2] = exsat3_normth_S;
                normal_dist = exsat3_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_3 ? "On": "Off" );
                frequency = off_rfse3;
                break;
            case 3:
                location = opexsatloc4;
                thickness = opexsathick4;
                RASnormal[0] = exsat4_normth_R;
                RASnormal[1] = exsat4_normth_A;
                RASnormal[2] = exsat4_normth_S;
                normal_dist = exsat4_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_4 ? "On": "Off" );
                frequency = off_rfse4;
                break;
            case 4:
                location = opexsatloc5;
                thickness = opexsathick5;
                RASnormal[0] = exsat5_normth_R;
                RASnormal[1] = exsat5_normth_A;
                RASnormal[2] = exsat5_normth_S;
                normal_dist = exsat5_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_5 ? "On": "Off" );
                frequency = off_rfse5;
                break;
            case 5:
                location = opexsatloc6;
                thickness = opexsathick6;
                RASnormal[0] = exsat6_normth_R;
                RASnormal[1] = exsat6_normth_A;
                RASnormal[2] = exsat6_normth_S;
                normal_dist = exsat6_dist;
                strcpy( active, opexsatmask & PSD_EXPLICIT_6 ? "On": "Off" );
                frequency = off_rfse6;
                break;
        }
        fprintf(fp, "Input\n");
        fprintf(fp, "Saturation Band Index %d is %s\n", i, active);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "", eg_sat_rot[i][0], eg_sat_rot[i][1],
                eg_sat_rot[i][2]);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "Explicit sat rotation matrix:",
                eg_sat_rot[i][3], eg_sat_rot[i][4],
                eg_sat_rot[i][5]);
        fprintf(fp, "%-*s%+10f, %+8f, %+8f\n",
                justified, "", eg_sat_rot[i][6], eg_sat_rot[i][7],
                eg_sat_rot[i][8]);
        fprintf(fp, "%-*s%+8.4f\n",
                justified, "Offset from isocenter (mm):", location);
        fprintf(fp, "%-*s%+10.4f\n",
                justified, "Thickness (mm):", thickness);
        fprintf(fp, "%-*s%+10.4f, %+8.4f, %+8.4f\n",
                justified, "RAS normal vector with thickness:",
                RASnormal[0], RASnormal[1], RASnormal[2]);
        fprintf(fp, "%-*s%+10.4f\n",
                justified, "Offset distance along normal:", normal_dist);
        fprintf(fp, "Calculated\n");
        fprintf(fp, "%-*s%+10d\n",
                justified, "Frequency (Hz):", frequency);
        fprintf(fp, "\n");
    }

    for (i=0;i<sat_rot_ex_num*2; i=i+2)
    {
        fprintf(fp, "Saturation Band Index %d\n",i);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i][0], sat_rot_matrices[i][1],
                sat_rot_matrices[i][2]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "SpSat rotation matrix:",
                sat_rot_matrices[i][3], sat_rot_matrices[i][4],
                sat_rot_matrices[i][5]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i][6], sat_rot_matrices[i][7],
                sat_rot_matrices[i][8]);
        fprintf(fp, "\n");

        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1],
                sat_rot_matrices[i+1][2]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "SpSat slice rotation matrix:",
                sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4],
                sat_rot_matrices[i+1][5]);
        fprintf(fp, "%-*s%+10ld, %+8ld, %+8ld\n",
                justified, "", sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7],
                sat_rot_matrices[i+1][8]);
        fprintf(fp, "\n");
    }
            
    fprintf(fp, "Default Saturation Band info\n");

    if( (opsatx & PSD_SATNEG) || opsatx & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative X Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satxlocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick1);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsx1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative X Saturation:", "Off");
    }

    if( opsatx & PSD_SATPOS || opsatx & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive X Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satxlocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick2);
        if (opsatx & PSD_SATPARA)
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsx2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsx1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive X Saturation:", "Off");
    }

    if( opsaty & PSD_SATNEG || opsaty & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Y Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satylocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick3);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsy1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Y Saturation:", "Off");
    }

    if( opsaty & PSD_SATPOS || opsaty & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Y Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satylocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick4);
        if (opsaty & PSD_SATPARA)
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsy2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsy1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Y Saturation:", "Off");
    }

    if( opsatz & PSD_SATNEG || opsatz & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Z Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satzlocneg);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness (mm):", opdfsathick5);
        fprintf(fp, "%-*s %7d\n",
                justified, "     Calculated Frequency (Hz):", off_rfsz1);
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Negative Z Saturation:", "Off");
    }
    if( opsatz & PSD_SATPOS || opsatz & PSD_SATPARA )
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Z Saturation:", "On");
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Position (mm):", satzlocpos);
        fprintf(fp, "%-*s %7.4f\n",
                justified, "     Thickness:", opdfsathick6);
        if ( opsatz & PSD_SATPARA )
        {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsz2);
        } else {
            fprintf(fp, "%-*s %7d\n",
                    justified, "     Calculated Frequency (Hz):", off_rfsz1);
        }
    }
    else
    {
        fprintf(fp, "%-*s %s\n",
                justified, "Positive Z Saturation:", "Off");
    }

    fclose(fp);

    return;
}

/* Calculates offset frequencies for Z direction SAT bands only for
   concatenated sat */

void
SatGetZOffset( DOUBLE locpos,
               DOUBLE locneg,
               INT *offset1,
               INT *offset2 )
{
    switch (opsatz) 		
    {
    case PSD_SATOFF:
        *offset1 = 0;
        *offset2 = 0;
        break;

    case PSD_SATNEG:		/* Use negative location */
        *offset1 = (int)(GAM*a_gzrfsz1 * locneg/10);
        *offset2 = 0;
        break;

    case PSD_SATPOS:		/* Use positive location */
        *offset1 = (int)(GAM*a_gzrfsz1* locpos/10);
        *offset2 = 0;
        break;

    case PSD_SATHAD:      /* Find middle of Hadamard and space btwn */
        *offset1 = (int)(GAM*a_gzrfsz1* ((locpos+locneg)/2.0)/10);
        *offset2 = *offset1;
        break;

    case PSD_SATPARA:
        /* 2 SAT bands - positive & negative locs */
        *offset1 = (int)(GAM*a_gzrfsz1* locneg/10);
        *offset2 = (int)(GAM*a_gzrfsz2 * locpos/10);
        break;

    default:
        break;
    }
    return;
}
    /* Calculate amount of time to be burned in relaxers for cat sat */

int
SatCatRelaxtime( INT acqs,
                 INT seq_time,
                 INT seq_type )
{
  
    /* Check if we are doing a Concatenated Sat Non-Sequential Scan */
    if ( ((seq_type == TYPCAT) && (opirmode == PSD_SEQMODE_OFF)
          && !((opepi == PSD_ON) && (opexcitemode == FOCUS)))
         || (seq_type == TYP3DMSCAT) || (seq_type == TYP3DFSECAT) )
    {
        ccs_relaxers  = _ccs_relaxers.fixedflag ?  ((void)((int)ceil(ccs_dead/(double)seq_time)), ccs_relaxers) : (int)ceil(ccs_dead/(double)seq_time);
        ccs_relaxtime  = _ccs_relaxtime.fixedflag ?  ((void)(RUP_GRD(ccs_relaxers*seq_time*(acqs-1))), ccs_relaxtime) : RUP_GRD(ccs_relaxers*seq_time*(acqs-1));
        ccs_relaxseqtime  = _ccs_relaxseqtime.fixedflag ?  ((void)(RUP_GRD(seq_time)), ccs_relaxseqtime) : RUP_GRD(seq_time);
        SatRelaxers  = _SatRelaxers.fixedflag ?  ((void)(1), SatRelaxers) : 1;
    }
    else 
    {
        ccs_relaxers  = _ccs_relaxers.fixedflag ?  ((void)(0), ccs_relaxers) : 0;
        ccs_relaxtime  = _ccs_relaxtime.fixedflag ?  ((void)(0), ccs_relaxtime) : 0;
        ccs_relaxseqtime  = _ccs_relaxseqtime.fixedflag ?  ((void)(0), ccs_relaxseqtime) : 0;
        SatRelaxers  = _SatRelaxers.fixedflag ?  ((void)(0), SatRelaxers) : 0;
    }
    return(ccs_relaxtime);		    
}

STATUS
SatPlacement( INT numPasses ) 
{
    INT   i;			/* generic indices */
    INT   pass;
    INT   skip_next_sat;
    INT   explicit_sat_mask;
    INT   explicit_sat_paral;
    INT   maxslices;

    DOUBLE tmp_z, tmp_x, tmp_y;

    DOUBLE max_z, max_x, max_y;			/* maximum z, x, y location */
    DOUBLE min_z, min_x, min_y;			/* minimum z, x, y location */

    DOUBLE max[DATA_ACQ_MAX];	/* storage for finding slice range */
    DOUBLE min[DATA_ACQ_MAX];

    DOUBLE loczaoff = 0.0;		/* offset for CATSAT positive slice */
    DOUBLE loczboff = 0.0;		/* offset for CATSAT negative slice */

    /* Initialize TG limit for SpSat to max system TG: 200 */
    sat_TGlimit  = _sat_TGlimit.fixedflag ?  ((void)(MAX_SYS_TG), sat_TGlimit) : MAX_SYS_TG;

    if ((opsat == PSD_OFF) || ((opsatx == PSD_OFF)&&(opsaty == PSD_OFF) &&
                               (opsatz == PSD_OFF)&&(opexsatmask == PSD_OFF)))
        return SUCCESS;

    /*  opsat<x,y,z>       Band        Thickness        Satgap    Location
        1 (PSD_SATNEG)   I,P,L       1,3,or 5          neg       neg
        2 (PSD_SATPOS)   S,A,R       2,4,or 6          pos       pos
    */

    if (opimode == PSD_3D)
    {
        maxslices = exist(opslquant) * exist(opvquant);
    }
    else
    {
        maxslices = exist(opslquant);
    }

    /* X Sat placement ------------------------------------*/

    /* sathickx1 goes with opsat set to PSD_SATNEG (1)
       sathickx2 goes with opsat set to PSD_SATPOS (2) */
    if (satgap_opt_flag == PSD_ON)  
    {
        satgapxpos  = _satgapxpos.fixedflag ?        ((void)(30.0*satthickx2/40.0*lp_stretch/1.5), satgapxpos) : 30.0*satthickx2/40.0*lp_stretch/1.5;
        satgapxneg  = _satgapxneg.fixedflag ?        ((void)(30.0*satthickx1/40.0*lp_stretch/1.5), satgapxneg) : 30.0*satthickx1/40.0*lp_stretch/1.5;
    }
    else
    {
        satgapxpos  = _satgapxpos.fixedflag ?    ((void)(30.0/80.0*satthickx2), satgapxpos) : 30.0/80.0*satthickx2;
        satgapxneg  = _satgapxneg.fixedflag ?    ((void)(30.0/80.0*satthickx1), satgapxneg) : 30.0/80.0*satthickx1;
    }

    /* MRIhc03229: Search for farthest slice in each direction */
    min_x = max_x = (DOUBLE)(scan_info[0].oprloc + scan_info[0].oprloc_shift);
    for (i=1;i<maxslices;i++) 
    {
       tmp_x = (DOUBLE)(scan_info[i].oprloc + scan_info[i].oprloc_shift);

       if ( tmp_x > max_x )
           max_x = tmp_x;
       else if ( tmp_x < min_x )
       	   min_x = tmp_x;
    }

    satxlocpos  = _satxlocpos.fixedflag ?        ((void)((get_act_freq_fov()+satthickx2)/2+satgapxpos+max_x), satxlocpos) : (get_act_freq_fov()+satthickx2)/2+satgapxpos+max_x;
    satxlocneg  = _satxlocneg.fixedflag ?        ((void)((get_act_freq_fov()+satthickx1)/-2-satgapxneg+min_x), satxlocneg) : (get_act_freq_fov()+satthickx1)/-2-satgapxneg+min_x;

    off_rfsx1  = _off_rfsx1.fixedflag ?  ((void)(0), off_rfsx1) : 0;
    off_rfsx2  = _off_rfsx2.fixedflag ?  ((void)(0), off_rfsx2) : 0;
    satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
    satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;

    switch (opsatx) 		/* Calculate offset frequencies */
    {
    case PSD_SATOFF:
        off_rfsx1  = _off_rfsx1.fixedflag ?  ((void)(0), off_rfsx1) : 0;
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        off_rfsx2  = _off_rfsx2.fixedflag ?  ((void)(0), off_rfsx2) : 0;
        satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;
        break;

    case PSD_SATNEG:		/* Use negative location */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)((int)(GAM*a_gxrfsx1*(satxlocneg)/10)), off_rfsx1) : (int)(GAM*a_gxrfsx1*(satxlocneg)/10);
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        break;

    case PSD_SATPOS:		/* Use positive location */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)((int)(GAM*a_gxrfsx1*(satxlocpos)/10)), off_rfsx1) : (int)(GAM*a_gxrfsx1*(satxlocpos)/10);
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        break;

    case PSD_SATHAD:	/* Find middle of Hadamard and space btwn */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)((int)(GAM*a_gxrfsx1*((satxlocpos+satxlocneg)/2.0)/10)), off_rfsx1) : (int)(GAM*a_gxrfsx1*((satxlocpos+satxlocneg)/2.0)/10);
        satspacex1  = _satspacex1.fixedflag ?  ((void)(fabs(satxlocpos-satxlocneg)), satspacex1) : fabs(satxlocpos-satxlocneg);

        break;

    case PSD_SATPARA:          /* 2 SAT bands - positive & negative locs */
        off_rfsx1  = _off_rfsx1.fixedflag ?   ((void)((int)(GAM*a_gxrfsx1*(satxlocneg)/10)), off_rfsx1) : (int)(GAM*a_gxrfsx1*(satxlocneg)/10);
        satspacex1  = _satspacex1.fixedflag ?  ((void)(0.0), satspacex1) : 0.0;
        off_rfsx2  = _off_rfsx2.fixedflag ?   ((void)((int)(GAM*a_gxrfsx2*(satxlocpos)/10)), off_rfsx2) : (int)(GAM*a_gxrfsx2*(satxlocpos)/10);
        satspacex2  = _satspacex2.fixedflag ?  ((void)(0.0), satspacex2) : 0.0;
        break;

    default:
        break;
    }

    /* TG limit calc */
    if(PSD_OFF != opsatx)
    {
        calcTGLimitAtOffset((INT)(off_rfsx1/1000.0), _sat_TGlimit.fixedflag ? (_temp795_sat_TGlimit=sat_TGlimit,&_temp795_sat_TGlimit) : &sat_TGlimit, psddebugcode2);

        if(PSD_SATPARA == opsatx)
        {
            calcTGLimitAtOffset((INT)(off_rfsx2/1000.0), _sat_TGlimit.fixedflag ? (_temp796_sat_TGlimit=sat_TGlimit,&_temp796_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }
    }

    /* Y Sat placement ------------------------------------*/

    if (satgap_opt_flag == PSD_ON)
    {
        satgapypos  = _satgapypos.fixedflag ?        ((void)(30.0*satthicky2/40.0*lp_stretch/1.5), satgapypos) : 30.0*satthicky2/40.0*lp_stretch/1.5;
        satgapyneg  = _satgapyneg.fixedflag ?        ((void)(30.0*satthicky1/40.0*lp_stretch/1.5), satgapyneg) : 30.0*satthicky1/40.0*lp_stretch/1.5;
    }
    else
    {
        satgapypos  = _satgapypos.fixedflag ?    ((void)(30.0/80.0*satthicky2), satgapypos) : 30.0/80.0*satthicky2;
        satgapyneg  = _satgapyneg.fixedflag ?    ((void)(30.0/80.0*satthicky1), satgapyneg) : 30.0/80.0*satthicky1;
    }
  
    /* satthicky1 goes with opsat set to PSD_SATNEG (1)
       satthicky2 goes with opsat set to PSD_SATPOS (2) */

    /* MRIhc03229: Search for farthest slice in each direction */
    min_y = max_y = (DOUBLE)(scan_info[0].opphasoff + scan_info[0].opphasoff_shift);
    for (i=1;i<maxslices;i++) 
    {
       tmp_y = (DOUBLE)(scan_info[i].opphasoff + scan_info[i].opphasoff_shift);

       if ( tmp_y > max_y )
       {
           max_y = tmp_y;
       }
       else if ( tmp_y < min_y )
       {
       	   min_y = tmp_y;
       }
    }

    satylocpos  = _satylocpos.fixedflag ?        ((void)((get_act_phase_fov()+satthicky2)/2+satgapypos+max_y), satylocpos) : (get_act_phase_fov()+satthicky2)/2+satgapypos+max_y;
    satylocneg  = _satylocneg.fixedflag ?        ((void)((get_act_phase_fov()+satthicky1)/-2-satgapyneg+min_y), satylocneg) : (get_act_phase_fov()+satthicky1)/-2-satgapyneg+min_y;

    off_rfsy1  = _off_rfsy1.fixedflag ?  ((void)(0), off_rfsy1) : 0;
    off_rfsy2  = _off_rfsy2.fixedflag ?  ((void)(0), off_rfsy2) : 0;
    satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
    satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;

    switch (opsaty)         /* Calculate offset frequencies */
    {
    case PSD_SATOFF:
        off_rfsy1  = _off_rfsy1.fixedflag ?  ((void)(0), off_rfsy1) : 0;
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        off_rfsy2  = _off_rfsy2.fixedflag ?  ((void)(0), off_rfsy2) : 0;
        satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;
        break;

    case PSD_SATNEG:        /* Use negative location */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)((int)(GAM*a_gyrfsy1*satylocneg/10)), off_rfsy1) : (int)(GAM*a_gyrfsy1*satylocneg/10);
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        break;

    case PSD_SATPOS:        /* Use positive location */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)((int)(GAM*a_gyrfsy1*satylocpos/10)), off_rfsy1) : (int)(GAM*a_gyrfsy1*satylocpos/10);
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        break;

    case PSD_SATHAD:    /* Find middle of Hadamard and space btwn */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)((int)(GAM*a_gyrfsy1*((satylocpos+satylocneg)/2.0)/10)), off_rfsy1) : (int)(GAM*a_gyrfsy1*((satylocpos+satylocneg)/2.0)/10);
        satspacey1  = _satspacey1.fixedflag ?  ((void)(fabs(satylocpos-satylocneg)), satspacey1) : fabs(satylocpos-satylocneg);
        break;

    case PSD_SATPARA:      /* 2 SAT bands- positive & negative locs */
        off_rfsy1  = _off_rfsy1.fixedflag ?      ((void)((int)(GAM*a_gyrfsy1*satylocneg/10)), off_rfsy1) : (int)(GAM*a_gyrfsy1*satylocneg/10);
        satspacey1  = _satspacey1.fixedflag ?  ((void)(0.0), satspacey1) : 0.0;
        off_rfsy2  = _off_rfsy2.fixedflag ?      ((void)((int)(GAM*a_gyrfsy2*satylocpos/10)), off_rfsy2) : (int)(GAM*a_gyrfsy2*satylocpos/10);
        satspacey2  = _satspacey2.fixedflag ?  ((void)(0.0), satspacey2) : 0.0;
        break;
     
    default:
        break;
    }

    /* TG limit calc */
    if(PSD_OFF != opsaty)
    {
        calcTGLimitAtOffset((INT)(off_rfsy1/1000.0), _sat_TGlimit.fixedflag ? (_temp797_sat_TGlimit=sat_TGlimit,&_temp797_sat_TGlimit) : &sat_TGlimit, psddebugcode2);

        if(PSD_SATPARA == opsaty)
        {
            calcTGLimitAtOffset((INT)(off_rfsy2/1000.0), _sat_TGlimit.fixedflag ? (_temp798_sat_TGlimit=sat_TGlimit,&_temp798_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }
    }

    /* Z Sat placement ------------------------------------*/

    if (satgap_opt_flag == PSD_ON)     
    {
        satgapzpos  = _satgapzpos.fixedflag ?        ((void)(30.0*satthickz2/40.0*lp_stretch/1.5), satgapzpos) : 30.0*satthickz2/40.0*lp_stretch/1.5;
        satgapzneg  = _satgapzneg.fixedflag ?        ((void)(30.0*satthickz1/40.0*lp_stretch/1.5), satgapzneg) : 30.0*satthickz1/40.0*lp_stretch/1.5;
        /* Min satgap set 30mm to keep satulation effect for flow signal such as CSF flow and blood flow */
        if (satgapzpos < 30.0) 
        {
            satgapzpos  = _satgapzpos.fixedflag ?  ((void)(30.0), satgapzpos) : 30.0;
        }
        if (satgapzneg < 30.0) 
        {
            satgapzneg  = _satgapzneg.fixedflag ?  ((void)(30.0), satgapzneg) : 30.0;
        }
    }
    else
    {
        satgapzpos  = _satgapzpos.fixedflag ?  ((void)(30.0), satgapzpos) : 30.0;
        satgapzneg  = _satgapzneg.fixedflag ?  ((void)(30.0), satgapzneg) : 30.0;
    }

    /* Not concatenated SAT */
    if ( ((seq_type!=TYPCAT) || ((exist(opepi) == PSD_ON) && (exist(opexcitemode) == FOCUS))) && (seq_type!=TYP3DMSCAT) &&
            (exist(opccsat) == PSD_OFF) )
    {	
        /* Search for farthest slice in each direction */
        min_z = max_z = (DOUBLE)(scan_info[0].optloc + scan_info[0].optloc_shift);
	for (i=1;i<maxslices;i++) 
        {
            tmp_z = (DOUBLE)(scan_info[i].optloc + scan_info[i].optloc_shift);

	    if ( tmp_z > max_z )
                max_z = tmp_z;
	    else if ( tmp_z < min_z )
		min_z = tmp_z;
	}

        /* Place SAT bands at ends of prescribed slices */
        satzlocpos  = _satzlocpos.fixedflag ?        ((void)(max_z+(opslthick/2)+satgapzpos+satthickz2/2.0), satzlocpos) : max_z+(opslthick/2)+satgapzpos+satthickz2/2.0;
        satzlocneg  = _satzlocneg.fixedflag ?        ((void)(min_z-(opslthick/2)-satgapzneg-satthickz1/2.0), satzlocneg) : min_z-(opslthick/2)-satgapzneg-satthickz1/2.0;
    
        off_rfsz1  = _off_rfsz1.fixedflag ?  ((void)(0), off_rfsz1) : 0;
        off_rfsz2  = _off_rfsz2.fixedflag ?  ((void)(0), off_rfsz2) : 0;
        satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
        satspacez2  = _satspacez2.fixedflag ?  ((void)(0.0), satspacez2) : 0.0;

        SatGetZOffset(satzlocpos,satzlocneg, _off_rfsz1.fixedflag ? (_temp799_off_rfsz1=off_rfsz1,&_temp799_off_rfsz1) : &off_rfsz1, _off_rfsz2.fixedflag ? (_temp800_off_rfsz2=off_rfsz2,&_temp800_off_rfsz2) : &off_rfsz2);

        if (opsatz==PSD_SATHAD)
            satspacez1  = _satspacez1.fixedflag ?  ((void)(fabs(satzlocpos-satzlocneg)), satspacez1) : fabs(satzlocpos-satzlocneg);
        else
            satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
        /* TG limit calc */
        if(PSD_OFF != opsatz)
        {
            calcTGLimitAtOffset((INT)(off_rfsz1/1000.0), _sat_TGlimit.fixedflag ? (_temp801_sat_TGlimit=sat_TGlimit,&_temp801_sat_TGlimit) : &sat_TGlimit, psddebugcode2);

            if(PSD_SATPARA == opsatz)
            {
                calcTGLimitAtOffset((INT)(off_rfsz2/1000.0), _sat_TGlimit.fixedflag ? (_temp802_sat_TGlimit=sat_TGlimit,&_temp802_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
            }
        }
    } 
    /* Concatenated SAT */
    else 
    {
        /* Initially set a and b sat locations to be the same */
        switch (opsatz)
        {
        case PSD_SATNEG:
            loczaoff = (opslthick/2.0) + satgapzneg + (satthickz1/2.0);
            loczboff = (opslthick/2.0) + satgapzneg + (satthickz1/2.0);
            break;
        
        case PSD_SATPOS:
            loczaoff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            loczboff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            break;

        case PSD_SATHAD:
            loczaoff = (opslthick/2.0) + satgapzpos + (satthickz1/2.0);
            loczboff = (opslthick/2.0) + satgapzpos + (satthickz2/2.0);
            break;

            /* PSD_SATPARA is an illegal selection with concat SAT */
        default:
            break; 
        }
    
        /* For sequential mode, there are always 1 slice per pass.
           To allow the saturated area to return to normal, the
           Z SAT bands are placed around 2 slices instead of the
           around the pass which only contains 1 slice. This allows
           the saturated area to relax before the slice is collected.

           If the direction of the slices prescribed ( i.e. S to I 
           or I to S) is the same as the SAT band selected (i.e. S in 
           the I to S case and I in the S to I case) then the SAT band
           needs to be moved 1 slice. In this case the sat band is 2
           bands away from the slice allowing the saturated area 
           an extra pass of time to relax before it becomes the next 
           slice to be collected. */

        if (opirmode==SIRMODE)
        {
            if (scan_info[0].optloc < scan_info[maxslices-1].optloc)
            {
                loczaoff += opslthick; /* move the sat forward by 1 slice */
            }
            else
            {
                loczboff += opslthick;	/* move the sat back by one slice */
            }
        }
  
        for (i=0;i<numPasses;i++) 	/* Initialize min and max storage */
        {
            max[i] = -1e10;	/* Just some big numbers that are */
            min[i] =  1e10;	/* opposite of what we are looking for */
	}
      
        /* Loop over all locations and check for the extent of the 
           slices in a pass. The scan_info table contains all the 
           slices in a scan. We need to know the slice extent for
           each pass; so only the slices in a particular pass are
           considered. */
        for (i=0;i<maxslices;i++) 
        {
            /* Figure out which pass we are in */
            pass = data_acq_order[i].slpass;

            tmp_z = (DOUBLE)(scan_info[i].optloc + scan_info[i].optloc_shift);

            /* check the range for this pass */
            if ( tmp_z > max[pass] )
            {
                max[pass] = tmp_z;
            }
            if ( tmp_z < min[pass])
            {
                min[pass] = tmp_z;
            }
        }

        /* For each pass, the z sat slice moves to surround that
           pass of slices. (Recall each pass is only 1 slice in sequential
           mode.) That is the definition of concat SAT.
           Concatenated sat is only supported for
           cases SATPOS, SATNEG and SATHAD, which only use one
           rf offset. That is why only the first off_rfsz1 is used. */
        for (i=0; i < numPasses; ++i)
        {
            satzloca  = _satzloca.fixedflag ?    ((void)(max[i]+loczaoff), satzloca) : max[i]+loczaoff;
            satzlocb  = _satzlocb.fixedflag ?    ((void)(min[i]-loczboff), satzlocb) : min[i]-loczboff;

            SatGetZOffset(satzloca,satzlocb, _off_rfsz1.fixedflag ? (_temp803_off_rfsz1=off_rfsz1,&_temp803_off_rfsz1) : &off_rfsz1, _off_rfsz2.fixedflag ? (_temp804_off_rfsz2=off_rfsz2,&_temp804_off_rfsz2) : &off_rfsz2);
            off_rfcsz[i] = off_rfsz1; 
            /* TG limit calc */
            if(PSD_OFF != opsatz)
            {
                calcTGLimitAtOffset((INT)(off_rfsz1/1000.0), _sat_TGlimit.fixedflag ? (_temp805_sat_TGlimit=sat_TGlimit,&_temp805_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
            }
        }

        /* Determine sat pulse separation */
        /* First slice always has the widest */
        if (opsatz==PSD_SATHAD)	/* Sat band separation for hadamard */
        {
            satspacez1  = _satspacez1.fixedflag ?  ((void)(((max[0]+loczaoff)-(min[0]-loczboff))), satspacez1) : ((max[0]+loczaoff)-(min[0]-loczboff));
        }
        else			/* otherwise no separation */
        {
            satspacez1  = _satspacez1.fixedflag ?  ((void)(0.0), satspacez1) : 0.0;
        }
    } /* end concat sat */

    /* Explicit SAT processing:
       1. Set Szt location
       2. Set RF offset frequency
       3. Set SAT spacing
       4. Process two SAT bands together if they are parallel
       5. Go to next SAT band unless it has been processed as
       part of parallel pair. */

    explicit_sat_mask = exist(opexsatmask);
    explicit_sat_paral = exist(opexsatparal);

    switch (sat_debug)
    {
        /* Calculate offsets for explicit sat bands from psc_info with LS's method. */ /* 15-Feb-2015 HS */
        case 2:
            if (oppscvquant > 0)
            {
                satloce1  = _satloce1.fixedflag ?  ((void)(psc_info[0].oppsctloc), satloce1) : psc_info[0].oppsctloc; 
                satloce2  = _satloce2.fixedflag ?  ((void)(psc_info[0].oppsctloc), satloce2) : psc_info[0].oppsctloc;
                satloce3  = _satloce3.fixedflag ?  ((void)(psc_info[0].oppscrloc), satloce3) : psc_info[0].oppscrloc; 
                satloce4  = _satloce4.fixedflag ?  ((void)(psc_info[0].oppscrloc), satloce4) : psc_info[0].oppscrloc;
                satloce5  = _satloce5.fixedflag ?  ((void)(-psc_info[0].oppscphasoff), satloce5) : -psc_info[0].oppscphasoff; 
                satloce6  = _satloce6.fixedflag ?  ((void)(-psc_info[0].oppscphasoff), satloce6) : -psc_info[0].oppscphasoff;
            }
            break;

        /* Calculate offsets for explicit sat bands from psc_info with HS's method. */
        case 3:
            if (oppscvquant > 0)
            {
                satloce1  = _satloce1.fixedflag ?  ((void)(psc_info[0].oppsctloc), satloce1) : psc_info[0].oppsctloc; 
                satloce2  = _satloce2.fixedflag ?  ((void)(psc_info[0].oppsctloc), satloce2) : psc_info[0].oppsctloc;
                satloce3  = _satloce3.fixedflag ?  ((void)(-psc_info[0].oppscrloc), satloce3) : -psc_info[0].oppscrloc; 
                satloce4  = _satloce4.fixedflag ?  ((void)(-psc_info[0].oppscrloc), satloce4) : -psc_info[0].oppscrloc;
                satloce5  = _satloce5.fixedflag ?  ((void)(psc_info[0].oppscphasoff), satloce5) : psc_info[0].oppscphasoff; 
                satloce6  = _satloce6.fixedflag ?  ((void)(psc_info[0].oppscphasoff), satloce6) : psc_info[0].oppscphasoff;
            }
            break;

        /* Set the offsets with rsp variables for AutoShim, has to be set in @rsp */
        case 4:
            break;

        /* For other cases, use offsets provided by scan for the explicit sat bands. */
        default:
            satloce1  = _satloce1.fixedflag ?  ((void)(exist(opexsatloc1)), satloce1) : exist(opexsatloc1); 
            satloce2  = _satloce2.fixedflag ?  ((void)(exist(opexsatloc2)), satloce2) : exist(opexsatloc2);
            satloce3  = _satloce3.fixedflag ?  ((void)(exist(opexsatloc3)), satloce3) : exist(opexsatloc3); 
            satloce4  = _satloce4.fixedflag ?  ((void)(exist(opexsatloc4)), satloce4) : exist(opexsatloc4);
            satloce5  = _satloce5.fixedflag ?  ((void)(exist(opexsatloc5)), satloce5) : exist(opexsatloc5); 
            satloce6  = _satloce6.fixedflag ?  ((void)(exist(opexsatloc6)), satloce6) : exist(opexsatloc6);
            break;
    }

    if (explicit_sat_mask != 0)
    {
        skip_next_sat = 0; 
        if ((explicit_sat_mask & PSD_EXPLICIT_1) != 0)  /* SAT band 1 & 2 */
        {
            off_rfse1  = _off_rfse1.fixedflag ?      ((void)((int)(GAM*a_gzrfse1*satloce1/10)), off_rfse1) : (int)(GAM*a_gzrfse1*satloce1/10);
            satspace1  = _satspace1.fixedflag ?  ((void)(0), satspace1) : 0;
 
            if ((explicit_sat_paral & PSD_1_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                off_rfse1  = _off_rfse1.fixedflag ?        ((void)((int)(GAM*a_gzrfse1*((satloce1+satloce2)/2.)/10)), off_rfse1) : (int)(GAM*a_gzrfse1*((satloce1+satloce2)/2.)/10);
                satspace1  = _satspace1.fixedflag ?     ((void)(fabs(satloce1-satloce2)), satspace1) : fabs(satloce1-satloce2);
            }

            calcTGLimitAtOffset((INT)(off_rfse1/1000.0), _sat_TGlimit.fixedflag ? (_temp806_sat_TGlimit=sat_TGlimit,&_temp806_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            off_rfse2  = _off_rfse2.fixedflag ?      ((void)((int)(GAM*a_gzrfse2*satloce2/10)), off_rfse2) : (int)(GAM*a_gzrfse2*satloce2/10);
            satspace2  = _satspace2.fixedflag ?  ((void)(0), satspace2) : 0;

            calcTGLimitAtOffset((INT)(off_rfse2/1000.0), _sat_TGlimit.fixedflag ? (_temp807_sat_TGlimit=sat_TGlimit,&_temp807_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_3) != 0)  /* SAT band 3 & 4 */
        {
            off_rfse3  = _off_rfse3.fixedflag ?      ((void)((int)(GAM*a_gzrfse3*satloce3/10)), off_rfse3) : (int)(GAM*a_gzrfse3*satloce3/10);
            satspace3  = _satspace3.fixedflag ?  ((void)(0), satspace3) : 0;
 
            if ((explicit_sat_paral & PSD_2_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                off_rfse3  = _off_rfse3.fixedflag ?        ((void)((int)(GAM*a_gzrfse3*((satloce3+satloce4)/2.)/10)), off_rfse3) : (int)(GAM*a_gzrfse3*((satloce3+satloce4)/2.)/10);
                satspace3  = _satspace3.fixedflag ?     ((void)(fabs(satloce3-satloce4)), satspace3) : fabs(satloce3-satloce4);
            }
            calcTGLimitAtOffset((INT)(off_rfse3/1000.0), _sat_TGlimit.fixedflag ? (_temp808_sat_TGlimit=sat_TGlimit,&_temp808_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            off_rfse4  = _off_rfse4.fixedflag ?      ((void)((int)(GAM*a_gzrfse4*satloce4/10)), off_rfse4) : (int)(GAM*a_gzrfse4*satloce4/10);
            satspace4  = _satspace4.fixedflag ?  ((void)(0), satspace4) : 0;
            calcTGLimitAtOffset((INT)(off_rfse4/1000.0), _sat_TGlimit.fixedflag ? (_temp809_sat_TGlimit=sat_TGlimit,&_temp809_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }

        skip_next_sat = 0;
        if ((explicit_sat_mask & PSD_EXPLICIT_5) != 0)  /* SAT band 5 & 6 */
        {
            off_rfse5  = _off_rfse5.fixedflag ?      ((void)((int)(GAM*a_gzrfse5*satloce5/10)), off_rfse5) : (int)(GAM*a_gzrfse5*satloce5/10);
            satspace5  = _satspace5.fixedflag ?  ((void)(0.0), satspace5) : 0.0;
  
            if ((explicit_sat_paral & PSD_3_PARALLEL) != 0)
            {
                skip_next_sat = 1;
                off_rfse5  = _off_rfse5.fixedflag ?        ((void)((int)(GAM*a_gzrfse5*((satloce5+satloce6)/2.)/10)), off_rfse5) : (int)(GAM*a_gzrfse5*((satloce5+satloce6)/2.)/10);
                satspace5  = _satspace5.fixedflag ?     ((void)(fabs(satloce5-satloce6)), satspace5) : fabs(satloce5-satloce6);
            }
            calcTGLimitAtOffset((INT)(off_rfse5/1000.0), _sat_TGlimit.fixedflag ? (_temp810_sat_TGlimit=sat_TGlimit,&_temp810_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }

        if (((explicit_sat_mask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            off_rfse6  = _off_rfse6.fixedflag ?      ((void)((int)(GAM*a_gzrfse6*satloce6/10)), off_rfse6) : (int)(GAM*a_gzrfse6*satloce6/10);
            satspace6  = _satspace6.fixedflag ?  ((void)(0), satspace6) : 0;

            calcTGLimitAtOffset((INT)(off_rfse6/1000.0), _sat_TGlimit.fixedflag ? (_temp811_sat_TGlimit=sat_TGlimit,&_temp811_sat_TGlimit) : &sat_TGlimit, psddebugcode2);
        }
    } /* end explicit SAT */

	
    /* Scale the explicit rotation matrices, and the interspersed
       killer pulse rotation matrices (based on default rotation matrices).
       At this time the killer matrices are null - they will be copied
       in later in the SpSat_set_sat1_matrix call.  But we scale the
       matrices here in single scalerotmats call, for simplicity's sake */

    if(scalerotmats(sat_rot_matrices, &satloggrd, &phygrd, 2*sat_rot_ex_num,
                 sat_obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }


    if (spsat_host_debug)
    {
        dump_sat_input();
    }

    return SUCCESS;
}

    /* Sets the internal rf pulse amplitudes. */
STATUS
SpSatIAmp( void )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return SUCCESS;

    if (exist(opsatx) > PSD_SATOFF)
    {
        ia_rfsx1  = _ia_rfsx1.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSX1_SLOT].amp))), ia_rfsx1) : (int)(max_pg_iamp*(*rfpulse[RFSX1_SLOT].amp));
        if (exist(opsatx) == PSD_SATPARA)
            ia_rfsx2  = _ia_rfsx2.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSX2_SLOT].amp))), ia_rfsx2) : (int)(max_pg_iamp*(*rfpulse[RFSX2_SLOT].amp));
    }
    if (exist(opsaty) > PSD_SATOFF)
    {
        ia_rfsy1  = _ia_rfsy1.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSY1_SLOT].amp))), ia_rfsy1) : (int)(max_pg_iamp*(*rfpulse[RFSY1_SLOT].amp));
        if (exist(opsaty) == PSD_SATPARA) 
            ia_rfsy2  = _ia_rfsy2.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSY2_SLOT].amp))), ia_rfsy2) : (int)(max_pg_iamp*(*rfpulse[RFSY2_SLOT].amp));
    }
    if (exist(opsatz) > PSD_SATOFF)
    {
        ia_rfsz1  = _ia_rfsz1.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSZ1_SLOT].amp))), ia_rfsz1) : (int)(max_pg_iamp*(*rfpulse[RFSZ1_SLOT].amp));
        if (exist(opsatz) == PSD_SATPARA)
            ia_rfsz2  = _ia_rfsz2.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSZ2_SLOT].amp))), ia_rfsz2) : (int)(max_pg_iamp*(*rfpulse[RFSZ2_SLOT].amp));
    }

    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_1) != 0)
    {
        ia_rfse1  = _ia_rfse1.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE1_SLOT].amp))), ia_rfse1) : (int)(max_pg_iamp*(*rfpulse[RFSE1_SLOT].amp));
        if ((exist(opexsatparal) & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        ia_rfse2  = _ia_rfse2.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE2_SLOT].amp))), ia_rfse2) : (int)(max_pg_iamp*(*rfpulse[RFSE2_SLOT].amp));
 
    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_3) != 0)
    {
        ia_rfse3  = _ia_rfse3.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE3_SLOT].amp))), ia_rfse3) : (int)(max_pg_iamp*(*rfpulse[RFSE3_SLOT].amp));
        if ((exist(opexsatparal)& PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        ia_rfse4  = _ia_rfse4.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE4_SLOT].amp))), ia_rfse4) : (int)(max_pg_iamp*(*rfpulse[RFSE4_SLOT].amp));

    skip_next_sat = 0;
    if ((exist(opexsatmask) & PSD_EXPLICIT_5) != 0)
    {
        ia_rfse5  = _ia_rfse5.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE5_SLOT].amp))), ia_rfse5) : (int)(max_pg_iamp*(*rfpulse[RFSE5_SLOT].amp));
        if ((exist(opexsatparal) & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((exist(opexsatmask) & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        ia_rfse6  = _ia_rfse6.fixedflag ?    ((void)((int)(max_pg_iamp*(*rfpulse[RFSE6_SLOT].amp))), ia_rfse6) : (int)(max_pg_iamp*(*rfpulse[RFSE6_SLOT].amp));

    return SUCCESS;
}

/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PShost                                *
 *                                                                   *
 * Write here the code unique to the Host PSD process.               *
 *********************************************************************/
#include <string.h>
#include "sar_limit_api.h"
#include "sar_pm.h" 

/*
 *  set_presscfh_mode
 *  
 *  Type: Private Function
 *  
 *  Description: Set the modes for presscfh
 * 			PRESSCFH_SLICE 1      
 * 			PRESSCFH_SLAB 2                                              
 * 			PRESSCFH_SHIMVOL 3
 * 			PRESSCFH_SHIMVOL_SLICE 4
 * 			PRESSCFH_NONE          5
 * 
 * */

STATUS
set_presscfh_mode (void)
{
    if(exist(oppscvquant) >= 1)
    {
        if (presscfh_override > 0) 
        {
            cvoverride(presscfh, presscfh_override, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else if (cfh_steam_flag == PSD_ON)
        {
            /* For STEAM CFH mode, force to use shim volume mode */
            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
        }
        else
        {
            switch(exist(opimode)) 
            {
                case PSD_2D:
                case PSD_CINE: 
                    if( (opplane == PSD_3PLANE) || ((exist(oprealtime) == PSD_ON)) || (exist(opcoax) == 0) )
                    {   /* For 3-Plane or Realtime or Radial mode use SHIMVOL Mode*/
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    else if(exist(opassetcal) && existcv(opassetcal) 
                               && ( (1==exist(opasset)) || (exist(opasset) == ASSET_REG_CAL) ) && existcv(opasset)) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            }
                    else /* NON-RADIAL MODE */
                    {
                        int vidx;
                        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                        {
                            if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                            {
                                cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                            } 
                            else 
                            {
                                cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                break;
                            }
                        }
                    }
                    break;
                case PSD_3D:
                case PSD_3DM:
                case PSD_ANGIO:
                    /* If Shim Volume is placed */
                    if( exist(opcoax) != 0 )      /* Non-Radial/Oblique MODE */
                    {
                        if( exist(opvquant) > 1 )     /* Multiple Slabs */
                        {
                            cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);	
                        }
                        else     /* Single Slab */
                        {
                            int vidx;
                            for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
                            {
                                if( shimvol_slice_intersect(&psc_info[vidx], &scan_info[PSslice_num], 0, PSdebugstate) != 0 ) 
                                {
                                    cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                                } 
                                else 
                                {
                                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);	
                                    break;
                                }
                            }
                        }
                    }
                    else     /* Radial Case or Orthogonal Slabs */
                    {
                        cvoverride(presscfh, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON);
                    }
                    break;
                default: 
                    cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
                    break;
            }
        } 
    }
    else
    {
        cvoverride(presscfh, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON);
    }
    
    if(presscfh_debug) 
    {
        printf("\n The presscfh is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh);
        printf("\n The presscfh_ctrl is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE), \n",presscfh_ctrl);
        printf("\n The presscfh_override is %d (1 - SLICE, 2 - SLAB, 3 - SHIMVOL 4- NONE)\n",presscfh_override);
        fflush(stdout);
    }
    return SUCCESS;
}

/*
 *  sr_derate
 *  
 *  Type: Private Function
 *  
 *  Description:
 *    update the ramp time for loggrad by *sr_derate_factor  
 *    @param[out] lgrad, logical gradient characteristics
 *    @param[in]  sc_derate_factor, SR derating factor ( >=1.0 ) 
 *
 */

STATUS
sr_derate (LOG_GRAD *lgrad, const float sr_derate_factor, const float amp_derate_factor)
{
    STATUS status = SUCCESS;

    if ((sr_derate_factor < 1.0) || (amp_derate_factor < 1.0))
    {
        status = FAILURE;
    }
    else
    {
        lgrad->xrt = (int)ceilf(lgrad->xrt*sr_derate_factor);
        lgrad->yrt = (int)ceilf(lgrad->yrt*sr_derate_factor);
        lgrad->zrt = (int)ceilf(lgrad->zrt*sr_derate_factor);
        lgrad->xft = (int)ceilf(lgrad->xft*sr_derate_factor);
        lgrad->yft = (int)ceilf(lgrad->yft*sr_derate_factor);
        lgrad->zft = (int)ceilf(lgrad->zft*sr_derate_factor);
        
        lgrad->tx_xyz = lgrad->tx_xyz/amp_derate_factor;
        lgrad->ty_xyz = lgrad->ty_xyz/amp_derate_factor;
        lgrad->tz_xyz = lgrad->tz_xyz/amp_derate_factor;
        lgrad->tx_xy = lgrad->tx_xy/amp_derate_factor;
        lgrad->tx_xz = lgrad->tx_xz/amp_derate_factor;
        lgrad->ty_xy = lgrad->ty_xy/amp_derate_factor;
        lgrad->ty_yz = lgrad->ty_yz/amp_derate_factor;
        lgrad->tz_xz = lgrad->tz_xz/amp_derate_factor;
        lgrad->tz_yz = lgrad->tz_yz/amp_derate_factor;
        lgrad->tx = lgrad->tx/amp_derate_factor;
        lgrad->ty = lgrad->ty/amp_derate_factor;
        lgrad->tz = lgrad->tz/amp_derate_factor;

        status = SUCCESS;
    }

    return status;
}

/*
 *  PS1cvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cvinit( void )
{
    INT index;

    /* initialize pulse widths */
    pw_rf1mps1  = _pw_rf1mps1.fixedflag ?  ((void)(rfpulse[RF1_APS1_SLOT].nom_pw), pw_rf1mps1) : rfpulse[RF1_APS1_SLOT].nom_pw;
    pw_rf2mps1  = _pw_rf2mps1.fixedflag ?  ((void)(rfpulse[RF2_APS1_SLOT].nom_pw), pw_rf2mps1) : rfpulse[RF2_APS1_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1mps1  = _res_rf1mps1.fixedflag ?  ((void)(0), res_rf1mps1) : 0;
    res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(0), res_rf2mps1) : 0;

    /* initialize amplitudes */
    a_rf1mps1  = _a_rf1mps1.fixedflag ?  ((void)(0.5), a_rf1mps1) : 0.5;
    a_rf2mps1  = _a_rf2mps1.fixedflag ?  ((void)(1.0), a_rf2mps1) : 1.0;

    /* initialize flip angles */
    flip_rf1mps1  = _flip_rf1mps1.fixedflag ?  ((void)(90), flip_rf1mps1) : 90;
    flip_rf2mps1  = _flip_rf2mps1.fixedflag ?  ((void)(180), flip_rf2mps1) : 180;

    /* initialize sinc cycles */
    cyc_rf1mps1  = _cyc_rf1mps1.fixedflag ?  ((void)(1), cyc_rf1mps1) : 1;
    cyc_rf2mps1  = _cyc_rf2mps1.fixedflag ?  ((void)(1), cyc_rf2mps1) : 1;

    /* initialize gscale values */
    gscale_rf1mps1  = _gscale_rf1mps1.fixedflag ?  ((void)(0.90909), gscale_rf1mps1) : 0.90909;
    gscale_rf2mps1  = _gscale_rf2mps1.fixedflag ?  ((void)(0.4545), gscale_rf2mps1) : 0.4545;

    /* begin aps1_mod changes (GE) */
    if ( ( getAps1Mod() > 0 || ((B0_15000 == cffield) && isLowSarEnabled()) ) && (PSD_OFF == local_tg) )
    {
        for( index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = 0.0;
        }

        if (1==getAps1ModPlane()) /* Axial, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (2==getAps1ModPlane()) /* Sagittal, read=z */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[4] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (3==getAps1ModPlane()) /* Coronal, read=z */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[6] = 1.0;
        }
        if (4==getAps1ModPlane()) /* Axial, read=y */
        {
            ps1scan_info[0].oprot[1] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[8] = 1.0;
        }
        if (5==getAps1ModPlane()) /* Sagittal, read=y */
        {
            ps1scan_info[0].oprot[2] = ps1scan_info[0].oprot[3] = ps1scan_info[0].oprot[7] = 1.0;
        }
        if (6==getAps1ModPlane()) /* Coronal, read=x */
        {
            ps1scan_info[0].oprot[0] = ps1scan_info[0].oprot[5] = ps1scan_info[0].oprot[7] = 1.0;
        }
    }
    else if((oppscvquant > 0) && (PSD_ON == local_tg))
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = psc_info[0].oppscrot[index]; /* use shim vol rot for local tg */ 
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            ps1scan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }
    /* end aps1_mod changes (GE) */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&ps1loggrd, &phygrd, ps1scan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp812_ps1_newgeo=ps1_newgeo,&_temp812_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PS1cvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&ps1loggrd, PSsr_derate_factor, PSamp_derate_factor);

    return SUCCESS;
}

/*
 *  CFLcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcvinit( void )
{
    /* initialize pulse widths */
    pw_rf1cfl  = _pw_rf1cfl.fixedflag ?  ((void)(rfpulse[RF1_CFL_SLOT].nom_pw), pw_rf1cfl) : rfpulse[RF1_CFL_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf1cfl  = _res_rf1cfl.fixedflag ?   ((void)(0), res_rf1cfl) : 0;

    /* initialize amplitudes */
    a_rf1cfl  = _a_rf1cfl.fixedflag ?  ((void)(0.5), a_rf1cfl) : 0.5;

    /* initialize flip angles */
    flip_rf1cfl  = _flip_rf1cfl.fixedflag ?  ((void)(90), flip_rf1cfl) : 90;

    /* initialize sinc cycles */
    cyc_rf1cfl  = _cyc_rf1cfl.fixedflag ?  ((void)(2), cyc_rf1cfl) : 2; /* MRIhc54366: increased from 1 */

    /* initialize gscale values */
    gscale_rf1cfl  = _gscale_rf1cfl.fixedflag ?  ((void)(0.90909), gscale_rf1cfl) : 0.90909;

    return SUCCESS;
}


/*
 *  RCVNcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcvinit( void )
{
    if (CFG_VAL_RECEIVER_RRF == cfreceivertype)
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(1024), rcvn_xres) : 1024;
    }
    else
    {
        rcvn_xres  = _rcvn_xres.fixedflag ?  ((void)(4096), rcvn_xres) : 4096;
    }


    return SUCCESS;
}


/*
 *  CFHcvinit
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcvinit( void )
{
    /* initialize pulse widths */
    pw_rf0cfh  = _pw_rf0cfh.fixedflag ?  ((void)(rfpulse[RF0_CFH_SLOT].nom_pw), pw_rf0cfh) : rfpulse[RF0_CFH_SLOT].nom_pw;
    pw_rf1cfh  = _pw_rf1cfh.fixedflag ?  ((void)(rfpulse[RF1_CFH_SLOT].nom_pw), pw_rf1cfh) : rfpulse[RF1_CFH_SLOT].nom_pw;
    pw_rf2cfh  = _pw_rf2cfh.fixedflag ?  ((void)(rfpulse[RF2_CFH_SLOT].nom_pw), pw_rf2cfh) : rfpulse[RF2_CFH_SLOT].nom_pw;
    pw_rf3cfh  = _pw_rf3cfh.fixedflag ?  ((void)(rfpulse[RF3_CFH_SLOT].nom_pw), pw_rf3cfh) : rfpulse[RF3_CFH_SLOT].nom_pw; /* For presscfh MRIhc08321 */
    pw_rf4cfh  = _pw_rf4cfh.fixedflag ?  ((void)(rfpulse[RF4_CFH_SLOT].nom_pw), pw_rf4cfh) : rfpulse[RF4_CFH_SLOT].nom_pw;

    /* initialize resolutions */
    res_rf0cfh  = _res_rf0cfh.fixedflag ?   ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC; /* Adiabatic pulse */
    res_rf1cfh  = _res_rf1cfh.fixedflag ?   ((void)(0), res_rf1cfh) : 0;
    res_rf2cfh  = _res_rf2cfh.fixedflag ?   ((void)(0), res_rf2cfh) : 0;
    res_rf3cfh  = _res_rf3cfh.fixedflag ?   ((void)(0), res_rf3cfh) : 0; /* For presscfh MRIhc08321 */
    res_rf4cfh  = _res_rf4cfh.fixedflag ?   ((void)(0), res_rf4cfh) : 0;

    /* initialize amplitudes */
    a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
    a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
    a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
    a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; /* For presscfh MRIhc08321 */
    a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0;

    /* initialize flip angles */
    flip_rf0cfh  = _flip_rf0cfh.fixedflag ?  ((void)(180), flip_rf0cfh) : 180;
    flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
    flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
    flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; /* For presscfh MRIhc08321 */
    flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180;

    /* initialize sinc cycles */
    cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(2), cyc_rf0cfh) : 2; /* Adiabatic pulse */
    cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
    cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
    cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; /* For presscfh MRIhc08321 */
    cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1;
    a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(0.0), a_gzrf4cfh) : 0.0;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(0.0), a_gxrf2cfh) : 0.0;/*For  presscfh MRIhc11621 */
    a_gzrf1cfh  = _a_gzrf1cfh.fixedflag ?  ((void)(0.0), a_gzrf1cfh) : 0.0;/*For presscfh MRIhc11621 */
    a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0.0), a_gzrf0cfh) : 0.0;/*For presscfh MRIhc11621 */


    /* initialize gscale values */
    gscale_rf1cfh  = _gscale_rf1cfh.fixedflag ?  ((void)(0.90909), gscale_rf1cfh) : 0.90909;

#ifdef PSD_CFH_CHEMSAT
    rfpulse[RFCSSAT_CFH_SLOT].pw = _pw_rfcssatcfh.fixedflag ? (_temp813_pw_rfcssatcfh=pw_rfcssatcfh,&_temp813_pw_rfcssatcfh) : &pw_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].amp = _a_rfcssatcfh.fixedflag ? (_temp814_a_rfcssatcfh=a_rfcssatcfh,&_temp814_a_rfcssatcfh) : &a_rfcssatcfh;
    rfpulse[RFCSSAT_CFH_SLOT].act_fa = _flip_rfcssatcfh.fixedflag ? (_temp815_flip_rfcssatcfh=flip_rfcssatcfh,&_temp815_flip_rfcssatcfh) : &flip_rfcssatcfh;
#endif

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp816_pw_rf1cfh=pw_rf1cfh,&_temp816_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp817_a_rf1cfh=a_rf1cfh,&_temp817_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp818_flip_rf1cfh=flip_rf1cfh,&_temp818_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp819_res_rf1cfh=res_rf1cfh,&_temp819_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp820_wg_rf1cfh=wg_rf1cfh,&_temp820_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp821_pw_rf2cfh=pw_rf2cfh,&_temp821_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp822_a_rf2cfh=a_rf2cfh,&_temp822_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp823_flip_rf2cfh=flip_rf2cfh,&_temp823_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp824_res_rf2cfh=res_rf2cfh,&_temp824_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp825_wg_rf2cfh=wg_rf2cfh,&_temp825_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp826_pw_rf3cfh=pw_rf3cfh,&_temp826_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp827_a_rf3cfh=a_rf3cfh,&_temp827_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp828_flip_rf3cfh=flip_rf3cfh,&_temp828_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp829_res_rf3cfh=res_rf3cfh,&_temp829_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp830_wg_rf3cfh=wg_rf3cfh,&_temp830_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp831_pw_rf4cfh=pw_rf4cfh,&_temp831_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp832_a_rf4cfh=a_rf4cfh,&_temp832_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp833_flip_rf4cfh=flip_rf4cfh,&_temp833_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp834_res_rf4cfh=res_rf4cfh,&_temp834_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp835_wg_rf4cfh=wg_rf4cfh,&_temp835_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464; /* 0.5/0.61*(60/90) */
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp836_pw_rf1cfh=pw_rf1cfh,&_temp836_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp837_a_rf1cfh=a_rf1cfh,&_temp837_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp838_flip_rf1cfh=flip_rf1cfh,&_temp838_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp839_res_rf1cfh=res_rf1cfh,&_temp839_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp840_wg_rf1cfh=wg_rf1cfh,&_temp840_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp841_pw_rf2cfh=pw_rf2cfh,&_temp841_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp842_a_rf2cfh=a_rf2cfh,&_temp842_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp843_flip_rf2cfh=flip_rf2cfh,&_temp843_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp844_res_rf2cfh=res_rf2cfh,&_temp844_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp845_wg_rf2cfh=wg_rf2cfh,&_temp845_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp846_pw_rf3cfh=pw_rf3cfh,&_temp846_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp847_a_rf3cfh=a_rf3cfh,&_temp847_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp848_flip_rf3cfh=flip_rf3cfh,&_temp848_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp849_res_rf3cfh=res_rf3cfh,&_temp849_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp850_wg_rf3cfh=wg_rf3cfh,&_temp850_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp851_pw_rf4cfh=pw_rf4cfh,&_temp851_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp852_a_rf4cfh=a_rf4cfh,&_temp852_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp853_flip_rf4cfh=flip_rf4cfh,&_temp853_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp854_res_rf4cfh=res_rf4cfh,&_temp854_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp855_wg_rf4cfh=wg_rf4cfh,&_temp855_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 
    }
    return SUCCESS;
}



/*
 *  PScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScvinit( void )
{
    if( (exist(opimode) == PSD_SPECTRO) || (PSD_ON == pimrsapsflg) )
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(0), fastprescan) : 0;
    }
    else
    {
        fastprescan  = _fastprescan.fixedflag ?  ((void)(cffastprescan), fastprescan) : cffastprescan;
    }

    /* Set the modes for presscfh */
    set_presscfh_mode();
    
    /* Fix to set CFH,CFL,APS1, FTG slice location to be axial mid slice to ensure
       the presence of signal when sample position is off iso center such as wrist scout scans */
    if (opplane == PSD_3PLANE)
    {
        PSslice_num  = _PSslice_num.fixedflag ?  ((void)((int)(opaxial_slice/2)), PSslice_num) : (int)(opaxial_slice/2);
    }
    else
    {  /* Start of code moved up from PSpredownload section below by SL */
        FLOAT minloc;
        FLOAT maxloc;         /* For MRIge45995 */
        FLOAT midloc;         /* For MRIge45995 */
        FLOAT minimum;        /* For MRIge45995 */
        FLOAT loc;
        INT index;

        /* search through the scan table to find the location nearest
           isocenter. Save the location information for prescan since
           graphic sat and different imaging techniques can alter the
           content and format of the rspinfo structure
        */

        minloc = MAXFLOAT;  /* For MRIge45995 */
        maxloc = -MAXFLOAT; /* For MRIge45995 */

        /* First to find the center of the prescribed region, MRIge45995 */
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (loc < minloc)
            {
                minloc = loc;
            }
            if (loc > maxloc)
            {
                maxloc = loc;
            }
        }
        midloc = 0.5*(minloc + maxloc);

        /* Find the slice most close to the center of the prescribed region, MRIge45995 */
        minimum = MAXFLOAT;
        for (index=0;index<opslquant*opvquant;index++)
        {
            loc = scan_info[index].optloc + scan_info[index].optloc_shift;
            if (fabs(loc-midloc) < minimum)
            {
                minimum = fabs(loc-midloc);
                PSslice_num  = _PSslice_num.fixedflag ?  ((void)(index), PSslice_num) : index;
            }
        }
    } /* End of code moved up from PSpredownload section below */

    /* Comment from /vobs/scan/MrScan/SrxControl/SrxGeos.m on setting opcoax */
    /* slightly modified */

    /* This next section determines the value of the opcoax CV  */
    /* The rules are as follows:  */
    /*   */
    /* coaxial      N   Y   Y  */
    /* offcenter    -   N   Y  */
    /* ======================  */
    /* opcoax       0   1   2  */
    /*  */
    /* The decision of NOT coaxial is determined by the following three  */
    /* conditions: (graphic rx imaging option selected) AND (oblique   */
    /* prescription) AND ( (more than one group has been prescribed) OR (Number
     * of radial slices > 1 ) ).  */
    /*  */
    /* The decision of offcenter is made based on whether or not   */
    /* all of the slices have 0 offset in their phase and frequency  */
    /* directions.  If even one is not 0, then the prescription is  */
    /* said to be offcenter.  */

    /* Use the below in the PSD Code if the HDMR2 changes for MRIhc08321
     * need to be overridden. RBA for MRIhc08321.
     */
    
    
    PS1cvinit();
    CFLcvinit();
    CFHcvinit();
    RCVNcvinit();

    /* initialize field strength and PS variables */ /* vmx 05/02/95 YO */
    PSfield_strength  = _PSfield_strength.fixedflag ?   ((void)((int)cffield), PSfield_strength) : (int)cffield;
    if(PSfield_strength <= B0_5000)
    {
        PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        PSmt  = _PSmt.fixedflag ?  ((void)(0), PSmt) : 0;
    }
    else
    {
        if (aspir_flag || (PSD_ON == exist(opspecir)))
        {   /* turn OFF ASPIR/SPECIAL during CFH */
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(0), PScs_sat) : 0;
        } else {
            PScs_sat  = _PScs_sat.fixedflag ?  ((void)(1), PScs_sat) : 1;
        }

        PSmt  = _PSmt.fixedflag ?  ((void)(1), PSmt) : 1;
    }

    pimrs[0] = _pimrsaps1.fixedflag ? (_temp856_pimrsaps1=pimrsaps1,&_temp856_pimrsaps1) : &pimrsaps1;
    pimrs[1] = _pimrsaps2.fixedflag ? (_temp857_pimrsaps2=pimrsaps2,&_temp857_pimrsaps2) : &pimrsaps2;
    pimrs[2] = _pimrsaps3.fixedflag ? (_temp858_pimrsaps3=pimrsaps3,&_temp858_pimrsaps3) : &pimrsaps3;
    pimrs[3] = _pimrsaps4.fixedflag ? (_temp859_pimrsaps4=pimrsaps4,&_temp859_pimrsaps4) : &pimrsaps4;
    pimrs[4] = _pimrsaps5.fixedflag ? (_temp860_pimrsaps5=pimrsaps5,&_temp860_pimrsaps5) : &pimrsaps5;
    pimrs[5] = _pimrsaps6.fixedflag ? (_temp861_pimrsaps6=pimrsaps6,&_temp861_pimrsaps6) : &pimrsaps6;
    pimrs[6] = _pimrsaps7.fixedflag ? (_temp862_pimrsaps7=pimrsaps7,&_temp862_pimrsaps7) : &pimrsaps7;
    pimrs[7] = _pimrsaps8.fixedflag ? (_temp863_pimrsaps8=pimrsaps8,&_temp863_pimrsaps8) : &pimrsaps8;
    pimrs[8] = _pimrsaps9.fixedflag ? (_temp864_pimrsaps9=pimrsaps9,&_temp864_pimrsaps9) : &pimrsaps9;
    pimrs[9] = _pimrsaps10.fixedflag ? (_temp865_pimrsaps10=pimrsaps10,&_temp865_pimrsaps10) : &pimrsaps10;
    pimrs[10] = _pimrsaps11.fixedflag ? (_temp866_pimrsaps11=pimrsaps11,&_temp866_pimrsaps11) : &pimrsaps11;
    pimrs[11] = _pimrsaps12.fixedflag ? (_temp867_pimrsaps12=pimrsaps12,&_temp867_pimrsaps12) : &pimrsaps12;
    pimrs[12] = _pimrsaps13.fixedflag ? (_temp868_pimrsaps13=pimrsaps13,&_temp868_pimrsaps13) : &pimrsaps13;
    pimrs[13] = _pimrsaps14.fixedflag ? (_temp869_pimrsaps14=pimrsaps14,&_temp869_pimrsaps14) : &pimrsaps14;
    pimrs[14] = _pimrsaps15.fixedflag ? (_temp870_pimrsaps15=pimrsaps15,&_temp870_pimrsaps15) : &pimrsaps15;

    
    /* MRIhc15304: we will keep asfov as cv and fill it with the value
     * from coil. Some application (Spectro related) need to decide the
     * asfov based on the application (overriding the value decided by
     * coil). */ 
    asfov  = _asfov.fixedflag ?  ((void)(coilInfo[0].autoshimFov), asfov) : coilInfo[0].autoshimFov;

    /* 
     * Set the wait time for sethubindeximm.  A 100 ms delay is
     * sufficent to apply the settings on the driver module.  On systems
     * with an RRF receiver, a longer delay (250 ms) is needed for the
     * new receiver channel map to be loaded into the DRF. 
     */
    if( cfcoilswitchmethod & COIL_SWITCH_RSP_SETHUBINDEXIMM )
    {
        if( CFG_VAL_RECEIVER_RRF == cfreceivertype )
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(250000), csw_wait_sethubindeximm) : 250000;
        }
        else
        {
            csw_wait_sethubindeximm   = _csw_wait_sethubindeximm.fixedflag ?  ((void)(100000), csw_wait_sethubindeximm) : 100000;
        }
    }

    return SUCCESS;
}   /* end PScvinit() */


/*
 *  FTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcvinit( void )
{
    a_rf1ftg     = _a_rf1ftg.fixedflag ?  ((void)(0.5), a_rf1ftg) : 0.5;
    a_rf2ftg     = _a_rf2ftg.fixedflag ?  ((void)(1.0), a_rf2ftg) : 1.0;
    a_rf3ftg     = _a_rf3ftg.fixedflag ?  ((void)(1.0), a_rf3ftg) : 1.0;
    pw_rf1ftg    = _pw_rf1ftg.fixedflag ?  ((void)((int)rfpulse[RF1_FTG_SLOT].nom_pw), pw_rf1ftg) : (int)rfpulse[RF1_FTG_SLOT].nom_pw;
    pw_rf2ftg    = _pw_rf2ftg.fixedflag ?  ((void)((int)rfpulse[RF2_FTG_SLOT].nom_pw), pw_rf2ftg) : (int)rfpulse[RF2_FTG_SLOT].nom_pw;
    pw_rf3ftg    = _pw_rf3ftg.fixedflag ?  ((void)((int)rfpulse[RF3_FTG_SLOT].nom_pw), pw_rf3ftg) : (int)rfpulse[RF3_FTG_SLOT].nom_pw;
    cyc_rf1ftg   = _cyc_rf1ftg.fixedflag ?  ((void)(1), cyc_rf1ftg) : 1;
    res_rf1ftg   = _res_rf1ftg.fixedflag ?  ((void)(800), res_rf1ftg) : 800;
    cyc_rf2ftg   = _cyc_rf2ftg.fixedflag ?  ((void)(1), cyc_rf2ftg) : 1;
    res_rf2ftg   = _res_rf2ftg.fixedflag ?  ((void)(800), res_rf2ftg) : 800;
    cyc_rf3ftg   = _cyc_rf3ftg.fixedflag ?  ((void)(1), cyc_rf3ftg) : 1;
    res_rf3ftg   = _res_rf3ftg.fixedflag ?  ((void)(800), res_rf3ftg) : 800;
    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;

    return SUCCESS;
} /* end FTGcvinit() */


/*
 *  XTGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcvinit( void )
{   
    double coil_maxb1, coil_maxb1_gauss, fermi_b1; /* HCSDM00157626 */
    a_rf1xtg     = _a_rf1xtg.fixedflag ?  ((void)(0.5), a_rf1xtg) : 0.5;
    a_rf2xtg     = _a_rf2xtg.fixedflag ?  ((void)(1.0), a_rf2xtg) : 1.0;
    pw_rf1xtg    = _pw_rf1xtg.fixedflag ?  ((void)((int)rfpulse[RF1_XTG_SLOT].nom_pw), pw_rf1xtg) : (int)rfpulse[RF1_XTG_SLOT].nom_pw;
    pw_rf2xtg    = _pw_rf2xtg.fixedflag ?  ((void)((int)rfpulse[RF2_XTG_SLOT].nom_pw), pw_rf2xtg) : (int)rfpulse[RF2_XTG_SLOT].nom_pw;
    cyc_rf1xtg   = _cyc_rf1xtg.fixedflag ?  ((void)(1), cyc_rf1xtg) : 1;
    res_rf1xtg   = _res_rf1xtg.fixedflag ?  ((void)(0), res_rf1xtg) : 0;
    cyc_rf2xtg   = _cyc_rf2xtg.fixedflag ?  ((void)(1), cyc_rf2xtg) : 1;
    res_rf2xtg   = _res_rf2xtg.fixedflag ?  ((void)(800), res_rf2xtg) : 800;
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;

    a_rf3xtg  = _a_rf3xtg.fixedflag ?  ((void)(-1.0), a_rf3xtg) : -1.0; 
    a_rf4xtg  = _a_rf4xtg.fixedflag ?  ((void)(1.0), a_rf4xtg) : 1.0;
    res_rf3xtg  = _res_rf3xtg.fixedflag ?  ((void)(RES_FERMI_BLS), res_rf3xtg) : RES_FERMI_BLS;
    res_rf4xtg  = _res_rf4xtg.fixedflag ?  ((void)(res_rf3xtg), res_rf4xtg) : res_rf3xtg;
    pw_rf3xtg    = _pw_rf3xtg.fixedflag ?  ((void)(pw_bsrf), pw_rf3xtg) : pw_bsrf;
    pw_rf4xtg    = _pw_rf4xtg.fixedflag ?  ((void)(pw_rf3xtg), pw_rf4xtg) : pw_rf3xtg;
    
    flip_rf3xtg  = _flip_rf3xtg.fixedflag ?  ((void)((FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW), flip_rf3xtg) : (FA_FERMI_BLS*pw_rf3xtg)/SAR_FERMI_BLS_NOM_PW;  /* scale flip to keep its maxB1 constant */
    /* 630 degree flip, 4ms pw: max B1 = 0.071 */
    flip_rf4xtg  = _flip_rf4xtg.fixedflag ?  ((void)(flip_rf3xtg), flip_rf4xtg) : flip_rf3xtg;       

    fermi_b1 = 100*FA_FERMI_BLS/NOM_FA_RFMT*SAR_MAXB1_FERMI_BLS;

    /* Find the maximum predicted B1 for the current weight and coil */
    /* HCSDM00384210 */

    if( SDL_RFDerating_entry( &coil_maxb1_gauss, cffield, opweight, txCoilInfo[getTxIndex(coilInfo[0])], (GRADIENT_COIL_E) cfgcoiltype, L_SCAN ) != SUCCESS)
    {
        epic_error(0, "Support routine %s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "SDL_RFDerating");
        return FAILURE;
    }

    coil_maxb1 = coil_maxb1_gauss/UTESLA2GAUSS;
        
    if(fermi_b1 > coil_maxb1)  /* disable XTG */ 
    {
        xtg_disabled = PSD_ON;
        rfpulse[RF1_XTG_SLOT].num = 0;  
        rfpulse[RF1_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF2_XTG_SLOT].num = 0; 
        rfpulse[RF2_XTG_SLOT].activity = PSD_OFF;    
        rfpulse[RF3_XTG_SLOT].num = 0;  
        rfpulse[RF3_XTG_SLOT].activity = PSD_OFF;
        rfpulse[RF4_XTG_SLOT].num = 0; 
        rfpulse[RF4_XTG_SLOT].activity = PSD_OFF;    
    }
    else
    {
        xtg_disabled = PSD_OFF;
        rfpulse[RF1_XTG_SLOT].num = 1;
        rfpulse[RF1_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF2_XTG_SLOT].num = 1;
        rfpulse[RF2_XTG_SLOT].activity = PSD_XTG_ON;    
        rfpulse[RF3_XTG_SLOT].num = 1;
        rfpulse[RF3_XTG_SLOT].activity = PSD_XTG_ON;
        rfpulse[RF4_XTG_SLOT].num = 1;
        rfpulse[RF4_XTG_SLOT].activity = PSD_XTG_ON;    
    }
    
    xtgtr  = _xtgtr.fixedflag ?  ((void)(200000), xtgtr) : 200000;
    
    xtg_dda  = _xtg_dda.fixedflag ?  ((void)(2), xtg_dda) : 2;
    XTGacq1  = _XTGacq1.fixedflag ?  ((void)(PSD_ON), XTGacq1) : PSD_ON;
    
    return SUCCESS;
} /* end XTGcvinit() */

/*
 *  AScvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScvinit( void )
{
    INT asplane;
    INT ascell;
    SCAN_INFO total_asscan_info[6];
    INT total_asplane = 3;

    td0as  = _td0as.fixedflag ?  ((void)(GRAD_UPDATE_TIME), td0as) : GRAD_UPDATE_TIME;

    /* Create a pseudo scan_info table for obloptimize to work with.
       The rotation matrices for the planes are what is important. */
    if(oppscvquant == 2)
    {
        total_asplane = oppscvquant * 3;
    }
    for( asplane = 0; asplane < total_asplane; asplane++ )
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[asplane].oprot[ascell] = 0.0;
        }
    }

    /* Axial */
    total_asscan_info[0].oprot[0] = total_asscan_info[0].oprot[4] = total_asscan_info[0].oprot[8]
        = 1.0;
    /* Sagittal */
    total_asscan_info[1].oprot[2] = total_asscan_info[1].oprot[4] = total_asscan_info[1].oprot[6]
        = 1.0;
    /* Coronal */
    total_asscan_info[2].oprot[1] = total_asscan_info[2].oprot[5] = total_asscan_info[2].oprot[6]
        = 1.0;

    if (oppscvquant > 0)
    {
        for( ascell = 0; ascell < 9; ascell++ )
        {
            total_asscan_info[0].oprot[ascell] = psc_info[0].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            if (oppscvquant == 2)
            {
                total_asscan_info[3].oprot[ascell] = psc_info[1].oppscrot[ascell]; /* use shim vol rot for autoshim planes */
            }
        }

        /* Create 2nd orthogonal plane from first shim vol matrix */
        total_asscan_info[1].oprot[0] = -total_asscan_info[0].oprot[2];
        total_asscan_info[1].oprot[1] = total_asscan_info[0].oprot[1];
        total_asscan_info[1].oprot[2] = total_asscan_info[0].oprot[0];
        total_asscan_info[1].oprot[3] = -total_asscan_info[0].oprot[5];
        total_asscan_info[1].oprot[4] = total_asscan_info[0].oprot[4];
        total_asscan_info[1].oprot[5] = total_asscan_info[0].oprot[3];
        total_asscan_info[1].oprot[6] = -total_asscan_info[0].oprot[8];
        total_asscan_info[1].oprot[7] = total_asscan_info[0].oprot[7];
        total_asscan_info[1].oprot[8] = total_asscan_info[0].oprot[6];
        /* Create 3rd orthogonal plane */
        total_asscan_info[2].oprot[0] = total_asscan_info[0].oprot[0];
        total_asscan_info[2].oprot[1] = total_asscan_info[0].oprot[2];
        total_asscan_info[2].oprot[2] = -total_asscan_info[0].oprot[1];
        total_asscan_info[2].oprot[3] = total_asscan_info[0].oprot[3];
        total_asscan_info[2].oprot[4] = total_asscan_info[0].oprot[5];
        total_asscan_info[2].oprot[5] = -total_asscan_info[0].oprot[4];
        total_asscan_info[2].oprot[6] = total_asscan_info[0].oprot[6];
        total_asscan_info[2].oprot[7] = total_asscan_info[0].oprot[8];
        total_asscan_info[2].oprot[8] = -total_asscan_info[0].oprot[7];

        if (oppscvquant == 2)
        {
            /* Create 2nd orthogonal plane for 2nd shim vol */
            total_asscan_info[4].oprot[0] = -total_asscan_info[3].oprot[2];
            total_asscan_info[4].oprot[1] = total_asscan_info[3].oprot[1];
            total_asscan_info[4].oprot[2] = total_asscan_info[3].oprot[0];
            total_asscan_info[4].oprot[3] = -total_asscan_info[3].oprot[5];
            total_asscan_info[4].oprot[4] = total_asscan_info[3].oprot[4];
            total_asscan_info[4].oprot[5] = total_asscan_info[3].oprot[3];
            total_asscan_info[4].oprot[6] = -total_asscan_info[3].oprot[8];
            total_asscan_info[4].oprot[7] = total_asscan_info[3].oprot[7];
            total_asscan_info[4].oprot[8] = total_asscan_info[3].oprot[6];
            /* Create 3rd orthogonal plane */
            total_asscan_info[5].oprot[0] = total_asscan_info[3].oprot[0];
            total_asscan_info[5].oprot[1] = total_asscan_info[3].oprot[2];
            total_asscan_info[5].oprot[2] = -total_asscan_info[3].oprot[1];
            total_asscan_info[5].oprot[3] = total_asscan_info[3].oprot[3];
            total_asscan_info[5].oprot[4] = total_asscan_info[3].oprot[5];
            total_asscan_info[5].oprot[5] = -total_asscan_info[3].oprot[4];
            total_asscan_info[5].oprot[6] = total_asscan_info[3].oprot[6];
            total_asscan_info[5].oprot[7] = total_asscan_info[3].oprot[8];
            total_asscan_info[5].oprot[8] = -total_asscan_info[3].oprot[7];
        }
    }
  
    as_newgeo  = _as_newgeo.fixedflag ?  ((void)(1), as_newgeo) : 1;
    if (FAILURE==obloptimize(&asloggrd, &phygrd, total_asscan_info, total_asplane, PSD_OBL,
                             0, PSD_OBL_RESTRICT, asobl_debug, _as_newgeo.fixedflag ? (_temp871_as_newgeo=as_newgeo,&_temp871_as_newgeo) : &as_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in AScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&asloggrd, PSassr_derate_factor, PSasamp_derate_factor);

    /* X Killer CVs */
    if (FAILURE==amppwgrad(asx_killer_area, asloggrd.tx_xz, 0.0, 0.0, asloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkas.fixedflag ? (_temp872_a_gxkas=a_gxkas,&_temp872_a_gxkas) : &a_gxkas, _pw_gxkasa.fixedflag ? (_temp873_pw_gxkasa=pw_gxkasa,&_temp873_pw_gxkasa) : &pw_gxkasa,
                           _pw_gxkas.fixedflag ? (_temp874_pw_gxkas=pw_gxkas,&_temp874_pw_gxkas) : &pw_gxkas, _pw_gxkasd.fixedflag ? (_temp875_pw_gxkasd=pw_gxkasd,&_temp875_pw_gxkasd) : &pw_gxkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkas"); 
        return FAILURE;
    }

    /* Z Killer CVs */
    if (FAILURE==amppwgrad(asz_killer_area, asloggrd.tz_xz, 0.0, 0.0, asloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkas.fixedflag ? (_temp876_a_gzkas=a_gzkas,&_temp876_a_gzkas) : &a_gzkas, _pw_gzkasa.fixedflag ? (_temp877_pw_gzkasa=pw_gzkasa,&_temp877_pw_gzkasa) : &pw_gzkasa,
                           _pw_gzkas.fixedflag ? (_temp878_pw_gzkas=pw_gzkas,&_temp878_pw_gzkas) : &pw_gzkas, _pw_gzkasd.fixedflag ? (_temp879_pw_gzkasd=pw_gzkasd,&_temp879_pw_gzkasd) : &pw_gzkasd ))
    {
        epic_error(use_ermes, "%s failed in AScvinit.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkas"); 
        return FAILURE;
    }

    /* rf1 cvs  */
    a_rf1as  = _a_rf1as.fixedflag ?  ((void)(1.0), a_rf1as) : 1.0;
    pw_rf1as  = _pw_rf1as.fixedflag ?  ((void)(rfpulse[RF1_AUTOSHIM].nom_pw), pw_rf1as) : rfpulse[RF1_AUTOSHIM].nom_pw;
    gscale_rf1as  = _gscale_rf1as.fixedflag ?  ((void)(.90909), gscale_rf1as) : .90909;
    cyc_rf1as  = _cyc_rf1as.fixedflag ?  ((void)(1), cyc_rf1as) : 1;
    res_rf1as  = _res_rf1as.fixedflag ?  ((void)(0), res_rf1as) : 0; /* initialized to zero for system safety check in cveval */

    /* gzrf1 cvs */
    pw_gzrf1as  = _pw_gzrf1as.fixedflag ?  ((void)(pw_rf1as), pw_gzrf1as) : pw_rf1as;
    flip_rf1as  = _flip_rf1as.fixedflag ?  ((void)(asflip), flip_rf1as) : asflip;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadas   = _tleadas.fixedflag ?    ((void)(RUP_GRD(24)), tleadas) : RUP_GRD(24);
    bw_rf1as  = _bw_rf1as.fixedflag ?      ((void)((int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000))), bw_rf1as) : (int)(4*cyc_rf1as/((float)pw_rf1as/(float)1000000));
    t_exaas   = _t_exaas.fixedflag ?     ((void)(pw_gzrf1asa+pw_rf1as/2), t_exaas) : pw_gzrf1asa+pw_rf1as/2;

    return SUCCESS;
} /* end AScvinit() */


/*
 *  RScvinit
 *  Description:
 *  CV init for RFShim 
 *  
 *  Type: Public Function
 *  
 */
STATUS
RScvinit( void )
{
    INT index;

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* BLS RF pulse */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10.0), flip_rf1rs) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_RFSHIM_SLOT].abswidth = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].effwidth = 0.6755;
    rfpulse[RFB_RFSHIM_SLOT].area = 0.8018;
    rfpulse[RFB_RFSHIM_SLOT].dtycyc = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].maxpw = 1.0;
    rfpulse[RFB_RFSHIM_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_RFSHIM_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_RFSHIM_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_RFSHIM_SLOT].nom_fa = 90.0;
    rfpulse[RFB_RFSHIM_SLOT].act_fa = _flip_rfbrs.fixedflag ? (_temp880_flip_rfbrs=flip_rfbrs,&_temp880_flip_rfbrs) : &flip_rfbrs;
    rfpulse[RFB_RFSHIM_SLOT].nom_pw = 2000;
    rfpulse[RFB_RFSHIM_SLOT].num = 1;

    pw_rfbrs  = _pw_rfbrs.fixedflag ?  ((void)(2000), pw_rfbrs) : 2000;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(1000), res_rfbrs) : 1000;
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(res_rfbrs), res_thetarfbrs) : res_rfbrs;

    /* B1 Map rf1 */
    gscale_rf1rs  = _gscale_rf1rs.fixedflag ?  ((void)(1.0), gscale_rf1rs) : 1.0;
    a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(3200), pw_rf1rs) : 3200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(pw_rf1rs/RF_UPDATE_TIME), res_rf1rs) : pw_rf1rs/RF_UPDATE_TIME;
            cyc_rf1rs  = _cyc_rf1rs.fixedflag ?  ((void)(1), cyc_rf1rs) : 1;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rs_off90  = _rs_off90.fixedflag ?  ((void)(PSoff90), rs_off90) : PSoff90;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_RFSHIM_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_RFSHIM_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = 3200;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = 90;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(1200), pw_rf1rs) : 1200;
            res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(RES_TBW6), res_rf1rs) : RES_TBW6;
            a_rf1rs  = _a_rf1rs.fixedflag ?  ((void)(1.0), a_rf1rs) : 1.0;
            rfpulse[RF1_RFSHIM_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_RFSHIM_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_RFSHIM_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_RFSHIM_SLOT].num = 1;
            break;
    }

    /* Only support single slice RF Shim now */
    if ( PSD_ON == rsaxial_flag )
    {
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        for( index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = 0.0;
        }

        if ( (isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast"))
             || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_HEAD) ) 
        {
            /* Axial plane, Freq A/P for breast or Head Anatomy */
            rsscan_info[0].oprot[1] = rsscan_info[0].oprot[3] = rsscan_info[0].oprot[8] = 1.0;
        }
        else   /* Freq R/L */
        {
            rsscan_info[0].oprot[0] = rsscan_info[0].oprot[4] = rsscan_info[0].oprot[8] = 1.0;
        }
    }
    else
    {
        for (index = 0; index < 9; index++)
        {
            rsscan_info[0].oprot[index] = scan_info[PSslice_num].oprot[index]; /* use Rxed slice rot */ 
        }
    }

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    if (obloptimize(&rsloggrd, &phygrd, rsscan_info, 1, PSD_OBL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp881_ps1_newgeo=ps1_newgeo,&_temp881_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    /* derate SR for silent PSC */ 
    sr_derate(&rsloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* gzrf1 cvs */
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    /*******************/
    /* Starting point  */
    /*******************/
    tleadrs   = _tleadrs.fixedflag ?    ((void)(RUP_GRD(24)), tleadrs) : RUP_GRD(24);

    return SUCCESS;
}  /* end RScvinit */

/* 
 *  DTGcvinit
 *  Description:
 *  CV init for Dynamic TG 
 *  
 *  Type: Public Function
 *  
 */
STATUS
DTGcvinit( void )
{

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180.0), flip_rfbdtg) : 180.0;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10.0), flip_rf1dtg) : 10.0;

    /* BLS RF Pulse */
    rfpulse[RFB_DYNTG_SLOT].abswidth = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].effwidth = 0.6755;
    rfpulse[RFB_DYNTG_SLOT].area = 0.8018;
    rfpulse[RFB_DYNTG_SLOT].dtycyc = 1.0;
    rfpulse[RFB_DYNTG_SLOT].maxpw = 1.0;
    rfpulse[RFB_DYNTG_SLOT].max_b1 = 0.036615;
    rfpulse[RFB_DYNTG_SLOT].max_int_b1_sq = 0.00181119;
    rfpulse[RFB_DYNTG_SLOT].max_rms_b1 = 0.0300931;
    rfpulse[RFB_DYNTG_SLOT].nom_fa = 90.0;
    rfpulse[RFB_DYNTG_SLOT].act_fa = _flip_rfbdtg.fixedflag ? (_temp882_flip_rfbdtg=flip_rfbdtg,&_temp882_flip_rfbdtg) : &flip_rfbdtg;
    rfpulse[RFB_DYNTG_SLOT].nom_pw = 2000;
    rfpulse[RFB_DYNTG_SLOT].num = 1;


    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(1000), res_rfbdtg) : 1000;
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(res_rfbdtg), res_thetarfbdtg) : res_rfbdtg;
    pw_rfbdtg  = _pw_rfbdtg.fixedflag ?  ((void)(2000), pw_rfbdtg) : 2000;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;

    /* B1 Map rf1 */
    a_rf1dtg  = _a_rf1dtg.fixedflag ?  ((void)(1.0), a_rf1dtg) : 1.0;
    gscale_rf1dtg  = _gscale_rf1dtg.fixedflag ?  ((void)(1.0), gscale_rf1dtg) : 1.0;
    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(3200), pw_rf1dtg) : 3200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(pw_rf1dtg/RF_UPDATE_TIME), res_rf1dtg) : pw_rf1dtg/RF_UPDATE_TIME;
            cyc_rf1dtg  = _cyc_rf1dtg.fixedflag ?  ((void)(1), cyc_rf1dtg) : 1;
            dtg_off90  = _dtg_off90.fixedflag ?  ((void)(PSoff90), dtg_off90) : PSoff90;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_SINC1;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_PSINC1;
            rfpulse[RF1_DYNTG_SLOT].area = SAR_ASINC1;
            rfpulse[RF1_DYNTG_SLOT].dtycyc = SAR_DTYCYC_SINC1;
            rfpulse[RF1_DYNTG_SLOT].maxpw = SAR_MAXPW_SINC1;
            rfpulse[RF1_DYNTG_SLOT].max_b1 = MAX_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = 3200;
            rfpulse[RF1_DYNTG_SLOT].nom_bw = NOM_BW_SINC1_90;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = 90;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;

        case B1RF1_TBW:
        default:
            pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(1200), pw_rf1dtg) : 1200;
            res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(RES_TBW6), res_rf1dtg) : RES_TBW6;
            rfpulse[RF1_DYNTG_SLOT].abswidth = SAR_ABS_TBW6;
            rfpulse[RF1_DYNTG_SLOT].area     = SAR_A_TBW6;
            rfpulse[RF1_DYNTG_SLOT].effwidth = SAR_TBW6_EFF_WIDTH;
            rfpulse[RF1_DYNTG_SLOT].dtycyc   = SAR_DTYCYC_TBW6;
            rfpulse[RF1_DYNTG_SLOT].maxpw    = SAR_MAXPW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_b1   = MAX_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_TBW6;
            rfpulse[RF1_DYNTG_SLOT].max_rms_b1 = MAX_RMS_B1_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_pw   = NOM_PW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_bw   = NOM_BW_TBW6;
            rfpulse[RF1_DYNTG_SLOT].nom_fa   = NOM_FA_TBW6;
            rfpulse[RF1_DYNTG_SLOT].isodelay = NOM_PW_TBW6/2;
            rfpulse[RF1_DYNTG_SLOT].num = 1;
            break;
    }


    /* gzrf1 cvs */
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    /*******************/
    /* Starting point  */
    /*******************/
    tleaddtg   = _tleaddtg.fixedflag ?    ((void)(RUP_GRD(24)), tleaddtg) : RUP_GRD(24);

    return SUCCESS;
}  /* end DTGcvinit */



/*
 *  ExtCalcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:  cvinit section
 *  for ExtCal entry point
 *  
 */
STATUS
ExtCalcvinit( void )
{
    cal_xres  = _cal_xres.fixedflag ?  ((void)(32), cal_xres) : 32;
    cal_yres  = _cal_yres.fixedflag ?  ((void)(32), cal_yres) : 32;
    cal_nex  = _cal_nex.fixedflag ?  ((void)(2), cal_nex) : 2; 
    cal_pass  = _cal_pass.fixedflag ?  ((void)(2), cal_pass) : 2; 

    echo1bwcal  = _echo1bwcal.fixedflag ?  ((void)(62.5), echo1bwcal) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;
    /* use original_phygrd to avoid ART derating; use phygrd to apply derating */
    original_pgrd = getOrigphygrd();
    if (obloptimize(&calloggrd, &original_pgrd, calscan_info, cal_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp883_ps1_newgeo=ps1_newgeo,&_temp883_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize");
        return FAILURE;
    }

    cal_slewrate  = _cal_slewrate.fixedflag ?  ((void)(original_pgrd.zfs*10000.0/original_pgrd.zrt), cal_slewrate) : original_pgrd.zfs*10000.0/original_pgrd.zrt;

    /* initialize pulse */
    a_rf1cal  = _a_rf1cal.fixedflag ?  ((void)(1.0), a_rf1cal) : 1.0;
    flip_rf1cal  = _flip_rf1cal.fixedflag ?  ((void)(1.0), flip_rf1cal) : 1.0;
    res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(150), res_rf1cal) : 150;
    pw_rf1cal  = _pw_rf1cal.fixedflag ?    ((void)(300), pw_rf1cal) : 300;

    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    tleadcal  = _tleadcal.fixedflag ?    ((void)(RUP_GRD(24)), tleadcal) : RUP_GRD(24);

    return SUCCESS;
}

/*
 *  AutoCoilcvinit
 *
 *  Type: Public Function
 *
 *  Description:  cvinit section
 *  for Auto Coil entry point
 *
 */
STATUS
AutoCoilcvinit( void )
{
    float coil_sr_derate = 1.0;

    coil_nex  = _coil_nex.fixedflag ?  ((void)(2), coil_nex) : 2;
    coil_pass  = _coil_pass.fixedflag ?  ((void)(1), coil_pass) : 1;

    echo1bwcoil  = _echo1bwcoil.fixedflag ?  ((void)(62.5), echo1bwcoil) : 62.5;  /* Rec Bandwidth fixed to +/- 62.5kHz */

    ps1_newgeo  = _ps1_newgeo.fixedflag ?  ((void)(1), ps1_newgeo) : 1;

    if (obloptimize(&coilloggrd, &phygrd, coilscan_info, coil_slq, PSD_AXIAL,
                    0, obl_method, ps1obl_debug, _ps1_newgeo.fixedflag ? (_temp884_ps1_newgeo=ps1_newgeo,&_temp884_ps1_newgeo) : &ps1_newgeo,
                    cfsrmode) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in RScvinit.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize");
        return FAILURE;
    }

    if(opsilentmr)
    {
        coil_sr_derate = 40.0;
    }
    else
    {
        coil_sr_derate = 1.0;
    }
    coil_slewrate  = _coil_slewrate.fixedflag ?  ((void)(phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt)), coil_slewrate) : phygrd.zfs*10000.0/(coil_sr_derate*phygrd.zrt);
    coil_slewrate  = _coil_slewrate.fixedflag ?    ((void)(FMax(2,3.0,coil_slewrate)), coil_slewrate) : FMax(2,3.0,coil_slewrate);  /* limited slewrate to 3 mT/m/ms and above */

    /* initialize pulse */
    a_rf1coil  = _a_rf1coil.fixedflag ?  ((void)(1.0), a_rf1coil) : 1.0;
    flip_rf1coil  = _flip_rf1coil.fixedflag ?  ((void)(1.0), flip_rf1coil) : 1.0;
    res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(150), res_rf1coil) : 150;
    pw_rf1coil  = _pw_rf1coil.fixedflag ?    ((void)(300), pw_rf1coil) : 300;

    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    tleadcoil  = _tleadcoil.fixedflag ?    ((void)(RUP_GRD(24)), tleadcoil) : RUP_GRD(24);

    return SUCCESS;
}


/*
 *  PS1cveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1cveval( FLOAT *opthickPS )
{
    LONG bw_rf1mps1, bw_rf2mps1;    /* band widths of rf pulses */
    FLOAT area_pulse;
    FLOAT area_readrampmps1;
    FLOAT area_gxwmps1;
    FLOAT av_temp_float1 = 0;
    INT ps1_xrt;
    FLOAT ps1_tx;
    FLOAT ps1_tx_xz;
    FLOAT ps1_tz_xz;

    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

    /* check for breast L/R coil */
    if( isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast") )
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_ON), ps1_rxcoil) : PSD_ON;  /* Rxed rec coil for TG */
    }
    else
    {
        ps1_rxcoil  = _ps1_rxcoil.fixedflag ?  ((void)(PSD_OFF), ps1_rxcoil) : PSD_OFF;
    }

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_ON == ps1_rxcoil) )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(getAps1ModFov()), mpsfov) : getAps1ModFov();
    }
    else
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(cfsystemmaxfov), mpsfov) : cfsystemmaxfov;
    }

    if(PSD_ON == local_tg)
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(TGopslthickx), mpsfov) : TGopslthickx;
    }

    ps1_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ps1_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ps1_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ps1_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);

    /* Z slice select for 90 pulse */
    bw_rf1mps1 = (LONG)(rfpulse[RF1_APS1_SLOT].nom_bw*rfpulse[RF1_APS1_SLOT].nom_pw/(float)pw_rf1mps1);

    if (FAILURE== minslicethick(&av_temp_float1, bw_rf1mps1, ps1loggrd.tz, gscale_rf1mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "minslicethick");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1*10.0)/10.0;
    if (av_temp_float1 > *opthickPS)
    {
        *opthickPS = av_temp_float1;
    }

    if (0 == getAps1Mod()) {
        cvoverride(thickPS_mod, *opthickPS, PSD_FIX_ON, PSD_EXIST_ON);
    } else {
        float fov = FMax(2, getAps1ModSlThick(), av_temp_float1);
        cvoverride(thickPS_mod, fov, PSD_FIX_ON, PSD_EXIST_ON);
    }

    if(PSD_ON == local_tg)
    {
        pw_gyrf1mps1  = _pw_gyrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gyrf1mps1) : pw_rf1mps1;
        if(av_temp_float1 > TGopslthicky)
        {
            TGopslthicky  = _TGopslthicky.fixedflag ?  ((void)(av_temp_float1), TGopslthicky) : av_temp_float1;
        }

        if (FAILURE==ampslice(_a_gyrf1mps1.fixedflag ? (_temp885_a_gyrf1mps1=a_gyrf1mps1,&_temp885_a_gyrf1mps1) : &a_gyrf1mps1, bw_rf1mps1,TGopslthicky,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1mps1.");
            return FAILURE;
        }

        /* slice selection ramp */
        if (optramp(_pw_gyrf1mps1a.fixedflag ? (_temp886_pw_gyrf1mps1a=pw_gyrf1mps1a,&_temp886_pw_gyrf1mps1a) : &pw_gyrf1mps1a, a_gyrf1mps1, ps1loggrd.ty, ps1loggrd.yrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1mps1a.");
            return FAILURE;
        }
        pw_gyrf1mps1d  = _pw_gyrf1mps1d.fixedflag ?  ((void)(pw_gyrf1mps1a), pw_gyrf1mps1d) : pw_gyrf1mps1a;

        area_pulse = a_gyrf1mps1*(pw_gyrf1mps1/2 + PSoff90 + pw_gyrf1mps1d/2);
        if (amppwgz1(_a_gy1mps1.fixedflag ? (_temp887_a_gy1mps1=a_gy1mps1,&_temp887_a_gy1mps1) : &a_gy1mps1,_pw_gy1mps1.fixedflag ? (_temp888_pw_gy1mps1=pw_gy1mps1,&_temp888_pw_gy1mps1) : &pw_gy1mps1,_pw_gy1mps1a.fixedflag ? (_temp889_pw_gy1mps1a=pw_gy1mps1a,&_temp889_pw_gy1mps1a) : &pw_gy1mps1a,_pw_gy1mps1d.fixedflag ? (_temp890_pw_gy1mps1d=pw_gy1mps1d,&_temp890_pw_gy1mps1d) : &pw_gy1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }

        if(av_temp_float1 > TGopslthick)
        {
            TGopslthick  = _TGopslthick.fixedflag ?  ((void)(av_temp_float1), TGopslthick) : av_temp_float1;
        }

        thickPS_mod  = _thickPS_mod.fixedflag ?  ((void)(TGopslthick), thickPS_mod) : TGopslthick;
    }
    else
    {
        pw_gzrf1mps1  = _pw_gzrf1mps1.fixedflag ?  ((void)(pw_rf1mps1), pw_gzrf1mps1) : pw_rf1mps1;
        if (FAILURE==ampslice(_a_gzrf1mps1.fixedflag ? (_temp891_a_gzrf1mps1=a_gzrf1mps1,&_temp891_a_gzrf1mps1) : &a_gzrf1mps1, bw_rf1mps1,thickPS_mod,gscale_rf1mps1,TYPDEF))
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gzrf1mps1.");
            return FAILURE;
        }
        /* end aps1_mod changes (GE) */

        /* slice selection ramp */
        if (optramp(_pw_gzrf1mps1a.fixedflag ? (_temp892_pw_gzrf1mps1a=pw_gzrf1mps1a,&_temp892_pw_gzrf1mps1a) : &pw_gzrf1mps1a, a_gzrf1mps1, ps1loggrd.tz, ps1loggrd.zrt,
                    TYPDEF)==FAILURE) /* vmx 5/9/95 YI */ 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gzrf1mps1a.");
            return FAILURE;
        }
        pw_gzrf1mps1d  = _pw_gzrf1mps1d.fixedflag ?  ((void)(pw_gzrf1mps1a), pw_gzrf1mps1d) : pw_gzrf1mps1a;

        /* Z gradient refocus */
        /* available time not calculated, defaulted to 10ms */
        area_pulse = a_gzrf1mps1*(pw_gzrf1mps1/2 + PSoff90 + pw_gzrf1mps1d/2);
        if (amppwgz1(_a_gz1mps1.fixedflag ? (_temp893_a_gz1mps1=a_gz1mps1,&_temp893_a_gz1mps1) : &a_gz1mps1,_pw_gz1mps1.fixedflag ? (_temp894_pw_gz1mps1=pw_gz1mps1,&_temp894_pw_gz1mps1) : &pw_gz1mps1,_pw_gz1mps1a.fixedflag ? (_temp895_pw_gz1mps1a=pw_gz1mps1a,&_temp895_pw_gz1mps1a) : &pw_gz1mps1a,_pw_gz1mps1d.fixedflag ? (_temp896_pw_gz1mps1d=pw_gz1mps1d,&_temp896_pw_gz1mps1d) : &pw_gz1mps1d,area_pulse,
                     (int)(1000000),MIN_PLATEAU_TIME,ps1loggrd.zrt,ps1_tz_xz) == FAILURE)
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1mps1.");
            return FAILURE;
        }
    }

    /* Z gradient crushers for 180 pulse */
    /* Left crusher. Denoted by the "l" after the "2"  in "gzrf2lmps1" */
    if (amppwgrad(ps_crusher_area, ps1_tz_xz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gzrf2lmps1.fixedflag ? (_temp897_a_gzrf2lmps1=a_gzrf2lmps1,&_temp897_a_gzrf2lmps1) : &a_gzrf2lmps1, _pw_gzrf2lmps1a.fixedflag ? (_temp898_pw_gzrf2lmps1a=pw_gzrf2lmps1a,&_temp898_pw_gzrf2lmps1a) : &pw_gzrf2lmps1a,
                  _pw_gzrf2lmps1.fixedflag ? (_temp899_pw_gzrf2lmps1=pw_gzrf2lmps1,&_temp899_pw_gzrf2lmps1) : &pw_gzrf2lmps1, _pw_gzrf2lmps1d.fixedflag ? (_temp900_pw_gzrf2lmps1d=pw_gzrf2lmps1d,&_temp900_pw_gzrf2lmps1d) : &pw_gzrf2lmps1d) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzrf2lmps1"); 
        return FAILURE;
    }
  
    /* Right crusher. Denoted by the "r" after the "2" in "gzrf2rmps1"*/
    /* This is identical to left crusher */
    pw_gzrf2rmps1  = _pw_gzrf2rmps1.fixedflag ?  ((void)(pw_gzrf2lmps1), pw_gzrf2rmps1) : pw_gzrf2lmps1;
    a_gzrf2rmps1  = _a_gzrf2rmps1.fixedflag ?   ((void)(a_gzrf2lmps1), a_gzrf2rmps1) : a_gzrf2lmps1;

    /* right crusher ramps */
    pw_gzrf2rmps1a  = _pw_gzrf2rmps1a.fixedflag ?  ((void)(pw_gzrf2lmps1a), pw_gzrf2rmps1a) : pw_gzrf2lmps1a;
    pw_gzrf2rmps1d  = _pw_gzrf2rmps1d.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2rmps1d) : pw_gzrf2lmps1d;

    /* Z slice select for 180 pulse */
    pw_gzrf2mps1  = _pw_gzrf2mps1.fixedflag ?  ((void)(pw_rf2mps1), pw_gzrf2mps1) : pw_rf2mps1;
    bw_rf2mps1 = (LONG)(rfpulse[RF2_APS1_SLOT].nom_bw*rfpulse[RF2_APS1_SLOT].nom_pw/(float)pw_rf2mps1);

    /* begin aps1_mod changes (GE) */
    if (FAILURE==ampslice(_a_gzrf2mps1.fixedflag ? (_temp901_a_gzrf2mps1=a_gzrf2mps1,&_temp901_a_gzrf2mps1) : &a_gzrf2mps1, bw_rf2mps1, thickPS_mod, gscale_rf2mps1, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2mps1.");
        return FAILURE;
    }
    /* end aps1_mod changes (GE) */

    /* match ramps so gradient can be bridged in pulsegen */
    pw_gzrf2mps1a  = _pw_gzrf2mps1a.fixedflag ?  ((void)(pw_gzrf2lmps1d), pw_gzrf2mps1a) : pw_gzrf2lmps1d;
    pw_gzrf2mps1d  = _pw_gzrf2mps1d.fixedflag ?  ((void)(pw_gzrf2rmps1a), pw_gzrf2mps1d) : pw_gzrf2rmps1a;

    /* readout gradient */
    if (FAILURE==calcfilter( &echo1mps1_filt, 15.625, 256, OVERWRITE_NONE))
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1mps1_filt");
        return FAILURE;
    }

    /* MRIge30642 */
    /* Need check on fov.  Otherwise causes dwnld failures w/0.8 G/cm. */ 
    if (ampfov(&av_temp_float1, echo1mps1_filt.bw, ps1_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    av_temp_float1 = ceil(av_temp_float1/ 10.0) * 10.0;
    if( av_temp_float1 > mpsfov )
    {
        mpsfov  = _mpsfov.fixedflag ?  ((void)(av_temp_float1), mpsfov) : av_temp_float1;
    }

    if (ampfov(_a_gxwmps1.fixedflag ? (_temp902_a_gxwmps1=a_gxwmps1,&_temp902_a_gxwmps1) : &a_gxwmps1, echo1mps1_filt.bw, mpsfov) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwmps1.");
        return FAILURE;
    }

    /* attack and decay ramps */
    if (optramp(_pw_gxwmps1a.fixedflag ? (_temp903_pw_gxwmps1a=pw_gxwmps1a,&_temp903_pw_gxwmps1a) : &pw_gxwmps1a, a_gxwmps1, ps1_tx, ps1_xrt,
                TYPDEF)==FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxwmps1a.");
        return FAILURE;
    }
  
    pw_gxwmps1d  = _pw_gxwmps1d.fixedflag ?  ((void)(pw_gxwmps1a), pw_gxwmps1d) : pw_gxwmps1a;

    pw_gxwmps1  = _pw_gxwmps1.fixedflag ?  ((void)(echo1mps1_filt.tdaq), pw_gxwmps1) : echo1mps1_filt.tdaq;
  
    /* dephaser */
    area_gxwmps1 = a_gxwmps1*(pw_gxwmps1);
    area_readrampmps1 = 0.5*pw_gxwmps1a*a_gxwmps1;

    if (amppwgx1(_a_gx1mps1.fixedflag ? (_temp904_a_gx1mps1=a_gx1mps1,&_temp904_a_gx1mps1) : &a_gx1mps1, _pw_gx1mps1.fixedflag ? (_temp905_pw_gx1mps1=pw_gx1mps1,&_temp905_pw_gx1mps1) : &pw_gx1mps1, _pw_gx1mps1a.fixedflag ? (_temp906_pw_gx1mps1a=pw_gx1mps1a,&_temp906_pw_gx1mps1a) : &pw_gx1mps1a ,_pw_gx1mps1d.fixedflag ? (_temp907_pw_gx1mps1d=pw_gx1mps1d,&_temp907_pw_gx1mps1d) : &pw_gx1mps1d, TYPSPIN,
                 area_gxwmps1, (float)area_readrampmps1, 
                 (int)1000000, 1.0, MIN_PLATEAU_TIME, ps1_xrt, ps1_tx_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1mps1.");
        return FAILURE;
    }

    /* Y gradient is not used in MPS1 */

    return SUCCESS;
}

/*
 *  CFLcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLcveval( FLOAT opthickPS )
{
    LONG bw_rf1cfl;
    FLOAT area_gz1cfl;

    cflloggrd = loggrd; /* same as imaging loggrd */
    /* derate SR for quiet PSC */ 
    sr_derate(&cflloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(2), cfl_dda) : 2;      /* BJM MRIge80347: Changed from 0 -> 2 for MGD, coil switch problem */
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(1), cfl_nex) : 1;
    }
    else
    {
        cfl_dda  = _cfl_dda.fixedflag ?  ((void)(4), cfl_dda) : 4;
        cfl_nex  = _cfl_nex.fixedflag ?  ((void)(2), cfl_nex) : 2;
    }

    if(cffield == B0_2000) 
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(10.41666), echo1bwcfl) : 10.41666;
    } 
    else if(cffield == B0_15000)
    {
        /* MRIhc54366: accommodate B0 drift using larger receive bandwidth 
           with matched spectral resolution */
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(7.8125), echo1bwcfl) : 7.8125;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }
    else
    {
        echo1bwcfl  = _echo1bwcfl.fixedflag ?  ((void)(15.625), echo1bwcfl) : 15.625;         
        CFLxres  = _CFLxres.fixedflag ?  ((void)(1024), CFLxres) : 1024;
    }

    /* MRIhc54366: changed hard coded number of output points to CFLxres */
    if ( FAILURE==calcfilter( &echo1cfl, echo1bwcfl, CFLxres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfl_filt");
        return FAILURE;
    }

    /* MRIhc54366: dynamic CFL excitation pulse selection: */
    if(floatsAlmostEqualEpsilons(cyc_rf1cfl, 2.0, 2)) 
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC2;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC2;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC2;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC2;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC2;
        rfpulse[RF1_CFL_SLOT].max_b1 = SAR_MAXB1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = SAR_MAX_INT_B1_SQ_SINC2_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = SAR_MAX_RMS_B1_SINC2_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 2500;
    }
    else
    {
        rfpulse[RF1_CFL_SLOT].abswidth = SAR_ABS_SINC1;
        rfpulse[RF1_CFL_SLOT].effwidth = SAR_PSINC1;
        rfpulse[RF1_CFL_SLOT].area = SAR_ASINC1;
        rfpulse[RF1_CFL_SLOT].dtycyc = SAR_DTYCYC_SINC1;
        rfpulse[RF1_CFL_SLOT].maxpw = SAR_MAXPW_SINC1;
        rfpulse[RF1_CFL_SLOT].max_b1 = MAX_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_int_b1_sq = MAX_INT_B1_SQ_SINC1_90;
        rfpulse[RF1_CFL_SLOT].max_rms_b1 = MAX_RMS_B1_SINC1_90;
        rfpulse[RF1_CFL_SLOT].nom_bw = 1250;
    }
    /* MRIhc54366: END pulse selection. */

    /* CFL acq duration needed for attenuator setting */
    cfl_tdaq = echo1cfl.tdaq;

    pw_gzrf1cfl  = _pw_gzrf1cfl.fixedflag ?  ((void)(pw_rf1cfl), pw_gzrf1cfl) : pw_rf1cfl;
    bw_rf1cfl = (LONG)(rfpulse[RF1_CFL_SLOT].nom_bw*rfpulse[RF1_CFL_SLOT].nom_pw/(float)pw_rf1cfl);

    /* MRIhc54366: new lower limit */
    opthickPS = (exist(opslthick) < 5.0) ? 5.0 : exist(opslthick);

    if ( FAILURE==ampslice(_a_gzrf1cfl.fixedflag ? (_temp908_a_gzrf1cfl=a_gzrf1cfl,&_temp908_a_gzrf1cfl) : &a_gzrf1cfl, bw_rf1cfl, opthickPS, gscale_rf1cfl, TYPDEF) ) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    if ( FAILURE==optramp(_pw_gzrf1cfla.fixedflag ? (_temp909_pw_gzrf1cfla=pw_gzrf1cfla,&_temp909_pw_gzrf1cfla) : &pw_gzrf1cfla, a_gzrf1cfl, cflloggrd.tz, cflloggrd.zrt, TYPDEF) )  
    {
        epic_error(use_ermes, "%s failed for gzrf1cfl.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfld  = _pw_gzrf1cfld.fixedflag ?  ((void)(pw_gzrf1cfla), pw_gzrf1cfld) : pw_gzrf1cfla;

    /* Find Params for refocusing pulse */
    area_gz1cfl =  a_gzrf1cfl *0.5* ( pw_gzrf1cfl + pw_gzrf1cfld);
    if ( FAILURE==amppwgz1(_a_gz1cfl.fixedflag ? (_temp910_a_gz1cfl=a_gz1cfl,&_temp910_a_gz1cfl) : &a_gz1cfl, _pw_gz1cfl.fixedflag ? (_temp911_pw_gz1cfl=pw_gz1cfl,&_temp911_pw_gz1cfl) : &pw_gz1cfl, _pw_gz1cfla.fixedflag ? (_temp912_pw_gz1cfla=pw_gz1cfla,&_temp912_pw_gz1cfla) : &pw_gz1cfla, _pw_gz1cfld.fixedflag ? (_temp913_pw_gz1cfld=pw_gz1cfld,&_temp913_pw_gz1cfld) : &pw_gz1cfld, 
                           area_gz1cfl, (INT)1000000, MIN_PLATEAU_TIME,
                           cflloggrd.zrt, cflloggrd.tz) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1cfl");
        return FAILURE;
    }

    /* Find Params for killer pulse */
    area_gykcfl  = _area_gykcfl.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfl) : amp_killer*pw_killer;
    if ( FAILURE==amppwgrad(area_gykcfl, cflloggrd.ty, 0.0, 0.0, cflloggrd.yrt,
                            MIN_PLATEAU_TIME, _a_gykcfl.fixedflag ? (_temp914_a_gykcfl=a_gykcfl,&_temp914_a_gykcfl) : &a_gykcfl, _pw_gykcfla.fixedflag ? (_temp915_pw_gykcfla=pw_gykcfla,&_temp915_pw_gykcfla) : &pw_gykcfla,
                            _pw_gykcfl.fixedflag ? (_temp916_pw_gykcfl=pw_gykcfl,&_temp916_pw_gykcfl) : &pw_gykcfl, _pw_gykcfld.fixedflag ? (_temp917_pw_gykcfld=pw_gykcfld,&_temp917_pw_gykcfld) : &pw_gykcfld) ) 
    {
        epic_error(use_ermes, "%s failed in cfl.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfl");
        return FAILURE;
    }

    return SUCCESS;
}


/*
 *  RCVNcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNcveval( void )
{
    int rcvn_newgeo = 1;
    int roti;
    INT tot_gradtime = 0;
    INT tot_gradtime2 = 0;

    rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;

    for(  roti = 0; roti < 9; roti++ )
    {
        rcvnscan_info[0].oprot[roti] = 0.0;
    }
    /* for gradient prognostic, play out gradient on physical axes */
    rcvnscan_info[0].oprot[0]=rcvnscan_info[0].oprot[4]=rcvnscan_info[0].oprot[8]=1.0;

    if (FAILURE==obloptimize(&rcvnloggrd, &phygrd, rcvnscan_info, 1, PSD_OBL,
                             0, PSD_OBL_RESTRICT, ps1obl_debug, &rcvn_newgeo,
                             cfsrmode))
    {
        epic_error(use_ermes, "%s failed in RCVNcveval.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "obloptimize"); 
        return FAILURE;
    }

    if(mkgspec_flag == MK_SPEC_MODE_GRAD_3AXES)
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(1), rcvn_flag) : 1;  /* disable gradient prognostic and using Imaging plane */
        for (roti = 0; roti < 9; roti++)
        {
            rcvnscan_info[0].oprot[roti] = scan_info[PSslice_num].oprot[roti]; /* use Rxed slice rot */
        }
        rcvnloggrd = loggrd;
    }
    /* for grad prognostic test only for non-derated case */
    else if((PSsr_derate_factor < 2.0) && (PSamp_derate_factor < 2.0) && !(isSVSystem()))
    {
        rcvn_flag  = _rcvn_flag.fixedflag ?  ((void)(3), rcvn_flag) : 3;  /* new waveform for grad prognostic, using Axial plane */
    }

    /* derate SR for quiet PSC */ 
    sr_derate(&rcvnloggrd, PSsr_derate_factor, PSamp_derate_factor);

    /* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient before Receiver noise sequence */

    if ( FAILURE==amppwgrad( area_gxkrcvn, rcvnloggrd.tx_xyz, 0.0, 0.0, rcvnloggrd.xrt,
                             MIN_PLATEAU_TIME, _a_gxkrcvn.fixedflag ? (_temp918_a_gxkrcvn=a_gxkrcvn,&_temp918_a_gxkrcvn) : &a_gxkrcvn, _pw_gxkrcvna.fixedflag ? (_temp919_pw_gxkrcvna=pw_gxkrcvna,&_temp919_pw_gxkrcvna) : &pw_gxkrcvna,
                             _pw_gxkrcvn.fixedflag ? (_temp920_pw_gxkrcvn=pw_gxkrcvn,&_temp920_pw_gxkrcvn) : &pw_gxkrcvn, _pw_gxkrcvnd.fixedflag ? (_temp921_pw_gxkrcvnd=pw_gxkrcvnd,&_temp921_pw_gxkrcvnd) : &pw_gxkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gxkrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gykrcvn, rcvnloggrd.ty_xyz, 0.0, 0.0, rcvnloggrd.yrt,
                             MIN_PLATEAU_TIME, _a_gykrcvn.fixedflag ? (_temp922_a_gykrcvn=a_gykrcvn,&_temp922_a_gykrcvn) : &a_gykrcvn, _pw_gykrcvna.fixedflag ? (_temp923_pw_gykrcvna=pw_gykrcvna,&_temp923_pw_gykrcvna) : &pw_gykrcvna,
                             _pw_gykrcvn.fixedflag ? (_temp924_pw_gykrcvn=pw_gykrcvn,&_temp924_pw_gykrcvn) : &pw_gykrcvn, _pw_gykrcvnd.fixedflag ? (_temp925_pw_gykrcvnd=pw_gykrcvnd,&_temp925_pw_gykrcvnd) : &pw_gykrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykrcvn");
        return FAILURE;
    }

    if ( FAILURE==amppwgrad( area_gzkrcvn, rcvnloggrd.tz_xyz, 0.0, 0.0, rcvnloggrd.zrt,
                             MIN_PLATEAU_TIME, _a_gzkrcvn.fixedflag ? (_temp926_a_gzkrcvn=a_gzkrcvn,&_temp926_a_gzkrcvn) : &a_gzkrcvn, _pw_gzkrcvna.fixedflag ? (_temp927_pw_gzkrcvna=pw_gzkrcvna,&_temp927_pw_gzkrcvna) : &pw_gzkrcvna,
                             _pw_gzkrcvn.fixedflag ? (_temp928_pw_gzkrcvn=pw_gzkrcvn,&_temp928_pw_gzkrcvn) : &pw_gzkrcvn, _pw_gzkrcvnd.fixedflag ? (_temp929_pw_gzkrcvnd=pw_gzkrcvnd,&_temp929_pw_gzkrcvnd) : &pw_gzkrcvnd ) )
    {
        epic_error(use_ermes, "Support routine %s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gzkrcvn");
        return FAILURE;
    }

    if( 3 == rcvn_flag )
    {
        /* X Grad -- +12 ms, -4ms */
        pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gxkrcvna)), pw_gxkrcvn) : RUP_GRD(12000-2*pw_gxkrcvna);
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(-a_gxkrcvn), a_gxk2rcvn) : -a_gxkrcvn;
        pw_gxk2rcvna  = _pw_gxk2rcvna.fixedflag ?  ((void)(pw_gxkrcvna), pw_gxk2rcvna) : pw_gxkrcvna;
        pw_gxk2rcvnd  = _pw_gxk2rcvnd.fixedflag ?  ((void)(pw_gxk2rcvna), pw_gxk2rcvnd) : pw_gxk2rcvna;
        pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gxk2rcvna)), pw_gxk2rcvn) : RUP_GRD(4000-2*pw_gxk2rcvna);
        if(pw_gxkrcvn <= 0)
        {
            pw_gxkrcvn  = _pw_gxkrcvn.fixedflag ?  ((void)(4), pw_gxkrcvn) : 4;
        }
        if(pw_gxk2rcvn <= 0)
        {
            pw_gxk2rcvn  = _pw_gxk2rcvn.fixedflag ?  ((void)(4), pw_gxk2rcvn) : 4;
        }

        /* Y Grad -- +8 ms, -12ms  */
        pw_gykrcvn  = _pw_gykrcvn.fixedflag ?    ((void)(RUP_GRD(8000-2*pw_gykrcvna)), pw_gykrcvn) : RUP_GRD(8000-2*pw_gykrcvna);
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(-a_gykrcvn), a_gyk2rcvn) : -a_gykrcvn;
        pw_gyk2rcvna  = _pw_gyk2rcvna.fixedflag ?  ((void)(pw_gykrcvna), pw_gyk2rcvna) : pw_gykrcvna;
        pw_gyk2rcvnd  = _pw_gyk2rcvnd.fixedflag ?  ((void)(pw_gyk2rcvna), pw_gyk2rcvnd) : pw_gyk2rcvna;
        pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gyk2rcvna)), pw_gyk2rcvn) : RUP_GRD(12000-2*pw_gyk2rcvna);
        if(pw_gykrcvn <= 0)
        {
            pw_gykrcvn  = _pw_gykrcvn.fixedflag ?  ((void)(4), pw_gykrcvn) : 4;
        }
        if(pw_gyk2rcvn <= 0)
        {
            pw_gyk2rcvn  = _pw_gyk2rcvn.fixedflag ?  ((void)(4), pw_gyk2rcvn) : 4;
        }

        /* Z Grad -- +4 ms, -12ms */
        pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?    ((void)(RUP_GRD(4000-2*pw_gzkrcvna)), pw_gzkrcvn) : RUP_GRD(4000-2*pw_gzkrcvna);
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(-a_gzkrcvn), a_gzk2rcvn) : -a_gzkrcvn;
        pw_gzk2rcvna  = _pw_gzk2rcvna.fixedflag ?  ((void)(pw_gzkrcvna), pw_gzk2rcvna) : pw_gzkrcvna;
        pw_gzk2rcvnd  = _pw_gzk2rcvnd.fixedflag ?  ((void)(pw_gzk2rcvna), pw_gzk2rcvnd) : pw_gzk2rcvna;
        pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?    ((void)(RUP_GRD(12000-2*pw_gzk2rcvna)), pw_gzk2rcvn) : RUP_GRD(12000-2*pw_gzk2rcvna);
        if(pw_gzkrcvn <= 0)
        {
            pw_gzkrcvn  = _pw_gzkrcvn.fixedflag ?  ((void)(4), pw_gzkrcvn) : 4;
        }
        if(pw_gzk2rcvn <= 0)
        {
            pw_gzk2rcvn  = _pw_gzk2rcvn.fixedflag ?  ((void)(4), pw_gzk2rcvn) : 4;
        }

        tot_gradtime2 = IMax(3, pw_gxk2rcvna+pw_gxk2rcvn+pw_gxk2rcvnd, 
                             pw_gyk2rcvna+pw_gyk2rcvn+pw_gyk2rcvnd, pw_gzk2rcvna+pw_gzk2rcvn+pw_gzk2rcvnd);
    }
    else
    {
        a_gxk2rcvn  = _a_gxk2rcvn.fixedflag ?  ((void)(0.0), a_gxk2rcvn) : 0.0;
        a_gyk2rcvn  = _a_gyk2rcvn.fixedflag ?  ((void)(0.0), a_gyk2rcvn) : 0.0;
        a_gzk2rcvn  = _a_gzk2rcvn.fixedflag ?  ((void)(0.0), a_gzk2rcvn) : 0.0;
        tot_gradtime2 = 0;
    }

    tot_gradtime = pw_gykrcvna+pw_gykrcvn+pw_gykrcvnd+tot_gradtime2;

    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?    ((void)(IMax(2,20000,RUP_GRD(tot_gradtime+1000))), pre_rcvn_tr) : IMax(2,20000,RUP_GRD(tot_gradtime+1000));
    }
    else if(rcvn_flag == 2)  /* extra wait before rcvn */
    {
        pre_rcvn_tr  = _pre_rcvn_tr.fixedflag ?  ((void)(1000000), pre_rcvn_tr) : 1000000;
    }

    if (existcv(oprbw))
    {
        echo1bwrcvn  = _echo1bwrcvn.fixedflag ?  ((void)(exist(oprbw)), echo1bwrcvn) : exist(oprbw);
    }

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW)), echo1bwrcvn) : FMax(2,echo1bwrcvn,(float)RCVN_MIN_BW);

    echo1bwrcvn  = _echo1bwrcvn.fixedflag ?     ((void)(FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW)), echo1bwrcvn) : FMin(2,echo1bwrcvn,(float)RCVN_MAX_BW);

    if ( FAILURE==calcfilter( &echo1rcvn, echo1bwrcvn, rcvn_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rcvn");
        return FAILURE;
    }

    /* RCVN acq duration needed for attenuator setting */
    rcvn_tdaq = echo1rcvn.tdaq;

    /* Add 20ms dead time to prevent runtime errors */
    rcvn_tr  = _rcvn_tr.fixedflag ?       ((void)(IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR)), rcvn_tr) : IMax(2,rcvn_tdaq+20000,(int)RCVN_MIN_TR);

    /* To make sure RCVN loops enough to acquire 4K points */
    rcvn_loops  = _rcvn_loops.fixedflag ?       ((void)(IMax(2,2*(int)(4096/rcvn_xres),1)), rcvn_loops) : IMax(2,2*(int)(4096/rcvn_xres),1);

    return SUCCESS;
}

/*
 *  AScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AScveval( void )
{
    /* DV26: Baseline used for Autoshim noise level thresholding */
    asbaseline  = _asbaseline.fixedflag ?  ((void)(8), asbaseline) : 8;
    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) ||
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(0), as_dda) : 0;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(62.5), echo1bwas) : 62.5;
        asxres  = _asxres.fixedflag ?  ((void)(128), asxres) : 128;
        asyres  = _asyres.fixedflag ?   ((void)(64), asyres) : 64;
        /* asres=128 and asyres=64 for all T fields */
    }
    else
    {
        as_dda  = _as_dda.fixedflag ?  ((void)(4), as_dda) : 4;
        echo1bwas  = _echo1bwas.fixedflag ?  ((void)(15.625), echo1bwas) : 15.625;
        asxres  = _asxres.fixedflag ?  ((void)(256), asxres) : 256;
        asyres  = _asyres.fixedflag ?  ((void)(128), asyres) : 128;
        te_as  = _te_as.fixedflag ?  ((void)(9000), te_as) : 9000;
        if (cffield == B0_15000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
        }
        else if (cffield == B0_10000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(30000), tr_as) : 30000;
        }
        else if (cffield == B0_2000) /* profile 05/22/95 NM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000; /* Profile 09/29/95 NM */
        }
        else if (cffield == B0_3500) /* MFO,Hino, Feb/02/00 MM */
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(40000), tr_as) : 40000;
        }
        else if (cffield == B0_5000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(35000), tr_as) : 35000;
        }
        else if (cffield == B0_40000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_4_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_30000)
        {
            /* REDFLAG : Using same value as 1.5T. */
            tr_as  = _tr_as.fixedflag ?  ((void)(25000), tr_as) : 25000;
            DEBUG_3_0(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else if (cffield == B0_7000)
        {
            tr_as  = _tr_as.fixedflag ?  ((void)(32000), tr_as) : 32000;
            DEBUG_0_7(SD_PSD_SUPPORT,__FILE__,__LINE__);
        }
        else 
        {
            SDL_PrintFStrengthWarning(SD_PSD_SUPPORT,cffield,__FILE__,__LINE__);
        }
    }

    /* MRIge21914 - moved deltf to @cv */

    /* Call the SDL function to compute fat-water separation. */
    deltf  = _deltf.fixedflag ?    ((void)(SDL_GetChemicalShift(cffield)), deltf) : SDL_GetChemicalShift(cffield);
    /* In phase delta TE will be used in MFO. Hino, Feb/02/00 MM */

    /* dixon time shift.  put it on grad boundary. */
    dix_timeas  = _dix_timeas.fixedflag ?   ((void)(RUP_GRD((int)(1000000/deltf))), dix_timeas) : RUP_GRD((int)(1000000/deltf));
    pw_sdixon2  = _pw_sdixon2.fixedflag ?    ((void)(GRAD_UPDATE_TIME+dix_timeas), pw_sdixon2) : GRAD_UPDATE_TIME+dix_timeas;

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    if (FAILURE==ampslice(_a_gzrf1as.fixedflag ? (_temp930_a_gzrf1as=a_gzrf1as,&_temp930_a_gzrf1as) : &a_gzrf1as, bw_rf1as, asslthick, gscale_rf1as, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1as.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1asa.fixedflag ? (_temp931_pw_gzrf1asa=pw_gzrf1asa,&_temp931_pw_gzrf1asa) : &pw_gzrf1asa, a_gzrf1as, asloggrd.tz_xyz, asloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1asa.");
        return FAILURE;
    }
    pw_gzrf1asd  = _pw_gzrf1asd.fixedflag ?  ((void)(pw_gzrf1asa), pw_gzrf1asd) : pw_gzrf1asa;

    /******************************************/
    /*   Calc area needed for z rephaser      */
    /******************************************/
    area_gz1as  = _area_gz1as.fixedflag ?     ((void)((off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as), area_gz1as) : (off90as+pw_rf1as/2.0+pw_gzrf1asd/2.0)*a_gzrf1as;

    /* availible time for rephaser */
    avail_pwgz1as  = _avail_pwgz1as.fixedflag ?  ((void)(1000000), avail_pwgz1as) : 1000000;

    if ( FAILURE==amppwgz1(_a_gz1as.fixedflag ? (_temp932_a_gz1as=a_gz1as,&_temp932_a_gz1as) : &a_gz1as, _pw_gz1as.fixedflag ? (_temp933_pw_gz1as=pw_gz1as,&_temp933_pw_gz1as) : &pw_gz1as, _pw_gz1asa.fixedflag ? (_temp934_pw_gz1asa=pw_gz1asa,&_temp934_pw_gz1asa) : &pw_gz1asa, _pw_gz1asd.fixedflag ? (_temp935_pw_gz1asd=pw_gz1asd,&_temp935_pw_gz1asd) : &pw_gz1asd,
                           area_gz1as, avail_pwgz1as, MIN_PLATEAU_TIME,
                           asloggrd.zrt, asloggrd.tz_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1as.");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1as_filt, echo1bwas, asxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1as_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(_a_gxwas.fixedflag ? (_temp936_a_gxwas=a_gxwas,&_temp936_a_gxwas) : &a_gxwas, echo1as_filt.bw, asfov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwas.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwasa.fixedflag ? (_temp937_pw_gxwasa=pw_gxwasa,&_temp937_pw_gxwasa) : &pw_gxwasa, a_gxwas, asloggrd.tx_xyz, asloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwasa.");
        return FAILURE;
    }

    pw_gxwasd  = _pw_gxwasd.fixedflag ?  ((void)(pw_gxwasa), pw_gxwasd) : pw_gxwasa;
    pw_gxwas  = _pw_gxwas.fixedflag ?  ((void)(echo1as_filt.tdaq), pw_gxwas) : echo1as_filt.tdaq;

    avail_pwgx1as  = _avail_pwgx1as.fixedflag ?  ((void)(1000000), avail_pwgx1as) : 1000000;

    area_readrampas  = _area_readrampas.fixedflag ?  ((void)(0.5*pw_gxwasa*a_gxwas), area_readrampas) : 0.5*pw_gxwasa*a_gxwas;
    area_gxwas  = _area_gxwas.fixedflag ?  ((void)(pw_gxwas*a_gxwas), area_gxwas) : pw_gxwas*a_gxwas;

    if ( FAILURE==amppwgx1(_a_gx1as.fixedflag ? (_temp938_a_gx1as=a_gx1as,&_temp938_a_gx1as) : &a_gx1as, _pw_gx1as.fixedflag ? (_temp939_pw_gx1as=pw_gx1as,&_temp939_pw_gx1as) : &pw_gx1as, _pw_gx1asa.fixedflag ? (_temp940_pw_gx1asa=pw_gx1asa,&_temp940_pw_gx1asa) : &pw_gx1asa, _pw_gx1asd.fixedflag ? (_temp941_pw_gx1asd=pw_gx1asd,&_temp941_pw_gx1asd) : &pw_gx1asd,
                           (int)TYPGRAD, area_gxwas, area_readrampas,
                           avail_pwgx1as, 1.0, MIN_PLATEAU_TIME,
                           asloggrd.xrt, asloggrd.tx_xyz) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1as.");
        return FAILURE;
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(asyres), _endview_iampas.fixedflag ? (_temp942_endview_iampas=endview_iampas,&_temp942_endview_iampas) : &endview_iampas) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:autoshim");
        return FAILURE;
    } 
  
    endview_scaleas  = _endview_scaleas.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampas), endview_scaleas) : (float)max_pg_iamp/(float)endview_iampas;

    if ( FAILURE==amppwtpe(_a_gy1asa.fixedflag ? (_temp943_a_gy1asa=a_gy1asa,&_temp943_a_gy1asa) : &a_gy1asa, _a_gy1asb.fixedflag ? (_temp944_a_gy1asb=a_gy1asb,&_temp944_a_gy1asb) : &a_gy1asb, _pw_gy1as.fixedflag ? (_temp945_pw_gy1as=pw_gy1as,&_temp945_pw_gy1as) : &pw_gy1as, _pw_gy1asa.fixedflag ? (_temp946_pw_gy1asa=pw_gy1asa,&_temp946_pw_gy1asa) : &pw_gy1asa, _pw_gy1asd.fixedflag ? (_temp947_pw_gy1asd=pw_gy1asd,&_temp947_pw_gy1asd) : &pw_gy1asd,
                           asloggrd.ty_xyz/endview_scaleas,asloggrd.yrt,
                           (0.5 * (FLOAT)(asyres-1))/(asfov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:autoshim");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1ras  = _a_gy1ras.fixedflag ?  ((void)(a_gy1as), a_gy1ras) : a_gy1as;
    a_gy1rasa  = _a_gy1rasa.fixedflag ?  ((void)(a_gy1asa), a_gy1rasa) : a_gy1asa;
    a_gy1rasb  = _a_gy1rasb.fixedflag ?  ((void)(a_gy1asb), a_gy1rasb) : a_gy1asb;
    pw_gy1ras  = _pw_gy1ras.fixedflag ?  ((void)(pw_gy1as), pw_gy1ras) : pw_gy1as;
    pw_gy1rasa  = _pw_gy1rasa.fixedflag ?  ((void)(pw_gy1asa), pw_gy1rasa) : pw_gy1asa;
    pw_gy1rasd  = _pw_gy1rasd.fixedflag ?  ((void)(pw_gy1asd), pw_gy1rasd) : pw_gy1asd;

    if(1==fastprescan) 
    {

        te_as  = _te_as.fixedflag ?           
                                  
                               ((void)(RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2)), te_as) : RUP_GRD(pw_rf1as/2+off90as+pw_gzrf1asd+pw_gz1asa+pw_gz1as+pw_gz1asd+pw_gy1asa+pw_gy1as+pw_gy1asd+pw_gx1asa+pw_gx1as+pw_gx1asd+pw_gxwasa+pw_gxwas/2);

        tr_as  = _tr_as.fixedflag ?           
                                  
                             ((void)(RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000)), tr_as) : RUP_GRD(te_as+dix_timeas+pw_gzrf1as/2+pw_gzrf1asa+td0as+tleadas-rfupa+pw_gxwas/2+pw_gxwasd+pw_gzkasa+pw_gzkas+pw_gzkasd+1000);
    }

    return SUCCESS;
}   /* end AScveval() */


/*
 *  CFHfilter
 *  
 *  Type: Private Function
 *  
 *  Description: Separate function for CFH for inclusion in 
 *               in Spectroscopy volume localized CFH
 *  
 */
STATUS
CFHfilter( int xres )
{
    CFHxres  = _CFHxres.fixedflag ?  ((void)(xres), CFHxres) : xres;

    if(cffield <= B0_5000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.25), echo1bwcfh) : 0.25;
    }
    else if (cffield >= B0_30000) 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(1.0), echo1bwcfh) : 1.0;
    }
    else 
    {
        echo1bwcfh  = _echo1bwcfh.fixedflag ?  ((void)(0.50), echo1bwcfh) : 0.50;
    }

    if ( FAILURE==calcfilter( &echo1cfh, echo1bwcfh, CFHxres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cfh_filt");
        return FAILURE;
    }

    cfh_tdaq = echo1cfh.tdaq;

    return SUCCESS;
}

/*
 *  CFHcveval
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHcveval( FLOAT opthickPS )
{
    LONG bw_rf0cfh;
    LONG bw_rf1cfh;

    GRAD_PULSE psd_cfhrightcrush;
    GRAD_PULSE psd_cfhleftcrush;

    FLOAT area_gz1cfh;
    a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(0.0), a_gyrf3cfh) : 0.0;/*For MRIhc11621 */
    /* For presscfh MRIhc08321 */
    if( presscfh == PRESSCFH_SLICE && PSfield_strength > B0_5000 && 
        cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLICE, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    } 
    else if(presscfh == PRESSCFH_SLAB && PSfield_strength > B0_5000 &&
            cfh_newmode && exist(oppscvquant)>= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SLAB, PSD_FIX_ON, PSD_EXIST_ON);
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.8), presscfh_fov_ratio) : 0.8;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.8), presscfh_pfov_ratio) : 0.8;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.75), presscfh_slab_ratio) : 0.75;
    }
    else if( presscfh == PRESSCFH_SHIMVOL && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(0.5), presscfh_fov_ratio) : 0.5;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(0.5), presscfh_pfov_ratio) : 0.5;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(0.5), presscfh_slab_ratio) : 0.5;
    }
    else if( presscfh == PRESSCFH_SHIMVOL_SLICE && PSfield_strength > B0_5000 &&
             cfh_newmode && exist(oppscvquant) >= 1 ) 
    {
        cvoverride(presscfh_ctrl, PRESSCFH_SHIMVOL_SLICE, PSD_FIX_ON, PSD_EXIST_ON); 
        presscfh_fov_ratio  = _presscfh_fov_ratio.fixedflag ?  ((void)(1.0), presscfh_fov_ratio) : 1.0;
        presscfh_pfov_ratio  = _presscfh_pfov_ratio.fixedflag ?  ((void)(1.0), presscfh_pfov_ratio) : 1.0;
        presscfh_slab_ratio  = _presscfh_slab_ratio.fixedflag ?  ((void)(1.0), presscfh_slab_ratio) : 1.0;
    }
    else
    { 
        cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
    }
    
    if(presscfh_debug) 
    {
        printf("\n CFHcveval : presscfh = %d,presscfh_ctrl = %d,presscfh_override = %d\n",presscfh,presscfh_ctrl,presscfh_override);
        fflush(stdout);
    }

    wg_cfh_rf3  = _wg_cfh_rf3.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD), wg_cfh_rf3) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:XGRAD;
    wg_cfh_rf4  = _wg_cfh_rf4.fixedflag ?            ((void)(((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD), wg_cfh_rf4) : ((presscfh_ctrl!=PRESSCFH_SHIMVOL_SLICE)||(debug_shimvol_slice==0))?ZGRAD:YGRAD;

    /* REDFLAG : Making the same as 1.0T and 1.5T (3T/4T) */
    if ((fastprescan == 1) &&
        ((cffield == B0_10000) || (cffield == B0_15000) || 
         (cffield == B0_30000) || (cffield == B0_40000)))
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(0), cfh_dda) : 0;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(1), cfh_nex) : 1;
    }
    else
    {
        cfh_dda  = _cfh_dda.fixedflag ?  ((void)(4), cfh_dda) : 4;
        cfh_nex  = _cfh_nex.fixedflag ?  ((void)(2), cfh_nex) : 2;
    }

    if(cffield == B0_15000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_1HT), cfh_ti) : CFHTI_1HT;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_1HT), eff_cfh_te) : CFHTE_1HT;
    }
    else if(cffield >= B0_30000) 
    {
        cfh_ti  = _cfh_ti.fixedflag ?  ((void)(CFHTI_3T), cfh_ti) : CFHTI_3T;
        eff_cfh_te  = _eff_cfh_te.fixedflag ?  ((void)(CFHTE_3T), eff_cfh_te) : CFHTE_3T;
    }

    CFHfilter(256);

    /* Initialize some grad structures 
       so we can use the psdsupport routine amppwlcrsh */
    psd_cfhleftcrush.attack = _pw_gzrf2lcfha.fixedflag ? (_temp948_pw_gzrf2lcfha=pw_gzrf2lcfha,&_temp948_pw_gzrf2lcfha) : &pw_gzrf2lcfha;
    psd_cfhleftcrush.decay = _pw_gzrf2lcfhd.fixedflag ? (_temp949_pw_gzrf2lcfhd=pw_gzrf2lcfhd,&_temp949_pw_gzrf2lcfhd) : &pw_gzrf2lcfhd;
    psd_cfhleftcrush.pw = _pw_gzrf2lcfh.fixedflag ? (_temp950_pw_gzrf2lcfh=pw_gzrf2lcfh,&_temp950_pw_gzrf2lcfh) : &pw_gzrf2lcfh;
    psd_cfhleftcrush.amp = _a_gzrf2lcfh.fixedflag ? (_temp951_a_gzrf2lcfh=a_gzrf2lcfh,&_temp951_a_gzrf2lcfh) : &a_gzrf2lcfh;
 
    psd_cfhrightcrush.attack = _pw_gzrf2rcfha.fixedflag ? (_temp952_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp952_pw_gzrf2rcfha) : &pw_gzrf2rcfha;
    psd_cfhrightcrush.decay = _pw_gzrf2rcfhd.fixedflag ? (_temp953_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp953_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd;
    psd_cfhrightcrush.pw = _pw_gzrf2rcfh.fixedflag ? (_temp954_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp954_pw_gzrf2rcfh) : &pw_gzrf2rcfh;
    psd_cfhrightcrush.amp = _a_gzrf2rcfh.fixedflag ? (_temp955_a_gzrf2rcfh=a_gzrf2rcfh,&_temp955_a_gzrf2rcfh) : &a_gzrf2rcfh;

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        psd_cfhrightcrush.attack = _pw_gzrf3rcfha.fixedflag ? (_temp956_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp956_pw_gzrf3rcfha) : &pw_gzrf3rcfha;
        psd_cfhrightcrush.decay = _pw_gzrf3rcfhd.fixedflag ? (_temp957_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp957_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd;
        psd_cfhrightcrush.pw = _pw_gzrf3rcfh.fixedflag ? (_temp958_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp958_pw_gzrf3rcfh) : &pw_gzrf3rcfh;
        psd_cfhrightcrush.amp = _a_gzrf3rcfh.fixedflag ? (_temp959_a_gzrf3rcfh=a_gzrf3rcfh,&_temp959_a_gzrf3rcfh) : &a_gzrf3rcfh;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp960_pw_rf1cfh=pw_rf1cfh,&_temp960_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp961_a_rf1cfh=a_rf1cfh,&_temp961_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp962_flip_rf1cfh=flip_rf1cfh,&_temp962_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp963_res_rf1cfh=res_rf1cfh,&_temp963_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp964_wg_rf1cfh=wg_rf1cfh,&_temp964_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp965_pw_rf2cfh=pw_rf2cfh,&_temp965_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp966_a_rf2cfh=a_rf2cfh,&_temp966_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp967_flip_rf2cfh=flip_rf2cfh,&_temp967_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp968_res_rf2cfh=res_rf2cfh,&_temp968_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp969_wg_rf2cfh=wg_rf2cfh,&_temp969_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp970_pw_rf3cfh=pw_rf3cfh,&_temp970_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp971_a_rf3cfh=a_rf3cfh,&_temp971_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp972_flip_rf3cfh=flip_rf3cfh,&_temp972_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp973_res_rf3cfh=res_rf3cfh,&_temp973_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp974_wg_rf3cfh=wg_rf3cfh,&_temp974_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp975_pw_rf4cfh=pw_rf4cfh,&_temp975_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp976_a_rf4cfh=a_rf4cfh,&_temp976_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC3, SAR_PSINC3,
                     SAR_ASINC3, SAR_DTYCYC_SINC3, SAR_MAXPW_SINC3, 1,
                     MAX_B1_SINC3_90, MAX_INT_B1_SQ_SINC3_90,
                     MAX_RMS_B1_SINC3_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp977_flip_rf4cfh=flip_rf4cfh,&_temp977_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     3750, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp978_res_rf4cfh=res_rf4cfh,&_temp978_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp979_wg_rf4cfh=wg_rf4cfh,&_temp979_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(1), a_rf0cfh) : 1;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5464), a_rf1cfh) : 0.5464;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(0.5464), a_rf2cfh) : 0.5464;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(0.5464), a_rf3cfh) : 0.5464; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(0.5464), a_rf4cfh) : 0.5464; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(60), flip_rf1cfh) : 60;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(60), flip_rf2cfh) : 60;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(60), flip_rf3cfh) : 60; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(60), flip_rf4cfh) : 60; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(3), cyc_rf1cfh) : 3;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(3), cyc_rf2cfh) : 3;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(3), cyc_rf3cfh) : 3; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(3), cyc_rf4cfh) : 3; 
    }
    else
    {
        setuprfpulse(RF1_CFH_SLOT, _pw_rf1cfh.fixedflag ? (_temp980_pw_rf1cfh=pw_rf1cfh,&_temp980_pw_rf1cfh) : &pw_rf1cfh, _a_rf1cfh.fixedflag ? (_temp981_a_rf1cfh=a_rf1cfh,&_temp981_a_rf1cfh) : &a_rf1cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf1cfh.fixedflag ? (_temp982_flip_rf1cfh=flip_rf1cfh,&_temp982_flip_rf1cfh) : &flip_rf1cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf1cfh.fixedflag ? (_temp983_res_rf1cfh=res_rf1cfh,&_temp983_res_rf1cfh) : &res_rf1cfh, 0, _wg_rf1cfh.fixedflag ? (_temp984_wg_rf1cfh=wg_rf1cfh,&_temp984_wg_rf1cfh) : &wg_rf1cfh, 1, rfpulse);

        setuprfpulse(RF2_CFH_SLOT, _pw_rf2cfh.fixedflag ? (_temp985_pw_rf2cfh=pw_rf2cfh,&_temp985_pw_rf2cfh) : &pw_rf2cfh, _a_rf2cfh.fixedflag ? (_temp986_a_rf2cfh=a_rf2cfh,&_temp986_a_rf2cfh) : &a_rf2cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf2cfh.fixedflag ? (_temp987_flip_rf2cfh=flip_rf2cfh,&_temp987_flip_rf2cfh) : &flip_rf2cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf2cfh.fixedflag ? (_temp988_res_rf2cfh=res_rf2cfh,&_temp988_res_rf2cfh) : &res_rf2cfh, 0, _wg_rf2cfh.fixedflag ? (_temp989_wg_rf2cfh=wg_rf2cfh,&_temp989_wg_rf2cfh) : &wg_rf2cfh, 1, rfpulse);

        setuprfpulse(RF3_CFH_SLOT, _pw_rf3cfh.fixedflag ? (_temp990_pw_rf3cfh=pw_rf3cfh,&_temp990_pw_rf3cfh) : &pw_rf3cfh, _a_rf3cfh.fixedflag ? (_temp991_a_rf3cfh=a_rf3cfh,&_temp991_a_rf3cfh) : &a_rf3cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf3cfh.fixedflag ? (_temp992_flip_rf3cfh=flip_rf3cfh,&_temp992_flip_rf3cfh) : &flip_rf3cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf3cfh.fixedflag ? (_temp993_res_rf3cfh=res_rf3cfh,&_temp993_res_rf3cfh) : &res_rf3cfh, 0, _wg_rf3cfh.fixedflag ? (_temp994_wg_rf3cfh=wg_rf3cfh,&_temp994_wg_rf3cfh) : &wg_rf3cfh, 1, rfpulse);

        setuprfpulse(RF4_CFH_SLOT, _pw_rf4cfh.fixedflag ? (_temp995_pw_rf4cfh=pw_rf4cfh,&_temp995_pw_rf4cfh) : &pw_rf4cfh, _a_rf4cfh.fixedflag ? (_temp996_a_rf4cfh=a_rf4cfh,&_temp996_a_rf4cfh) : &a_rf4cfh, SAR_ABS_SINC1, SAR_PSINC1,
                     SAR_ASINC1, SAR_DTYCYC_SINC1, SAR_MAXPW_SINC1, 1,
                     MAX_B1_SINC1_90, MAX_INT_B1_SQ_SINC1_90,
                     MAX_RMS_B1_SINC1_90, 90.0, _flip_rf4cfh.fixedflag ? (_temp997_flip_rf4cfh=flip_rf4cfh,&_temp997_flip_rf4cfh) : &flip_rf4cfh, 3200.0,
                     1250, PSD_CFH_ON, 0,
                     0, 0, _res_rf4cfh.fixedflag ? (_temp998_res_rf4cfh=res_rf4cfh,&_temp998_res_rf4cfh) : &res_rf4cfh, 0, _wg_rf4cfh.fixedflag ? (_temp999_wg_rf4cfh=wg_rf4cfh,&_temp999_wg_rf4cfh) : &wg_rf4cfh, 1, rfpulse);

        a_rf0cfh  = _a_rf0cfh.fixedflag ?  ((void)(0.61), a_rf0cfh) : 0.61;
        a_rf1cfh  = _a_rf1cfh.fixedflag ?  ((void)(0.5), a_rf1cfh) : 0.5;
        a_rf2cfh  = _a_rf2cfh.fixedflag ?  ((void)(1.0), a_rf2cfh) : 1.0;
        a_rf3cfh  = _a_rf3cfh.fixedflag ?  ((void)(1.0), a_rf3cfh) : 1.0; 
        a_rf4cfh  = _a_rf4cfh.fixedflag ?  ((void)(1.0), a_rf4cfh) : 1.0; 

        flip_rf1cfh  = _flip_rf1cfh.fixedflag ?  ((void)(90), flip_rf1cfh) : 90;
        flip_rf2cfh  = _flip_rf2cfh.fixedflag ?  ((void)(180), flip_rf2cfh) : 180;
        flip_rf3cfh  = _flip_rf3cfh.fixedflag ?  ((void)(180), flip_rf3cfh) : 180; 
        flip_rf4cfh  = _flip_rf4cfh.fixedflag ?  ((void)(180), flip_rf4cfh) : 180; 

        cyc_rf1cfh  = _cyc_rf1cfh.fixedflag ?  ((void)(1), cyc_rf1cfh) : 1;
        cyc_rf2cfh  = _cyc_rf2cfh.fixedflag ?  ((void)(1), cyc_rf2cfh) : 1;
        cyc_rf3cfh  = _cyc_rf3cfh.fixedflag ?  ((void)(1), cyc_rf3cfh) : 1; 
        cyc_rf4cfh  = _cyc_rf4cfh.fixedflag ?  ((void)(1), cyc_rf4cfh) : 1; 

    }

    if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB ) 
    {
        /* it is assumed: 
         * (a) cubicle local shim volume 
         */

        FLOAT av;
        FLOAT dxv, dyv, dzv, dxs, dys, dzs, dxs0, dys0, dzs0; 
        FLOAT Dz=0.0;
        FLOAT al2=0.0;
        FLOAT al=0.0;
        FLOAT dxl=0.0;
        FLOAT dyl=0.0;
        FLOAT dzl=0.0;
        FLOAT rs[9], rv[9], rstrv[9];
        INT ii, vidx;
       
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            av = (psc_info[vidx].oppsclenx)/2.0;
            dxv = psc_info[vidx].oppscrloc;
            dyv = psc_info[vidx].oppscphasoff;
            dzv = psc_info[vidx].oppsctloc;

            dxs = scan_info[PSslice_num].oprloc    + scan_info[PSslice_num].oprloc_shift;
            dys = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            dzs = scan_info[PSslice_num].optloc    + scan_info[PSslice_num].optloc_shift;

            for( ii = 0; ii < 9; ii++ )
            {
                rs[ii] = scan_info[PSslice_num].oprot[ii];
                rv[ii] = psc_info[vidx].oppscrot[ii];
            }

            for( ii = 0; ii < 9; ii++ )
            {
                int ir, ic;
                ir = ii/ 3;
                ic = ii % 3;
                rstrv[ii] = rs[3*0+ir]*rv[3*0+ic] 
                    + rs[3*1+ir]*rv[3*1+ic] 
                    + rs[3*2+ir]*rv[3*2+ic]; 
            }

            if( presscfh_debug )
            {
                printf("rot for shim volume %d\n", vidx);
                printf("%8.2f %8.2f %8.2f\n", rv[0], rv[3], rv[6]);
                printf("%8.2f %8.2f %8.2f\n", rv[1], rv[4], rv[7]);
                printf("%8.2f %8.2f %8.2f\n", rv[2], rv[5], rv[8]);
                printf("rot for slice\n");
                printf("%8.2f %8.2f %8.2f\n", rs[0], rs[3], rs[6]);
                printf("%8.2f %8.2f %8.2f\n", rs[1], rs[4], rs[7]);
                printf("%8.2f %8.2f %8.2f\n", rs[2], rs[5], rs[8]);
            }

            dxs0 = rstrv[0]*dxv + rstrv[1]*dyv + rstrv[2]*dzv;
            dys0 = rstrv[3]*dxv + rstrv[4]*dyv + rstrv[5]*dzv;
            dzs0 = rstrv[6]*dxv + rstrv[7]*dyv + rstrv[8]*dzv;

            if( presscfh == PRESSCFH_SLICE ) 
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                if( fabs(dzs0 - dzs) >= av )
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                } else {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }
            } 
            else 
            {   /* presscfh == PRESSCFH_SLAB */
                FLOAT dzss, dzse, dzs0s, dzs0e;
                FLOAT dz1, dz2;
                dzss = scan_info[0].optloc + scan_info[0].optloc_shift;
                dzse = scan_info[opslquant*opvquant-1].optloc + scan_info[opslquant*opvquant-1].optloc_shift;
                dzs0s = dzs0 - av/2;
                dzs0e = dzs0 + av/2;

                /* find dz1 and dz2 */
                if( dzs0e - dzs0s < 0 ) 
                {
                    FLOAT temp;
                    temp = dzs0e;
                    dzs0e = dzs0s;
                    dzs0s = temp;
                }
                if( dzse - dzss < 0 ) 
                {
                    FLOAT temp;
                    temp = dzse;
                    dzse = dzss;
                    dzss = temp;
                }

                dz1 = dzs0s;
                dz2 = dzs0e;

                if( dzss > dz1 ) 
                { 
                    dz1 = dzss;
                }
                if( dzse < dz2 ) 
                {
                    dz2 = dzse;
                }

                if( dzss >= dz2 || dzse <= dz1 ) 
                {
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
                }
                else
                {
                    dzs = dz1 + (dz2-dz1)/2;   
                    presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_slab_ratio*(dz2-dz1)), presscfh_slthick) : presscfh_slab_ratio*(dz2-dz1);
                    if( presscfh_slthick < opthickPS ) 
                    {
                        presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(opthickPS), presscfh_slthick) : opthickPS;
                    }
                    presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(0), presscfh_outrange) : 0;
                }         
            }

            if( presscfh_outrange == 0 ) 
            {
                Dz = dzs0 - dzs;
                al2 = av*av - Dz*Dz;
                if( al2 > 0 ) 
                {
                    al = sqrt(al2);
                } else {
                    al = 0;
                }
            }

            if( al >= presscfh_minfov_ratio*av ) 
            {
                dxl = dxs0;
                dyl = dys0;
                dzl = dzs;

                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_fov_ratio*al*2.0), presscfh_fov) : presscfh_fov_ratio*al*2.0;
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_pfov_ratio*al*2.0), presscfh_pfov) : presscfh_pfov_ratio*al*2.0;

                presscfh_info[vidx].oppsctloc = dzl;
                presscfh_info[vidx].oppscrloc = dxl;
                presscfh_info[vidx].oppscphasoff = dyl;
                for( ii = 0; ii < 9; ii++ ) 
                {
                    presscfh_info[vidx].oppscrot[ii] = scan_info[PSslice_num].oprot[ii]; 
                }
                presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov_ratio*al*2.0);
                presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov_ratio*al*2.0);
                presscfh_info[vidx].oppsclenz = (INT)presscfh_slthick;
            } 
            else 
            {
                presscfh_outrange  = _presscfh_outrange.fixedflag ?  ((void)(1), presscfh_outrange) : 1;
            }

            if( presscfh_debug ) 
            {
                printf("av, dxv, dyv, dzv: %8.2f, %8.2f, %8.2f, %8.2f\n", av, dxv, dyv, dzv);    
                printf("dxs, dys, dzs: %8.2f, %8.2f, %8.2f\n", dxs, dys, dzs);    
                printf("al, dxl, dyl, dzl: %8.2f, %8.2f, %8.2f, %8.2f\n", al, dxl, dyl, dzl);    
                printf("presscfh_slthick: %8.2f\n", presscfh_slthick);    
                printf("outrange: %d\n", presscfh_outrange);    
            }

            if( presscfh_outrange == 1 ) 
            {
                cvoverride(presscfh_ctrl, PRESSCFH_NONE, PSD_FIX_ON, PSD_EXIST_ON); 
                if(presscfh_debug) 
                {
                    printf("\nCFHcveval : THIS TURNS OUT TO BE PRESSCFH_NONE,but was initially %d\n",presscfh);
                    fflush(stdout);
                }
                break;
            }
        }
    } 

    if( (presscfh_ctrl == PRESSCFH_SHIMVOL ) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            presscfh_fov  = _presscfh_fov.fixedflag ?    ((void)(presscfh_fov_ratio*psc_info[vidx].oppsclenx), presscfh_fov) : presscfh_fov_ratio*psc_info[vidx].oppsclenx;
            presscfh_pfov  = _presscfh_pfov.fixedflag ?    ((void)(presscfh_pfov_ratio*psc_info[vidx].oppscleny), presscfh_pfov) : presscfh_pfov_ratio*psc_info[vidx].oppscleny;
            presscfh_slthick  = _presscfh_slthick.fixedflag ?    ((void)(presscfh_slab_ratio*psc_info[vidx].oppsclenz), presscfh_slthick) : presscfh_slab_ratio*psc_info[vidx].oppsclenz;

            presscfh_info[vidx].oppsclenx = (INT)(presscfh_fov);
            presscfh_info[vidx].oppscleny = (INT)(presscfh_pfov);
            presscfh_info[vidx].oppsclenz = (INT)(presscfh_slthick);

            if( presscfh_debug ) 
            {
                printf(": SHIM VOLUME %d presscfh=2; presscfh_fov=%8.2f\n", vidx, presscfh_fov);
                fflush(stdout);
            }
        }
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        INT vidx = 0;
        for( vidx = 0; vidx < exist(oppscvquant); vidx ++ )
        {
            if( presscfh_fov < presscfh_info[vidx].oppsclenx )
            {
                presscfh_fov  = _presscfh_fov.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenx), presscfh_fov) : presscfh_info[vidx].oppsclenx;
            }
            if( presscfh_pfov < presscfh_info[vidx].oppscleny )
            {
                presscfh_pfov  = _presscfh_pfov.fixedflag ?  ((void)(presscfh_info[vidx].oppscleny), presscfh_pfov) : presscfh_info[vidx].oppscleny;
            }
            if( presscfh_slthick < presscfh_info[vidx].oppsclenz )
            {
                presscfh_slthick  = _presscfh_slthick.fixedflag ?  ((void)(presscfh_info[vidx].oppsclenz), presscfh_slthick) : presscfh_info[vidx].oppsclenz;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                if( presscfh_slice < opthickPS )
                {
                    presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;
                }
            }
        }

        presscfh_ir_slthick  = _presscfh_ir_slthick.fixedflag ?  ((void)(presscfh_slthick), presscfh_ir_slthick) : presscfh_slthick;

        rfpulse[RF3_CFH_SLOT].num = 1;
        rfpulse[RF3_CFH_SLOT].activity = PSD_CFH_ON;

        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            presscfh_slice  = _presscfh_slice.fixedflag ?  ((void)(opthickPS), presscfh_slice) : opthickPS;

            rfpulse[RF4_CFH_SLOT].num = 1;
            rfpulse[RF4_CFH_SLOT].activity = PSD_CFH_ON;
        }
        else
        {
            rfpulse[RF4_CFH_SLOT].num = 0; 
            rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
        }
    }
    else
    {
        rfpulse[RF3_CFH_SLOT].num = 0;
        rfpulse[RF3_CFH_SLOT].activity = PSD_PULSE_OFF;

        rfpulse[RF4_CFH_SLOT].num = 0; 
        rfpulse[RF4_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* If inversion recovery image mode, Calcs for the Inversion pulse */
    if (PSD_ON == PSir)
    {
        res_rf0cfh  = _res_rf0cfh.fixedflag ?  ((void)(RES_SH_ADIABATIC), res_rf0cfh) : RES_SH_ADIABATIC;  /* Adiabatic pulse */
        /* MRIge90312 -- use 1.5sec TR for IR cfh */
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(1500000), cfh_tr) : 1500000;
        gscale_rf0cfh  = _gscale_rf0cfh.fixedflag ?  ((void)(0.87), gscale_rf0cfh) : 0.87; /* Changed from .65 to .87 for adiabatic pulse */

        pw_gzrf0cfh    = _pw_gzrf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_gzrf0cfh) : pw_rf0cfh;

        /* Y Killer CVs */ /* YMSmr09211  04/26/2006 YI */
        if(amppwgrad(cfhir_killer_area, cfhloggrd.ty_yz, 0.0, 0.0, cfhloggrd.yrt,
                     MIN_PLATEAU_TIME, _a_gyrf0kcfh.fixedflag ? (_temp1000_a_gyrf0kcfh=a_gyrf0kcfh,&_temp1000_a_gyrf0kcfh) : &a_gyrf0kcfh, _pw_gyrf0kcfha.fixedflag ? (_temp1001_pw_gyrf0kcfha=pw_gyrf0kcfha,&_temp1001_pw_gyrf0kcfha) : &pw_gyrf0kcfha, _pw_gyrf0kcfh.fixedflag ? (_temp1002_pw_gyrf0kcfh=pw_gyrf0kcfh,&_temp1002_pw_gyrf0kcfh) : &pw_gyrf0kcfh, _pw_gyrf0kcfhd.fixedflag ? (_temp1003_pw_gyrf0kcfhd=pw_gyrf0kcfhd,&_temp1003_pw_gyrf0kcfhd) : &pw_gyrf0kcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "amppwgrad:gyrf0kcfh"); 
            return FAILURE;
        }

        rfpulse[RF0_CFH_SLOT].num = 1;
        rfpulse[RF0_CFH_SLOT].activity = PSD_CFH_ON;
        bw_rf0cfh = (LONG)(5.12*cyc_rf0cfh/((FLOAT)pw_rf0cfh/(FLOAT)1000000)); /* adiabatic pulse */
 
        if(ampslice(_a_gzrf0cfh.fixedflag ? (_temp1004_a_gzrf0cfh=a_gzrf0cfh,&_temp1004_a_gzrf0cfh) : &a_gzrf0cfh, bw_rf0cfh, ((presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_ir_slthick),
                    gscale_rf0cfh, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gzrf0cfh.",EM_PSD_SUPPORT_FAILURE, 
                       EE_ARGS(1), STRING_ARG, "ampslice");
            return FAILURE;
        }
        /* Non Selective IR */
        if( (presscfh_ctrl != PRESSCFH_NONE) && presscfh_ir_noselect ) 
        {
            a_gzrf0cfh  = _a_gzrf0cfh.fixedflag ?  ((void)(0), a_gzrf0cfh) : 0;
        }
        /* YMSmr09211  04/26/2006 YI */
        if(optramp(_pw_gzrf0cfha.fixedflag ? (_temp1005_pw_gzrf0cfha=pw_gzrf0cfha,&_temp1005_pw_gzrf0cfha) : &pw_gzrf0cfha,a_gzrf0cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF)==FAILURE) 
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gzrf0cfha.");
            return FAILURE;
        }
        pw_gzrf0cfhd  = _pw_gzrf0cfhd.fixedflag ?  ((void)(pw_gzrf0cfha), pw_gzrf0cfhd) : pw_gzrf0cfha;
    } else {
        cfh_tr  = _cfh_tr.fixedflag ?  ((void)(398000), cfh_tr) : 398000;
        rfpulse[RF0_CFH_SLOT].num = 0;
        rfpulse[RF0_CFH_SLOT].activity = PSD_PULSE_OFF;
    }

    /* Calculations for the 90 pulse */
    pw_gzrf1cfh  = _pw_gzrf1cfh.fixedflag ?  ((void)(pw_rf1cfh), pw_gzrf1cfh) : pw_rf1cfh;
    bw_rf1cfh = (LONG)(rfpulse[RF1_CFH_SLOT].nom_bw*rfpulse[RF1_CFH_SLOT].nom_pw/(float)pw_rf1cfh);
       
    if (ampslice(_a_gzrf1cfh.fixedflag ? (_temp1006_a_gzrf1cfh=a_gzrf1cfh,&_temp1006_a_gzrf1cfh) : &a_gzrf1cfh, bw_rf1cfh, ( (presscfh_ctrl == PRESSCFH_NONE) ? opthickPS : presscfh_slthick),
                 gscale_rf1cfh, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice");
        return FAILURE;
    }

    /* YMSmr09211  04/26/2006 YI */
    if (optramp(_pw_gzrf1cfha.fixedflag ? (_temp1007_pw_gzrf1cfha=pw_gzrf1cfha,&_temp1007_pw_gzrf1cfha) : &pw_gzrf1cfha, a_gzrf1cfh, cfhloggrd.tz, cfhloggrd.zrt, TYPDEF) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed for gzrf1cfh.", 
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "optramp");
        return FAILURE;
    }

    pw_gzrf1cfhd  = _pw_gzrf1cfhd.fixedflag ?  ((void)(pw_gzrf1cfha), pw_gzrf1cfhd) : pw_gzrf1cfha;

    /* Calculations for the 180 pulse */
    /* Have to rely on the PSD to keep these up to date - can't tell from
       here whether or not the PSD is a mempoid. */
    pw_gxrf2cfh  = _pw_gxrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gxrf2cfh) : pw_rf2cfh;
    pw_gyrf2cfh  = _pw_gyrf2cfh.fixedflag ?  ((void)(pw_rf2cfh), pw_gyrf2cfh) : pw_rf2cfh;
    pw_gyrf3cfh  = _pw_gyrf3cfh.fixedflag ?  ((void)(pw_rf3cfh), pw_gyrf3cfh) : pw_rf3cfh; /* for presscfh */
    pw_gzrf4cfh  = _pw_gzrf4cfh.fixedflag ?  ((void)(pw_rf4cfh), pw_gzrf4cfh) : pw_rf4cfh; /* for presscfh-slice */ 

    /* Find amplitudes for the FOV selective traps */
    if (opcoax==1) 
    {
        /* If coaxial through isocenter */
        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,opfov/10.0)), cfh_fov) : FMin(2,40.0,opfov/10.0);
    } else {
        /* Otherwise open it up */
        cfh_fov  = _cfh_fov.fixedflag ?  ((void)(40.0), cfh_fov) : 40.0;
    }

    if(cfh_newmode) 
    {   /*override with new mode*/
        float cfh_new_fov = opspf ? (opphasefov*opfov/10.0) : (opfov/10.0);

        cfh_fov  = _cfh_fov.fixedflag ?    ((void)(FMin(2,40.0,cfh_new_fov)), cfh_fov) : FMin(2,40.0,cfh_new_fov);
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground */
        cfh_fov  = _cfh_fov.fixedflag ?        ((void)((opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov)), cfh_fov) : (opcoax==0)?40.0:FMax(2,(float)FOV_MIN,cfh_fov);
    }

    if( presscfh_ctrl != PRESSCFH_NONE ) 
    {
        /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*presscfh_fov/10.0);
        if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp1008_pw_gxrf2cfha=pw_gxrf2cfha,&_temp1008_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gxrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gxrf2cfh"); 
            return FAILURE;
        }
        pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
        pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
        target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */

        /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
        a_gyrf3cfh  = _a_gyrf3cfh.fixedflag ?  ((void)(4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0)), a_gyrf3cfh) : 4*cyc_rf3cfh/(GAM*(float)pw_rf3cfh/(float)(1000000)*presscfh_pfov/10.0);
        if (optramp(_pw_gyrf3cfha.fixedflag ? (_temp1009_pw_gyrf3cfha=pw_gyrf3cfha,&_temp1009_pw_gyrf3cfha) : &pw_gyrf3cfha, a_gyrf3cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed for gyrf3cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "optramp for gyrf3cfh");
            return FAILURE;
        }
        pw_gyrf3cfha  = _pw_gyrf3cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha)), pw_gyrf3cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf3cfha);
        pw_gyrf3cfhd  = _pw_gyrf3cfhd.fixedflag ?  ((void)(pw_gyrf3cfha), pw_gyrf3cfhd) : pw_gyrf3cfha;
        target_cfh_crusher2  = _target_cfh_crusher2.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher2) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */

        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            /* Z SLICE Selective */
            a_gzrf4cfh  = _a_gzrf4cfh.fixedflag ?  ((void)(4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0)), a_gzrf4cfh) : 4*cyc_rf4cfh/(GAM*(float)pw_rf4cfh/(float)(1000000)*presscfh_slice/10.0);
            if (optramp(_pw_gzrf4cfha.fixedflag ? (_temp1010_pw_gzrf4cfha=pw_gzrf4cfha,&_temp1010_pw_gzrf4cfha) : &pw_gzrf4cfha, a_gzrf4cfh, loggrd.tz, loggrd.zrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gzrf4cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gzrf4cfh");
                return FAILURE;
            }
            pw_gzrf4cfha  = _pw_gzrf4cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha)), pw_gzrf4cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gzrf4cfha);
            pw_gzrf4cfhd  = _pw_gzrf4cfhd.fixedflag ?  ((void)(pw_gzrf4cfha), pw_gzrf4cfhd) : pw_gzrf4cfha;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp1011_a_gzrf2rcfh=a_gzrf2rcfh,&_temp1011_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp1012_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp1012_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp1013_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp1013_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp1014_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp1014_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp1015_a_gzrf3rcfh=a_gzrf3rcfh,&_temp1015_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp1016_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp1016_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp1017_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp1017_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp1018_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp1018_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.",
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }
            pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf3rcfha), pw_gzrf2lcfha) : pw_gzrf3rcfha;
            pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf3rcfhd), pw_gzrf2lcfhd) : pw_gzrf3rcfhd;
        }

        if( cfh_steam_flag != PSD_ON )
        {
            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3rcfh.fixedflag ? (_temp1019_a_gzrf3rcfh=a_gzrf3rcfh,&_temp1019_a_gzrf3rcfh) : &a_gzrf3rcfh, _pw_gzrf3rcfha.fixedflag ? (_temp1020_pw_gzrf3rcfha=pw_gzrf3rcfha,&_temp1020_pw_gzrf3rcfha) : &pw_gzrf3rcfha,
                          _pw_gzrf3rcfh.fixedflag ? (_temp1021_pw_gzrf3rcfh=pw_gzrf3rcfh,&_temp1021_pw_gzrf3rcfh) : &pw_gzrf3rcfh, _pw_gzrf3rcfhd.fixedflag ? (_temp1022_pw_gzrf3rcfhd=pw_gzrf3rcfhd,&_temp1022_pw_gzrf3rcfhd) : &pw_gzrf3rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3rcfh"); 
                return FAILURE;
            }

            /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp1023_a_gzrf3lcfh=a_gzrf3lcfh,&_temp1023_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp1024_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp1024_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp1025_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp1025_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp1026_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp1026_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4rcfh.fixedflag ? (_temp1027_a_gzrf4rcfh=a_gzrf4rcfh,&_temp1027_a_gzrf4rcfh) : &a_gzrf4rcfh, _pw_gzrf4rcfha.fixedflag ? (_temp1028_pw_gzrf4rcfha=pw_gzrf4rcfha,&_temp1028_pw_gzrf4rcfha) : &pw_gzrf4rcfha,
                              _pw_gzrf4rcfh.fixedflag ? (_temp1029_pw_gzrf4rcfh=pw_gzrf4rcfh,&_temp1029_pw_gzrf4rcfh) : &pw_gzrf4rcfh, _pw_gzrf4rcfhd.fixedflag ? (_temp1030_pw_gzrf4rcfhd=pw_gzrf4rcfhd,&_temp1030_pw_gzrf4rcfhd) : &pw_gzrf4rcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                              STRING_ARG, "amppwgrad:gzrf4rcfh"); 
                    return FAILURE;
                }

                /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
                if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                              MIN_PLATEAU_TIME, _a_gzrf4lcfh.fixedflag ? (_temp1031_a_gzrf4lcfh=a_gzrf4lcfh,&_temp1031_a_gzrf4lcfh) : &a_gzrf4lcfh, _pw_gzrf4lcfha.fixedflag ? (_temp1032_pw_gzrf4lcfha=pw_gzrf4lcfha,&_temp1032_pw_gzrf4lcfha) : &pw_gzrf4lcfha,
                              _pw_gzrf4lcfh.fixedflag ? (_temp1033_pw_gzrf4lcfh=pw_gzrf4lcfh,&_temp1033_pw_gzrf4lcfh) : &pw_gzrf4lcfh, _pw_gzrf4lcfhd.fixedflag ? (_temp1034_pw_gzrf4lcfhd=pw_gzrf4lcfhd,&_temp1034_pw_gzrf4lcfhd) : &pw_gzrf4lcfhd) == FAILURE) 
                {
                    epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                               STRING_ARG, "amppwgrad:gzrf4lcfh"); 
                    return FAILURE;
                }
            }
        }
        else
        {
            if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp1035_a_gzrf2rcfh=a_gzrf2rcfh,&_temp1035_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp1036_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp1036_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                          _pw_gzrf2rcfh.fixedflag ? (_temp1037_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp1037_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp1038_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp1038_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf2rcfh"); 
                return FAILURE;
            }

            if (amppwgrad(cfh_crusher_area, target_cfh_crusher2, 0.0, 0.0, cfhloggrd.zrt,
                          MIN_PLATEAU_TIME, _a_gzrf3lcfh.fixedflag ? (_temp1039_a_gzrf3lcfh=a_gzrf3lcfh,&_temp1039_a_gzrf3lcfh) : &a_gzrf3lcfh, _pw_gzrf3lcfha.fixedflag ? (_temp1040_pw_gzrf3lcfha=pw_gzrf3lcfha,&_temp1040_pw_gzrf3lcfha) : &pw_gzrf3lcfha,
                          _pw_gzrf3lcfh.fixedflag ? (_temp1041_pw_gzrf3lcfh=pw_gzrf3lcfh,&_temp1041_pw_gzrf3lcfh) : &pw_gzrf3lcfh, _pw_gzrf3lcfhd.fixedflag ? (_temp1042_pw_gzrf3lcfhd=pw_gzrf3lcfhd,&_temp1042_pw_gzrf3lcfhd) : &pw_gzrf3lcfhd) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed in PScveval.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "amppwgrad:gzrf3lcfh"); 
                return FAILURE;
            }
        }
    } else {
        if (opspf == 0) 
        {
            /* X FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gxrf2cfh  = _a_gxrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gxrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gxrf2cfha.fixedflag ? (_temp1043_pw_gxrf2cfha=pw_gxrf2cfha,&_temp1043_pw_gxrf2cfha) : &pw_gxrf2cfha, a_gxrf2cfh, cfhloggrd.tx, cfhloggrd.xrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gxrf2cfh.", 
                           EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gxrf2cfh");
                return FAILURE;
            }
            pw_gxrf2cfha  = _pw_gxrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha)), pw_gxrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gxrf2cfha);
            pw_gxrf2cfhd  = _pw_gxrf2cfhd.fixedflag ?  ((void)(pw_gxrf2cfha), pw_gxrf2cfhd) : pw_gxrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_xz), target_cfh_crusher) : cfhloggrd.tz_xz; /* YMSmr09211  04/26/2006 YI */
        } 
        else 
        {
            /* Y FOV Selective */ /* YMSmr09211  04/26/2006 YI */
            a_gyrf2cfh  = _a_gyrf2cfh.fixedflag ?  ((void)(4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov)), a_gyrf2cfh) : 4*cyc_rf2cfh/(GAM*(float)pw_rf2cfh/(float)(1000000)*cfh_fov);
            if (optramp(_pw_gyrf2cfha.fixedflag ? (_temp1044_pw_gyrf2cfha=pw_gyrf2cfha,&_temp1044_pw_gyrf2cfha) : &pw_gyrf2cfha, a_gyrf2cfh, cfhloggrd.ty, cfhloggrd.yrt, TYPDEF) == FAILURE) 
            {
                epic_error(use_ermes, "%s failed for gyrf2cfh.", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                           STRING_ARG, "optramp for gyrf2cfh");
                return FAILURE;
            }
            pw_gyrf2cfha  = _pw_gyrf2cfha.fixedflag ?   ((void)(IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha)), pw_gyrf2cfha) : IMax(2,(int)(2*GRAD_UPDATE_TIME),pw_gyrf2cfha);
            pw_gyrf2cfhd  = _pw_gyrf2cfhd.fixedflag ?  ((void)(pw_gyrf2cfha), pw_gyrf2cfhd) : pw_gyrf2cfha;
            target_cfh_crusher  = _target_cfh_crusher.fixedflag ?  ((void)(cfhloggrd.tz_yz), target_cfh_crusher) : cfhloggrd.tz_yz; /* YMSmr09211  04/26/2006 YI */
        }

        /* Z CRUSHER CVs */ /* YMSmr09211  04/26/2006 YI */
        if (amppwgrad(cfh_crusher_area, target_cfh_crusher, 0.0, 0.0, cfhloggrd.zrt,
                      MIN_PLATEAU_TIME, _a_gzrf2rcfh.fixedflag ? (_temp1045_a_gzrf2rcfh=a_gzrf2rcfh,&_temp1045_a_gzrf2rcfh) : &a_gzrf2rcfh, _pw_gzrf2rcfha.fixedflag ? (_temp1046_pw_gzrf2rcfha=pw_gzrf2rcfha,&_temp1046_pw_gzrf2rcfha) : &pw_gzrf2rcfha,
                      _pw_gzrf2rcfh.fixedflag ? (_temp1047_pw_gzrf2rcfh=pw_gzrf2rcfh,&_temp1047_pw_gzrf2rcfh) : &pw_gzrf2rcfh, _pw_gzrf2rcfhd.fixedflag ? (_temp1048_pw_gzrf2rcfhd=pw_gzrf2rcfhd,&_temp1048_pw_gzrf2rcfhd) : &pw_gzrf2rcfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gzrf2rcfh"); 
            return FAILURE;
        }

        pw_gzrf2lcfha  = _pw_gzrf2lcfha.fixedflag ?  ((void)(pw_gzrf2rcfha), pw_gzrf2lcfha) : pw_gzrf2rcfha;
        pw_gzrf2lcfhd  = _pw_gzrf2lcfhd.fixedflag ?  ((void)(pw_gzrf2rcfhd), pw_gzrf2lcfhd) : pw_gzrf2rcfhd;
    }

    area_gz1cfh = (PSoff90 + pw_rf1cfh/2.0 + pw_gzrf1cfhd/2.0)*a_gzrf1cfh;
    /* YMSmr09211  04/26/2006 YI */
    if (amppwlcrsh(&psd_cfhleftcrush, &psd_cfhrightcrush,
                   area_gz1cfh, (float)0, cfhloggrd.tz_xz, 
                   MIN_PLATEAU_TIME, cfhloggrd.zrt, _dummy_pw.fixedflag ? (_temp1049_dummy_pw=dummy_pw,&_temp1049_dummy_pw) : &dummy_pw) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwlcrsh for gzrf2lcfh");
        return FAILURE;
    }

    if( presscfh_ctrl != PRESSCFH_NONE && cfh_steam_flag == PSD_ON )
    {
        FLOAT area_g1 = (pw_gxrf2cfh + pw_gxrf2cfha)*a_gxrf2cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.tx, 0.0, 0.0, cfhloggrd.xrt,
                      MIN_PLATEAU_TIME, _a_gx1cfh.fixedflag ? (_temp1050_a_gx1cfh=a_gx1cfh,&_temp1050_a_gx1cfh) : &a_gx1cfh, _pw_gx1cfha.fixedflag ? (_temp1051_pw_gx1cfha=pw_gx1cfha,&_temp1051_pw_gx1cfha) : &pw_gx1cfha,
                      _pw_gx1cfh.fixedflag ? (_temp1052_pw_gx1cfh=pw_gx1cfh,&_temp1052_pw_gx1cfh) : &pw_gx1cfh, _pw_gx1cfhd.fixedflag ? (_temp1053_pw_gx1cfhd=pw_gx1cfhd,&_temp1053_pw_gx1cfhd) : &pw_gx1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gx1cfh"); 
            return FAILURE;
        }

        area_g1 = (pw_gyrf3cfh + pw_gyrf3cfhd)*a_gyrf3cfh/2.0; 
        if (amppwgrad(area_g1, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                      MIN_PLATEAU_TIME, _a_gy1cfh.fixedflag ? (_temp1054_a_gy1cfh=a_gy1cfh,&_temp1054_a_gy1cfh) : &a_gy1cfh, _pw_gy1cfha.fixedflag ? (_temp1055_pw_gy1cfha=pw_gy1cfha,&_temp1055_pw_gy1cfha) : &pw_gy1cfha,
                      _pw_gy1cfh.fixedflag ? (_temp1056_pw_gy1cfh=pw_gy1cfh,&_temp1056_pw_gy1cfh) : &pw_gy1cfh, _pw_gy1cfhd.fixedflag ? (_temp1057_pw_gy1cfhd=pw_gy1cfhd,&_temp1057_pw_gy1cfhd) : &pw_gy1cfhd) == FAILURE) 
        {
            epic_error(use_ermes, "%s failed in PScveval.",
                       EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                       STRING_ARG, "amppwgrad:gy1cfh"); 
            return FAILURE;
        }
    }

    /* Find Params for killer pulse */ /* YMSmr09211  04/26/2006 YI */
    area_gykcfh  = _area_gykcfh.fixedflag ?  ((void)(amp_killer*pw_killer), area_gykcfh) : amp_killer*pw_killer;
    if (amppwgrad(area_gykcfh, cfhloggrd.ty, 0.0, 0.0, cfhloggrd.yrt,
                  MIN_PLATEAU_TIME, _a_gykcfh.fixedflag ? (_temp1058_a_gykcfh=a_gykcfh,&_temp1058_a_gykcfh) : &a_gykcfh, _pw_gykcfha.fixedflag ? (_temp1059_pw_gykcfha=pw_gykcfha,&_temp1059_pw_gykcfha) : &pw_gykcfha,
                  _pw_gykcfh.fixedflag ? (_temp1060_pw_gykcfh=pw_gykcfh,&_temp1060_pw_gykcfh) : &pw_gykcfh, _pw_gykcfhd.fixedflag ? (_temp1061_pw_gykcfhd=pw_gykcfhd,&_temp1061_pw_gykcfhd) : &pw_gykcfhd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in cfh.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykcfh");
        return FAILURE;
    }
    return SUCCESS;
}

/*
 *  PScveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScveval( void )
{
    STATUS ps_status;
    FLOAT opthickPS;
    INT i,j; /* YMSmr09211  04/26/2006 YI */
    INT num_cfhlocs;

    /*********************************************************************
     * Generic SECTION
     *********************************************************************/
   
    /* Set the modes for presscfh */
    set_presscfh_mode();

    /* YMSmr09211  04/26/2006 YI */
    if( ( presscfh_ctrl == PRESSCFH_SHIMVOL ) || ( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE ) )
    {
        num_cfhlocs = exist(oppscvquant);
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = psc_info[i].oppscrot[j];
            }
        }
    }
    else
    {
        num_cfhlocs = IMax(2, 1, exist(oppscvquant));
        for (i=0; i< num_cfhlocs; i++)
        {
            for (j=0; j<9; j++)
            {
                cfh_info[i].oprot[j] = scan_info[PSslice_num].oprot[j];
            }
        }
    }

    cfh_newgeo  = _cfh_newgeo.fixedflag ?  ((void)(1), cfh_newgeo) : 1;
    if (obloptimize(&cfhloggrd, &phygrd, cfh_info, num_cfhlocs,
                    PSD_OBL, 0, obl_method, cfhobl_debug, _cfh_newgeo.fixedflag ? (_temp1062_cfh_newgeo=cfh_newgeo,&_temp1062_cfh_newgeo) : &cfh_newgeo, cfsrmode)==FAILURE)
    {
        epic_error(use_ermes,"%s failed in %s",
                   EM_PSD_FUNCTION_FAILURE,EE_ARGS(2),STRING_ARG,"obloptimize",STRING_ARG,"PScveval()");
        return FAILURE; 

    }

    /* derate SR for quiet PSC */ 
    sr_derate(&cfhloggrd, PSsr_derate_factor, PSamp_derate_factor);

    if (opimode == PSD_3D)  
    {
        opthickPS = 10.0;
    } 
    else 
    {
            opthickPS = (exist(opslthick) < 3.5) ? 3.5 : exist(opslthick);
        }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1cveval( &opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1cveval");
        return ps_status;
    }

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLcveval");
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNcveval( )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNcveval");
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHcveval( opthickPS )) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHcveval");
        return ps_status;
    }

    /***********************************************************************
     * Programmable Prescan SECTION
     ***********************************************************************/

    /* Check for valid Optprescan entry points */
    if(pimrsapsflg) {
        int ipi;
        char strmrs[16] = "pimrsaps1";

        for (ipi = 0; ipi < PSC_MAX_CONTROL_ARRAY; ipi++) 
        {
            switch(*pimrs[ipi]) 
            {
            case MRSAPS_OFF: case MRSAPS_CFL: case MRSAPS_TG:
            case MRSAPS_CFH: case MRSAPS_TR: case MRSAPS_FSEPS:
            case MRSAPS_AWS: case MRSAPS_AVS: case MRSAPS_XTG:
            case MRSAPS_AS: case MRSAPS_FTG: case MRSAPS_RCVN:
            case MRSAPS_XTG_SPINE:
            case MRSAPS_RFSHIM: case MRSAPS_DYNTG:
            case MRSAPS_CAL: case MRSAPS_AUTOCOIL:
                break;
            default:
                sprintf(strmrs, "pimrsaps%d", ipi + 1);
                epic_error(use_ermes, "%s is out of range.",
                           EM_PSD_CV_OUT_OF_RANGE, EE_ARGS(1),
                           STRING_ARG, strmrs);
                return FAILURE;
            }
        }
    } /* end pimrsapsflg check */

    return SUCCESS;
}   /* end PScveval() */


/*
 *  FTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGcveval( void )
{
    LONG bw_rf1ftg;
    LONG bw_rf2ftg;
    LONG bw_rf3ftg;
    FLOAT area_g1ftg;
    FLOAT area_g2ftg;
    FLOAT area_g2bftg;
    FLOAT area_g3ftg;
    FLOAT area_postgxw1ftg;
    FLOAT area_gxw1ftg;
    FLOAT area_gx1ftg;
    FLOAT area_gx2ftg;
    INT PosReadoutWindow;  /* Readout window location            */
    INT ftg_xrt;
    FLOAT ftg_tx;
    FLOAT ftg_tx_xz;
    FLOAT ftg_tz_xz;
    FLOAT ftg_tx_xyz;
    INT FTGtau1check1, FTGtau1check2, FTGtau1check3,
        FTGtau1check4, FTGtau1check5, FTGtau1check6, temp_FTGtau1;

    /* HCSDM00161809: for calculation of minimum FTGtau1 */
    FTGtau1  = _FTGtau1.fixedflag ?    ((void)(8192), FTGtau1) : 8192;
    FTGtau1check1   = FTGtau1;
    FTGtau1check2   = FTGtau1;
    FTGtau1check3   = FTGtau1;
    FTGtau1check4   = FTGtau1;
    FTGtau1check5   = FTGtau1;
    FTGtau1check6   = FTGtau1;
    temp_FTGtau1    = FTGtau1;
    
    ftg_xrt = (TGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    ftg_tx = (TGspf ? ps1loggrd.ty : ps1loggrd.tx);
    ftg_tx_xz = (TGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    ftg_tz_xz = (TGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    ftg_tx_xyz = (TGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);

    FTGfov  = _FTGfov.fixedflag ?  ((void)(cfsystemmaxfov), FTGfov) : cfsystemmaxfov;

    FTGopslthickz1  = _FTGopslthickz1.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz1) : 4*FTGslthk;
    FTGopslthickz2  = _FTGopslthickz2.fixedflag ?  ((void)(4*FTGslthk), FTGopslthickz2) : 4*FTGslthk;
    FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(FTGslthk), FTGopslthickz3) : FTGslthk;
    gscale_rf1ftg   = _gscale_rf1ftg.fixedflag ?  ((void)(0.90909), gscale_rf1ftg) : 0.90909;
    gscale_rf2ftg   = _gscale_rf2ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf2ftg) : gscale_rf1ftg;
    gscale_rf3ftg   = _gscale_rf3ftg.fixedflag ?  ((void)(gscale_rf1ftg), gscale_rf3ftg) : gscale_rf1ftg;
    pw_gzrf1ftg  = _pw_gzrf1ftg.fixedflag ?  ((void)(pw_rf1ftg), pw_gzrf1ftg) : pw_rf1ftg;
    pw_gzrf2ftg  = _pw_gzrf2ftg.fixedflag ?  ((void)(pw_rf2ftg), pw_gzrf2ftg) : pw_rf2ftg;
    pw_gzrf3ftg  = _pw_gzrf3ftg.fixedflag ?  ((void)(pw_rf3ftg), pw_gzrf3ftg) : pw_rf3ftg;

    /* 12/07/94 YI temporary change to avoid internal error with Vectra SGC coil */
    if( cfgradcoil == GCOIL_VECTRA )
    {
        FTGopslthickz3  = _FTGopslthickz3.fixedflag ?  ((void)(7), FTGopslthickz3) : 7;
    }
    
    bw_rf1ftg = (LONG)(4 * cyc_rf1ftg/ ((FLOAT)pw_rf1ftg/ (FLOAT)1000000));

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    if( ampslice(_a_gzrf1ftg.fixedflag ? (_temp1063_a_gzrf1ftg=a_gzrf1ftg,&_temp1063_a_gzrf1ftg) : &a_gzrf1ftg, bw_rf1ftg, FTGopslthickz1, gscale_rf1ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1ftg.");
        return FAILURE;
    }
    
    bw_rf2ftg = (LONG)(4 * cyc_rf2ftg/ ((FLOAT)pw_rf2ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf2ftg.fixedflag ? (_temp1064_a_gzrf2ftg=a_gzrf2ftg,&_temp1064_a_gzrf2ftg) : &a_gzrf2ftg, bw_rf2ftg, FTGopslthickz2, gscale_rf2ftg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2ftg.");
        return FAILURE;
    }
    
 
    bw_rf3ftg = (LONG)(4 * cyc_rf3ftg/ ((FLOAT)pw_rf3ftg/ (FLOAT)1000000));
 
    if( ampslice(_a_gzrf3ftg.fixedflag ? (_temp1065_a_gzrf3ftg=a_gzrf3ftg,&_temp1065_a_gzrf3ftg) : &a_gzrf3ftg, bw_rf3ftg, FTGopslthickz3, gscale_rf3ftg, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf3ftg.");
        return FAILURE;
    }
    if( optramp(_pw_gzrf1ftga.fixedflag ? (_temp1066_pw_gzrf1ftga=pw_gzrf1ftga,&_temp1066_pw_gzrf1ftga) : &pw_gzrf1ftga, a_gzrf1ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1ftga.");
        return FAILURE;
    }    
    
    pw_gzrf1ftgd  = _pw_gzrf1ftgd.fixedflag ?  ((void)(pw_gzrf1ftga), pw_gzrf1ftgd) : pw_gzrf1ftga;

    if (optramp(_pw_gzrf2ftga.fixedflag ? (_temp1067_pw_gzrf2ftga=pw_gzrf2ftga,&_temp1067_pw_gzrf2ftga) : &pw_gzrf2ftga, a_gzrf2ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2ftga.");
        return FAILURE;
    }    
    
    pw_gzrf2ftgd  = _pw_gzrf2ftgd.fixedflag ?  ((void)(pw_gzrf2ftga), pw_gzrf2ftgd) : pw_gzrf2ftga;
 
 
    /* Find Params for first zgrad refocusing pulse */
    area_g1ftg = ( a_gzrf1ftg *.5* ( pw_gzrf1ftg + pw_gzrf1ftgd)
                   + a_gzrf2ftg *.5 * (pw_gzrf2ftga + pw_gzrf2ftg) );
    if( amppwgz1(_a_gz1ftg.fixedflag ? (_temp1068_a_gz1ftg=a_gz1ftg,&_temp1068_a_gz1ftg) : &a_gz1ftg, _pw_gz1ftg.fixedflag ? (_temp1069_pw_gz1ftg=pw_gz1ftg,&_temp1069_pw_gz1ftg) : &pw_gz1ftg, _pw_gz1ftga.fixedflag ? (_temp1070_pw_gz1ftga=pw_gz1ftga,&_temp1070_pw_gz1ftga) : &pw_gz1ftga, _pw_gz1ftgd.fixedflag ? (_temp1071_pw_gz1ftgd=pw_gz1ftgd,&_temp1071_pw_gz1ftgd) : &pw_gz1ftgd,
                 area_g1ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1ftg.");
        return FAILURE;
    }
    

    /* Find Params for refocusing pulse gz2ftg */
    area_g2ftg =  a_gzrf2ftg *.5* ( pw_gzrf2ftg + pw_gzrf2ftgd);
    if( amppwgz1(_a_gz2ftg.fixedflag ? (_temp1072_a_gz2ftg=a_gz2ftg,&_temp1072_a_gz2ftg) : &a_gz2ftg, _pw_gz2ftg.fixedflag ? (_temp1073_pw_gz2ftg=pw_gz2ftg,&_temp1073_pw_gz2ftg) : &pw_gz2ftg, _pw_gz2ftga.fixedflag ? (_temp1074_pw_gz2ftga=pw_gz2ftga,&_temp1074_pw_gz2ftga) : &pw_gz2ftga, _pw_gz2ftgd.fixedflag ? (_temp1075_pw_gz2ftgd=pw_gz2ftgd,&_temp1075_pw_gz2ftgd) : &pw_gz2ftgd,
                 area_g2ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE ) {
	epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz2ftg.");
	return FAILURE;
    }
 
    /* Find Params for refocusing pulse gz2btg */

    /* MRIge56170  AF  10/13/99 */
    if( optramp(_pw_gzrf3ftga.fixedflag ? (_temp1076_pw_gzrf3ftga=pw_gzrf3ftga,&_temp1076_pw_gzrf3ftga) : &pw_gzrf3ftga, a_gzrf3ftg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf3ftga.");
        return FAILURE;
    }

    area_g2bftg =  a_gzrf3ftg * .5 *(pw_gzrf3ftga + pw_gzrf3ftg);
    if( amppwgz1(_a_gz2bftg.fixedflag ? (_temp1077_a_gz2bftg=a_gz2bftg,&_temp1077_a_gz2bftg) : &a_gz2bftg, _pw_gz2bftg.fixedflag ? (_temp1078_pw_gz2bftg=pw_gz2bftg,&_temp1078_pw_gz2bftg) : &pw_gz2bftg, _pw_gz2bftga.fixedflag ? (_temp1079_pw_gz2bftga=pw_gz2bftga,&_temp1079_pw_gz2bftga) : &pw_gz2bftga, _pw_gz2bftgd.fixedflag ? (_temp1080_pw_gz2bftgd=pw_gz2bftgd,&_temp1080_pw_gz2bftgd) : &pw_gz2bftgd,
                 area_g2bftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ps1loggrd.tz) == FAILURE ) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, ":amppwgz1 for gz2bftg.");
        return FAILURE;
    }
    
    pw_gzrf3ftgd  = _pw_gzrf3ftgd.fixedflag ?  ((void)(pw_gzrf3ftga), pw_gzrf3ftgd) : pw_gzrf3ftga;
 
    /* Find Params for refocusing pulse */
    area_g3ftg =  a_gzrf3ftg *.5* ( pw_gzrf3ftg + pw_gzrf3ftgd);
    if( amppwgz1(_a_gz3ftg.fixedflag ? (_temp1081_a_gz3ftg=a_gz3ftg,&_temp1081_a_gz3ftg) : &a_gz3ftg, _pw_gz3ftg.fixedflag ? (_temp1082_pw_gz3ftg=pw_gz3ftg,&_temp1082_pw_gz3ftg) : &pw_gz3ftg, _pw_gz3ftga.fixedflag ? (_temp1083_pw_gz3ftga=pw_gz3ftga,&_temp1083_pw_gz3ftga) : &pw_gz3ftga, _pw_gz3ftgd.fixedflag ? (_temp1084_pw_gz3ftgd=pw_gz3ftgd,&_temp1084_pw_gz3ftgd) : &pw_gz3ftgd,
                 area_g3ftg, (INT)1000000, MIN_PLATEAU_TIME,
                 ps1loggrd.zrt, ftg_tz_xz) == FAILURE )
    {

        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz3ftg.");
        return FAILURE;
    }
    
    if( calcfilter( &echo1ftg_filt, FTGecho1bw, FTGxres, OVERWRITE_NONE)
        == FAILURE ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1ftg_filt");
        return FAILURE;
    }

    if( ampfov(_a_gxw1ftg.fixedflag ? (_temp1085_a_gxw1ftg=a_gxw1ftg,&_temp1085_a_gxw1ftg) : &a_gxw1ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1ftg.");
        return FAILURE;
 
    }
 
    pw_gxw1ftg  = _pw_gxw1ftg.fixedflag ?  ((void)(RUP_GRD((int)(echo1ftg_filt.tdaq)/4)), pw_gxw1ftg) : RUP_GRD((int)(echo1ftg_filt.tdaq)/4);

    area_gxw1ftg = 2.0*a_gxw1ftg*(float)(pw_gxw1ftg);
 
    if( amppwgx1(_a_gx1ftg.fixedflag ? (_temp1086_a_gx1ftg=a_gx1ftg,&_temp1086_a_gx1ftg) : &a_gx1ftg, _pw_gx1ftg.fixedflag ? (_temp1087_pw_gx1ftg=pw_gx1ftg,&_temp1087_pw_gx1ftg) : &pw_gx1ftg, _pw_gx1ftga.fixedflag ? (_temp1088_pw_gx1ftga=pw_gx1ftga,&_temp1088_pw_gx1ftga) : &pw_gx1ftga, _pw_gx1ftgd.fixedflag ? (_temp1089_pw_gx1ftgd=pw_gx1ftgd,&_temp1089_pw_gx1ftgd) : &pw_gx1ftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");
        return FAILURE;
    }
    
    if( amppwgx1(_a_gx2test.fixedflag ? (_temp1090_a_gx2test=a_gx2test,&_temp1090_a_gx2test) : &a_gx2test, _pw_gx2test.fixedflag ? (_temp1091_pw_gx2test=pw_gx2test,&_temp1091_pw_gx2test) : &pw_gx2test, _pw_gx2testa.fixedflag ? (_temp1092_pw_gx2testa=pw_gx2testa,&_temp1092_pw_gx2testa) : &pw_gx2testa, _pw_gx2testd.fixedflag ? (_temp1093_pw_gx2testd=pw_gx2testd,&_temp1093_pw_gx2testd) : &pw_gx2testd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1ftg.");

        return FAILURE;
    }
    
 
    area_gxw1ftg = a_gxw1ftg*(float)(pw_gxw1ftg);
    if( amppwgx1(_a_gx1bftg.fixedflag ? (_temp1094_a_gx1bftg=a_gx1bftg,&_temp1094_a_gx1bftg) : &a_gx1bftg, _pw_gx1bftg.fixedflag ? (_temp1095_pw_gx1bftg=pw_gx1bftg,&_temp1095_pw_gx1bftg) : &pw_gx1bftg, _pw_gx1bftga.fixedflag ? (_temp1096_pw_gx1bftga=pw_gx1bftga,&_temp1096_pw_gx1bftga) : &pw_gx1bftga, _pw_gx1bftgd.fixedflag ? (_temp1097_pw_gx1bftgd=pw_gx1bftgd,&_temp1097_pw_gx1bftgd) : &pw_gx1bftgd,
                 TYPSPIN, area_gxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s call failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1:gx1btg");
    }

    if( optramp(_pw_gxw1ftga.fixedflag ? (_temp1098_pw_gxw1ftga=pw_gxw1ftga,&_temp1098_pw_gxw1ftga) : &pw_gxw1ftga, a_gxw1ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1ftga.");
        return FAILURE;
    }    
    
    pw_gxw1ftgd  = _pw_gxw1ftgd.fixedflag ?  ((void)(pw_gxw1ftga), pw_gxw1ftgd) : pw_gxw1ftga;
 
    area_postgxw1ftg = ( 3.0 * a_gxw1ftg * (float)(pw_gxw1ftg)
                         - 0.5 * a_gxw1ftg * (pw_gxw1ftga + pw_gxw1ftgd) );
    if( amppwgx1(_a_postgxw1ftg.fixedflag ? (_temp1099_a_postgxw1ftg=a_postgxw1ftg,&_temp1099_a_postgxw1ftg) : &a_postgxw1ftg, _pw_postgxw1ftg.fixedflag ? (_temp1100_pw_postgxw1ftg=pw_postgxw1ftg,&_temp1100_pw_postgxw1ftg) : &pw_postgxw1ftg, _pw_postgxw1ftga.fixedflag ? (_temp1101_pw_postgxw1ftga=pw_postgxw1ftga,&_temp1101_pw_postgxw1ftga) : &pw_postgxw1ftga,
                 _pw_postgxw1ftgd.fixedflag ? (_temp1102_pw_postgxw1ftgd=pw_postgxw1ftgd,&_temp1102_pw_postgxw1ftgd) : &pw_postgxw1ftgd, TYPSPIN, area_postgxw1ftg, .0,
                 (int)1000000, 1.0, MIN_PLATEAU_TIME,
                 ftg_xrt, ftg_tx) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for postgxw1ftg.");
        return FAILURE;
    }
    
    if( ampfov(_a_gxw2ftg.fixedflag ? (_temp1103_a_gxw2ftg=a_gxw2ftg,&_temp1103_a_gxw2ftg) : &a_gxw2ftg, echo1ftg_filt.bw, FTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw2ftg.");
        return FAILURE;
    }
    
    pw_gxw2ftg  = _pw_gxw2ftg.fixedflag ?  ((void)(RUP_GRD((int)(4.0*(float)pw_gxw1ftg))), pw_gxw2ftg) : RUP_GRD((int)(4.0*(float)pw_gxw1ftg));
    if( optramp(_pw_gxw2ftga.fixedflag ? (_temp1104_pw_gxw2ftga=pw_gxw2ftga,&_temp1104_pw_gxw2ftga) : &pw_gxw2ftga, a_gxw2ftg, ftg_tx,
                ftg_xrt, TYPDEF) == FAILURE )
    { 
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw2ftga.");
 
        return FAILURE;
    }
    
    pw_gxw2ftgd  = _pw_gxw2ftgd.fixedflag ?  ((void)(pw_gxw2ftga), pw_gxw2ftgd) : pw_gxw2ftga;
 
    /* We want S1 to refocus tau1 ms after rf3.  The gx2tg refocusing
       pulse accomplishes this.  gxw2tg pulse can't start before the
       end of the gz3tg refocussing pulse (why bother collecting
       corrupt data? ). */
    area_gx1ftg = a_gx1ftg * (0.5 * (float)(pw_gx1ftga + pw_gx1ftgd) + pw_gx1ftg);
 
    /* Starting readout window position relative to center of rf3 */
    PosReadoutWindow = ( pw_rf3ftg/2 + pw_gzrf3ftgd + pw_gz3ftga
                         + pw_gz3ftg + pw_gz3ftgd );
 
    pw_gxw2ftgleft  = _pw_gxw2ftgleft.fixedflag ?  ((void)(RUP_GRD(echo1ftg_filt.tdaq/8)), pw_gxw2ftgleft) : RUP_GRD(echo1ftg_filt.tdaq/8);   /* 1/8th of readout window to left of S1 */

    area_gx2ftg = area_gx1ftg - a_gxw2ftg * (float)(pw_gxw2ftga/ 2 + pw_gxw2ftgleft);
 
    if( amppwgrad(area_gx2ftg, ftg_tx_xz,
                  0.0, 0.0, ftg_xrt,
                  MIN_PLATEAU_TIME, _a_gx2ftg.fixedflag ? (_temp1105_a_gx2ftg=a_gx2ftg,&_temp1105_a_gx2ftg) : &a_gx2ftg, _pw_gx2ftga.fixedflag ? (_temp1106_pw_gx2ftga=pw_gx2ftga,&_temp1106_pw_gx2ftga) : &pw_gx2ftga,
                  _pw_gx2ftg.fixedflag ? (_temp1107_pw_gx2ftg=pw_gx2ftg,&_temp1107_pw_gx2ftg) : &pw_gx2ftg, _pw_gx2ftgd.fixedflag ? (_temp1108_pw_gx2ftgd=pw_gx2ftgd,&_temp1108_pw_gx2ftgd) : &pw_gx2ftgd) == FAILURE ) {
        epic_error(use_ermes, "%s failed in fasttg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gx2ftg");
        return FAILURE;
    }
   
    if( (pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft
         > FTGtau1) || (pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft > FTGtau1) )
    {
        /* return FAILURE; */
    }
    
    /* HCSDM00161809: calculate minimum FTGtau1 */
    FTGtau1check1 = RUP_GRD(pw_rf1ftg/2+pw_gx1ftga+pw_gx1ftg+pw_gx1ftgd+pw_rf2ftg/2);
    FTGtau1check2 = RUP_GRD(pw_rf1ftg/2+pw_gzrf1ftgd+pw_gz1ftga+pw_gz1ftg+pw_gz1ftgd+pw_gzrf2ftga+pw_rf2ftg/2);
    FTGtau1check3 = RUP_GRD(pw_rf2ftg/2+pw_gx1bftga+pw_gx1bftg+pw_gx1bftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check4 = RUP_GRD(pw_rf2ftg/2+pw_gzrf2ftgd+pw_gz2ftga+pw_gz2ftg+pw_gz2ftgd+pw_gxw1ftga+pw_gxw1ftg/2);
    FTGtau1check5 = RUP_GRD(pw_rf3ftg/2+pw_gx2ftga+pw_gx2ftg+pw_gx2ftgd+pw_gxw2ftga+pw_gxw2ftgleft);
    FTGtau1check6 = RUP_GRD(pw_rf3ftg/2+pw_gzrf3ftgd+pw_gz3ftga+pw_gz3ftg+pw_gz3ftgd+pw_gxw2ftga+pw_gxw2ftgleft);

    temp_FTGtau1 = IMax(7, FTGtau1, FTGtau1check1, FTGtau1check2, FTGtau1check3, FTGtau1check4, FTGtau1check5, FTGtau1check6);

    cvoverride(FTGtau1, temp_FTGtau1, PSD_FIX_OFF, PSD_EXIST_ON);

    if( !existcv(FTGtau2) )
    {
        FTGtau2  = _FTGtau2.fixedflag ?  ((void)((int)(exist(FTGtau1)*exist(FTGau))), FTGtau2) : (int)(exist(FTGtau1)*exist(FTGau));
    }

    flip_rf1ftg  = _flip_rf1ftg.fixedflag ?   ((void)(90.0), flip_rf1ftg) : 90.0;
    flip_rf2ftg  = _flip_rf2ftg.fixedflag ?  ((void)(180.0), flip_rf2ftg) : 180.0;
    flip_rf3ftg  = _flip_rf3ftg.fixedflag ?  ((void)(180.0), flip_rf3ftg) : 180.0;
    
    strcpy(entry_point_table[L_FTG].epname, "fasttg");
 
    return SUCCESS;
}   /* end FTGcveval() */


/*
 *  XTGcveval
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGcveval( void )
{
    LONG bw_rf1xtg;
    LONG bw_rf2xtg;
    FLOAT area_g1xtg;
    FLOAT area_gxw1xtg;
    INT ta_180, tb_180;
    FLOAT area_gxw1rampxtg;
    INT xtg_xrt, xtg_yrt;
    FLOAT xtg_tx;
    FLOAT xtg_tx_xz;
    FLOAT xtg_tz_xz;
    FLOAT xtg_tx_xyz, xtg_ty_xyz, xtg_tz_xyz;
    FLOAT xtg_temp_float;
    INT XTGspf;
    INT timeBeforeFermi; /* Time before Off resonance Fermi pulse */

    XTGspf = (TGspf && (PSD_OFF == local_tg));
    XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), XTGfov) : FMin(2,480.0,cfsystemmaxfov);

    if(0 == getAps1Mod())
    {
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMin(2,opfov,XTGfov)), XTGfov) : FMin(2,opfov,XTGfov);
        XTGfov  = _XTGfov.fixedflag ?    ((void)(FMax(2,XTGfov,MINFOV_TG)), XTGfov) : FMax(2,XTGfov,MINFOV_TG);
    }

    xtg_xrt = (XTGspf ? ps1loggrd.yrt : ps1loggrd.xrt);
    xtg_yrt = (XTGspf ? ps1loggrd.xrt : ps1loggrd.yrt);
    xtg_tx = (XTGspf ? ps1loggrd.ty : ps1loggrd.tx);
    xtg_tx_xz = (XTGspf ? ps1loggrd.ty_yz : ps1loggrd.tx_xz);
    xtg_tz_xz = (XTGspf ? ps1loggrd.tz_yz : ps1loggrd.tz_xz);
    xtg_tz_xyz = ps1loggrd.tz_xyz;
    xtg_tx_xyz = (XTGspf ? ps1loggrd.ty_xyz : ps1loggrd.tx_xyz);
    xtg_ty_xyz = (XTGspf ? ps1loggrd.tx_xyz : ps1loggrd.ty_xyz);

    gscale_rf1xtg   = _gscale_rf1xtg.fixedflag ?  ((void)(0.90909), gscale_rf1xtg) : 0.90909;
    gscale_rf2xtg   = _gscale_rf2xtg.fixedflag ?  ((void)(gscale_rf1xtg), gscale_rf2xtg) : gscale_rf1xtg;

    pw_gzrf2xtg  = _pw_gzrf2xtg.fixedflag ?  ((void)(pw_rf2xtg), pw_gzrf2xtg) : pw_rf2xtg;

    XTGecho1bw  = _XTGecho1bw.fixedflag ?  ((void)(15.625), XTGecho1bw) : 15.625;

    bw_rf1xtg = (LONG)(4 * cyc_rf1xtg/ ((FLOAT)pw_rf1xtg/ (FLOAT)1000000));

    if(PSD_ON == local_tg)
    {
        pw_gyrf1xtg  = _pw_gyrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gyrf1xtg) : pw_rf1xtg;
        XTGfov  = _XTGfov.fixedflag ?  ((void)(TGopslthickx), XTGfov) : TGopslthickx;

        if( ampslice(_a_gyrf1xtg.fixedflag ? (_temp1109_a_gyrf1xtg=a_gyrf1xtg,&_temp1109_a_gyrf1xtg) : &a_gyrf1xtg, bw_rf1xtg, TGopslthicky, gscale_rf1xtg, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "ampslice for gyrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gyrf1xtga.fixedflag ? (_temp1110_pw_gyrf1xtga=pw_gyrf1xtga,&_temp1110_pw_gyrf1xtga) : &pw_gyrf1xtga, a_gyrf1xtg, ps1loggrd.ty, ps1loggrd.yrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "optramp for gyrf1xtga.");
            return FAILURE;
        }    

        pw_gyrf1xtgd  = _pw_gyrf1xtgd.fixedflag ?  ((void)(pw_gyrf1xtga), pw_gyrf1xtgd) : pw_gyrf1xtga;

    }
    else
    {
        pw_gzrf1xtg  = _pw_gzrf1xtg.fixedflag ?  ((void)(pw_rf1xtg), pw_gzrf1xtg) : pw_rf1xtg;

        if( ampslice(_a_gzrf1xtg.fixedflag ? (_temp1111_a_gzrf1xtg=a_gzrf1xtg,&_temp1111_a_gzrf1xtg) : &a_gzrf1xtg, bw_rf1xtg, TGopslthick, gscale_rf1xtg, TYPDEF)
        == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1xtg.");
            return FAILURE;
        }

        if( optramp(_pw_gzrf1xtga.fixedflag ? (_temp1112_pw_gzrf1xtga=pw_gzrf1xtga,&_temp1112_pw_gzrf1xtga) : &pw_gzrf1xtga, a_gzrf1xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
            == FAILURE )
        {
            epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1xtga.");
            return FAILURE;
        }    

        pw_gzrf1xtgd  = _pw_gzrf1xtgd.fixedflag ?  ((void)(pw_gzrf1xtga), pw_gzrf1xtgd) : pw_gzrf1xtga;

    }

    bw_rf2xtg = (LONG)(4 * cyc_rf2xtg/ ((FLOAT)pw_rf2xtg/ (FLOAT)1000000));

    if( ampslice(_a_gzrf2xtg.fixedflag ? (_temp1113_a_gzrf2xtg=a_gzrf2xtg,&_temp1113_a_gzrf2xtg) : &a_gzrf2xtg, bw_rf2xtg, TGopslthick, gscale_rf2xtg, TYPDEF)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf2xtg.");
        return FAILURE;
    }

    if (optramp(_pw_gzrf2xtga.fixedflag ? (_temp1114_pw_gzrf2xtga=pw_gzrf2xtga,&_temp1114_pw_gzrf2xtga) : &pw_gzrf2xtga, a_gzrf2xtg, ps1loggrd.tz, ps1loggrd.zrt, TYPDEF)
        == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf2xtga.");
        return FAILURE;
    }    

    pw_gzrf2xtgd  = _pw_gzrf2xtgd.fixedflag ?  ((void)(pw_gzrf2xtga), pw_gzrf2xtgd) : pw_gzrf2xtga;

    /* Z CRUSHER CVs */ 
    if(PSD_ON == local_tg)
    {
        area_g1xtg = 0.0;
    }
    else
    {
        area_g1xtg = (PSoff90 + pw_gzrf1xtg/2.0 + pw_gzrf1xtgd/2.0)*a_gzrf1xtg;
    }
    area_xtgzkiller  = _area_xtgzkiller.fixedflag ?  ((void)(amp_killer*pw_killer+area_g1xtg), area_xtgzkiller) : amp_killer*pw_killer+area_g1xtg;
    if (amppwgrad(area_xtgzkiller, xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz2xtg.fixedflag ? (_temp1115_a_gz2xtg=a_gz2xtg,&_temp1115_a_gz2xtg) : &a_gz2xtg, _pw_gz2xtga.fixedflag ? (_temp1116_pw_gz2xtga=pw_gz2xtga,&_temp1116_pw_gz2xtga) : &pw_gz2xtga,
                  _pw_gz2xtg.fixedflag ? (_temp1117_pw_gz2xtg=pw_gz2xtg,&_temp1117_pw_gz2xtg) : &pw_gz2xtg, _pw_gz2xtgd.fixedflag ? (_temp1118_pw_gz2xtgd=pw_gz2xtgd,&_temp1118_pw_gz2xtgd) : &pw_gz2xtgd) == FAILURE)
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz2xtg"); 
        return FAILURE;
    }

    if (amppwgrad((area_xtgzkiller-area_g1xtg), xtg_tz_xyz, 0.0, 0.0, ps1loggrd.zrt,
                  MIN_PLATEAU_TIME, _a_gz1xtg.fixedflag ? (_temp1119_a_gz1xtg=a_gz1xtg,&_temp1119_a_gz1xtg) : &a_gz1xtg, _pw_gz1xtga.fixedflag ? (_temp1120_pw_gz1xtga=pw_gz1xtga,&_temp1120_pw_gz1xtga) : &pw_gz1xtga,
                  _pw_gz1xtg.fixedflag ? (_temp1121_pw_gz1xtg=pw_gz1xtg,&_temp1121_pw_gz1xtg) : &pw_gz1xtg, _pw_gz1xtgd.fixedflag ? (_temp1122_pw_gz1xtgd=pw_gz1xtgd,&_temp1122_pw_gz1xtgd) : &pw_gz1xtgd) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed in XTGcveval.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "amppwgrad: gz1xtg"); 
        return FAILURE;
    }

    /* use 16kHz, 256 xres */
    if( calcfilter( &echo1xtg_filt, XTGecho1bw, XTGxres, OVERWRITE_NONE)
        == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"calcfilter for echo1xtg_filt");
        return FAILURE;
    }
    
    if (ampfov(&xtg_temp_float, echo1xtg_filt.bw, xtg_tx) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "xtg ampfov");
        return FAILURE;
    }

    xtg_temp_float = ceil(xtg_temp_float/ 10.0) * 10.0;
    if( xtg_temp_float > XTGfov )
    {
        XTGfov  = _XTGfov.fixedflag ?  ((void)(xtg_temp_float), XTGfov) : xtg_temp_float;
    }

    if( ampfov(_a_gxw1xtg.fixedflag ? (_temp1123_a_gxw1xtg=a_gxw1xtg,&_temp1123_a_gxw1xtg) : &a_gxw1xtg, echo1xtg_filt.bw, XTGfov) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxw1xtg.");
        return FAILURE;        
    }

    if( optramp(_pw_gxw1xtga.fixedflag ? (_temp1124_pw_gxw1xtga=pw_gxw1xtga,&_temp1124_pw_gxw1xtga) : &pw_gxw1xtga, a_gxw1xtg, xtg_tx,
                xtg_xrt, TYPDEF) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gxw1xtga.");
        return FAILURE;
    }    

    pw_gxw1xtgd  = _pw_gxw1xtgd.fixedflag ?  ((void)(pw_gxw1xtga), pw_gxw1xtgd) : pw_gxw1xtga;
    
    pw_gxw1xtg  = _pw_gxw1xtg.fixedflag ?  ((void)(RUP_GRD((int)(echo1xtg_filt.tdaq))), pw_gxw1xtg) : RUP_GRD((int)(echo1xtg_filt.tdaq));
    
    area_gxw1xtg = a_gxw1xtg*(float)(pw_gxw1xtg);
    area_gxw1rampxtg = 0.5*a_gxw1xtg*(float)(pw_gxw1xtga);
    
    if( amppwgx1(_a_gx1bxtg.fixedflag ? (_temp1125_a_gx1bxtg=a_gx1bxtg,&_temp1125_a_gx1bxtg) : &a_gx1bxtg, _pw_gx1bxtg.fixedflag ? (_temp1126_pw_gx1bxtg=pw_gx1bxtg,&_temp1126_pw_gx1bxtg) : &pw_gx1bxtg, _pw_gx1bxtga.fixedflag ? (_temp1127_pw_gx1bxtga=pw_gx1bxtga,&_temp1127_pw_gx1bxtga) : &pw_gx1bxtga, _pw_gx1bxtgd.fixedflag ? (_temp1128_pw_gx1bxtgd=pw_gx1bxtgd,&_temp1128_pw_gx1bxtgd) : &pw_gx1bxtgd,
                 TYPSPIN, area_gxw1xtg, area_gxw1rampxtg,
                 1000000, 1.0, MIN_PLATEAU_TIME, xtg_xrt, xtg_tx_xyz) == FAILURE )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1bxtg.");
        return FAILURE;
    }
    a_gx1bxtg  = _a_gx1bxtg.fixedflag ?  ((void)(-a_gx1bxtg), a_gx1bxtg) : -a_gx1bxtg;

    /* Find Params for killer pulse */
    if(PSD_ON == local_tg)
    {
        area_g1xtg = (PSoff90 + pw_gyrf1xtg/2.0 + pw_gyrf1xtgd/2.0)*a_gyrf1xtg;
    }
    else
    {
        area_g1xtg = 0.0;
    }
    area_xtgykiller  = _area_xtgykiller.fixedflag ?  ((void)(amp_killer*pw_killer), area_xtgykiller) : amp_killer*pw_killer;
    if (amppwgrad(area_xtgykiller-area_g1xtg, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgl.fixedflag ? (_temp1129_a_gykxtgl=a_gykxtgl,&_temp1129_a_gykxtgl) : &a_gykxtgl, _pw_gykxtgla.fixedflag ? (_temp1130_pw_gykxtgla=pw_gykxtgla,&_temp1130_pw_gykxtgla) : &pw_gykxtgla,
                  _pw_gykxtgl.fixedflag ? (_temp1131_pw_gykxtgl=pw_gykxtgl,&_temp1131_pw_gykxtgl) : &pw_gykxtgl, _pw_gykxtgld.fixedflag ? (_temp1132_pw_gykxtgld=pw_gykxtgld,&_temp1132_pw_gykxtgld) : &pw_gykxtgld) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgl");
        return FAILURE;
    }
    
    if (amppwgrad(area_xtgykiller, xtg_ty_xyz, 0.0, 0.0, xtg_yrt,
                  MIN_PLATEAU_TIME, _a_gykxtgr.fixedflag ? (_temp1133_a_gykxtgr=a_gykxtgr,&_temp1133_a_gykxtgr) : &a_gykxtgr, _pw_gykxtgra.fixedflag ? (_temp1134_pw_gykxtgra=pw_gykxtgra,&_temp1134_pw_gykxtgra) : &pw_gykxtgra,
                  _pw_gykxtgr.fixedflag ? (_temp1135_pw_gykxtgr=pw_gykxtgr,&_temp1135_pw_gykxtgr) : &pw_gykxtgr, _pw_gykxtgrd.fixedflag ? (_temp1136_pw_gykxtgrd=pw_gykxtgrd,&_temp1136_pw_gykxtgrd) : &pw_gykxtgrd) == FAILURE) {
        epic_error(use_ermes, "%s failed in xtg.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgrad:gykxtgr");
        return FAILURE;
    }
    flip_rf1xtg  = _flip_rf1xtg.fixedflag ?   ((void)(90.0), flip_rf1xtg) : 90.0;
    flip_rf2xtg  = _flip_rf2xtg.fixedflag ?  ((void)(180.0), flip_rf2xtg) : 180.0;
 
    /* XTGtau1 */
    /* 1. Compute ta_180 */
    /*    Compute timeBeforeFermi as time after RF1 and before FermiL, accouting for min_ssp */
    if(PSD_ON == local_tg)
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GyRF1d */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd );
        }
        else
        {
            /* GyRF1d + YKillerL */
            timeBeforeFermi = IMax( 2, min_ssp, pw_gyrf1xtgd + pw_gykxtgla+pw_gykxtgl+pw_gykxtgld );  
        }
    }
    else
    {
        if ( XTG_minimizeYKillerGap == PSD_ON )
        {
            /* GzRF1d */
            timeBeforeFermi = IMax(2, min_ssp, pw_gzrf1xtgd);
        }
        else
        {
            /* MAX(GzRF1d,YKillerL), since YKillerL can be applied during GzRF1d) */
            timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf1xtgd, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld));
        }
    }
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL + FermiL + MAX(ZDephaser,YKillerL) + HALF(GzRF2) */
        ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + IMax(2, pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld) + pw_gzrf2xtg/2;
    }
    else
    {
        /* ta_180 = HALF(RF1) + timeBeforeFermiL(including YKillerL) + FermiL + ZDephaser + HALF(GzRF2) */
         ta_180 = pw_rf1xtg/2 + timeBeforeFermi + pw_rf3xtg + pw_gz1xtga + pw_gz1xtg+pw_gz1xtgd+pw_gzrf2xtga+pw_gzrf2xtg/2;
    }

    /* 2. Compute tb_180 */
    /*    Compute timeBeforeFermi as time after RF2 and before FermiR, accouting for min_ssp */  
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* MAX(ZRephaser,YKillerR), since YKillerR can be applied during ZRephaser */
        timeBeforeFermi = IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd));
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser and YKillerR) + FermiR + XReadoutDephaser + HALFeadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd + pw_gxw1xtga+pw_gxw1xtg/2;
    }
    else
    {
        /* MAX of XReadoutDephaser and YKillerR */
        timeBeforeFermi = IMax(2, min_ssp, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd);
        /* tb_180 = HALF(GzRF2) + timeBeforeFermi(including ZRephaser) + FermiR + MAX(YKillerR,XReadoutDephaser) + HALF(ReadoutWindow) */ 
        tb_180 = pw_gzrf2xtg/2 + timeBeforeFermi + pw_rf4xtg + IMax(2, pw_gx1bxtga+pw_gx1bxtg+pw_gx1bxtgd, pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd) + pw_gxw1xtga+pw_gxw1xtg/2;
    }   

    /* 3. Compute XTGtau1 based on ta_180 and tb180 */
    XTGtau1  = _XTGtau1.fixedflag ?    ((void)(RUP_GRD(IMax(2,ta_180,tb_180))), XTGtau1) : RUP_GRD(IMax(2,ta_180,tb_180)); 
    
    strcpy(entry_point_table[L_XTG].epname, "expresstg");
 
    return SUCCESS;
}   /* end XTGcveval() */

/* 
 *  RScveval
 *  Description:
 *  CV eval for RFShim 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
RScveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1rs, area_gx1rs;
    FLOAT area_gxkbsrs, area_gxkrs;
    FLOAT area_gzkbsrs, area_gzkrs;
    FLOAT area_gx2rs;
    FLOAT temp_float;
    LONG bw_rf1rs;

    echo1bwrs  = _echo1bwrs.fixedflag ?  ((void)(31.25), echo1bwrs) : 31.25;
    rfshim_baseline  = _rfshim_baseline.fixedflag ?  ((void)(0), rfshim_baseline) : 0;
    rfshim_xres  = _rfshim_xres.fixedflag ?  ((void)(64), rfshim_xres) : 64;
    rfshim_yres  = _rfshim_yres.fixedflag ?  ((void)(64), rfshim_yres) : 64;
    rfshim_slthick  = _rfshim_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), rfshim_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if( (PSD_ON == rsaxial_flag) )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(460), rfshim_fov) : 460;
        if(isCategoryMatchForAnatomy(opanatomy, ATTRIBUTE_CATEGORY_HEAD))
        {
            rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(280), rfshim_fov) : 280;  /* 28 cm FOV for head scans */
        }

    }

    if(exist(opdrivemode) == 3)
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_ON), B1Cal_mode) : PSD_ON;
    }
    else
    {
        B1Cal_mode  = _B1Cal_mode.fixedflag ?  ((void)(PSD_OFF), B1Cal_mode) : PSD_OFF;
    }

    flip_rfbrs  = _flip_rfbrs.fixedflag ?  ((void)(180), flip_rfbrs) : 180;  /* I/Q DD cal needs to double flip */
    flip_rf1rs  = _flip_rf1rs.fixedflag ?  ((void)(10), flip_rf1rs) : 10;
    rfshim_flipangle  = _rfshim_flipangle.fixedflag ?  ((void)(flip_rf1rs), rfshim_flipangle) : flip_rf1rs;

    rfshim_slquant  = _rfshim_slquant.fixedflag ?  ((void)(1), rfshim_slquant) : 1;
    rfshim_slquant  = _rfshim_slquant.fixedflag ?    ((void)(IMin(2,RFSHIM_SLQ,rfshim_slquant)), rfshim_slquant) : IMin(2,RFSHIM_SLQ,rfshim_slquant);

    pw_rf1rs  = _pw_rf1rs.fixedflag ?  ((void)(RUP_GRD(pw_rf1rs)), pw_rf1rs) : RUP_GRD(pw_rf1rs);

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            bw_rf1rs = (LONG)(4*cyc_rf1rs/((float)pw_rf1rs/(float)1000000));
            rs_iso_delay   = _rs_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw)), rs_iso_delay) : RUP_GRD(pw_rf1rs/2.0+(float)rs_off90*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1rs = (LONG)(rfpulse[RF1_RFSHIM_SLOT].nom_bw*rfpulse[RF1_RFSHIM_SLOT].nom_pw/pw_rf1rs);
            rs_iso_delay  = _rs_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw))), rs_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_RFSHIM_SLOT].isodelay*pw_rf1rs/rfpulse[RF1_RFSHIM_SLOT].nom_pw));
            break;
    }


    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1rs  = _pw_gzrf1rs.fixedflag ?  ((void)(pw_rf1rs), pw_gzrf1rs) : pw_rf1rs;

    if (FAILURE==ampslice(_a_gzrf1rs.fixedflag ? (_temp1137_a_gzrf1rs=a_gzrf1rs,&_temp1137_a_gzrf1rs) : &a_gzrf1rs, bw_rf1rs, rfshim_slthick, gscale_rf1rs, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1rs.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1rsa.fixedflag ? (_temp1138_pw_gzrf1rsa=pw_gzrf1rsa,&_temp1138_pw_gzrf1rsa) : &pw_gzrf1rsa, a_gzrf1rs, rsloggrd.tz_xyz, rsloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1rsa.");
        return FAILURE;
    }
    pw_gzrf1rsd  = _pw_gzrf1rsd.fixedflag ?  ((void)(pw_gzrf1rsa), pw_gzrf1rsd) : pw_gzrf1rsa;

    /* Z BLS killer */
    area_gzkbsrs = 1.0E6*3.0*10.0/GAM/exist(rfshim_slthick);

    if (FAILURE==amppwgrad(area_gzkbsrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsrs.fixedflag ? (_temp1139_a_gzkbsrs=a_gzkbsrs,&_temp1139_a_gzkbsrs) : &a_gzkbsrs, _pw_gzkbsrsa.fixedflag ? (_temp1140_pw_gzkbsrsa=pw_gzkbsrsa,&_temp1140_pw_gzkbsrsa) : &pw_gzkbsrsa,
                           _pw_gzkbsrs.fixedflag ? (_temp1141_pw_gzkbsrs=pw_gzkbsrs,&_temp1141_pw_gzkbsrs) : &pw_gzkbsrs, _pw_gzkbsrsd.fixedflag ? (_temp1142_pw_gzkbsrsd=pw_gzkbsrsd,&_temp1142_pw_gzkbsrsd) : &pw_gzkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsrs");
        return FAILURE;
    }

    if (a_gzrf1rs>0.0)
    {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsrs)), a_gzkbsrs) : -1.0*fabsf(a_gzkbsrs);
    } else {
        a_gzkbsrs  = _a_gzkbsrs.fixedflag ?  ((void)(fabsf(a_gzkbsrs)), a_gzkbsrs) : fabsf(a_gzkbsrs);
    }

    rst_exa  = _rst_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay)), rst_exa) : RUP_GRD(pw_gzrf1rsa+pw_gzrf1rs-rs_iso_delay);
    rst_exb  = _rst_exb.fixedflag ?  ((void)(rs_iso_delay), rst_exb) : rs_iso_delay;

    area_gz1rs = (rs_iso_delay + (pw_gzrf1rsd/ 2.0)) * a_gzrf1rs;
    if (area_gz1rs > 0.0)
    {
        area_gz1rs -= fabsf(area_gzkbsrs);
    }
    else
    {
        area_gz1rs += fabsf(area_gzkbsrs);
    }

    if (amppwgz1(_a_gz1rs.fixedflag ? (_temp1143_a_gz1rs=a_gz1rs,&_temp1143_a_gz1rs) : &a_gz1rs,_pw_gz1rs.fixedflag ? (_temp1144_pw_gz1rs=pw_gz1rs,&_temp1144_pw_gz1rs) : &pw_gz1rs,_pw_gz1rsa.fixedflag ? (_temp1145_pw_gz1rsa=pw_gz1rsa,&_temp1145_pw_gz1rsa) : &pw_gz1rsa,_pw_gz1rsd.fixedflag ? (_temp1146_pw_gz1rsd=pw_gz1rsd,&_temp1146_pw_gz1rsd) : &pw_gz1rsd,area_gz1rs,
                 (int)(1000000),MIN_PLATEAU_TIME,rsloggrd.zrt,rsloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1rs.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkrs = 980;

    if (FAILURE==amppwgrad(area_gzkrs, rsloggrd.tz_xyz, 0.0, 0.0, rsloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkrs.fixedflag ? (_temp1147_a_gzkrs=a_gzkrs,&_temp1147_a_gzkrs) : &a_gzkrs, _pw_gzkrsa.fixedflag ? (_temp1148_pw_gzkrsa=pw_gzkrsa,&_temp1148_pw_gzkrsa) : &pw_gzkrsa,
                           _pw_gzkrs.fixedflag ? (_temp1149_pw_gzkrs=pw_gzkrs,&_temp1149_pw_gzkrs) : &pw_gzkrs, _pw_gzkrsd.fixedflag ? (_temp1150_pw_gzkrsd=pw_gzkrsd,&_temp1150_pw_gzkrsd) : &pw_gzkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkrs");
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1rs_filt, echo1bwrs, rfshim_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1rs_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1rs_filt.bw, rsloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > rfshim_fov )
    {
        rfshim_fov  = _rfshim_fov.fixedflag ?  ((void)(temp_float), rfshim_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwrs.fixedflag ? (_temp1151_a_gxwrs=a_gxwrs,&_temp1151_a_gxwrs) : &a_gxwrs, echo1rs_filt.bw, rfshim_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwrs.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwrsa.fixedflag ? (_temp1152_pw_gxwrsa=pw_gxwrsa,&_temp1152_pw_gxwrsa) : &pw_gxwrsa, a_gxwrs, rsloggrd.tx_xyz, rsloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwrsa.");
        return FAILURE;
    }

    pw_gxwrsd  = _pw_gxwrsd.fixedflag ?  ((void)(pw_gxwrsa), pw_gxwrsd) : pw_gxwrsa;
    pw_acqrs1  = _pw_acqrs1.fixedflag ?  ((void)(echo1rs_filt.tdaq), pw_acqrs1) : echo1rs_filt.tdaq;  /* one echo data */

    rd_ext_rs  = _rd_ext_rs.fixedflag ?  
                        ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_rs) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwrs  = _pw_gxwrs.fixedflag ?      ((void)(pw_acqrs1+e2_delay_rs+rd_ext_rs), pw_gxwrs) : pw_acqrs1+e2_delay_rs+rd_ext_rs;  /* total readout */

    /* X BLS killer */
    area_gxkbsrs = area_gzkbsrs;

    if (FAILURE==amppwgrad(area_gxkbsrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsrs.fixedflag ? (_temp1153_a_gxkbsrs=a_gxkbsrs,&_temp1153_a_gxkbsrs) : &a_gxkbsrs, _pw_gxkbsrsa.fixedflag ? (_temp1154_pw_gxkbsrsa=pw_gxkbsrsa,&_temp1154_pw_gxkbsrsa) : &pw_gxkbsrsa,
                           _pw_gxkbsrs.fixedflag ? (_temp1155_pw_gxkbsrs=pw_gxkbsrs,&_temp1155_pw_gxkbsrs) : &pw_gxkbsrs, _pw_gxkbsrsd.fixedflag ? (_temp1156_pw_gxkbsrsd=pw_gxkbsrsd,&_temp1156_pw_gxkbsrsd) : &pw_gxkbsrsd ))
    {
        epic_error(use_ermes, "%s failed in RFcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsrs");
        return FAILURE;
    }

    if (a_gxwrs>0.0)
    {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsrs)), a_gxkbsrs) : -1.0*fabsf(a_gxkbsrs);
    } else {
        a_gxkbsrs  = _a_gxkbsrs.fixedflag ?  ((void)(fabsf(a_gxkbsrs)), a_gxkbsrs) : fabsf(a_gxkbsrs);
    }

    /* combine gxkbs and gx1 */
    area_gx1rs = area_gxkbsrs - (pw_gxwrs+pw_gxwrsa)/2.0*a_gxwrs;

    if (FAILURE==amppwgrad(area_gx1rs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1rs.fixedflag ? (_temp1157_a_gx1rs=a_gx1rs,&_temp1157_a_gx1rs) : &a_gx1rs, _pw_gx1rsa.fixedflag ? (_temp1158_pw_gx1rsa=pw_gx1rsa,&_temp1158_pw_gx1rsa) : &pw_gx1rsa,
                           _pw_gx1rs.fixedflag ? (_temp1159_pw_gx1rs=pw_gx1rs,&_temp1159_pw_gx1rs) : &pw_gx1rs, _pw_gx1rsd.fixedflag ? (_temp1160_pw_gx1rsd=pw_gx1rsd,&_temp1160_pw_gx1rsd) : &pw_gx1rsd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1rs.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkrs = 980;
    if (FAILURE==amppwgrad(area_gxkrs, rsloggrd.tx_xyz, 0.0, 0.0, rsloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkrs.fixedflag ? (_temp1161_a_gxkrs=a_gxkrs,&_temp1161_a_gxkrs) : &a_gxkrs, _pw_gxkrsa.fixedflag ? (_temp1162_pw_gxkrsa=pw_gxkrsa,&_temp1162_pw_gxkrsa) : &pw_gxkrsa,
                           _pw_gxkrs.fixedflag ? (_temp1163_pw_gxkrs=pw_gxkrs,&_temp1163_pw_gxkrs) : &pw_gxkrs, _pw_gxkrsd.fixedflag ? (_temp1164_pw_gxkrsd=pw_gxkrsd,&_temp1164_pw_gxkrsd) : &pw_gxkrsd ))
    {
        epic_error(use_ermes, "%s failed in RScveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkrs");
        return FAILURE;
    }

    if(rfshim_etl >=2)
    {
        pw_gxw2rs  = _pw_gxw2rs.fixedflag ?  ((void)(pw_gxwrs), pw_gxw2rs) : pw_gxwrs;
        pw_gxw2rsa  = _pw_gxw2rsa.fixedflag ?  ((void)(pw_gxwrsa), pw_gxw2rsa) : pw_gxwrsa;
        pw_gxw2rsd  = _pw_gxw2rsd.fixedflag ?  ((void)(pw_gxwrsd), pw_gxw2rsd) : pw_gxwrsd;
        a_gxw2rs  = _a_gxw2rs.fixedflag ?  ((void)(a_gxwrs), a_gxw2rs) : a_gxwrs;

        area_gx2rs = -(pw_gxw2rs+(pw_gxw2rsa+pw_gxw2rsd)/2.0)*a_gxw2rs;

        if (FAILURE==amppwgrad(area_gx2rs, rsloggrd.tx_xy, 0.0, 0.0, rsloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2rs.fixedflag ? (_temp1165_a_gx2rs=a_gx2rs,&_temp1165_a_gx2rs) : &a_gx2rs, _pw_gx2rsa.fixedflag ? (_temp1166_pw_gx2rsa=pw_gx2rsa,&_temp1166_pw_gx2rsa) : &pw_gx2rsa,
                               _pw_gx2rs.fixedflag ? (_temp1167_pw_gx2rs=pw_gx2rs,&_temp1167_pw_gx2rs) : &pw_gx2rs, _pw_gx2rsd.fixedflag ? (_temp1168_pw_gx2rsd=pw_gx2rsd,&_temp1168_pw_gx2rsd) : &pw_gx2rsd ))
        {
            epic_error(use_ermes, "%s failed in RScveval.", EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2rs");
            return FAILURE;
        }

        rs_esp  = _rs_esp.fixedflag ?                
                                                
                                                  
                                                
                                                  ((void)(RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd))), rs_esp) : RUP_GRD(pw_gxwrs+IMax(3,(pw_gxwrsd+pw_gxw2rsa+pw_gx2rsa+pw_gx2rs+pw_gx2rsd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2rsa+pw_gy2rs+pw_gy2rsd));

    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(rfshim_yres), _endview_iamprs.fixedflag ? (_temp1169_endview_iamprs=endview_iamprs,&_temp1169_endview_iamprs) : &endview_iamprs) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:RFShim B1 map");
        return FAILURE;
    } 
  
    endview_scalers  = _endview_scalers.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iamprs), endview_scalers) : (float)max_pg_iamp/(float)endview_iamprs;

    if ( FAILURE==amppwtpe(_a_gy1rsa.fixedflag ? (_temp1170_a_gy1rsa=a_gy1rsa,&_temp1170_a_gy1rsa) : &a_gy1rsa, _a_gy1rsb.fixedflag ? (_temp1171_a_gy1rsb=a_gy1rsb,&_temp1171_a_gy1rsb) : &a_gy1rsb, _pw_gy1rs.fixedflag ? (_temp1172_pw_gy1rs=pw_gy1rs,&_temp1172_pw_gy1rs) : &pw_gy1rs, _pw_gy1rsa.fixedflag ? (_temp1173_pw_gy1rsa=pw_gy1rsa,&_temp1173_pw_gy1rsa) : &pw_gy1rsa, _pw_gy1rsd.fixedflag ? (_temp1174_pw_gy1rsd=pw_gy1rsd,&_temp1174_pw_gy1rsd) : &pw_gy1rsd,
                           rsloggrd.ty_xyz/endview_scalers,rsloggrd.yrt,
                           (0.5 * (FLOAT)(rfshim_yres-1))/(rfshim_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:RFShim B1 map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rrs  = _a_gy1rrs.fixedflag ?  ((void)(a_gy1rs), a_gy1rrs) : a_gy1rs;
    a_gy1rrsa  = _a_gy1rrsa.fixedflag ?  ((void)(a_gy1rsa), a_gy1rrsa) : a_gy1rsa;
    a_gy1rrsb  = _a_gy1rrsb.fixedflag ?  ((void)(a_gy1rsb), a_gy1rrsb) : a_gy1rsb;
    pw_gy1rrs  = _pw_gy1rrs.fixedflag ?  ((void)(pw_gy1rs), pw_gy1rrs) : pw_gy1rs;
    pw_gy1rrsa  = _pw_gy1rrsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy1rrsa) : pw_gy1rsa;
    pw_gy1rrsd  = _pw_gy1rrsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy1rrsd) : pw_gy1rsd;

    a_gy2rs  = _a_gy2rs.fixedflag ?  ((void)(a_gy1rs), a_gy2rs) : a_gy1rs;
    a_gy2rsa  = _a_gy2rsa.fixedflag ?  ((void)(a_gy1rsa), a_gy2rsa) : a_gy1rsa;
    a_gy2rsb  = _a_gy2rsb.fixedflag ?  ((void)(a_gy1rsb), a_gy2rsb) : a_gy1rsb;
    pw_gy2rs  = _pw_gy2rs.fixedflag ?  ((void)(pw_gy1rs), pw_gy2rs) : pw_gy1rs;
    pw_gy2rsa  = _pw_gy2rsa.fixedflag ?  ((void)(pw_gy1rsa), pw_gy2rsa) : pw_gy1rsa;
    pw_gy2rsd  = _pw_gy2rsd.fixedflag ?  ((void)(pw_gy1rsd), pw_gy2rsd) : pw_gy1rsd;


    td0rs  = _td0rs.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()))), td0rs) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleadrs+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1rsd + pw_gz1rsa + pw_gz1rs + pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd);
    temp_time2 = IMax(3, pw_gx1rsa + pw_gx1rs + pw_gx1rsd + pw_gxwrsa, pw_gy1rsa + pw_gy1rs + pw_gy1rsd,
                      pw_gzkbsrsa + pw_gzkbsrs + pw_gzkbsrsd);

    min_rste  = _min_rste.fixedflag ?            ((void)(RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0)), min_rste) : RUP_GRD(rst_exb+temp_time+pw_rfbrs+temp_time2+psd_grd_wait+pw_gxwrs/2.0);

    temp_time = IMax(3, pw_gxwrsd + pw_gxkrsa + pw_gxkrs + pw_gxkrsd, pw_gy1rrsa + pw_gy1rrs + pw_gy1rrsd,
                     pw_gzkrsa + pw_gzkrs + pw_gzkrsd);

    tr_rs  = _tr_rs.fixedflag ?              ((void)(RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp)), tr_rs) : RUP_GRD(td0rs+rst_exa+min_rste+pw_gxwrs/2.0+temp_time+time_ssirs+(rfshim_etl-1)*rs_esp);

    return SUCCESS;
} /* end RScveval */

/* 
 *  DTGcveval
 *  Description:
 *  CV eval for DynTG B1map 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
DTGcveval( void )
{
    INT temp_time, temp_time2;
    FLOAT area_gz1dtg, area_gx1dtg;
    FLOAT area_gxkbsdtg, area_gxkdtg, area_gzkbsdtg, area_gzkdtg, area_gx2dtg;
    FLOAT temp_float;
    LONG bw_rf1dtg;
    int maptg_newgeo = 1;
    int rotation_index;

    if ( PSD_ON == enableMapTg)
    {
		for( rotation_index = 0; rotation_index < 9; rotation_index++)
		{
			maptgscan_info[0].oprot[rotation_index] = 0.0;
		}

        /* Axial Scan with Freq R/L */
		maptgscan_info[0].oprot[0] = maptgscan_info[0].oprot[4] = maptgscan_info[0].oprot[8] = 1.0;

		if (obloptimize(&maptgloggrd, &phygrd, maptgscan_info, 1, PSD_OBL,
					0, obl_method, ps1obl_debug, &maptg_newgeo,
					cfsrmode) == FAILURE)
		{
			epic_error(use_ermes, "%s failed in DTGcvinit.", EM_PSD_SUPPORT_FAILURE,
					EE_ARGS(1), STRING_ARG, "obloptimize"); 
			return FAILURE;
		}

		/* derate SR for silent PSC */ 
		sr_derate(&maptgloggrd, PSsr_derate_factor, PSamp_derate_factor);

        dtgloggrd = maptgloggrd; /* Map TG uses Axial scan */
    }
    else
    {
        dtgloggrd = loggrd; /* same as imaging loggrd */
    }

    echo1bwdtg  = _echo1bwdtg.fixedflag ?  ((void)(31.25), echo1bwdtg) : 31.25;
    dynTG_baseline  = _dynTG_baseline.fixedflag ?  ((void)(0), dynTG_baseline) : 0;
    dynTG_xres  = _dynTG_xres.fixedflag ?  ((void)(64), dynTG_xres) : 64;
    dynTG_yres  = _dynTG_yres.fixedflag ?  ((void)(64), dynTG_yres) : 64;
    dynTG_slthick  = _dynTG_slthick.fixedflag ?    ((void)(FMax(2,exist(opslthick),10.0)), dynTG_slthick) : FMax(2,exist(opslthick),10.0);  /* limit min slthick to 10mm */

    if(PSD_ON == enableMapTg)
    {
        /* Setting FOV for map TG */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,480.0,cfsystemmaxfov)), dynTG_fov) : FMin(2,480.0,cfsystemmaxfov);
    }
    else
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMax(2,exist(opfov),80.0)), dynTG_fov) : FMax(2,exist(opfov),80.0);  /* limit to min FOV of 80mm */
        dynTG_fov  = _dynTG_fov.fixedflag ?    ((void)(FMin(2,dynTG_fov,(float)FOV_MAX)), dynTG_fov) : FMin(2,dynTG_fov,(float)FOV_MAX);
    }

    flip_rfbdtg  = _flip_rfbdtg.fixedflag ?  ((void)(180), flip_rfbdtg) : 180;
    flip_rf1dtg  = _flip_rf1dtg.fixedflag ?  ((void)(10), flip_rf1dtg) : 10;

    dynTG_flipangle  = _dynTG_flipangle.fixedflag ?  ((void)(flip_rf1dtg), dynTG_flipangle) : flip_rf1dtg;

    pw_rf1dtg  = _pw_rf1dtg.fixedflag ?  ((void)(RUP_GRD(pw_rf1dtg)), pw_rf1dtg) : RUP_GRD(pw_rf1dtg);

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            bw_rf1dtg = (LONG)(4*cyc_rf1dtg/((float)pw_rf1dtg/(float)1000000));
            dtg_iso_delay   = _dtg_iso_delay.fixedflag ?      
 ((void)(RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw)), dtg_iso_delay) : RUP_GRD(pw_rf1dtg/2.0+(float)dtg_off90*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw);
            break;
        case B1RF1_TBW:
        default:
            bw_rf1dtg = (LONG)(rfpulse[RF1_DYNTG_SLOT].nom_bw*rfpulse[RF1_DYNTG_SLOT].nom_pw/pw_rf1dtg);
            dtg_iso_delay  = _dtg_iso_delay.fixedflag ?  
                                          ((void)(RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw))), dtg_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_DYNTG_SLOT].isodelay*pw_rf1dtg/rfpulse[RF1_DYNTG_SLOT].nom_pw));
            break;
    }

    if(PSD_ON == enableMapTg)
    {
        dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(MAPTG_SLQ), dynTG_slquant) : MAPTG_SLQ;
    }
    else
    {
        if (exist(opslquant)<=DYNTG_SLQ)
        {
            if (1 == (exist(opslquant) % 2))
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(exist(opslquant)), dynTG_slquant) : exist(opslquant);
            }
            else
            {
                dynTG_slquant  = _dynTG_slquant.fixedflag ?    ((void)(exist(opslquant)-1), dynTG_slquant) : exist(opslquant)-1;
            }
        }
        else
        {
            dynTG_slquant  = _dynTG_slquant.fixedflag ?  ((void)(DYNTG_SLQ), dynTG_slquant) : DYNTG_SLQ;
        }
    }

    /********************************************************/
    /*   Z Board                                            */
    /*   Slice Selection                                    */
    /********************************************************/
    pw_gzrf1dtg  = _pw_gzrf1dtg.fixedflag ?  ((void)(pw_rf1dtg), pw_gzrf1dtg) : pw_rf1dtg;

    if (FAILURE==ampslice(_a_gzrf1dtg.fixedflag ? (_temp1175_a_gzrf1dtg=a_gzrf1dtg,&_temp1175_a_gzrf1dtg) : &a_gzrf1dtg, bw_rf1dtg, dynTG_slthick, gscale_rf1dtg, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampslice for gzrf1dtg.");

        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gzrf1dtga.fixedflag ? (_temp1176_pw_gzrf1dtga=pw_gzrf1dtga,&_temp1176_pw_gzrf1dtga) : &pw_gzrf1dtga, a_gzrf1dtg, dtgloggrd.tz_xyz, dtgloggrd.zrt, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for gzrf1dtga.");
        return FAILURE;
    }
    pw_gzrf1dtgd  = _pw_gzrf1dtgd.fixedflag ?  ((void)(pw_gzrf1dtga), pw_gzrf1dtgd) : pw_gzrf1dtga;

    /* Z BLS killer */
    area_gzkbsdtg = 1.0E6*3.0*10.0/GAM/exist(dynTG_slthick);

    if (FAILURE==amppwgrad(area_gzkbsdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkbsdtg.fixedflag ? (_temp1177_a_gzkbsdtg=a_gzkbsdtg,&_temp1177_a_gzkbsdtg) : &a_gzkbsdtg, _pw_gzkbsdtga.fixedflag ? (_temp1178_pw_gzkbsdtga=pw_gzkbsdtga,&_temp1178_pw_gzkbsdtga) : &pw_gzkbsdtga,
                           _pw_gzkbsdtg.fixedflag ? (_temp1179_pw_gzkbsdtg=pw_gzkbsdtg,&_temp1179_pw_gzkbsdtg) : &pw_gzkbsdtg, _pw_gzkbsdtgd.fixedflag ? (_temp1180_pw_gzkbsdtgd=pw_gzkbsdtgd,&_temp1180_pw_gzkbsdtgd) : &pw_gzkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkbsdtg"); 
        return FAILURE;
    }

    if (a_gzrf1dtg>0.0)
    {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gzkbsdtg)), a_gzkbsdtg) : -1.0*fabsf(a_gzkbsdtg);
    } else {
        a_gzkbsdtg  = _a_gzkbsdtg.fixedflag ?  ((void)(fabsf(a_gzkbsdtg)), a_gzkbsdtg) : fabsf(a_gzkbsdtg);
    }

    dtgt_exa  = _dtgt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay)), dtgt_exa) : RUP_GRD(pw_gzrf1dtga+pw_gzrf1dtg-dtg_iso_delay);
    dtgt_exb  = _dtgt_exb.fixedflag ?  ((void)(dtg_iso_delay), dtgt_exb) : dtg_iso_delay;

    area_gz1dtg = (dtg_iso_delay + (pw_gzrf1dtgd/ 2.0)) * a_gzrf1dtg;
    if (area_gz1dtg > 0.0)
    {
        area_gz1dtg -= fabsf(area_gzkbsdtg);
    }
    else
    {
        area_gz1dtg += fabsf(area_gzkbsdtg);
    }

    if (amppwgz1(_a_gz1dtg.fixedflag ? (_temp1181_a_gz1dtg=a_gz1dtg,&_temp1181_a_gz1dtg) : &a_gz1dtg,_pw_gz1dtg.fixedflag ? (_temp1182_pw_gz1dtg=pw_gz1dtg,&_temp1182_pw_gz1dtg) : &pw_gz1dtg,_pw_gz1dtga.fixedflag ? (_temp1183_pw_gz1dtga=pw_gz1dtga,&_temp1183_pw_gz1dtga) : &pw_gz1dtga,_pw_gz1dtgd.fixedflag ? (_temp1184_pw_gz1dtgd=pw_gz1dtgd,&_temp1184_pw_gz1dtgd) : &pw_gz1dtgd,area_gz1dtg,
                 (int)(1000000),MIN_PLATEAU_TIME,dtgloggrd.zrt,dtgloggrd.tz_xz) == FAILURE)
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgz1 for gz1dtg.");
        return FAILURE;
    }

    /* Z killer */
    area_gzkdtg = 980;

    if (FAILURE==amppwgrad(area_gzkdtg, dtgloggrd.tz_xyz, 0.0, 0.0, dtgloggrd.zrt,
                           MIN_PLATEAU_TIME, _a_gzkdtg.fixedflag ? (_temp1185_a_gzkdtg=a_gzkdtg,&_temp1185_a_gzkdtg) : &a_gzkdtg, _pw_gzkdtga.fixedflag ? (_temp1186_pw_gzkdtga=pw_gzkdtga,&_temp1186_pw_gzkdtga) : &pw_gzkdtga,
                           _pw_gzkdtg.fixedflag ? (_temp1187_pw_gzkdtg=pw_gzkdtg,&_temp1187_pw_gzkdtg) : &pw_gzkdtg, _pw_gzkdtgd.fixedflag ? (_temp1188_pw_gzkdtgd=pw_gzkdtgd,&_temp1188_pw_gzkdtgd) : &pw_gzkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gzkdtg"); 
        return FAILURE;
    }

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1dtg_filt, echo1bwdtg, dynTG_xres, OVERWRITE_NONE) ) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1dtg_filt");

        return FAILURE;
    }

    if ( FAILURE==ampfov(&temp_float, echo1dtg_filt.bw, dtgloggrd.tx) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov");
        return FAILURE;
    }

    temp_float = ceil(temp_float/ 10.0) * 10.0;
    if( temp_float > dynTG_fov )
    {
        dynTG_fov  = _dynTG_fov.fixedflag ?  ((void)(temp_float), dynTG_fov) : temp_float;
    }

    if ( FAILURE==ampfov(_a_gxwdtg.fixedflag ? (_temp1189_a_gxwdtg=a_gxwdtg,&_temp1189_a_gxwdtg) : &a_gxwdtg, echo1dtg_filt.bw, dynTG_fov) )
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "ampfov for gxwdtg.");
        return FAILURE;
    }

    if (FAILURE==optramp(_pw_gxwdtga.fixedflag ? (_temp1190_pw_gxwdtga=pw_gxwdtga,&_temp1190_pw_gxwdtga) : &pw_gxwdtga, a_gxwdtg, dtgloggrd.tx_xyz, dtgloggrd.xrt, TYPDEF)) 
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwdtga.");
        return FAILURE;
    }

    pw_gxwdtgd  = _pw_gxwdtgd.fixedflag ?  ((void)(pw_gxwdtga), pw_gxwdtgd) : pw_gxwdtga;
    pw_acqdtg1  = _pw_acqdtg1.fixedflag ?  ((void)(echo1dtg_filt.tdaq), pw_acqdtg1) : echo1dtg_filt.tdaq;  /* one echo data */

    rd_ext_dtg  = _rd_ext_dtg.fixedflag ?  
                           ((void)(RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr)), rd_ext_dtg) : RUP_GRD(attenlen+tns_len+XTR_length[bd_index]+RBA_length[bd_index]+DAB_length[bd_index]+fast_xtr);

    pw_gxwdtg  = _pw_gxwdtg.fixedflag ?      ((void)(pw_acqdtg1+e2_delay_dtg+rd_ext_dtg), pw_gxwdtg) : pw_acqdtg1+e2_delay_dtg+rd_ext_dtg;  /* total readout */

    /* X BLS killer */
    area_gxkbsdtg = area_gzkbsdtg;

    if (FAILURE==amppwgrad(area_gxkbsdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkbsdtg.fixedflag ? (_temp1191_a_gxkbsdtg=a_gxkbsdtg,&_temp1191_a_gxkbsdtg) : &a_gxkbsdtg, _pw_gxkbsdtga.fixedflag ? (_temp1192_pw_gxkbsdtga=pw_gxkbsdtga,&_temp1192_pw_gxkbsdtga) : &pw_gxkbsdtga,
                           _pw_gxkbsdtg.fixedflag ? (_temp1193_pw_gxkbsdtg=pw_gxkbsdtg,&_temp1193_pw_gxkbsdtg) : &pw_gxkbsdtg, _pw_gxkbsdtgd.fixedflag ? (_temp1194_pw_gxkbsdtgd=pw_gxkbsdtgd,&_temp1194_pw_gxkbsdtgd) : &pw_gxkbsdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkbsdtg"); 
        return FAILURE;
    }

    if (a_gxwdtg>0.0)
    {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(-1.0*fabsf(a_gxkbsdtg)), a_gxkbsdtg) : -1.0*fabsf(a_gxkbsdtg);
    } else {
        a_gxkbsdtg  = _a_gxkbsdtg.fixedflag ?  ((void)(fabsf(a_gxkbsdtg)), a_gxkbsdtg) : fabsf(a_gxkbsdtg);
    }

    /* combine gxkbs and gx1dtg */
    area_gx1dtg = area_gxkbsdtg - (pw_gxwdtg+pw_gxwdtga)/2.0*a_gxwdtg;

    if (FAILURE==amppwgrad(area_gx1dtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gx1dtg.fixedflag ? (_temp1195_a_gx1dtg=a_gx1dtg,&_temp1195_a_gx1dtg) : &a_gx1dtg, _pw_gx1dtga.fixedflag ? (_temp1196_pw_gx1dtga=pw_gx1dtga,&_temp1196_pw_gx1dtga) : &pw_gx1dtga,
                           _pw_gx1dtg.fixedflag ? (_temp1197_pw_gx1dtg=pw_gx1dtg,&_temp1197_pw_gx1dtg) : &pw_gx1dtg, _pw_gx1dtgd.fixedflag ? (_temp1198_pw_gx1dtgd=pw_gx1dtgd,&_temp1198_pw_gx1dtgd) : &pw_gx1dtgd ))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwgx1 for gx1dtg.");
        return FAILURE;
    }

    /* X Killer */
    area_gxkdtg = 980;
    if (FAILURE==amppwgrad(area_gxkdtg, dtgloggrd.tx_xyz, 0.0, 0.0, dtgloggrd.xrt,
                           MIN_PLATEAU_TIME, _a_gxkdtg.fixedflag ? (_temp1199_a_gxkdtg=a_gxkdtg,&_temp1199_a_gxkdtg) : &a_gxkdtg, _pw_gxkdtga.fixedflag ? (_temp1200_pw_gxkdtga=pw_gxkdtga,&_temp1200_pw_gxkdtga) : &pw_gxkdtga,
                           _pw_gxkdtg.fixedflag ? (_temp1201_pw_gxkdtg=pw_gxkdtg,&_temp1201_pw_gxkdtg) : &pw_gxkdtg, _pw_gxkdtgd.fixedflag ? (_temp1202_pw_gxkdtgd=pw_gxkdtgd,&_temp1202_pw_gxkdtgd) : &pw_gxkdtgd ))
    {
        epic_error(use_ermes, "%s failed in DTGcveval.",
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                   STRING_ARG,"amppwgrad:gxkdtg"); 
        return FAILURE;
    }

    /* echo train */
    if(dynTG_etl >= 2)
    {
        pw_gxw2dtg  = _pw_gxw2dtg.fixedflag ?  ((void)(pw_gxwdtg), pw_gxw2dtg) : pw_gxwdtg;
        pw_gxw2dtga  = _pw_gxw2dtga.fixedflag ?  ((void)(pw_gxwdtga), pw_gxw2dtga) : pw_gxwdtga;
        pw_gxw2dtgd  = _pw_gxw2dtgd.fixedflag ?  ((void)(pw_gxwdtgd), pw_gxw2dtgd) : pw_gxwdtgd;
        a_gxw2dtg  = _a_gxw2dtg.fixedflag ?  ((void)(a_gxwdtg), a_gxw2dtg) : a_gxwdtg;

        area_gx2dtg = -(pw_gxwdtg+(pw_gxwdtga+pw_gxwdtgd)/2.0)*a_gxwdtg;

        if (FAILURE==amppwgrad(area_gx2dtg, dtgloggrd.tx_xy, 0.0, 0.0, dtgloggrd.xrt,
                               MIN_PLATEAU_TIME, _a_gx2dtg.fixedflag ? (_temp1203_a_gx2dtg=a_gx2dtg,&_temp1203_a_gx2dtg) : &a_gx2dtg, _pw_gx2dtga.fixedflag ? (_temp1204_pw_gx2dtga=pw_gx2dtga,&_temp1204_pw_gx2dtga) : &pw_gx2dtga,
                               _pw_gx2dtg.fixedflag ? (_temp1205_pw_gx2dtg=pw_gx2dtg,&_temp1205_pw_gx2dtg) : &pw_gx2dtg, _pw_gx2dtgd.fixedflag ? (_temp1206_pw_gx2dtgd=pw_gx2dtgd,&_temp1206_pw_gx2dtgd) : &pw_gx2dtgd ))
        {
            epic_error(use_ermes, "%s failed in DTGcveval.",
                       EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),
                       STRING_ARG,"amppwgrad:gx2dtg"); 
            return FAILURE;
        }

        dtg_esp  = _dtg_esp.fixedflag ?                
                                        
                                            
                                        
                                          ((void)(RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd))), dtg_esp) : RUP_GRD(pw_gxwdtg+IMax(3,(pw_gxwdtgd+pw_gxw2dtga+pw_gx2dtga+pw_gx2dtg+pw_gx2dtgd),attenlen+tns_len+IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]))+RBA_length[bd_index]+psd_grd_wait,pw_gy2dtga+pw_gy2dtg+pw_gy2dtgd));
    }

    /***************************************************************/
    /*   Y Board - Dephaser and Killer                             */
    /*                                                             */
    /*   Calculate Y Phase encode amp and pw.                      */
    /*                                                             */
    /***************************************************************/

    /* Scale the waveform amps for the phase encodes 
     * so each phase instruction jump is an integer step */
    if ( FAILURE==endview((int)(dynTG_yres), _endview_iampdtg.fixedflag ? (_temp1207_endview_iampdtg=endview_iampdtg,&_temp1207_endview_iampdtg) : &endview_iampdtg) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "endview:DynTG B1 map");
        return FAILURE;
    } 
  
    endview_scaledtg  = _endview_scaledtg.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampdtg), endview_scaledtg) : (float)max_pg_iamp/(float)endview_iampdtg;

    if ( FAILURE==amppwtpe(_a_gy1dtga.fixedflag ? (_temp1208_a_gy1dtga=a_gy1dtga,&_temp1208_a_gy1dtga) : &a_gy1dtga, _a_gy1dtgb.fixedflag ? (_temp1209_a_gy1dtgb=a_gy1dtgb,&_temp1209_a_gy1dtgb) : &a_gy1dtgb, _pw_gy1dtg.fixedflag ? (_temp1210_pw_gy1dtg=pw_gy1dtg,&_temp1210_pw_gy1dtg) : &pw_gy1dtg, _pw_gy1dtga.fixedflag ? (_temp1211_pw_gy1dtga=pw_gy1dtga,&_temp1211_pw_gy1dtga) : &pw_gy1dtga, _pw_gy1dtgd.fixedflag ? (_temp1212_pw_gy1dtgd=pw_gy1dtgd,&_temp1212_pw_gy1dtgd) : &pw_gy1dtgd,
                           dtgloggrd.ty_xyz/endview_scaledtg,dtgloggrd.yrt,
                           (0.5 * (FLOAT)(dynTG_yres-1))/(dynTG_fov * 0.1) * 1.0e6/ GAM) ) 
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:DynTG map");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rdtg  = _a_gy1rdtg.fixedflag ?  ((void)(a_gy1dtg), a_gy1rdtg) : a_gy1dtg;
    a_gy1rdtga  = _a_gy1rdtga.fixedflag ?  ((void)(a_gy1dtga), a_gy1rdtga) : a_gy1dtga;
    a_gy1rdtgb  = _a_gy1rdtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy1rdtgb) : a_gy1dtgb;
    pw_gy1rdtg  = _pw_gy1rdtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy1rdtg) : pw_gy1dtg;
    pw_gy1rdtga  = _pw_gy1rdtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy1rdtga) : pw_gy1dtga;
    pw_gy1rdtgd  = _pw_gy1rdtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy1rdtgd) : pw_gy1dtgd;

    a_gy2dtg  = _a_gy2dtg.fixedflag ?  ((void)(a_gy1dtg), a_gy2dtg) : a_gy1dtg;
    a_gy2dtga  = _a_gy2dtga.fixedflag ?  ((void)(a_gy1dtga), a_gy2dtga) : a_gy1dtga;
    a_gy2dtgb  = _a_gy2dtgb.fixedflag ?  ((void)(a_gy1dtgb), a_gy2dtgb) : a_gy1dtgb;
    pw_gy2dtg  = _pw_gy2dtg.fixedflag ?  ((void)(pw_gy1dtg), pw_gy2dtg) : pw_gy1dtg;
    pw_gy2dtga  = _pw_gy2dtga.fixedflag ?  ((void)(pw_gy1dtga), pw_gy2dtga) : pw_gy1dtga;
    pw_gy2dtgd  = _pw_gy2dtgd.fixedflag ?  ((void)(pw_gy1dtgd), pw_gy2dtgd) : pw_gy1dtgd;

    td0dtg  = _td0dtg.fixedflag ?      ((void)(RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()))), td0dtg) : RUP_GRD((int)(GRAD_UPDATE_TIME+tleaddtg+minimumPreRfSspTime()));

    temp_time = IMax(2, pw_gzrf1dtgd + pw_gz1dtga + pw_gz1dtg + pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd);
    temp_time2 = IMax(3, pw_gx1dtga + pw_gx1dtg + pw_gx1dtgd + pw_gxwdtga, pw_gy1dtga + pw_gy1dtg + pw_gy1dtgd,
                      pw_gzkbsdtga + pw_gzkbsdtg + pw_gzkbsdtgd);

    min_dtgte  = _min_dtgte.fixedflag ?            ((void)(RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0)), min_dtgte) : RUP_GRD(dtgt_exb+temp_time+pw_rfbdtg+temp_time2+psd_grd_wait+pw_gxwdtg/2.0); 

    temp_time = IMax(3, pw_gxwdtgd + pw_gxkdtga + pw_gxkdtg + pw_gxkdtgd, pw_gy1rdtga + pw_gy1rdtg + pw_gy1rdtgd,
                     pw_gzkdtga + pw_gzkdtg + pw_gzkdtgd);

    tr_dtg  = _tr_dtg.fixedflag ?              ((void)(RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp)), tr_dtg) : RUP_GRD(td0dtg+dtgt_exa+min_dtgte+pw_gxwdtg/2.0+temp_time+time_ssidtg+(dynTG_etl-1)*dtg_esp);

    return SUCCESS;
} /* end DTGcveval */


/* 
 *  ExtCalcveval
 *  Description:
 *  CV eval for ExtCal entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
ExtCalcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_cal;
    FLOAT encode_cal = 0.0;
    FLOAT a_delta_cal = 0.0;
    FLOAT encode_cal2 = 0.0;
    FLOAT a_delta_cal2 = 0.0;
    FLOAT area_gxwcal;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;
    INT temp_time;


    if(coilInfo[0].pureCompatible > 0)
    {
        cvoverride(cal_pass, 2, PSD_FIX_ON, PSD_EXIST_ON);
    }
    else
    {
        cvoverride(cal_pass, 1, PSD_FIX_ON, PSD_EXIST_ON);
    }

    /* freq/phase scaling for image cut reduction */
    cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(calscan_info[0].opfov_freq_scale), cal_freq_scale) : calscan_info[0].opfov_freq_scale;
    cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(calscan_info[0].opfov_phase_scale), cal_phase_scale) : calscan_info[0].opfov_phase_scale;

    if(cal_freq_scale <= 0.0)
    {
        cal_freq_scale  = _cal_freq_scale.fixedflag ?  ((void)(1.0), cal_freq_scale) : 1.0;
    }
    if(cal_phase_scale <= 0.0)
    {
        cal_phase_scale  = _cal_phase_scale.fixedflag ?  ((void)(1.0), cal_phase_scale) : 1.0;
    }
    cal_xfov  = _cal_xfov.fixedflag ?  ((void)(cal_fov*cal_freq_scale), cal_xfov) : cal_fov*cal_freq_scale;
    cal_yfov  = _cal_yfov.fixedflag ?  ((void)(cal_fov*cal_phase_scale), cal_yfov) : cal_fov*cal_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1cal  = _pw_gzrf1cal.fixedflag ?  ((void)(pw_rf1cal), pw_gzrf1cal) : pw_rf1cal;

    cal_vthick  = _cal_vthick.fixedflag ?    ((void)(cal_slthick*cal_slq), cal_vthick) : cal_slthick*cal_slq;
    bw_rf1cal  = _bw_rf1cal.fixedflag ?  ((void)((int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal), bw_rf1cal) : (int)rfpulse[RF1_EXTCAL_SLOT].nom_bw*rfpulse[RF1_EXTCAL_SLOT].nom_pw/pw_rf1cal;

    if (ampslice(_a_gzrf1cal.fixedflag ? (_temp1213_a_gzrf1cal=a_gzrf1cal,&_temp1213_a_gzrf1cal) : &a_gzrf1cal, bw_rf1cal, cal_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1cal)");
        return FAILURE;
    }

    a_gzrf1cal  = _a_gzrf1cal.fixedflag ?    ((void)(cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal), a_gzrf1cal) : cal_ampscale*cal_slq/(cal_slq-4)*a_gzrf1cal;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp1214_cal_amplimit=cal_amplimit,&_temp1214_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz);

    if(a_gzrf1cal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tz;
        target_risetime = calloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1cala.fixedflag ? (_temp1215_pw_gzrf1cala=pw_gzrf1cala,&_temp1215_pw_gzrf1cala) : &pw_gzrf1cala, a_gzrf1cal, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1cala)");
        return FAILURE;
    }
    pw_gzrf1cald  = _pw_gzrf1cald.fixedflag ?  ((void)(pw_gzrf1cala), pw_gzrf1cald) : pw_gzrf1cala;

    if (endview(cal_slq, _endviewz_iampcal.fixedflag ? (_temp1216_endviewz_iampcal=endviewz_iampcal,&_temp1216_endviewz_iampcal) : &endviewz_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcal");
        return FAILURE;
    } 

    endviewz_scalecal  = _endviewz_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcal), endviewz_scalecal) : (float)max_pg_iamp/(float)endviewz_iampcal;

    refocus_cal = fabs(a_gzrf1cal)*(cal_iso_delay + pw_gzrf1cald/2.0);
    temp_area = (0.5 * (FLOAT)(cal_slq-1))/(cal_vthick * 0.1) * 1.0e6/ GAM;

    /* Z slice encode + gzrf1 refocus */
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp1217_cal_amplimit=cal_amplimit,&_temp1217_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tz_xyz);
    target_amp = cal_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    if ( FAILURE==amppwtpe(_a_gzcombcala.fixedflag ? (_temp1218_a_gzcombcala=a_gzcombcala,&_temp1218_a_gzcombcala) : &a_gzcombcala, _a_gzcombcalb.fixedflag ? (_temp1219_a_gzcombcalb=a_gzcombcalb,&_temp1219_a_gzcombcalb) : &a_gzcombcalb, _pw_gzcombcal.fixedflag ? (_temp1220_pw_gzcombcal=pw_gzcombcal,&_temp1220_pw_gzcombcal) : &pw_gzcombcal, 
                           _pw_gzcombcala.fixedflag ? (_temp1221_pw_gzcombcala=pw_gzcombcala,&_temp1221_pw_gzcombcala) : &pw_gzcombcala, _pw_gzcombcald.fixedflag ? (_temp1222_pw_gzcombcald=pw_gzcombcald,&_temp1222_pw_gzcombcald) : &pw_gzcombcald,
                           target_amp, target_risetime,
                           temp_area + refocus_cal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode cal");
        return FAILURE;
    }

    encode_cal = 0.5*(float)pw_gzcombcala*a_gzcombcala + 0.5*(float)pw_gzcombcal*(a_gzcombcala
             + a_gzcombcalb) + 0.5*(float)pw_gzcombcald*a_gzcombcalb - fabs(refocus_cal);

    a_delta_cal = 4.0*encode_cal/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcal + (float)pw_gzcombcald);
    
    /* max neg amp */
    a_combcal  = _a_combcal.fixedflag ?  ((void)(a_gzcombcalb), a_combcal) : a_gzcombcalb;

    /* max positive amp */
    a_endcal  = _a_endcal.fixedflag ?    ((void)(a_combcal-a_delta_cal*(float)(cal_slq-1)), a_endcal) : a_combcal-a_delta_cal*(float)(cal_slq-1);

    a_gzcombcal  = _a_gzcombcal.fixedflag ?  ((void)(-a_combcal), a_gzcombcal) : -a_combcal;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcala.fixedflag ? (_temp1223_a_gzprcala=a_gzprcala,&_temp1223_a_gzprcala) : &a_gzprcala, _a_gzprcalb.fixedflag ? (_temp1224_a_gzprcalb=a_gzprcalb,&_temp1224_a_gzprcalb) : &a_gzprcalb, _pw_gzprcal.fixedflag ? (_temp1225_pw_gzprcal=pw_gzprcal,&_temp1225_pw_gzprcal) : &pw_gzprcal, 
                           _pw_gzprcala.fixedflag ? (_temp1226_pw_gzprcala=pw_gzprcala,&_temp1226_pw_gzprcala) : &pw_gzprcala, _pw_gzprcald.fixedflag ? (_temp1227_pw_gzprcald=pw_gzprcald,&_temp1227_pw_gzprcald) : &pw_gzprcald,
                           target_amp, target_risetime,
                           temp_area + area_gzkcal) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr cal rewinder");
        return FAILURE;
    }
    encode_cal2 = 0.5*(float)pw_gzprcala*a_gzprcala + 0.5*(float)pw_gzprcal*(a_gzprcala
             + a_gzprcalb) + 0.5*(float)pw_gzprcald*a_gzprcalb - area_gzkcal;

    a_delta_cal2 = 4.0*encode_cal2/(float)(cal_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcala +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcal + (float)pw_gzprcald);
    
    /* max neg amp */
    a_combcal2  = _a_combcal2.fixedflag ?  ((void)(a_gzprcalb), a_combcal2) : a_gzprcalb;

    /* max positive amp */
    a_endcal2  = _a_endcal2.fixedflag ?    ((void)(a_combcal2-a_delta_cal2*(float)(cal_slq-1.0)), a_endcal2) : a_combcal2-a_delta_cal2*(float)(cal_slq-1.0);

    a_gzprcal  = _a_gzprcal.fixedflag ?  ((void)(a_combcal2), a_gzprcal) : a_combcal2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1cal_filt, echo1bwcal, cal_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "calcfilter for echo1cal_filt");

        return FAILURE;
    }

    if((echo1bwcal > 0) && (cal_xfov > 0.0))
    {
        a_gxwcal  = _a_gxwcal.fixedflag ?          ((void)((FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov)), a_gxwcal) : (FLOAT)(2*echo1bwcal*1000/GAM)*(10.0/cal_xfov);
    }
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcal");
        return FAILURE;
    }

    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp1228_cal_amplimit=cal_amplimit,&_temp1228_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if(a_gxwcal <= cal_amplimit)
    {
        target_amp = cal_amplimit;
    }
    else
    {
        target_amp = calloggrd.tx_xyz;
        target_risetime = calloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcala.fixedflag ? (_temp1229_pw_gxwcala=pw_gxwcala,&_temp1229_pw_gxwcala) : &pw_gxwcala, a_gxwcal, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcala.");
        return FAILURE;
    }
    pw_gxwcald  = _pw_gxwcald.fixedflag ?  ((void)(pw_gxwcala), pw_gxwcald) : pw_gxwcala;

    tacq_cal  = _tacq_cal.fixedflag ?  ((void)(RUP_GRD(echo1cal_filt.tdaq)), tacq_cal) : RUP_GRD(echo1cal_filt.tdaq);

    /* Gx1 */
    area_gxwcal = a_gxwcal*tacq_cal;
    temp_area = 0.5*a_gxwcal*pw_gxwcala;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp1230_cal_amplimit=cal_amplimit,&_temp1230_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.tx_xyz);
    if (amppwgx1(_a_gx1cal.fixedflag ? (_temp1231_a_gx1cal=a_gx1cal,&_temp1231_a_gx1cal) : &a_gx1cal, _pw_gx1cal.fixedflag ? (_temp1232_pw_gx1cal=pw_gx1cal,&_temp1232_pw_gx1cal) : &pw_gx1cal, _pw_gx1cala.fixedflag ? (_temp1233_pw_gx1cala=pw_gx1cala,&_temp1233_pw_gx1cala) : &pw_gx1cala, _pw_gx1cald.fixedflag ? (_temp1234_pw_gx1cald=pw_gx1cald,&_temp1234_pw_gx1cald) : &pw_gx1cald,
                 (int)TYPGRAD, area_gxwcal, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, cal_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1cal");
    }

    /* X killer -- ext gxwcal */
    temp_area = 5.0e6 * cal_xres/(cal_fov*GAM);
    pw_gxwcal  = _pw_gxwcal.fixedflag ?        ((void)(IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2))), pw_gxwcal) : IMax(2,tacq_cal,RUP_GRD(tacq_cal+temp_area/a_gxwcal-pw_gxwcald/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(cal_yres, _endview_iampcal.fixedflag ? (_temp1235_endview_iampcal=endview_iampcal,&_temp1235_endview_iampcal) : &endview_iampcal) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for cal");
        return FAILURE;
    } 

    endview_scalecal  = _endview_scalecal.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcal), endview_scalecal) : (float)max_pg_iamp/(float)endview_iampcal;
    amp_rt_dbdtopt(_cal_amplimit.fixedflag ? (_temp1236_cal_amplimit=cal_amplimit,&_temp1236_cal_amplimit) : &cal_amplimit, &target_risetime, cal_slewrate, 1.0, calloggrd.ty_xyz);
    target_amp = cal_amplimit/endview_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecal));  /* rise time for target amp */
    
    if ( FAILURE==amppwtpe(_a_gy1cala.fixedflag ? (_temp1237_a_gy1cala=a_gy1cala,&_temp1237_a_gy1cala) : &a_gy1cala, _a_gy1calb.fixedflag ? (_temp1238_a_gy1calb=a_gy1calb,&_temp1238_a_gy1calb) : &a_gy1calb, _pw_gy1cal.fixedflag ? (_temp1239_pw_gy1cal=pw_gy1cal,&_temp1239_pw_gy1cal) : &pw_gy1cal, _pw_gy1cala.fixedflag ? (_temp1240_pw_gy1cala=pw_gy1cala,&_temp1240_pw_gy1cala) : &pw_gy1cala, _pw_gy1cald.fixedflag ? (_temp1241_pw_gy1cald=pw_gy1cald,&_temp1241_pw_gy1cald) : &pw_gy1cald,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(cal_yres-1))/(cal_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: cal ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcal  = _a_gy1rcal.fixedflag ?  ((void)(a_gy1cal), a_gy1rcal) : a_gy1cal;
    a_gy1rcala  = _a_gy1rcala.fixedflag ?  ((void)(a_gy1cala), a_gy1rcala) : a_gy1cala;
    a_gy1rcalb  = _a_gy1rcalb.fixedflag ?  ((void)(a_gy1calb), a_gy1rcalb) : a_gy1calb;
    pw_gy1rcal  = _pw_gy1rcal.fixedflag ?  ((void)(pw_gy1cal), pw_gy1rcal) : pw_gy1cal;
    pw_gy1rcala  = _pw_gy1rcala.fixedflag ?  ((void)(pw_gy1cala), pw_gy1rcala) : pw_gy1cala;
    pw_gy1rcald  = _pw_gy1rcald.fixedflag ?  ((void)(pw_gy1cald), pw_gy1rcald) : pw_gy1cald;


    td0cal  = _td0cal.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0cal) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0cal  = _td0cal.fixedflag ?    ((void)(RUP_GRD((int)(td0cal+tleadcal))), td0cal) : RUP_GRD((int)(td0cal+tleadcal));

    cal_iso_delay  = _cal_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw))), cal_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_EXTCAL_SLOT].isodelay*pw_rf1cal/rfpulse[RF1_EXTCAL_SLOT].nom_pw));

    calt_exa  = _calt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay)), calt_exa) : RUP_GRD(pw_gzrf1cala+pw_gzrf1cal-cal_iso_delay);
    calt_exb  = _calt_exb.fixedflag ?  ((void)(cal_iso_delay), calt_exb) : cal_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcala + pw_gx1cala + pw_gx1cal + pw_gx1cald,
                     pw_gy1cala + pw_gy1cal + pw_gy1cald,
                     pw_gzrf1cald + pw_gzcombcala + pw_gzcombcal + pw_gzcombcald);

    te_cal  = _te_cal.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0))), te_cal) : IMax(2,500,RUP_GRD(calt_exb+temp_time+tacq_cal/2.0));

    temp_time = IMax(3, pw_gxwcald + pw_gxwcal - tacq_cal,
                     pw_gy1rcala + pw_gy1rcal + pw_gy1rcald,
                     pw_gzprcala + pw_gzprcal + pw_gzprcald);
    tr_cal  = _tr_cal.fixedflag ?              ((void)(RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical)), tr_cal) : RUP_GRD(td0cal+calt_exa+te_cal+tacq_cal/2.0+temp_time+psd_grd_wait+time_ssical);

    cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;

    if(cal_pass > 1)
    {
        char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
        getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);

        if (B0_30000 == cffield)
        {
            if ((isDVSystem() || isRioSystem()) &&
                ((isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strcmp(attribute_codeMeaning, "Breast"))
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_ABDOMEN)
                 || isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_PELVIS)))
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_ON), cal_tr_interleave) : PSD_ON;
            }
            else
            {
                cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_ON), cal_nex_interleave) : PSD_ON;
                cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
            }
        }
        else
        {
            cal_nex_interleave  = _cal_nex_interleave.fixedflag ?  ((void)(PSD_OFF), cal_nex_interleave) : PSD_OFF;
            cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
        }
    }

    /* set up CV cal_interleave mode */
    if (cal_nex_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NEX_INTERLEAVED), cal_interleave) : CAL_NEX_INTERLEAVED;
        cal_tr_interleave  = _cal_tr_interleave.fixedflag ?  ((void)(PSD_OFF), cal_tr_interleave) : PSD_OFF;
    }
    else if (cal_tr_interleave)
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_TR_INTERLEAVED), cal_interleave) : CAL_TR_INTERLEAVED;
    }
    else
    {
        cal_interleave  = _cal_interleave.fixedflag ?  ((void)(CAL_NONE_INTERLEAVED), cal_interleave) : CAL_NONE_INTERLEAVED;
    }

    cal_delay_dda  = _cal_delay_dda.fixedflag ?  ((void)(((int)(cal_delay/(float)tr_cal)/2)*2), cal_delay_dda) : ((int)(cal_delay/(float)tr_cal)/2)*2;  /* delay for long T1 signal to recover */


    return SUCCESS;
} /* End of ExtCalcveval */


/* 
 *  AutoCoilcveval
 *  Description:
 *  CV eval for AutoCoil entry point 
 *  
 *  Type: Public Function
 *  
 *  
 */
STATUS
AutoCoilcveval( void )
{
    FLOAT temp_area;
    FLOAT refocus_coil;
    FLOAT encode_coil = 0.0;
    FLOAT a_delta_coil = 0.0;
    FLOAT encode_coil2 = 0.0;
    FLOAT a_delta_coil2 = 0.0;
    FLOAT area_gxwcoil;
    FLOAT area_gzkcoil = 300.0;
    INT temp_time;
    FLOAT target_amp = 1.0;
    INT target_risetime = 4;

    /* freq/phase scaling for image cut reduction */
    coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_freq_scale), coil_freq_scale) : coilscan_info[0].opfov_freq_scale;
    coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(coilscan_info[0].opfov_phase_scale), coil_phase_scale) : coilscan_info[0].opfov_phase_scale;

    if(coil_freq_scale <= 0.0)
    {
        coil_freq_scale  = _coil_freq_scale.fixedflag ?  ((void)(1.0), coil_freq_scale) : 1.0;
    }
    if(coil_phase_scale <= 0.0)
    {
        coil_phase_scale  = _coil_phase_scale.fixedflag ?  ((void)(1.0), coil_phase_scale) : 1.0;
    }
    coil_xfov  = _coil_xfov.fixedflag ?  ((void)(coil_fov*coil_freq_scale), coil_xfov) : coil_fov*coil_freq_scale;
    coil_yfov  = _coil_yfov.fixedflag ?  ((void)(coil_fov*coil_phase_scale), coil_yfov) : coil_fov*coil_phase_scale;

    /*****************************************************/
    /*   Z gradients                                     */  
    /*****************************************************/
    pw_gzrf1coil  = _pw_gzrf1coil.fixedflag ?  ((void)(pw_rf1coil), pw_gzrf1coil) : pw_rf1coil;

    coil_vthick  = _coil_vthick.fixedflag ?    ((void)(coil_slthick*coil_slq), coil_vthick) : coil_slthick*coil_slq;
    bw_rf1coil  = _bw_rf1coil.fixedflag ?  ((void)((int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil), bw_rf1coil) : (int)rfpulse[RF1_AUTOCOIL_SLOT].nom_bw*rfpulse[RF1_AUTOCOIL_SLOT].nom_pw/pw_rf1coil;

    if (ampslice(_a_gzrf1coil.fixedflag ? (_temp1242_a_gzrf1coil=a_gzrf1coil,&_temp1242_a_gzrf1coil) : &a_gzrf1coil, bw_rf1coil, coil_vthick, 1.0, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE,EE_ARGS(1),STRING_ARG,"amplice (for gzrf1coil)");
        return FAILURE;
    }

    a_gzrf1coil  = _a_gzrf1coil.fixedflag ?    ((void)(1.05*coil_slq/(coil_slq-4)*a_gzrf1coil), a_gzrf1coil) : 1.05*coil_slq/(coil_slq-4)*a_gzrf1coil;   /* scale for slice blank of 2 */

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp1243_coil_amplimit=coil_amplimit,&_temp1243_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz);
    if(a_gzrf1coil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tz;
        target_risetime = coilloggrd.zrta.z;  /* rise time for target amp */
    }

    if (optramp(_pw_gzrf1coila.fixedflag ? (_temp1244_pw_gzrf1coila=pw_gzrf1coila,&_temp1244_pw_gzrf1coila) : &pw_gzrf1coila, a_gzrf1coil, target_amp, target_risetime, TYPDEF) == FAILURE) {
        epic_error(use_ermes, supfailfmt,
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "optramp (for gzrf1coila)");
        return FAILURE;
    }
    pw_gzrf1coild  = _pw_gzrf1coild.fixedflag ?  ((void)(pw_gzrf1coila), pw_gzrf1coild) : pw_gzrf1coila;

    if (endview(coil_slq, _endviewz_iampcoil.fixedflag ? (_temp1245_endviewz_iampcoil=endviewz_iampcoil,&_temp1245_endviewz_iampcoil) : &endviewz_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview:gzcombcoil");
        return FAILURE;
    } 
    endviewz_scalecoil  = _endviewz_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endviewz_iampcoil), endviewz_scalecoil) : (float)max_pg_iamp/(float)endviewz_iampcoil;

    refocus_coil = fabs(a_gzrf1coil)*(coil_iso_delay + pw_gzrf1coild/2.0);
    temp_area = (0.5 * (FLOAT)(coil_slq-1))/(coil_vthick * 0.1) * 1.0e6/ GAM;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp1246_coil_amplimit=coil_amplimit,&_temp1246_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tz_xyz);
    target_amp = coil_amplimit/endviewz_scalecal;
    target_risetime = RUP_GRD(ceil(target_risetime/endviewz_scalecal));  /* rise time for target amp */
    /* Z slice encode + gzrf1 refocus */
    if ( FAILURE==amppwtpe(_a_gzcombcoila.fixedflag ? (_temp1247_a_gzcombcoila=a_gzcombcoila,&_temp1247_a_gzcombcoila) : &a_gzcombcoila, _a_gzcombcoilb.fixedflag ? (_temp1248_a_gzcombcoilb=a_gzcombcoilb,&_temp1248_a_gzcombcoilb) : &a_gzcombcoilb, _pw_gzcombcoil.fixedflag ? (_temp1249_pw_gzcombcoil=pw_gzcombcoil,&_temp1249_pw_gzcombcoil) : &pw_gzcombcoil, 
                           _pw_gzcombcoila.fixedflag ? (_temp1250_pw_gzcombcoila=pw_gzcombcoila,&_temp1250_pw_gzcombcoila) : &pw_gzcombcoila, _pw_gzcombcoild.fixedflag ? (_temp1251_pw_gzcombcoild=pw_gzcombcoild,&_temp1251_pw_gzcombcoild) : &pw_gzcombcoild,
                           target_amp, target_risetime,
                           temp_area + refocus_coil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: slice encode for auto coil");
        return FAILURE;
    }

    encode_coil = 0.5*(float)pw_gzcombcoila*a_gzcombcoila + 0.5*(float)pw_gzcombcoil*(a_gzcombcoila
             + a_gzcombcoilb) + 0.5*(float)pw_gzcombcoild*a_gzcombcoilb - fabs(refocus_coil);

    a_delta_coil = 4.0*encode_coil/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzcombcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzcombcoil + (float)pw_gzcombcoild);
    
    /* max neg amp */
    a_combcoil  = _a_combcoil.fixedflag ?  ((void)(a_gzcombcoilb), a_combcoil) : a_gzcombcoilb;

    /* max positive amp */
    a_endcoil  = _a_endcoil.fixedflag ?    ((void)(a_combcoil-a_delta_coil*(float)(coil_slq-1.0)), a_endcoil) : a_combcoil-a_delta_coil*(float)(coil_slq-1.0);

    a_gzcombcoil  = _a_gzcombcoil.fixedflag ?  ((void)(-a_combcoil), a_gzcombcoil) : -a_combcoil;

    /* Z rewinder */
    if ( FAILURE==amppwtpe(_a_gzprcoila.fixedflag ? (_temp1252_a_gzprcoila=a_gzprcoila,&_temp1252_a_gzprcoila) : &a_gzprcoila, _a_gzprcoilb.fixedflag ? (_temp1253_a_gzprcoilb=a_gzprcoilb,&_temp1253_a_gzprcoilb) : &a_gzprcoilb, _pw_gzprcoil.fixedflag ? (_temp1254_pw_gzprcoil=pw_gzprcoil,&_temp1254_pw_gzprcoil) : &pw_gzprcoil, 
                           _pw_gzprcoila.fixedflag ? (_temp1255_pw_gzprcoila=pw_gzprcoila,&_temp1255_pw_gzprcoila) : &pw_gzprcoila, _pw_gzprcoild.fixedflag ? (_temp1256_pw_gzprcoild=pw_gzprcoild,&_temp1256_pw_gzprcoild) : &pw_gzprcoild,
                           target_amp, target_risetime,
                           temp_area + area_gzkcoil) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe:gzpr autocoil rewinder");
        return FAILURE;
    }
    encode_coil2 = 0.5*(float)pw_gzprcoila*a_gzprcoila + 0.5*(float)pw_gzprcoil*(a_gzprcoila
             + a_gzprcoilb) + 0.5*(float)pw_gzprcoild*a_gzprcoilb - area_gzkcoil;

    a_delta_coil2 = 4.0*encode_coil2/(float)(coil_slq-1.0)/(PSDRAMPEDTRAP*(float)pw_gzprcoila +
              (1.0+PSDRAMPEDTRAP)*(float)pw_gzprcoil + (float)pw_gzprcoild);
    
    /* max neg amp */
    a_combcoil2  = _a_combcoil2.fixedflag ?  ((void)(a_gzprcoilb), a_combcoil2) : a_gzprcoilb;

    /* max positive amp */
    a_endcoil2  = _a_endcoil2.fixedflag ?    ((void)(a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0)), a_endcoil2) : a_combcoil2-a_delta_coil2*(float)(coil_slq-1.0);

    a_gzprcoil  = _a_gzprcoil.fixedflag ?  ((void)(a_combcoil2), a_gzprcoil) : a_combcoil2;

    /*****************************************************************/
    /*  X Board - readout and dephaser                               */
    /*****************************************************************/

    if ( FAILURE==calcfilter( &echo1coil_filt, echo1bwcoil, coil_xres, OVERWRITE_NONE) )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "coilcfilter for echo1coil_filt");

        return FAILURE;
    }

    if ((echo1bwcoil > 0) && (coil_xfov > 0.0))
    {
        a_gxwcoil  = _a_gxwcoil.fixedflag ?         ((void)((FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov)), a_gxwcoil) : (FLOAT)(2*echo1bwcoil*1000/GAM)*(10.0/coil_xfov);
    }   
    else
    {
        epic_error(use_ermes,"%s failed",EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"ampfov for a_gxwcoil");
        return FAILURE;
    }

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp1257_coil_amplimit=coil_amplimit,&_temp1257_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if(a_gxwcoil <= coil_amplimit)
    {
        target_amp = coil_amplimit;
    }
    else
    {
        target_amp = coilloggrd.tx_xyz;
        target_risetime = coilloggrd.xrta.x;  /* rise time for target amp */
    }

    if (FAILURE==optramp(_pw_gxwcoila.fixedflag ? (_temp1258_pw_gxwcoila=pw_gxwcoila,&_temp1258_pw_gxwcoila) : &pw_gxwcoila, a_gxwcoil, target_amp, target_risetime, TYPDEF))
    {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "optramp for pw_gxwcoila.");
        return FAILURE;
    }
    pw_gxwcoild  = _pw_gxwcoild.fixedflag ?  ((void)(pw_gxwcoila), pw_gxwcoild) : pw_gxwcoila;

    tacq_coil  = _tacq_coil.fixedflag ?  ((void)(RUP_GRD(echo1coil_filt.tdaq)), tacq_coil) : RUP_GRD(echo1coil_filt.tdaq);

    /* Gx1 */
    area_gxwcoil = a_gxwcoil*tacq_coil;
    temp_area = 0.5*a_gxwcoil*pw_gxwcoila;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp1259_coil_amplimit=coil_amplimit,&_temp1259_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.tx_xyz);
    if (amppwgx1(_a_gx1coil.fixedflag ? (_temp1260_a_gx1coil=a_gx1coil,&_temp1260_a_gx1coil) : &a_gx1coil, _pw_gx1coil.fixedflag ? (_temp1261_pw_gx1coil=pw_gx1coil,&_temp1261_pw_gx1coil) : &pw_gx1coil, _pw_gx1coila.fixedflag ? (_temp1262_pw_gx1coila=pw_gx1coila,&_temp1262_pw_gx1coila) : &pw_gx1coila, _pw_gx1coild.fixedflag ? (_temp1263_pw_gx1coild=pw_gx1coild,&_temp1263_pw_gx1coild) : &pw_gx1coild,
                 (int)TYPGRAD, area_gxwcoil, temp_area,
                 1000000, 1.0, MIN_PLATEAU_TIME,
                 target_risetime, coil_amplimit) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"amppwgx1:gx1coil");
    }

    /* X killer -- ext gxwcoil */
    temp_area = 5.0e6 * coil_xres/(coil_fov*GAM);
    pw_gxwcoil  = _pw_gxwcoil.fixedflag ?        ((void)(IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2))), pw_gxwcoil) : IMax(2,tacq_coil,RUP_GRD(tacq_coil+temp_area/a_gxwcoil-pw_gxwcoild/2));


    /***********************************************/
    /*    Y phase encode                           */
    /**********************************************/
    if (endview(coil_yres, _endview_iampcoil.fixedflag ? (_temp1264_endview_iampcoil=endview_iampcoil,&_temp1264_endview_iampcoil) : &endview_iampcoil) == FAILURE)
    {
        epic_error(use_ermes,supfailfmt,EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1),STRING_ARG,"endview y for coil");
        return FAILURE;
    } 
    endview_scalecoil  = _endview_scalecoil.fixedflag ?   ((void)((float)max_pg_iamp/(float)endview_iampcoil), endview_scalecoil) : (float)max_pg_iamp/(float)endview_iampcoil;

    amp_rt_dbdtopt(_coil_amplimit.fixedflag ? (_temp1265_coil_amplimit=coil_amplimit,&_temp1265_coil_amplimit) : &coil_amplimit, &target_risetime, coil_slewrate, 1.0, coilloggrd.ty_xyz);
    target_amp = coil_amplimit/endview_scalecoil;
    target_risetime = RUP_GRD(ceil(target_risetime/endview_scalecoil));  /* rise time for target amp */

    if ( FAILURE==amppwtpe(_a_gy1coila.fixedflag ? (_temp1266_a_gy1coila=a_gy1coila,&_temp1266_a_gy1coila) : &a_gy1coila, _a_gy1coilb.fixedflag ? (_temp1267_a_gy1coilb=a_gy1coilb,&_temp1267_a_gy1coilb) : &a_gy1coilb, _pw_gy1coil.fixedflag ? (_temp1268_pw_gy1coil=pw_gy1coil,&_temp1268_pw_gy1coil) : &pw_gy1coil, _pw_gy1coila.fixedflag ? (_temp1269_pw_gy1coila=pw_gy1coila,&_temp1269_pw_gy1coila) : &pw_gy1coila, _pw_gy1coild.fixedflag ? (_temp1270_pw_gy1coild=pw_gy1coild,&_temp1270_pw_gy1coild) : &pw_gy1coild,
                           target_amp, target_risetime,
                           (0.5 * (FLOAT)(coil_yres-1))/(coil_yfov * 0.1) * 1.0e6/ GAM) )
    {
        epic_error(use_ermes, supfailfmt, EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "amppwtpe: coil ");
        return FAILURE;
    }

    /* phase rewinders */
    a_gy1rcoil  = _a_gy1rcoil.fixedflag ?  ((void)(a_gy1coil), a_gy1rcoil) : a_gy1coil;
    a_gy1rcoila  = _a_gy1rcoila.fixedflag ?  ((void)(a_gy1coila), a_gy1rcoila) : a_gy1coila;
    a_gy1rcoilb  = _a_gy1rcoilb.fixedflag ?  ((void)(a_gy1coilb), a_gy1rcoilb) : a_gy1coilb;
    pw_gy1rcoil  = _pw_gy1rcoil.fixedflag ?  ((void)(pw_gy1coil), pw_gy1rcoil) : pw_gy1coil;
    pw_gy1rcoila  = _pw_gy1rcoila.fixedflag ?  ((void)(pw_gy1coila), pw_gy1rcoila) : pw_gy1coila;
    pw_gy1rcoild  = _pw_gy1rcoild.fixedflag ?  ((void)(pw_gy1coild), pw_gy1rcoild) : pw_gy1coild;


    td0coil  = _td0coil.fixedflag ?  
                                 
                                  ((void)(RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait))), td0coil) : RUP_GRD((INT)IMax(2,GRAD_UPDATE_TIME,DAB_length[bd_index]+minimumPreRfSspTime()-psd_rf_wait));
    td0coil  = _td0coil.fixedflag ?    ((void)(RUP_GRD((int)(td0coil+tleadcoil))), td0coil) : RUP_GRD((int)(td0coil+tleadcoil));

    coil_iso_delay  = _coil_iso_delay.fixedflag ?  
                                     ((void)(RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw))), coil_iso_delay) : RUP_GRD((int)((float)rfpulse[RF1_AUTOCOIL_SLOT].isodelay*pw_rf1coil/rfpulse[RF1_AUTOCOIL_SLOT].nom_pw));

    coilt_exa  = _coilt_exa.fixedflag ?      ((void)(RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay)), coilt_exa) : RUP_GRD(pw_gzrf1coila+pw_gzrf1coil-coil_iso_delay);
    coilt_exb  = _coilt_exb.fixedflag ?  ((void)(coil_iso_delay), coilt_exb) : coil_iso_delay;
    temp_time = IMax(4, cfrfupd + cal_btw_rf_rba_ssp + RBA_length[bd_index] + cal_grd_rf_delays,
                     pw_gxwcoila + pw_gx1coila + pw_gx1coil + pw_gx1coild,
                     pw_gy1coila + pw_gy1coil + pw_gy1coild,
                     pw_gzrf1coild + pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild);

    te_coil  = _te_coil.fixedflag ?        ((void)(IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0))), te_coil) : IMax(2,500,RUP_GRD(coilt_exb+temp_time+tacq_coil/2.0));

    temp_time = IMax(3, pw_gxwcoild + pw_gxwcoil - tacq_coil,
                     pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild,
                     pw_gzprcoila + pw_gzprcoil + pw_gzprcoild);
    tr_coil  = _tr_coil.fixedflag ?              ((void)(RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil)), tr_coil) : RUP_GRD(td0coil+coilt_exa+te_coil+tacq_coil/2.0+psd_grd_wait+temp_time+time_ssicoil);

    coil_interleave  = _coil_interleave.fixedflag ?      ((void)(coil_nex_interleave?CAL_NEX_INTERLEAVED:0), coil_interleave) : coil_nex_interleave?CAL_NEX_INTERLEAVED:0;

    return SUCCESS;
} /* End of AutoCoilcveval */


/*
 *  RGcvinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RGcvinit( void )
{
    return SUCCESS;
}


/*
 *  RGcveval
 *
 *  Type: Public Function
 *
 *  Description:
 *
 */
STATUS
RGcveval( void )
{
    if (PSD_ON == rgfeature_enable) 
    { 
        cvmod( opuser39, RG_CAL_MODE_MEASURED, RG_CAL_MODE_HIGH_FIXED, RG_CAL_MODE_HIGH_FIXED, 
               "Receiver Gain (0:Prescan Measured, 1:Predefined)", 0, "" );

        if ( (PSD_2D == exist(opimode)) &&
             ((PSD_SE == exist(oppseq)) || (PSD_IR == exist(oppseq))) &&
             (exist(opptsize) == 4) &&
             (exist(opslthick) <= 10) ) 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(_opuser39.defval), opuser39) : _opuser39.defval;
            activate_reserved_usercv(39);

            if( existcv(opuser39) && 
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.minval, 2) &&
                !floatsAlmostEqualEpsilons(exist(opuser39), _opuser39.maxval, 2) )
            {
                epic_error(use_ermes, "%s must be 0 or 1", EM_PSD_CV_0_OR_1,
                           EE_ARGS(1), STRING_ARG, "UserCV39");

                return FAILURE;
            }

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)((int)rint(exist(opuser39))), oprgcalmode) : (int)rint(exist(opuser39));
        }
        else 
        {
            opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
            deactivate_reserved_usercv(39);

            oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
        }
    } 
    else 
    {
        opuser39  = _opuser39.fixedflag ?  ((void)(0), opuser39) : 0;
        deactivate_reserved_usercv(39);

        oprgcalmode  = _oprgcalmode.fixedflag ?  ((void)(RG_CAL_MODE_MEASURED), oprgcalmode) : RG_CAL_MODE_MEASURED;
    }

    return SUCCESS;
}   /* end RGcveval() */

/*
 *  PSfilter
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfilter( void )
{
    if (setfilter( &echo1cfl,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfl_fid  = _filter_cfl_fid.fixedflag ?  ((void)(echo1cfl.fslot), filter_cfl_fid) : echo1cfl.fslot;

    if (setfilter( &echo1rcvn,PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_rcvn_fid  = _filter_rcvn_fid.fixedflag ?  ((void)(echo1rcvn.fslot), filter_rcvn_fid) : echo1rcvn.fslot;

    if (setfilter(&echo1cfh, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_cfh_fid  = _filter_cfh_fid.fixedflag ?  ((void)(echo1cfh.fslot), filter_cfh_fid) : echo1cfh.fslot;


    if (setfilter(&echo1mps1_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1mps1  = _filter_echo1mps1.fixedflag ?  ((void)(echo1mps1_filt.fslot), filter_echo1mps1) : echo1mps1_filt.fslot;

    if (setfilter(&echo1ftg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1ftg   = _filter_echo1ftg.fixedflag ?  ((void)(echo1ftg_filt.fslot), filter_echo1ftg) : echo1ftg_filt.fslot; /* 11/24/94 YI */
    filter_echo2ftg  = _filter_echo2ftg.fixedflag ?   ((void)(filter_echo1ftg), filter_echo2ftg) : filter_echo1ftg;

    if (setfilter(&echo1xtg_filt, PRESCAN) == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1xtg   = _filter_echo1xtg.fixedflag ?  ((void)(echo1xtg_filt.fslot), filter_echo1xtg) : echo1xtg_filt.fslot;

    if (setfilter(&echo1as_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter");
        return FAILURE;
    }
    filter_echo1as  = _filter_echo1as.fixedflag ?  ((void)(echo1as_filt.fslot), filter_echo1as) : echo1as_filt.fslot;

    if (setfilter(&echo1rs_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter rs");
        return FAILURE;
    }
    filter_echo1rs  = _filter_echo1rs.fixedflag ?  ((void)(echo1rs_filt.fslot), filter_echo1rs) : echo1rs_filt.fslot;

    if (setfilter(&echo1dtg_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter dtg");
        return FAILURE;
    }
    filter_echo1dtg  = _filter_echo1dtg.fixedflag ?  ((void)(echo1dtg_filt.fslot), filter_echo1dtg) : echo1dtg_filt.fslot;

    if (setfilter(&echo1cal_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter cal");
        return FAILURE;
    }
    filter_echo1cal  = _filter_echo1cal.fixedflag ?  ((void)(echo1cal_filt.fslot), filter_echo1cal) : echo1cal_filt.fslot;

    if (setfilter(&echo1coil_filt, PRESCAN)  == FAILURE) {
        epic_error(use_ermes, "%s failed", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setfilter coil");
        return FAILURE;
    }
    filter_echo1coil  = _filter_echo1coil.fixedflag ?  ((void)(echo1coil_filt.fslot), filter_echo1coil) : echo1coil_filt.fslot;

    return SUCCESS;
}   /* end PSfilter() */


/*
 *  PS1predownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1predownload( void )
{
    /* Set xmtaddAPS1 according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddAPS1 is too big.
       Add in coilatten, too. */
    xmtaddAPS1  = _xmtaddAPS1.fixedflag ?    ((void)(-200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten()), xmtaddAPS1) : -200*log10(maxB1[L_APS1]/maxB1Seq)+getCoilAtten();
    if (xmtaddAPS1 > cfdbmax)
    {
        ps1scale  = _ps1scale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0)), ps1scale) : (float)pow(10.0,(cfdbmax-xmtaddAPS1)/200.0);
        xmtaddAPS1  = _xmtaddAPS1.fixedflag ?  ((void)(cfdbmax), xmtaddAPS1) : cfdbmax;
    }
    else
    {
        ps1scale  = _ps1scale.fixedflag ?  ((void)(1.0), ps1scale) : 1.0;
    }
  
    if( ((B0_30000 == cffield) && (PSD_XRMW_COIL == cfgcoiltype || PSD_VRMW_COIL == cfgcoiltype)) 
        || isRioSystem() )
    {
        /* MRIhc57081: Limit TG to coil peak B1 on MR750w */
        calcTGLimit(_tgcap.fixedflag ? (_temp1271_tgcap=tgcap,&_temp1271_tgcap) : &tgcap, _tgwindow.fixedflag ? (_temp1272_tgwindow=tgwindow,&_temp1272_tgwindow) : &tgwindow, maxB1Seq, txCoilInfo[getTxIndex(coilInfo[0])]);
    }
    else
    {
        /* Otherwise use defaults */
        tgcap  = _tgcap.fixedflag ?  ((void)(_tgcap.defval), tgcap) : _tgcap.defval;
        tgwindow  = _tgwindow.fixedflag ?  ((void)(_tgwindow.defval), tgwindow) : _tgwindow.defval;
    }

    if (setScale(L_APS1, RF_FREE, rfpulse, maxB1[L_APS1], 
                 ps1scale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1),
                   STRING_ARG, "setScale ps1");
        return FAILURE;
    }

    ia_rf1mps1  = _ia_rf1mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp))), ia_rf1mps1) : (int)(max_pg_iamp*(*rfpulse[RF1_APS1_SLOT].amp));
    ia_rf2mps1  = _ia_rf2mps1.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp))), ia_rf2mps1) : (int)(max_pg_iamp*(*rfpulse[RF2_APS1_SLOT].amp));

    entry_point_table[L_APS1].epxmtadd = (short) rint((double)xmtaddAPS1);
    /* APS1 & MPS1 */
    strcpy(entry_point_table[L_APS1].epname,"aps1");
    entry_point_table[L_APS1].epfilter=(n8)filter_echo1mps1;

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_APS1],
                  L_APS1,
                  (int)RF_FREE,
                  rfpulse,
                  ps1_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ps1");
        return FAILURE;
    }

    /* Check for multiple Tx coils. This routine is optimized only
     * for single Tx coil. */ 
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "Prescan");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1273_min_seqgrad=min_seqgrad,&_temp1273_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqmps1, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    /* If aps1_mod set to 1 and NOT breast R or L coil, use volRec coil to set TG */
    if ( (getAps1Mod() > 0) && (PSD_OFF == ps1_rxcoil) )
    {
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_APS1], 0);
        }
    }

    /* copy APS1 to MPS1 */
    entry_point_table[L_MPS1] = entry_point_table[L_APS1];

    strcpy(entry_point_table[L_MPS1].epname, "mps1");

    /* This is usually equal to the scan entry point.
       Make sure it is continuous for manual prescan */
    entry_point_table[L_MPS1].eppmtable.pmContinuousUpdate = 1;
    entry_point_table[L_MPS2].eppmtable.pmContinuousUpdate = 1;

    return SUCCESS;
}

/*
 *  CFLpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpredownload( void )
{
    /* Sample time for cfl */
    pitsp1 = echo1cfl.tdaq/echo1cfl.outputs;

    xmtaddCFL  = _xmtaddCFL.fixedflag ?    ((void)(-200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten()), xmtaddCFL) : -200*log10(maxB1[L_CFL]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFL > cfdbmax)
    {
        cflscale  = _cflscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0)), cflscale) : (float)pow(10.0,(cfdbmax-xmtaddCFL)/200.0);
        xmtaddCFL  = _xmtaddCFL.fixedflag ?  ((void)(cfdbmax), xmtaddCFL) : cfdbmax;
    }
    else
    {
        cflscale  = _cflscale.fixedflag ?  ((void)(1.0), cflscale) : 1.0;
    }

    if (setScale(L_CFL, RF_FREE, rfpulse, maxB1[L_CFL], 
                 cflscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfl");
        return FAILURE;
    }

    ia_rf1cfl  = _ia_rf1cfl.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp))), ia_rf1cfl) : (int)(max_pg_iamp*(*rfpulse[RF1_CFL_SLOT].amp));

    entry_point_table[L_CFL].epxmtadd = (short) rint((double)xmtaddCFL);

    entry_point_table[L_CFL].epprexres = (s16)CFLxres; /* MRIhc54366 */

    strcpy(entry_point_table[L_CFL].epname,"cfl");
    entry_point_table[L_CFL].epfilter=(n8)filter_cfl_fid;
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFL],
                  L_CFL,
                  (int)RF_FREE,
                  rfpulse,
                  cfl_tr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfl");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1274_min_seqgrad=min_seqgrad,&_temp1274_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfl, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  RCVNpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpredownload( void )
{
    entry_point_table[L_RCVN] = entry_point_table[L_MPS2];
    entry_point_table[L_RCVN].enableReceiveFreqBands  = _enableReceiveFreqBands.fixedflag ?  ((void)(0), enableReceiveFreqBands) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqLower  = _offsetReceiveFreqLower.fixedflag ?  ((void)(0), offsetReceiveFreqLower) : 0;
    entry_point_table[L_RCVN].offsetReceiveFreqHigher  = _offsetReceiveFreqHigher.fixedflag ?  ((void)(0), offsetReceiveFreqHigher) : 0;

    xmtaddRCVN  = _xmtaddRCVN.fixedflag ?  ((void)(xmtaddCFL), xmtaddRCVN) : xmtaddCFL;
    entry_point_table[L_RCVN].epxmtadd = (short) rint((double)xmtaddRCVN);

    strcpy(entry_point_table[L_RCVN].epname,"rcvn");
    
    entry_point_table[L_RCVN].epfilter  = (n8)filter_rcvn_fid;
    entry_point_table[L_RCVN].epprexres = rcvn_xres;

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1275_min_seqgrad=min_seqgrad,&_temp1275_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqrcvn, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    return SUCCESS;
}

/*
 *  CFHpredownload
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpredownload( void )
{
    /* Sample time for cfh */
    pitsp2 = echo1cfh.tdaq/echo1cfh.outputs;

    xmtaddCFH  = _xmtaddCFH.fixedflag ?    ((void)(-200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten()), xmtaddCFH) : -200*log10(maxB1[L_CFH]/maxB1Seq)+getCoilAtten();
    if (xmtaddCFH > cfdbmax)
    {
        cfhscale  = _cfhscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0)), cfhscale) : (float)pow(10.0,(cfdbmax-xmtaddCFH)/200.0);
        xmtaddCFH  = _xmtaddCFH.fixedflag ?  ((void)(cfdbmax), xmtaddCFH) : cfdbmax;
    }
    else
    {
        cfhscale  = _cfhscale.fixedflag ?  ((void)(1.0), cfhscale) : 1.0;
    }

    if (setScale(L_CFH, RF_FREE, rfpulse, maxB1[L_CFH], 
                 cfhscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cfh");
        return FAILURE;
    }

    ia_rf1cfh  = _ia_rf1cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp))), ia_rf1cfh) : (int)(max_pg_iamp*(*rfpulse[RF1_CFH_SLOT].amp));
    ia_rf2cfh  = _ia_rf2cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp))), ia_rf2cfh) : (int)(max_pg_iamp*(*rfpulse[RF2_CFH_SLOT].amp));
    if(presscfh_ctrl != PRESSCFH_NONE)
    {
        ia_rf3cfh  = _ia_rf3cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp))), ia_rf3cfh) : (int)(max_pg_iamp*(*rfpulse[RF3_CFH_SLOT].amp));
        if(presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            ia_rf4cfh  = _ia_rf4cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp))), ia_rf4cfh) : (int)(max_pg_iamp*(*rfpulse[RF4_CFH_SLOT].amp));
        }
    }

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ia_rfcssatcfh  = _ia_rfcssatcfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp))), ia_rfcssatcfh) : (int)(max_pg_iamp*(*rfpulse[RFCSSAT_CFH_SLOT].amp));
    }
#endif
    if (PSD_ON == PSir)
    {
        ia_rf0cfh  = _ia_rf0cfh.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp))), ia_rf0cfh) : (int)(max_pg_iamp*(*rfpulse[RF0_CFH_SLOT].amp));
    }

    if( (presscfh_ctrl != PRESSCFH_SHIMVOL) && (presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE) )
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*PStloc/(10*TARDIS_FREQ_RES));
    }
    else
    {
        cfh_rf1freq  = _cfh_rf1freq.fixedflag ?           ((void)((GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES))), cfh_rf1freq) : (GAM*a_gzrf1cfh*psc_info[0].oppsctloc/(10*TARDIS_FREQ_RES));
    }

    if( ( (opcoax != 0) && cfh_newmode ) || (presscfh != PRESSCFH_NONE) )
    {
        if( presscfh_ctrl == PRESSCFH_SLICE || presscfh_ctrl == PRESSCFH_SLAB )
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*presscfh_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*presscfh_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
        }
        else if(presscfh_ctrl == PRESSCFH_SHIMVOL)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?           ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            if((presscfh != presscfh_ctrl) && presscfh_debug)
            {
                printf("\n  presscfh %d changes to presscfh_ctrl %d \n",presscfh, presscfh_ctrl);
                fflush(stdout);
            }
        }
        else if (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE)
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES)), cfh_rf2freq) : GAM*psc_info[0].oppscrloc*a_gxrf2cfh/(10*TARDIS_FREQ_RES);
            cfh_rf3freq  = _cfh_rf3freq.fixedflag ?          ((void)(GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES)), cfh_rf3freq) : GAM*psc_info[0].oppscphasoff*a_gyrf3cfh/(10*TARDIS_FREQ_RES);
            cfh_rf4freq  = _cfh_rf4freq.fixedflag ?          ((void)(GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES)), cfh_rf4freq) : GAM*PStloc*a_gzrf4cfh/(10*TARDIS_FREQ_RES);
        }
        else
        {
            cfh_rf2freq  = _cfh_rf2freq.fixedflag ?              
    ((void)((GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES))), cfh_rf2freq) : (GAM*(opspf?PSphasoff*a_gyrf2cfh:PSrloc*a_gxrf2cfh)/(10*TARDIS_FREQ_RES));
        /* factor 10 is because rloc/phasoff is in mm */
    }
    }
    else
    {
        /* For non-coaxials (multi angle), center cfh_rf2freq and up the
           excitation region to 40 cm to cover lots of ground 
        */
        cfh_rf2freq  = _cfh_rf2freq.fixedflag ?  ((void)(0), cfh_rf2freq) : 0;
    }

    entry_point_table[L_CFH].epxmtadd = (short) rint((double)xmtaddCFH);
    strcpy(entry_point_table[L_CFH].epname,"cfh");
    entry_point_table[L_CFH].epfilter=(n8)filter_cfh_fid;
    entry_point_table[L_CFH].epprexres = (s16)CFHxres; /* MRIhc08633 */
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_CFH],
                  L_CFH,
                  (int)RF_FREE,
                  rfpulse,
                  cfh_tr) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cfh");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1276_min_seqgrad=min_seqgrad,&_temp1276_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqcfh, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
#endif

    switch (getTxCoilType()) /* Only 0.5/0.2T will use. */ /* vmx 07/27/95 YO */
    {
        case TX_COIL_LOCAL:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((10.0/256.0)), cfh_ec_position) : (10.0/256.0);
            break;
        default:
            cfh_ec_position  = _cfh_ec_position.fixedflag ?   ((void)((16.0/256.0)), cfh_ec_position) : (16.0/256.0);
            break;
    }

    return SUCCESS;
}

/*
 *  PSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpredownload( void )
{
    STATUS ps_status;
    INT i;
    INT j;
    INT index, vidx;
    
    /* Check for multiple Tx coils. This routine is optimized only for
     * single Tx coil. */
    if (1 != getNumTxCoils(coilInfo, opncoils))
    {
        epic_error( use_ermes,
                    "%s does not support more than one transmit coil",
                    EM_PSD_MULTI_TX_NOT_SUPPORTED, EE_ARGS(1), STRING_ARG,
                    "prescan");
        return FAILURE;
    }
    
    /***********************************************************************
     * Generic SECTION
     ***********************************************************************/

    if(PSD_ON == exist(oprtcgate)) {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_ON), phys_record_flag) : PSD_ON; /* flag for rt data recording */
    } else {
        phys_record_flag  = _phys_record_flag.fixedflag ?  ((void)(PSD_OFF), phys_record_flag) : PSD_OFF;
    }

    /* go through entry point table and set frequency offset based on receiver */
    for( i = 0; i < ENTRY_POINT_MAX; i++ )
    {
        PSfreq_offset[i] = cfreceiveroffsetfreq;
    }

    pw_omegarf0cfh  = _pw_omegarf0cfh.fixedflag ?  ((void)(pw_rf0cfh), pw_omegarf0cfh) : pw_rf0cfh; /* adiabatic pulse */

    PSslice_ind  = _PSslice_ind.fixedflag ?  ((void)(PSslice_num), PSslice_ind) : PSslice_num;  /* MRIge90312 -- for smart prescan */

    PStloc     = _PStloc.fixedflag ?       ((void)(scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift), PStloc) : scan_info[PSslice_num].optloc+scan_info[PSslice_num].optloc_shift;
    PSrloc     = _PSrloc.fixedflag ?       ((void)(scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift), PSrloc) : scan_info[PSslice_num].oprloc+scan_info[PSslice_num].oprloc_shift;
    PSphasoff  = _PSphasoff.fixedflag ?    ((void)(scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift), PSphasoff) : scan_info[PSslice_num].opphasoff+scan_info[PSslice_num].opphasoff_shift;

    /* begin aps1_mod changes (GE) */
    if ( (getAps1Mod() > 0) && (PSD_OFF == local_tg) )
    {
        cvunlock(PStloc_mod);
        cvunlock(PSrloc_mod);
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(getAps1ModPsTloc()), PStloc_mod) : getAps1ModPsTloc();
        PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(getAps1ModPsRloc()), PSrloc_mod) : getAps1ModPsRloc();
        PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(0), PSphasoff_mod) : 0; /* phase offset is not used */
        if(PSD_AXIAL == opplane)  /* To handle table delta */
        {
            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            if(2 == opentry)    /* Feet First */
            {
                PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(-PStloc), PStloc_mod) : -PStloc;
            }
        }
    }
    else if (PSD_ON == local_tg)
    {
        if (oppscvquant > 0)  /* use shim vol */
        {
            /* The default case for Localized TG = use Shim Vol info */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(psc_info[0].oppsctloc), PStloc_mod) : psc_info[0].oppsctloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(psc_info[0].oppscrloc), PSrloc_mod) : psc_info[0].oppscrloc;    
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(psc_info[0].oppscphasoff), PSphasoff_mod) : psc_info[0].oppscphasoff;    
        }
        else
        {
            /* For Research purpose only. Localized TG is normally enabled only if
             * Shim volume has been set by user via GRx. If this case is reached, 
             * local_tg flag was intentionally modified by user for Research purposes. */

            PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
            PSrloc_mod  = _PSrloc_mod.fixedflag ?  ((void)(PSrloc), PSrloc_mod) : PSrloc;
            PSphasoff_mod  = _PSphasoff_mod.fixedflag ?  ((void)(PSphasoff), PSphasoff_mod) : PSphasoff;
        }
    }
    else  /* use imaging locs */
    { 
        PStloc_mod  = _PStloc_mod.fixedflag ?  ((void)(PStloc), PStloc_mod) : PStloc;
        PSrloc_mod  = _PSrloc_mod.fixedflag ?      ((void)(opspf?PSphasoff:PSrloc), PSrloc_mod) : opspf?PSphasoff:PSrloc;    
    }
    /* end aps1_mod changes (GE) */

   /* Create rsp_psc_info table based on psc_info */
    for ( i=0; i < exist(oppscvquant); i ++) {
        rsp_psc_info[i].rsppsctloc = psc_info[i].oppsctloc;
        rsp_psc_info[i].rsppscrloc = psc_info[i].oppscrloc;
        rsp_psc_info[i].rsppscphasoff = psc_info[i].oppscphasoff;

        rsp_psc_info[i].rsppsclenx = psc_info[i].oppsclenx;
        rsp_psc_info[i].rsppscleny = psc_info[i].oppscleny;
        rsp_psc_info[i].rsppsclenz = psc_info[i].oppsclenz; 
    }

    /* Check the rotation matrix for rsp_psc_info */
    for (i=0; i< exist(oppscvquant); i++) {
        for (j=0; j<9; j++) {
            rsp_psc_info[i].rsppscrot[j] = hostToRspRotMat(psc_info[0].oppscrot[j]);
        }
    } 

    /* fill in the prescan rotation array for the prescan slice.
       PSrot is an ipgexport defined in epic.h  */

    /*
     * MRIge43971 BJM: loop over 2D PSrot array to be consistent with other
     *                 rotation matrices and since scalerotmats() expects a 2D
     *                 argument.
     */
    for (index = 0; index < 9; index++)
    {
        PSrot[0][index] = hostToRspRotMat(scan_info[PSslice_num].oprot[index]);
        PSrot_mod[0][index] = hostToRspRotMat(ps1scan_info[0].oprot[index]); 
        rsp_PSrot[0][index] = hostToRspRotMat(cfh_info[0].oprot[index]);
        rsp_rcvnrot[0][index] = hostToRspRotMat(rcvnscan_info[0].oprot[index]);


        /* set up rot for CFH */
        for( vidx = 1; vidx < oppscvquant; vidx++ )
        {
            rsp_PSrot[vidx][index] = hostToRspRotMat(cfh_info[vidx].oprot[index]);

        }
    }

    /* Scale Rot matrix for RCVN */
    if(scalerotmats(rsp_rcvnrot, &rcvnloggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for CFH */
    if(scalerotmats(rsp_PSrot, &cfhloggrd, &phygrd, IMax(2,1,exist(oppscvquant)), cfhobl_debug) == FAILURE) /* YMSmr09211  04/26/2006 YI */
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }
    
    /* Scale Rot matrix for CFL */
    if(scalerotmats(PSrot, &loggrd, &phygrd, 1, ps1obl_debug) == FAILURE)
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    /* Scale Rot matrix for ps1 & FTG  & XTG */
    if(scalerotmats(PSrot_mod, &ps1loggrd, &phygrd, 1, ps1obl_debug) == FAILURE) 
    {
        epic_error(use_ermes,"System configuration data integrity violation detected in PSD.\nPlease try again or restart the system.", 
                   EM_PSD_PSDCRUCIAL_CONFIG_FAILURE,EE_ARGS(0));
        return FAILURE;
    }

    PStrigger  = _PStrigger.fixedflag ?  ((void)(TRIG_LINE), PStrigger) : TRIG_LINE;

    /* For Prescan: Inform 'Auto' Prescan about prescan parameters 	*/
    pitr = 2000000;	        /* 1st pass prescan TR 	*/
    pichop = 0;		/* No chop		*/

    /* find minimum rfamp te time based on duty cycle */
    min180te  = _min180te.fixedflag ?    
                                 
                                ((void)(RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2), min180te) : RUP_GRD((int)((float)(pw_rf1mps1+cfrfminblank)/((TX_COIL_LOCAL==getTxCoilType())?cfrfmdch:cfrfmdcb)))*2;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = PS1predownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "PS1predownload");
        return ps_status;
    }


    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFLpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFLpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = CFHpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "CFHpredownload");  /* MRIhc08595 */
        return ps_status;
    }

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    if ( SUCCESS != (ps_status = RCVNpredownload()) ) {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "RCVNpredownload");
        return ps_status;
    }

    /* xmtaddRef is used for calculating TG value to be stored in smart prescan DB wrt a
     * reference maxB1 used in TG entry point */
    xmtaddRef = -200*log10(cfmaxb1ref/100.0/maxB1Seq) + getCoilAtten();

    /* HCSDM00184619 : Tools PSD dont inline PSpreDwonload.
     * This should move to a routine which  psdIF can handle. */

    /* Copy coilInfo, volRecCoilInfo, txCoilInfo to target side */
    copyCoilInfo();

    chksum_rampdir_tgt = chksum_rampdir;
    cframpdir_tgt = cframpdir;

    if(exist(opquickstep))  /* skip TG for quickstep */
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_psctg) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_psctg  = _psd_psctg.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_psctg) : APS_CONTROL_PSC;
    }
    pidotg = doTG(psd_psctg);  /* set PSC TG control flag */

    return SUCCESS;

}   /* end PSpredownload() */


/*
 *  FTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpredownload( void )
{
    /* Set xmtaddFTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddFTG is too big.
       We are assuming that the pulse shapes used in CFH are the
       same as in scan. */
    xmtaddFTG  = _xmtaddFTG.fixedflag ?    ((void)(-200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten()), xmtaddFTG) : -200*log10(maxB1[L_FTG]/maxB1Seq)+getCoilAtten();
    if (xmtaddFTG > cfdbmax)
    {
        ftgscale  = _ftgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0)), ftgscale) : (float)pow(10.0,(cfdbmax-xmtaddFTG)/200.0);
        xmtaddFTG  = _xmtaddFTG.fixedflag ?  ((void)(cfdbmax), xmtaddFTG) : cfdbmax;
    }
    else
    {
        ftgscale  = _ftgscale.fixedflag ?  ((void)(1.0), ftgscale) : 1.0;
    }

    if (setScale(L_FTG,RF_FREE,rfpulse,maxB1[L_FTG],ftgscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale ftg");
        return FAILURE;
    }
    
    /* Set the amplitude scale factors. */
    ia_rf1ftg  = _ia_rf1ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp))), ia_rf1ftg) : (int)(max_pg_iamp*(*rfpulse[RF1_FTG_SLOT].amp));
    ia_rf2ftg  = _ia_rf2ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp))), ia_rf2ftg) : (int)(max_pg_iamp*(*rfpulse[RF2_FTG_SLOT].amp));
    ia_rf3ftg  = _ia_rf3ftg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp))), ia_rf3ftg) : (int)(max_pg_iamp*(*rfpulse[RF3_FTG_SLOT].amp));
    
    entry_point_table[L_FTG].epxmtadd = (short)rint((double)xmtaddFTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_FTG],
                  L_FTG,
                  (int)RF_FREE,
                  rfpulse,
                  ftgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon ftg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddFTG), xmtadd) : xmtaddFTG;

    entry_point_table[L_FTG].epfilter = (n8)filter_echo1ftg; /* 11/24/94 YI */
    entry_point_table[L_FTG].epprexres = 256;
    
    FTGxmtadd  = _FTGxmtadd.fixedflag ?  ((void)(entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd), FTGxmtadd) : entry_point_table[L_APS1].epxmtadd-entry_point_table[L_FTG].epxmtadd;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1277_min_seqgrad=min_seqgrad,&_temp1277_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqftg, tsamp, tmin,
                                use_ermes, seg_debug ) )
        {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* Use volRec coil for FTG */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_FTG], 0);
    } 

    return SUCCESS;
}   /* end FTGpredownload() */


/*
 *  XTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpredownload( void )
{
    {
        float trsarscale = 1.0;
        int xtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&xtg_maxseqsar, RF_FREE, rfpulse, L_XTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar xtg");
            return FAILURE;
        }

        if( isLowSarEnabled() )
        {
            trsarscale = 1.2;   /* HCSDM00381012: adding 20% tr to prevent UPM trip for low SAR */
        }

        if(xtgtr < (int)(xtg_maxseqsar*trsarscale))
        {
            xtgtr  = _xtgtr.fixedflag ?  ((void)(RUP_GRD((int)(xtg_maxseqsar*trsarscale))), xtgtr) : RUP_GRD((int)(xtg_maxseqsar*trsarscale));
        }
    }
    
    /* Set xmtaddXTG according to maximum B1 and rescale for powermon,
       adding additional (audio) scaling if xmtaddXTG is too big. */
    xmtaddXTG  = _xmtaddXTG.fixedflag ?    ((void)(-200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten()), xmtaddXTG) : -200*log10(maxB1[L_XTG]/maxB1Seq)+getCoilAtten();

    if (xmtaddXTG > cfdbmax)
    {
        xtgscale  = _xtgscale.fixedflag ?      ((void)((float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0)), xtgscale) : (float)pow(10.0,(cfdbmax-xmtaddXTG)/200.0);
        xmtaddXTG  = _xmtaddXTG.fixedflag ?  ((void)(cfdbmax), xmtaddXTG) : cfdbmax;
    }
    else
    {
        xtgscale  = _xtgscale.fixedflag ?  ((void)(1.0), xtgscale) : 1.0;
    }

    if (setScale(L_XTG,RF_FREE,rfpulse,maxB1[L_XTG],xtgscale) == FAILURE)  
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale xtg");
        return FAILURE;
    }  
    
    /* Set the amplitude scale factors. */
    ia_rf1xtg  = _ia_rf1xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp))), ia_rf1xtg) : (int)(max_pg_iamp*(*rfpulse[RF1_XTG_SLOT].amp));
    ia_rf2xtg  = _ia_rf2xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp))), ia_rf2xtg) : (int)(max_pg_iamp*(*rfpulse[RF2_XTG_SLOT].amp));
    ia_rf4xtg  = _ia_rf4xtg.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp))), ia_rf4xtg) : (int)(max_pg_iamp*(*rfpulse[RF4_XTG_SLOT].amp));
    ia_rf3xtg  = _ia_rf3xtg.fixedflag ?  ((void)(-ia_rf4xtg), ia_rf3xtg) : -ia_rf4xtg;
    a_rf3xtg   = _a_rf3xtg.fixedflag ?  ((void)(-a_rf4xtg), a_rf3xtg) : -a_rf4xtg;
    
    entry_point_table[L_XTG].epxmtadd = (short)rint((double)xmtaddXTG);

    /* MRIge75651 */
    if( powermon( &entry_point_table[L_XTG],
                  L_XTG,
                  (int)RF_FREE,
                  rfpulse,
                  xtgtr ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon xtg");
        return FAILURE;
    }
    xmtadd  = _xmtadd.fixedflag ?  ((void)(xmtaddXTG), xmtadd) : xmtaddXTG;

    entry_point_table[L_XTG].epfilter = (n8)filter_echo1xtg; /* 11/24/94 YI */
    entry_point_table[L_XTG].epprexres = 256;

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1278_min_seqgrad=min_seqgrad,&_temp1278_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqxtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    if ( (2 == getAps1Mod()) && (PSD_OFF == local_tg) )
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_ON), xtg_volRecCoil) : PSD_ON;
    }
    else
    {
        xtg_volRecCoil  = _xtg_volRecCoil.fixedflag ?  ((void)(PSD_OFF), xtg_volRecCoil) : PSD_OFF;
    }

    if(PSD_ON == xtg_volRecCoil)
    {
        /* Use volRec coil for XTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_XTG], 0);
        } 
    }

    return SUCCESS;
}   /* end XTGpredownload() */


/*
 *  ASpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpredownload( void )
{
    FLOAT asscale;
 
    /******************************************************************/
    /* Set xmtaddas according to maximum B1 and rescale for powermon, */
    /* adding additional (audio) scaling if xmtaddas is too big.      */
    /* We are assuming that the pulse shapes used in CFH are the      */
    /* same as in scan.                                               */
    /******************************************************************/

    strcpy(entry_point_table[L_AUTOSHIM].epname, "autoshim");

    xmtaddas  = _xmtaddas.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten()), xmtaddas) : -200*log10(maxB1[L_AUTOSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddas > cfdbmax) 
    {
        asscale = (float) pow(10.0, (cfdbmax - xmtaddas)/200.0);
        xmtaddas  = _xmtaddas.fixedflag ?  ((void)(cfdbmax), xmtaddas) : cfdbmax;
    } 
    else
    {
        asscale = 1.0;
    }

    if (setScale(L_AUTOSHIM, RF_FREE, rfpulse, maxB1[L_AUTOSHIM],
                 asscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale autoshim");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1as  = _ia_rf1as.fixedflag ?  ((void)((int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp))), ia_rf1as) : (int)(max_pg_iamp*(*rfpulse[RF1_AUTOSHIM].amp));

    entry_point_table[L_AUTOSHIM].epxmtadd=(short)rint((double)xmtaddas);
    
    /* MRIge75651 */
    if( powermon( &entry_point_table[L_AUTOSHIM],
                  L_AUTOSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_as ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon autoshim");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
    /* Call minseq() to calculate Burst Mode model inputs.
       Disable writing corner points files for prescan entry points. */
    int gradHeatFile_save = gradHeatFile;
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
    if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1279_min_seqgrad=min_seqgrad,&_temp1279_min_seqgrad) : &min_seqgrad,
                            gradx, GX_FREE,
                            grady, GY_FREE,
                            gradz, GZ_FREE,
                            &loggrd, idx_seqaushim, tsamp, tmin,
                            use_ermes, seg_debug ) ) {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
        return FAILURE;
    }
    gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_AUTOSHIM].epfilter = (n8)filter_echo1as;
    entry_point_table[L_AUTOSHIM].epprexres = asxres;
    
    /* Use volRec coil for autoshim */
    if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
    {
        UpdateEntryTabRecCoil(&entry_point_table[L_AUTOSHIM], 0);
    } 

    if(exist(opquickstep))  /* skip AutoShim for quickstep */
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(PSD_CONTROL_PSC_SKIP), psd_pscshim) : PSD_CONTROL_PSC_SKIP;
    }
    else
    {
        psd_pscshim  = _psd_pscshim.fixedflag ?  ((void)(APS_CONTROL_PSC), psd_pscshim) : APS_CONTROL_PSC;
    }
    pidoshim = doAS(psd_pscshim);  /* set PSC AutoShim control flag */ 

    return SUCCESS;
}   /* end ASpredownload() */

/*
 *  RSpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpredownload( void )
{
    FLOAT rsscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    char attribute_codeMeaning[ATTRIBUTE_RESULT_SIZE] = "";
    getAnatomyAttributeCached(exist(opanatomy), ATTRIBUTE_CODE_MEANING, attribute_codeMeaning);


    {
        INT rs_maxseqsar = 0;

        if(FAILURE == maxseqsar(&rs_maxseqsar, RF_FREE, rfpulse, L_RFSHIM))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar RF Shim");
            return FAILURE;
        }
        if(tr_rs < rs_maxseqsar)
        {
            tr_rs  = _tr_rs.fixedflag ?  ((void)(RUP_GRD(rs_maxseqsar)), tr_rs) : RUP_GRD(rs_maxseqsar);
        }
    }

    DD_nCh  = _DD_nCh.fixedflag ?  ((void)(DD_channels), DD_nCh) : DD_channels;

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_RFSHIM].epname,  "RFshim");

    xmtaddrs  = _xmtaddrs.fixedflag ?    ((void)(-200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten()), xmtaddrs) : -200*log10(maxB1[L_RFSHIM]/maxB1Seq)+getCoilAtten();
    if (xmtaddrs > cfdbmax) 
    {
        rsscale = (float) pow(10.0, (cfdbmax - xmtaddrs)/200.0);
        xmtaddrs  = _xmtaddrs.fixedflag ?  ((void)(cfdbmax), xmtaddrs) : cfdbmax;
    } 
    else
    {
        rsscale = 1.0;
    }

    if (setScale(L_RFSHIM, RF_FREE, rfpulse, maxB1[L_RFSHIM],
                 rsscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale B1Map");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbrs  = _ia_rfbrs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp)), ia_rfbrs) : max_pg_iamp*(*rfpulse[RFB_RFSHIM_SLOT].amp);
    ia_thetarfbrs  = _ia_thetarfbrs.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbrs) : max_pg_iamp;
    pw_thetarfbrs  = _pw_thetarfbrs.fixedflag ?  ((void)(pw_rfbrs), pw_thetarfbrs) : pw_rfbrs;
    ia_rf1rs  = _ia_rf1rs.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp)), ia_rf1rs) : max_pg_iamp*(*rfpulse[RF1_RFSHIM_SLOT].amp);

    entry_point_table[L_RFSHIM].epxmtadd=(short)rint((double)xmtaddrs);

    if( powermon( &entry_point_table[L_RFSHIM],
                  L_RFSHIM,
                  (int)RF_FREE,
                  rfpulse,
                  tr_rs ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon DynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1280_min_seqgrad=min_seqgrad,&_temp1280_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqrs, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_RFSHIM].epfilter = (n8)filter_echo1rs;
    entry_point_table[L_RFSHIM].epprexres = rfshim_xres;

    /* set up B1 Map slice orientation and location */
    for (j = 0; j < rfshim_slquant; j++)
    {
        if(PSD_ON == rsaxial_flag)
        {
            rsrsp_info[j].rsprloc = 0.0;
            rsrsp_info[j].rspphasoff = 0.0;
            rsrsp_info[j].rsptloc = 0.0;

            if(isCategoryMatchForAnatomy(exist(opanatomy), ATTRIBUTE_CATEGORY_CHEST) && strstr(attribute_codeMeaning, "Breast")
               && (2 == exist(oppos)))  /* Prone breast scans */

            {
                rsrsp_info[j].rsprloc = -120.0;  /* offset in A/P diresction for breast coils */
            }
        }
        else
        {
            rsrsp_info[j].rsprloc = scan_info[PSslice_num].oprloc + scan_info[PSslice_num].oprloc_shift;
            rsrsp_info[j].rspphasoff = scan_info[PSslice_num].opphasoff + scan_info[PSslice_num].opphasoff_shift;
            rsrsp_info[j].rsptloc = scan_info[PSslice_num].optloc + scan_info[PSslice_num].optloc_shift;
        }

        for (i = 0; i < 9; i++)
        {
            rsrsprot[j][i] = hostToRspRotMat(rsscan_info[0].oprot[i]); /* use Rxed slice rot */ 
        }
    }

    scalerotmats(rsrsprot, &rsloggrd, &phygrd, rfshim_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    rfshim_b1factor  = _rfshim_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs), rfshim_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbrs*flip_rfbrs/90.0)*flip_rf1rs; 

    return SUCCESS;
}   /* end RSpredownload() */

/*
 *  DTGpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpredownload( void )
{
    FLOAT dtgscale;
    FLOAT b1map_factor = 0.0;

    INT i, j;

    FLOAT *dynTG_loc = NULL;

    {
        INT dtg_maxseqsar = 0;

        if(FAILURE == maxseqsar(&dtg_maxseqsar, RF_FREE, rfpulse, L_DYNTG))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar dynamic tg");
            return FAILURE;
        }
        if(tr_dtg < dtg_maxseqsar)
        {
            tr_dtg  = _tr_dtg.fixedflag ?  ((void)(RUP_GRD(dtg_maxseqsar)), tr_dtg) : RUP_GRD(dtg_maxseqsar);
        }
    }

    /******************************************************************/
    /* Set xmtadd according to maximum B1 and rescale for powermon,   */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/

    strcpy(entry_point_table[L_DYNTG].epname,  "DynTG");

    xmtadddtg  = _xmtadddtg.fixedflag ?    ((void)(-200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten()), xmtadddtg) : -200*log10(maxB1[L_DYNTG]/maxB1Seq)+getCoilAtten();
    if (xmtadddtg > cfdbmax) 
    {
        dtgscale = (float) pow(10.0, (cfdbmax - xmtadddtg)/200.0);
        xmtadddtg  = _xmtadddtg.fixedflag ?  ((void)(cfdbmax), xmtadddtg) : cfdbmax;
    } 
    else
    {
        dtgscale = 1.0;
    }

    if (setScale(L_DYNTG, RF_FREE, rfpulse, maxB1[L_DYNTG],
                 dtgscale) == FAILURE) 
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale DynTG");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rfbdtg  = _ia_rfbdtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp)), ia_rfbdtg) : max_pg_iamp*(*rfpulse[RFB_DYNTG_SLOT].amp);
    ia_thetarfbdtg  = _ia_thetarfbdtg.fixedflag ?  ((void)(max_pg_iamp), ia_thetarfbdtg) : max_pg_iamp;
    pw_thetarfbdtg  = _pw_thetarfbdtg.fixedflag ?  ((void)(pw_rfbdtg), pw_thetarfbdtg) : pw_rfbdtg;
    ia_rf1dtg  = _ia_rf1dtg.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp)), ia_rf1dtg) : max_pg_iamp*(*rfpulse[RF1_DYNTG_SLOT].amp);

    entry_point_table[L_DYNTG].epxmtadd=(short)rint((double)xmtadddtg);

    if( powermon( &entry_point_table[L_DYNTG],
                  L_DYNTG,
                  (int)RF_FREE,
                  rfpulse,
                  tr_dtg ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon dynTG B1 map");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */
        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1281_min_seqgrad=min_seqgrad,&_temp1281_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqdtg, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_DYNTG].epfilter = (n8)filter_echo1dtg;
    entry_point_table[L_DYNTG].epprexres = dynTG_xres;

    /* Now copy into Map TG */
    entry_point_table[L_MAPTG] = entry_point_table[L_DYNTG];
    strcpy(entry_point_table[L_MAPTG].epname,  "mapTg");

    dynTG_loc =  (float*)AllocNode(dynTG_slquant*sizeof(float));
    if (NULL == dynTG_loc)
    {
        epic_error( use_ermes, "%s failed.",
                    EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "AllocNode for dynTG_loc" );
        return FAILURE;
    }

    if(PSD_OFF == enableMapTg)
    {
        dynTG_sliceloc(dynTG_loc, dynTG_slquant, exist(opslquant), 1);
    }
    /* set up B1 Map slice orientation and location */
    for (j = 0; j < dynTG_slquant; j++)
    {
        if(PSD_ON == enableMapTg)
        {
            dtgrsp_info[j].rsprloc = 0.0;
            dtgrsp_info[j].rspphasoff = 0.0;
            dtgrsp_info[j].rsptloc = 0.0;

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(maptgscan_info[0].oprot[i]); /* use axial slice rot */
            }
        }
        else
        {
            int index0, index1;
            index0 = (int)dynTG_loc[j];
            if(index0<0)
            {
                index0=0;
            }
            index1 = index0+1;
            if(index1>=exist(opslquant))
            {
                index1=exist(opslquant)-1;
            }
            dtgrsp_info[j].rsprloc = scan_info[index0].oprloc + scan_info[index0].oprloc_shift;
            dtgrsp_info[j].rspphasoff = scan_info[index0].opphasoff + scan_info[index0].opphasoff_shift;
            dtgrsp_info[j].rsptloc = scan_info[index0].optloc + scan_info[index0].optloc_shift +
                (dynTG_loc[j]-(float)index0) *
                (scan_info[index1].optloc + scan_info[index1].optloc_shift - scan_info[index0].optloc - scan_info[index0].optloc_shift);

            if (ps1obl_debug)
            {
                printf("index=%d,dtg.rsprloc=%f,dtg.rspphaseoff=%f,dtg.rsptloc=%f\n",
                       j,dtgrsp_info[j].rsprloc,dtgrsp_info[j].rspphasoff,dtgrsp_info[j].rsptloc);
            }

            for (i = 0; i < 9; i++)
            {
                dtgrsprot[j][i] = hostToRspRotMat(scan_info[index0].oprot[i]); /* use Rxed slice rot */ 
            }
        }
    }

    FreeNode(dynTG_loc);

    scalerotmats(dtgrsprot, &dtgloggrd, &phygrd, dynTG_slquant, ps1obl_debug);

    /* calc b1map factor */
    b1map_factor = 2.0*PI*(2392.9/180.0);
    b1map_factor = sqrtf(b1map_factor);
    dynTG_b1factor  = _dynTG_b1factor.fixedflag ?  ((void)((1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg), dynTG_b1factor) : (1.0/b1map_factor)/(0.036615*2000.0/pw_rfbdtg*flip_rfbdtg/90.0)*flip_rf1dtg; 

    if( (PSD_ON == enableMapTg) && (PSD_ON == xtg_volRecCoil))
    {
        /* Use volRec coil for mapTG */
        if (volRecCoilInfo[0].hubIndex != coilInfo[0].hubIndex)
        {
            UpdateEntryTabRecCoil(&entry_point_table[L_MAPTG], 0);
        } 
    }

    return SUCCESS;
}   /* end DTGpredownload() */



/*
 *  ExtCalpredownload
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpredownload( void )
{
    INT i, j;
    FLOAT calscale = 1.0;

    /* SAR check */
    {
        INT cal_maxseqsar = 0;

        if(FAILURE == maxseqsar(&cal_maxseqsar, RF_FREE, rfpulse, L_EXTCAL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar Cal");
            return FAILURE;
        }
        if(tr_cal < cal_maxseqsar)
        {
            tr_cal  = _tr_cal.fixedflag ?  ((void)(RUP_GRD(cal_maxseqsar)), tr_cal) : RUP_GRD(cal_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_EXTCAL].epname,  "extcal");

    xmtaddcal  = _xmtaddcal.fixedflag ?    ((void)(-200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten()), xmtaddcal) : -200*log10(maxB1[L_EXTCAL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcal > cfdbmax)
    {
        calscale = (float) pow(10.0, (cfdbmax - xmtaddcal)/200.0);
        xmtaddcal  = _xmtaddcal.fixedflag ?  ((void)(cfdbmax), xmtaddcal) : cfdbmax;
    } 
    else
    {
        calscale = 1.0;
    }

    if (setScale(L_EXTCAL, RF_FREE, rfpulse, maxB1[L_EXTCAL],
                 calscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale cal");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1cal  = _ia_rf1cal.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp)), ia_rf1cal) : max_pg_iamp*(*rfpulse[RF1_EXTCAL_SLOT].amp);

    entry_point_table[L_EXTCAL].epxmtadd=(short)rint((double)xmtaddcal);

    if( powermon( &entry_point_table[L_EXTCAL],
                  L_EXTCAL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_cal ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon cal");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1282_min_seqgrad=min_seqgrad,&_temp1282_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcal, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    entry_point_table[L_EXTCAL].epfilter = (n8)filter_echo1cal;
    entry_point_table[L_EXTCAL].epprexres = cal_xres;


    if(cal_tr_interleave)  /* always set body coil ON for cal scan */
    {
        entry_point_table[L_EXTCAL].epRxCoilType = (n32)volRecCoilInfo[0].rxCoilType;
    }

    for( j = 0; j < cal_slq; j++)
    {
        calrsp_info[j].rsptloc = (calscan_info[cal_slq/2].optloc + calscan_info[cal_slq/2].optloc_shift
                                  + calscan_info[cal_slq/2-1].optloc + calscan_info[cal_slq/2-1].optloc_shift)/2.0;
        calrsp_info[j].rsprloc = calscan_info[0].oprloc + calscan_info[0].oprloc_shift;
        calrsp_info[j].rspphasoff = calscan_info[0].opphasoff + calscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            calrsprot[j][i] = hostToRspRotMat(calscan_info[0].oprot[i]); 
        }
    }

    scalerotmats(calrsprot, &calloggrd, &original_pgrd, cal_slq, ps1obl_debug);

    /* corner cutting */
    cal_pfkr_fraction  = _cal_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), cal_pfkr_fraction) : PI/4.0;  /* same as task based 3D Cal */
    cal_pfkr_flag  = _cal_pfkr_flag.fixedflag ?  ((void)(PSD_ON), cal_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( cal_zyindex,
                                    cal_yres,
                                    cal_slq,
                                    cal_yfov,
                                    cal_vthick,
                                    cal_pfkr_flag,
                                    cal_pfkr_fraction,
                                    _cal_sampledPts.fixedflag ? (_temp1283_cal_sampledPts=cal_sampledPts,&_temp1283_cal_sampledPts) : &cal_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }

    return SUCCESS;
}   /* end ExtCalpredownload() */


/*
 *  AutoCoilpredownload
 *  
 *  Type: Public Function
 *  
 *  Description: Predownload settings for AutoCoil entry point
 *  
 */
STATUS
AutoCoilpredownload( void )
{
    INT i, j;
    FLOAT coilscale = 1.0;

    /* SAR check */
    {
        INT coil_maxseqsar = 0;

        if(FAILURE == maxseqsar(&coil_maxseqsar, RF_FREE, rfpulse, L_AUTOCOIL))
        {
            epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                       EE_ARGS(1), STRING_ARG, "maxseqsar AutoCoil");
            return FAILURE;
        }
        if(tr_coil < coil_maxseqsar)
        {
            tr_coil  = _tr_coil.fixedflag ?  ((void)(RUP_GRD(coil_maxseqsar)), tr_coil) : RUP_GRD(coil_maxseqsar);
        }
    }

    /******************************************************************/
    /*  Set xmtadd according to maximum B1 and rescale for powermon,  */
    /* adding additional scaling if xmtadd is too big.                */
    /******************************************************************/
    strcpy(entry_point_table[L_AUTOCOIL].epname,  "Autocoil");

    xmtaddcoil  = _xmtaddcoil.fixedflag ?    ((void)(-200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten()), xmtaddcoil) : -200*log10(maxB1[L_AUTOCOIL]/maxB1Seq)+getCoilAtten();
    if (xmtaddcoil > cfdbmax)
    {
        coilscale = (float) pow(10.0, (cfdbmax - xmtaddcoil)/200.0);
        xmtaddcoil  = _xmtaddcoil.fixedflag ?  ((void)(cfdbmax), xmtaddcoil) : cfdbmax;
    } 
    else
    {
        coilscale = 1.0;
    }

    if (setScale(L_AUTOCOIL, RF_FREE, rfpulse, maxB1[L_AUTOCOIL],
                 coilscale) == FAILURE)
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "setScale coil");
        return FAILURE;
    }

    /* Set the amplitude scale factors. */
    ia_rf1coil  = _ia_rf1coil.fixedflag ?  ((void)(max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp)), ia_rf1coil) : max_pg_iamp*(*rfpulse[RF1_AUTOCOIL_SLOT].amp);

    entry_point_table[L_AUTOCOIL].epxmtadd=(short)rint((double)xmtaddcoil);

    if( powermon( &entry_point_table[L_AUTOCOIL],
                  L_AUTOCOIL,
                  (int)RF_FREE,
                  rfpulse,
                  tr_coil ) == FAILURE )
    {
        epic_error(use_ermes, "%s failed.", EM_PSD_SUPPORT_FAILURE,
                   EE_ARGS(1), STRING_ARG, "powermon coil");
        return FAILURE;
    }

#ifdef BURST_MODE_SUPPORT
    {
        /* Call minseq() to calculate Burst Mode model inputs.
           Disable writing corner points files for prescan entry points. */

        int gradHeatFile_save = gradHeatFile;
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(FALSE), gradHeatFile) : FALSE;
        if ( FAILURE == minseq( _min_seqgrad.fixedflag ? (_temp1284_min_seqgrad=min_seqgrad,&_temp1284_min_seqgrad) : &min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, idx_seqcoil, tsamp, tmin,
                                use_ermes, seg_debug ) ) {
            epic_error( use_ermes, "%s failed.",
                        EM_PSD_ROUTINE_FAILURE, EE_ARGS(1), STRING_ARG, "minseq" );
            return FAILURE;
        }
        gradHeatFile  = _gradHeatFile.fixedflag ?  ((void)(gradHeatFile_save), gradHeatFile) : gradHeatFile_save;
    }
#endif

    /* setup entry point table for Auto Coil */
    entry_point_table[L_AUTOCOIL].epfilter = (n8)filter_echo1coil;
    entry_point_table[L_AUTOCOIL].epprexres = coil_xres;

    /* Full coil mode for auto coil */
    entry_point_table[L_AUTOCOIL].epGeneralBankIndex = fullRecCoilInfo[0].hubIndex;
    entry_point_table[L_AUTOCOIL].epGeneralBankIndex2 = fullRecCoilInfo[0].hubIndex;
    entry_point_table[L_AUTOCOIL].epstartrec = 0;
    entry_point_table[L_AUTOCOIL].ependrec = fullRecCoilInfo[0].numChannels;

    for( j = 0; j < coil_slq; j++)
    {
        coilrsp_info[j].rsptloc = (coilscan_info[coil_slq/2].optloc + coilscan_info[coil_slq/2].optloc_shift
                                  + coilscan_info[coil_slq/2-1].optloc + coilscan_info[coil_slq/2-1].optloc_shift)/2.0;
        coilrsp_info[j].rsprloc = coilscan_info[0].oprloc + coilscan_info[0].oprloc_shift;
        coilrsp_info[j].rspphasoff = coilscan_info[0].opphasoff + coilscan_info[0].opphasoff_shift;

        for (i = 0; i < 9; i++)
        {
            coilrsprot[j][i] = hostToRspRotMat(coilscan_info[0].oprot[i]); 
        }
    }

    scalerotmats(coilrsprot, &coilloggrd, &phygrd, coil_slq, ps1obl_debug);

    /* corner cutting */
    coil_pfkr_fraction  = _coil_pfkr_fraction.fixedflag ?  ((void)(PI/4.0), coil_pfkr_fraction) : PI/4.0;
    coil_pfkr_flag  = _coil_pfkr_flag.fixedflag ?  ((void)(PSD_ON), coil_pfkr_flag) : PSD_ON;

    /* create zy encoding index and sort removed points to the end */
    /* sequential order for z & y */
    if (FAILURE == generateZyIndex( coil_zyindex,
                                    coil_yres,
                                    coil_slq,
                                    coil_yfov,
                                    coil_vthick,
                                    coil_pfkr_flag,
                                    coil_pfkr_fraction,
                                    _coil_sampledPts.fixedflag ? (_temp1285_coil_sampledPts=coil_sampledPts,&_temp1285_coil_sampledPts) : &coil_sampledPts ))
    {
        epic_error(use_ermes, "%s failed",
                   EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG, "generateZyIndex");
        return FAILURE;
    }


    return SUCCESS;
}   /* end AutoCoilpredownload() */


/* CoilSwitchGetTR (MRIhc15304)
 * 
 * Description:
 *   This function returns the TR for the coilSwitch SSP sequence based on
 *   the setRcvPortFlag as passed to CoilSwitchSetCoil.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  (O) return: TR in usec
 *  (I) setRcvPortFlag - flag to indicate that setrcvportimm will be
 *        executed when switching coils.  See CoilSwitchSetCoil
 */
int
CoilSwitchGetTR(const int setRcvPortFlag)
{
    int wait_rspimm = 0;
    
    /* When asynchronous RSP function calls are needed, the wait time is
     * extended to accomodate the worst case RSP time */
    if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
    {
        wait_rspimm = csw_wait_sethubindeximm;
    }

    if( setRcvPortFlag )
    {
        wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
    }

    return csw_tr + wait_rspimm;
}

/* doTG 
 *
 * Description:
 *  This function returns the doTG flag 
 *     PSD_CONTROL_PSC_SKIP -1: PSD force to skip TG
 *     APS_CONTROL_PSC       0: follow default smart prescan rules for TG
 *     PSD_CONTROL_PSC_RUN   1: force to run TG entry point for specific applications
 */
int
doTG(int psd_psc_control)
{
    int TG_control = psd_psc_control;
    if( ( exist(opdiffuse)
          || exist(opasl) 
          || (PSD_2D == exist(opimode) && PSD_SE == exist(oppseq) && PSD_OFF == exist(opfast)) 
          || (PSD_3D == exist(opimode) && PSD_SE == exist(oppseq) && exist(opinhance)) /* delta flow */ 
          || (PSD_SPECTRO == exist(opimode))
          || (PSD_OFF != exist(opflair)) || PSD_3PLANE == exist(opplane))
        && (!isValueSystem())
        && (APS_CONTROL_PSC == TG_control) )
    {
        TG_control = PSD_CONTROL_PSC_RUN;
    }

    if((TG_control != PSD_CONTROL_PSC_SKIP) && (TG_control != PSD_CONTROL_PSC_RUN) && (TG_control != APS_CONTROL_PSC))
    {
        TG_control = APS_CONTROL_PSC;
    }

    return TG_control;
}

/* doAS
 *
 * Description:
 *  This function returns the doAS flag 
 *     PSD_CONTROL_PSC_SKIP    -1: PSD force to skip autoshim 
 *     APS_CONTROL_PSC          0: follows default smart prescan rules for AS 
 *     PSD_CONTROL_PSC_RUN      1: forces to run Autoshim entry point for specific applications
 *     PSD_CONTROL_PSC_SPECIAL  2: forces to run global Autoshim for specific applications (breast DWI) 
 */
int
doAS(int psd_psc_control)
{
    int AS_control = psd_psc_control;
    if( ( PSD_ON == pimrsapsflg
          || PSD_ON == exist(opepi)
          || PSD_ON == exist(opspiral)
          || PSD_SSFP == oppseq
          || PSD_ON == exist(opvrg)
          || exist(opfat) || exist(opfatcl)
          || exist(opspecir) || exist(opwater))
        && (APS_CONTROL_PSC == AS_control)
        && (GRADSHIM_OFF != exist(opgradshim)) )
    {
        AS_control = PSD_CONTROL_PSC_RUN;
    }  /* Auto Shim is required for MRS, EPI, Spiral, VERSE and fiesta and Chem Sat */

    if((AS_control != PSD_CONTROL_PSC_SKIP) && (AS_control != PSD_CONTROL_PSC_RUN) 
       && (AS_control != APS_CONTROL_PSC) && (AS_control != PSD_CONTROL_PSC_SPECIAL))
    {
        AS_control = APS_CONTROL_PSC;
    }

    return AS_control;
}

/* generate zy encoding index for 3D acquisition for sequential order */
STATUS
generateZyIndex(ZY_INDEX * zy_index,
                const int zy_views,
                const int zy_slices,
                const float yFov,
                const float zFov,
                const int psc_pfkr_flag,
                const float psc_pfkr_fraction,
                int *zy_sampledPoints)
{
    n8 *xzPlanes = NULL;
    int i, j;
    int maxView = 0;
    float dist_ky, dist_kz;
    int superindex = 0;
    int sampledPts = 0;

    int zy_encodes = zy_views * zy_slices;
    float maskDist = 0;  /* Fake distance for sorting  masked encodess */
    float skipDist = 0;  /* Fake distance for sorting  encodes skipped due to
                            parallel imaging */

    float delta_ky = 1.0/yFov;  /* inverse mm */
    float delta_kz = 1.0/zFov;  /* inverse mm also */
    float origin_y = (float)(zy_views-1)/2.0 - 0.01;
    float origin_z = (float)(zy_slices-1)/2.0 - 0.01;
    float kr_fraction = 0.0;
    float max_dist_ky = 0.0;
    float max_dist_kz = 0.0;
    float sq_max_dist_ky = 0.0;
    float sq_max_dist_kz = 0.0;
    float sq_normdist_ky = 0.0;


    /*  Use dynamic memory allocation for zy_sort & zy_export */
    ZY_DIST1 *cal_zy_sort = NULL;
    if ((cal_zy_sort = (ZY_DIST1 *) malloc(sizeof(ZY_DIST1) * zy_encodes)) == NULL) {
        printf("%s: Failure allocating cal_zy_sort.\n", "generateZyIndex");
        return FAILURE;
    }
    memset(cal_zy_sort, 0, sizeof(ZY_DIST1) * zy_encodes);


    kr_fraction = sqrt(psc_pfkr_fraction*4.0/PI);
    max_dist_ky = 0.505*kr_fraction*delta_ky*(float)(zy_views-1);
    max_dist_kz = 0.505*kr_fraction*delta_kz*(float)(zy_slices-1);
    sq_max_dist_ky = max_dist_ky * max_dist_ky;
    sq_max_dist_kz = max_dist_kz * max_dist_kz;
    maskDist = 100.0*sqrt(sq_max_dist_ky + sq_max_dist_kz);

    if (maskDist < 10.0 * (float)(zy_encodes))
    {
        maskDist = 10.0 * (float)(zy_encodes);
    }

    skipDist = 2.0 * maskDist;

    superindex = 0;
    sampledPts = 0;

    for (i=0; i<zy_views; i++)
    {
        /*views start at 0*/
        dist_ky = delta_ky*(i - origin_y);
        sq_normdist_ky = pow(dist_ky, 2)/ sq_max_dist_ky;

        for (j=0; j<zy_slices; j++)
        {

            cal_zy_sort[superindex].view = i; /* sequential ordering: views start at 0*/
            cal_zy_sort[superindex].slice = j;  /*slices start at 0*/
            cal_zy_sort[superindex].flags  = 0; /* Initialized all flags to off */
            cal_zy_sort[superindex].distance =  (float) superindex;


            if (psc_pfkr_flag)
            {
                dist_kz = delta_kz*((float)(cal_zy_sort[superindex].slice) - origin_z);

                if ((sq_normdist_ky + (dist_kz*dist_kz)/ sq_max_dist_kz) > 1.0)
                {
                    cal_zy_sort[superindex].flags |= ZY_REMOVED;
                    cal_zy_sort[superindex].distance = maskDist;
                }
                else
                {
                    sampledPts +=1;
                }
            }
            else
            {
                sampledPts +=1;
            }

            superindex +=1;
        }
    }
    /* Sort to push the skipped and mask points to the end */
    qsort(cal_zy_sort, zy_encodes, sizeof(ZY_DIST1), psc_dist_compare);

    for (i=0; i < zy_encodes; i++)
    {
        zy_index[i].view = cal_zy_sort[i].view;
        zy_index[i].slice = cal_zy_sort[i].slice;
        zy_index[i].flags = cal_zy_sort[i].flags;
    }

    free(cal_zy_sort);

    maxView = 0;

    /* set flag for xz plane done */
    for (i=0; i < sampledPts; i++)
    {
        if (zy_index[i].view > maxView)
        {
            maxView = zy_index[i].view;
        }
    }
    /* Increment maxView such that it is the # of views to allocate */
    maxView++;

    /* Allocate buffer to keep track of XZ-planes completed */
    xzPlanes = (n8 *) malloc(sizeof(n8) * maxView);

    /* Initialize all XZ-planes */
    memset(xzPlanes, 1, sizeof(n8) * maxView);

    for (i = sampledPts - 1; i >= 0; i--)
    {
        if (xzPlanes[zy_index[i].view])
        {
            zy_index[i].flags |= ZY_XZ_PLANE_DONE;
            xzPlanes[zy_index[i].view] = 0;
        }
        else
        {
            zy_index[i].flags &= ~ZY_XZ_PLANE_DONE;
        }
    }

    free(xzPlanes);
    
    if(PSdebugstate)
    {
        const CHAR * export_filename = "pscCal.info";
        FILE * fid;
        fid = fopen(export_filename, "w");

        for (i = 0; i < zy_encodes; i++)
        {
            fprintf(fid, "PSC cal Info: superindex= %d view= %d slice=%d flags= %d \n",
                    i, zy_index[i].view, zy_index[i].slice, zy_index[i].flags);
        }

        fclose(fid);

    }

    *zy_sampledPoints = sampledPts;   /* fully sampled zy */


    return SUCCESS;
}

int psc_dist_compare(const void *dist1, const void *dist2)
{
        return (((ZY_DIST1 *)dist2)->distance < ((ZY_DIST1 *)dist1)->distance )? 1: -1;
}





/*
    Note: the current implementation does NOT cover the case of multi-angle oblique.
    So, we treat dwigcorr, dwikcorr, and dwibcorr as 1D arrays.  For future
    multi-angle oblique implementation, the following codes should be used. -- XJZ
 
    float dwigcorr[DATA_ACQ_MAX][9];	
    float dwibcorr[DATA_ACQ_MAX][3];	
    float dwikcorr[DATA_ACQ_MAX][9];

 */
/*  float dwigcorr[9];	output grad correction matrix */
/*  float dwibcorr[3];	output b0 (freg) correction matrix */
/*  float dwikcorr[9];	output pre-phaser area correction matrix */
/*  int   debug;           debug printf switch */
/*  int   rsprot[DATA_ACQ_MAX][9];  	 unscaled rotation matrices */
/*  float t_array[7];			 timing parametrers for DW-EPI sequence */
/*  int   xfs,yfs,zfs;               	 cfxfull, cfyfull, cfzfull */
/*  int   control;        control flag for dwi correction */
/** int   nslices;                   	number of slices */
STATUS
dwicorrcal(float dwigcorr[9],
           float dwibcorr[3],
           float dwikcorr[9], 
           int control, 
           int debug, 
           long rsprot[DATA_ACQ_MAX][9],
           int xfs, 
           int yfs,
           int zfs, 
           float t_array[7])
{
    STATUS status;                   	/* flag to return or exit */
  
    FILE *fp, *dwi_outfile;
    int   lines_header = 2;   		/* header lines to skip */
    int   lines_info_2_data = 1;		/* lines to skip between info and eddy data */
    int	lines_intra_axial = 1;		/* lines to skip between different eddy
                                       current acceptor axes for the SAME eddy
                                       current donor axis */
    int	lines_inter_axial = 2;		/* lines to skip between different eddy
                                       current donor axes  */
    int   max_chars_per_line = 100;  	/* for reading from delay.esp.xyz file */
    char  dummy[100];			/* dummy characters for the input file */

    int i, j;               		/* counter */

    float rot_norm[9]; 			/* normalized rotation matrix */


    /* Note: the current implementation does NOT cover the case of
       multi-angle oblique.  So, we treat rsp_norm as a 1D array.
       For future multi-angle oblique implementation, the following codes
       should be used. -- XJZ

       float rot_norm[DATA_ACQ_MAX][9]; 	
 
    */

    float *amp_x, *amp_y, *amp_z; 	/* eddy current amplitudes */

    float *tau_x, *tau_y, *tau_z; 	/* eddy current time constants */
 
    int  nx_eddy[4], ny_eddy[4],
        nz_eddy[4], nx_eddy_all,
        ny_eddy_all, nz_eddy_all;
    /* number of eddy current elements */

    float temp_g[9], temp_k[9], temp_b[3]; /* temp arrays  */

    const char  *infilename="grafidy.dwi";
    const char  *pathname="/usr/g/caldir/";
    char  basefilename[80];

    float xxx, yyy;			/* temporary variables  */  
    int offset_2d;			/* offset control for the 2D array */

    float t1, t2, t3, t4, t5, t9, t10, d4;   
    /* timing parameters */
    float R;		 		/* normalized slew-rate in 1.0/us  */

    float amp, tau;	    /* subroutine variables */  
  
    status = SUCCESS;


    /* I. Initialization and scaling the rotation matrix  */
 
    /* Note: the current implementation does NOT cover the case of multi-angle oblique.
       So, we treat dwigcorr, dwikcorr, and dwibcorr as 1D arrays.  For future
       multi-angle oblique implementation, the following codes should be used. -- XJZ 
   

       for(i=0; i<DATA_ACQ_MAX; i++) {
       for(j = 0; j<9; j++) {
       dwigcorr[i][j] = 0.0;
       dwikcorr[i][j] = 0.0;
       }
       for (j=0; j<3; j++) {
       dwibcorr[i][j] = 0.0;
       }
       }

    */

    for(j=0; j<9; j++) {
        dwigcorr[j] = 0.0;
        dwikcorr[j] = 0.0;
    }
    for(j=0; j<3; j++) {
        dwibcorr[j] = 0.0;
    }



    if (control == 1) {

        /* normailzing rotation matrices */
    
        rot_norm[0] = (float)rsprot[0][0]/(float)xfs;
        rot_norm[1] = (float)rsprot[0][1]/(float)xfs;
        rot_norm[2] = (float)rsprot[0][2]/(float)xfs;
        rot_norm[3] = (float)rsprot[0][3]/(float)yfs;
        rot_norm[4] = (float)rsprot[0][4]/(float)yfs;
        rot_norm[5] = (float)rsprot[0][5]/(float)yfs;
        rot_norm[6] = (float)rsprot[0][6]/(float)zfs;
        rot_norm[7] = (float)rsprot[0][7]/(float)zfs;
        rot_norm[8] = (float)rsprot[0][8]/(float)zfs;
    

        /* Note: the current implementation does NOT cover the case of
           multi-angle oblique.  So, we only take the [0][i] elements from
           the rotation matrix rsprot.  For future multi-angle oblique
           implementation, the following codes should be used. -- XJZ

           for(i=0; i<nslices; i++) {
           rot_norm[i][0] = (float)rsprot[i][0]/(float)xfs;
           rot_norm[i][1] = (float)rsprot[i][1]/(float)xfs;
           rot_norm[i][2] = (float)rsprot[i][2]/(float)xfs;
           rot_norm[i][3] = (float)rsprot[i][3]/(float)yfs;
           rot_norm[i][4] = (float)rsprot[i][4]/(float)yfs;
           rot_norm[i][5] = (float)rsprot[i][5]/(float)yfs;
           rot_norm[i][6] = (float)rsprot[i][6]/(float)zfs;
           rot_norm[i][7] = (float)rsprot[i][7]/(float)zfs;
           rot_norm[i][8] = (float)rsprot[i][8]/(float)zfs;
           }

        */



        /* II.  Open the GRAFIDY file */

        /* the GRAFIDY file has to follow the following format

        # header
        # header  (total lines of the header:  "lines_header")
        lx  (The numbers of x->x eddy currents)
        mx  (The numbers of x->y eddy currents)
        nx  (The numbers of x->z eddy currents)
        px  (The numbers of x->B0 eddy currents)

		(separated by "lines_info_2_data" lines)
	   
        tau(xx1)  alpha(xx1)
        tau(xx2)  alpha(xx2)
        ...		(x->x eddy currents; lx terms in total)
        tau(xxlx)  alpha(xxlx)

		(separated by "lines_intra_axial" lines)

        tau(xy1)  alpha(xy1)
        tau(xy2)  alpha(xy2)
        ...		(x->y eddy currents; mx terms in total)		
        tau(xymx)  alpha(xymx)
		
		(separated by "lines_intra_axial" lines)

        tau(xz1)  alpha(xz1)
        tau(xz2)  alpha(xz2)
        ...		(x->z eddy currents; nx terms in total)		
        tau(xznx)  alpha(xznx)

		(separated by "lines_intra_axial" lines)
	
        tau(x01)  alpha(x01)
        tau(x02)  alpha(x02)
        ...		(x->b0 eddy currents; px terms in total)		

        tau(x0px)  alpha(x0px)


		(separated by "lines_inter_axial" lines)


        ly   (The numbers of y->x eddy currents) 
        my   (The numbers of y->y eddy currents)
        ny   (The numbers of y->z eddy currents)
        py   (The numbers of y->b0 eddy currents)
	   
        tau(yx1)  alpha(yx1)
        tau(yx2)  alpha(yx2)
        ...		(y->x eddy currents; ly terms in total)
        tau(yxly)  alpha(yxly)

	
        tau(yy1)  alpha(yy1)
        tau(yy2)  alpha(yy2)
        ...		(y->y eddy currents; my terms in total)		
        tau(yymy)  alpha(yymy)
 

        tau(yz1)  alpha(yz1)
        tau(yz2)  alpha(yz2)
        ...		(y->z eddy currents; ny terms in total)		
        tau(yzny)  alpha(yzny)

	
        tau(y01)  alpha(y01)
        tau(y02)  alpha(y02)
        ...		(y->b0 eddy currents; py terms in total)		
        tau(y0py)  alpha(y0py)



        lz  (The numbers of z->x eddy currents)
        mz  (The numbers of z->y eddy currents)
        nz  (The numbers of z->z eddy currents)
        pz  (The numbers of z->b0 eddy currents) 
	   
        tau(zx1)  alpha(zx1)
        tau(zx2)  alpha(zx2)
        ...		(z->x eddy currents; lz terms in total)
        tau(zxlz)  alpha(zxlz)

	
        tau(zy1)  alpha(zy1)
        tau(zy2)  alpha(zy2)
        ...		(z->y eddy currents; mz terms in total)		
        tau(zymz)  alpha(zymz)
 

        tau(zz1)  alpha(zz1)
        tau(zz2)  alpha(zz2)
        ...		(z->z eddy currents; nz terms in total)		
        tau(zznz)  alpha(zznz)

	
        tau(z01)  alpha(z01)
        tau(z02)  alpha(z02)
        ...		(z->b0 eddy currents; pz terms in total)		
        tau(z0pz)  alpha(z0pz)

        ***************************************************************/


        strcpy(basefilename, pathname);
        strcat(basefilename, infilename);

        if ((fp = fopen(basefilename, "r")) == NULL) {
            /* Make non-fatal for now... */
            if (debug == 1)
                printf("dwicorrcal: could not open file: %s\n",basefilename);
            status = FAILURE;
            goto graceful_exit; 
        }


        if ((dwi_outfile = fopen("/usr/g/bin/dwi_dwbug_out", "w")) == NULL ) {
            printf("dwicorrcal: could not open file for debug.\n");
            status = FAILURE;
            goto graceful_exit;
        }

        if(lines_intra_axial > lines_inter_axial)  {
            if (debug == 1)
                printf("dwicorrcal: illed file format! \n the spacing of inter_axial info must be no smaller than the intra_axial spacing in %s\n",basefilename);
            status = FAILURE;
            goto graceful_exit; 
        }


        /* skip the header lines */
   
      	for (i=0; i<lines_header; i++)
            fgets(dummy, max_chars_per_line, fp);

        /* read in the x-eddy info */

        for (i=0; i<4; i++)
            fscanf(fp,"%d\n",&nx_eddy[i]);

        /* allocate memory for x_eddy terms */

        nx_eddy_all = nx_eddy[0]+nx_eddy[1]+nx_eddy[2]+nx_eddy[3];
        amp_x = (float *)malloc(nx_eddy_all*sizeof(float));
        tau_x = (float *)malloc(nx_eddy_all*sizeof(float));


        /* skipping the lines that separate the x_info from the x_data */

        for (i=0; i<lines_info_2_data; i++)
            fgets(dummy, max_chars_per_line, fp);

        /* read in the x-eddy data */

        offset_2d = 0;   
        for(j=0; j<4; j++)  {
            for(i=0; i<nx_eddy[j]; i++)  {
                fscanf(fp,"%f %f\n",&xxx, &yyy);
                tau_x[i+offset_2d] = xxx;
                amp_x[i+offset_2d] = yyy;
            }
            offset_2d = offset_2d+nx_eddy[j];
            for (i=0; i<lines_intra_axial; i++)
                fgets(dummy, max_chars_per_line, fp);
        }

        for (i=0; i<(lines_inter_axial-lines_intra_axial); i++)
            fgets(dummy, max_chars_per_line, fp);

        if(debug==1) {
            for(i=0; i<nx_eddy_all; i++) 
                fprintf(dwi_outfile, "tau_x[%d]=%f \t amp_x[%d]=%f\n", i,tau_x[i], i, amp_x[i]);

        }

        /* read in y-eddy info */

        for (i=0; i<4; i++)
            fscanf(fp,"%d\n",&ny_eddy[i]);

        /* allocate memory for y_eddy terms */

        ny_eddy_all = ny_eddy[0]+ny_eddy[1]+ny_eddy[2]+ny_eddy[3];
        amp_y = (float *)malloc(ny_eddy_all*sizeof(float));
        tau_y = (float *)malloc(ny_eddy_all*sizeof(float));

        /* skipping the lines that separate the y_info from the y_data */

        for (i=0; i<lines_info_2_data; i++)
            fgets(dummy, max_chars_per_line, fp);

        /* read in the y-eddy data */

        offset_2d = 0;
        for(j=0; j<4; j++)  {
            for(i=0; i<ny_eddy[j]; i++)  {
                fscanf(fp,"%f %f\n",&xxx, &yyy);
                tau_y[i+offset_2d] = xxx;
                amp_y[i+offset_2d] = yyy;
            }

            offset_2d = offset_2d+ny_eddy[j];
            for (i=0; i<lines_intra_axial; i++)
                fgets(dummy, max_chars_per_line, fp);
        }

        for (i=0; i<(lines_inter_axial-lines_intra_axial); i++)
            fgets(dummy, max_chars_per_line, fp);

        if(debug==1) {
            for(i=0; i<ny_eddy_all; i++) 
                fprintf(dwi_outfile, "tau_y[%d]=%f \t amp_y[%d]=%f\n", i,tau_y[i], i, amp_y[i]);
        }


        /* read in z-eddy info */

        for (i=0; i<4; i++)
            fscanf(fp,"%d\n",&nz_eddy[i]);

        /* allocate memory for z_eddy terms */

        nz_eddy_all = nz_eddy[0]+nz_eddy[1]+nz_eddy[2]+nz_eddy[3];
        amp_z = (float *)malloc(nz_eddy_all*sizeof(float));
        tau_z = (float *)malloc(nz_eddy_all*sizeof(float));

        /* skipping the lines that separate the z_info from the z_data */

        for (i=0; i<lines_info_2_data; i++)
            fgets(dummy, max_chars_per_line, fp);

        /* read in the z-eddy data */

        offset_2d = 0;
        for(j=0; j<4; j++)  {
            for(i=0; i<nz_eddy[j]; i++)  {
                fscanf(fp,"%f %f\n",&xxx, &yyy);
                tau_z[i+offset_2d] = xxx;
                amp_z[i+offset_2d] = yyy;
            }

            offset_2d = offset_2d+nz_eddy[j];
            if(j<3)  {
                for (i=0; i<lines_intra_axial; i++)
                    fgets(dummy, max_chars_per_line, fp);
            }
        }

        if(debug==1) {
            for(i=0; i<nz_eddy_all; i++) 
                fprintf(dwi_outfile, "tau_z[%d]=%f \t amp_z[%d]=%f\n", i,tau_z[i], i, amp_z[i]);
        }

        fclose(fp);


        /** end of reading the GRADIFY file **/


        /*  III. calculating the timing paramters        */

        t1= t_array[0]; 		/* all time units are in us */
        t2= t_array[0]+t_array[1];
        t3= 2*t_array[0]+t_array[1];
        t4= t_array[3];
        t5= t3+t_array[2];
        t9= 2*t3+t_array[2]+t_array[4];
        d4= t_array[4];
        t10 = t9+t_array[5];

        R = 1.0/t1;  		/* slew rate in 1.0/us */

        /* IV.  calculating the x-gradient-induced errors */

        offset_2d = 0;
        for(j=0; j<3; j++)  {
            for(i=0; i<nx_eddy[j]; i++)  {
                amp = amp_x[i+offset_2d];
                tau = tau_x[i+offset_2d];
                dwikcorr[j] = dwikcorr[j]+k_error(R, amp, tau, t1, t2, t3, t4, t9, d4, 0.0);
                dwigcorr[j] = dwigcorr[j]+g_error(R, amp, tau, t1, t2, t5, t10);
            }
            offset_2d = offset_2d+nx_eddy[j];

        }

        /*   b0 errors   */
        for(i=0; i<nx_eddy[3]; i++)  {
            amp = amp_x[i+offset_2d];
            tau = tau_x[i+offset_2d];
            dwibcorr[0] = dwibcorr[0]+g_error(R, amp, tau, t1, t2, t5, t10);
        }


        /* V.  calculating the y-gradient-induced errors */

        offset_2d = 0;
        for(j=0; j<3; j++)  {
            for(i=0; i<ny_eddy[j]; i++)  {
                amp = amp_y[i+offset_2d];
                tau = tau_y[i+offset_2d];
                dwikcorr[j+3] = dwikcorr[j+3]+k_error(R, amp, tau, t1, t2, t3, t4, t9, d4, 0.0);
                dwigcorr[j+3] = dwigcorr[j+3]+g_error(R, amp, tau, t1, t2, t5, t10);
            }
            offset_2d = offset_2d+ny_eddy[j];
        }

        /*   b0 errors   */
        for(i=0; i<ny_eddy[3]; i++)  {
            amp = amp_y[i+offset_2d];
            tau = tau_y[i+offset_2d];
            dwibcorr[1] = dwibcorr[1]+g_error(R, amp, tau, t1, t2, t5, t10);
        }


        /* VI.  calculating the z-gradient-induced errors */

        offset_2d = 0;
        for(j=0; j<3; j++)  {
            for(i=0; i<nz_eddy[j]; i++)  {
                amp = amp_z[i+offset_2d];
                tau = tau_z[i+offset_2d];
                dwikcorr[j+6] = dwikcorr[j+6]+k_error(R, amp, tau, t1, t2, t3, t4, t9, d4, 0.0);
                dwigcorr[j+6] = dwigcorr[j+6]+g_error(R, amp, tau, t1, t2, t5, t10);
            }
            offset_2d = offset_2d+nz_eddy[j];
        }

        /*   b0 errors   */
        for(i=0; i<nz_eddy[3]; i++)  {
            amp = amp_z[i+offset_2d];
            tau = tau_z[i+offset_2d];
            dwibcorr[2] = dwibcorr[2]+g_error(R, amp, tau, t1, t2, t5, t10);
        }


        if (debug == 1) {

            fprintf(dwi_outfile, "time array elements:\n\n");

            for(i=0; i<7; i++)  {
                fprintf(dwi_outfile, "t[%d]=%e\n", i, t_array[i]);
            }

            fprintf(dwi_outfile, "control flag for blip correction = %d\n",control);

            fprintf(dwi_outfile, "\n\nLamda matrix for gradient:\n");
            fprintf(dwi_outfile, "\t g[0]=%e \t g[1]=%e \t g[2]=%e\n", dwigcorr[0], dwigcorr[1], dwigcorr[2]);
            fprintf(dwi_outfile, "\t g[3]=%e \t g[4]=%e \t g[5]=%e\n", dwigcorr[3], dwigcorr[4], dwigcorr[5]);
            fprintf(dwi_outfile, "\t g[6]=%e \t g[7]=%e \t g[8]=%e\n", dwigcorr[6], dwigcorr[7], dwigcorr[8]);

            fprintf(dwi_outfile, "\n\nLamda matrix for k-space:\n");
            fprintf(dwi_outfile, "\t k[0]=%e \t k[1]=%e \t k[2]=%e\n", dwikcorr[0], dwikcorr[1], dwikcorr[2]);
            fprintf(dwi_outfile, "\t k[3]=%e \t k[4]=%e \t k[5]=%e\n", dwikcorr[3], dwikcorr[4], dwikcorr[5]);
            fprintf(dwi_outfile, "\t k[6]=%e \t k[7]=%e \t k[8]=%e\n", dwikcorr[6], dwikcorr[7], dwikcorr[8]);

            fprintf(dwi_outfile, "\n\nLamda matrix for B0-correction:\n");
            fprintf(dwi_outfile, "\t b[0]=%e \t b[1]=%e \t b[2]=%e\n", dwibcorr[0], dwibcorr[1], dwibcorr[2]);


            fprintf(dwi_outfile, "\n\nOriginal Rotation Matrix:\n");
            fprintf(dwi_outfile, "\t r[0]=%ld \t r[1]=%ld \t r[2]=%ld\n", rsprot[0][0], rsprot[0][1], rsprot[0][2]);
            fprintf(dwi_outfile, "\t r[3]=%ld \t r[4]=%ld \t r[5]=%ld\n", rsprot[0][3], rsprot[0][4], rsprot[0][5]);
            fprintf(dwi_outfile, "\t r[6]=%ld \t r[7]=%ld \t r[8]=%ld\n", rsprot[0][6], rsprot[0][7], rsprot[0][8]);

            fprintf(dwi_outfile, "\n\nfull scale gradient values:\n");
            fprintf(dwi_outfile, "\t xfs=%d \t yfs=%d \t zfs=%d\n", xfs, yfs, zfs);




            fprintf(dwi_outfile, "\n\nRotation matrix:\n");
            fprintf(dwi_outfile, "\t r[0]=%e \t r[1]=%e \t r[2]=%e\n", rot_norm[0], rot_norm[1], rot_norm[2]);
            fprintf(dwi_outfile, "\t r[3]=%e \t r[4]=%e \t r[5]=%e\n", rot_norm[3], rot_norm[4], rot_norm[5]);
            fprintf(dwi_outfile, "\t r[6]=%e \t r[7]=%e \t r[8]=%e\n", rot_norm[6], rot_norm[7], rot_norm[8]);

        }


        /** end of error calculation  **/


        /* VII.  Similarity transform of the correction matrix  **/

        /** first round for dwigcorr and dwikcorr matrices  **/

        for(j=0; j<3; j++)  {
            for(i=0; i<3; i++)  {
                temp_g[i+3*j] = rot_norm[j*3]*dwigcorr[i]+rot_norm[j*3+1]*dwigcorr[i+3]+rot_norm[j*3+2]*dwigcorr[i+6];
                temp_k[i+3*j] = rot_norm[j*3]*dwikcorr[i]+rot_norm[j*3+1]*dwikcorr[i+3]+rot_norm[j*3+2]*dwikcorr[i+6];
            }
        }

        /** second round for dwigcorr and dwikcorr matrices  **/

        for(i=0; i<3; i++)  {
            for(j=0; j<3; j++)  {
                dwigcorr[i+3*j] = temp_g[j*3]*rot_norm[i*3]+temp_g[j*3+1]*rot_norm[i*3+1]+temp_g[j*3+2]*rot_norm[i*3+2];

                dwikcorr[i+3*j] = temp_k[j*3]*rot_norm[i*3]+temp_k[j*3+1]*rot_norm[i*3+1]+temp_k[j*3+2]*rot_norm[i*3+2];
            }

        }

        /*  VIII. calculating the B0 errors  **/

        for(i=0; i<3; i++)
            temp_b[i] = dwibcorr[0]*rot_norm[i*3]+dwibcorr[1]*rot_norm[i*3+1]+dwibcorr[2]*rot_norm[i*3+2];

        for(i=0; i<3; i++)
            dwibcorr[i] = temp_b[i];

        /* IX.  Printing out info  **/

        if (debug == 1) {

            fprintf(dwi_outfile, "\n\n\nmatrices after the similarity transform:\n");
            fprintf(dwi_outfile, "\n\nLamda matrix for gradient:\n");
            fprintf(dwi_outfile, "\t g[0]=%e \t g[1]=%e \t g[2]=%e\n", dwigcorr[0], dwigcorr[1], dwigcorr[2]);
            fprintf(dwi_outfile, "\t g[3]=%e \t g[4]=%e \t g[5]=%e\n", dwigcorr[3], dwigcorr[4], dwigcorr[5]);
            fprintf(dwi_outfile, "\t g[6]=%e \t g[7]=%e \t g[8]=%e\n", dwigcorr[6], dwigcorr[7], dwigcorr[8]);

            fprintf(dwi_outfile, "\n\nLamda matrix for k-space:\n");
            fprintf(dwi_outfile, "\t k[0]=%e \t k[1]=%e \t k[2]=%e\n", dwikcorr[0], dwikcorr[1], dwikcorr[2]);
            fprintf(dwi_outfile, "\t k[3]=%e \t k[4]=%e \t k[5]=%e\n", dwikcorr[3], dwikcorr[4], dwikcorr[5]);
            fprintf(dwi_outfile, "\t k[6]=%e \t k[7]=%e \t k[8]=%e\n", dwikcorr[6], dwikcorr[7], dwikcorr[8]);

            fprintf(dwi_outfile, "\n\nLamda matrix for B0-correction:\n");
            fprintf(dwi_outfile, "\t b[0]=%e \t b[1]=%e \t b[2]=%e\n", dwibcorr[0], dwibcorr[1], dwibcorr[2]);

        }

        fclose(dwi_outfile);
    }  /* closing for the control flag  */

 graceful_exit:
    return status;


}  /* end of the dwicorrcal routine */


/* sub-subroutines  */

float k_error(float R, 
              float amp, 
              float tau,
              float t1, 
              float t2, 
              float t3, 
              float t4, 
              float t9,
              float d4,
              float delta)

/*float t1, t2, t3, t4, t9, d4;    timing parameters */
/*float R; 		           normalized slew-rate in 1.0/us  */
/*float amp, tau, delta; 	   subroutine variables */  


{

double gamma=0.0267475;          /* gyromagnetic ratio in MHz/gauss:
			  	   2*3.1415926*4.257*0.001 */
 
double error_a, error_b, error_c, error_d;

      	error_a = 0.01*(double)R*gamma*(double)(amp*tau*tau);
							/* 0.01 comes from
							the % expression of
							amp */
	error_b = 1-exp((double)(t1/tau));
	error_c = 1-exp((double)(t2/tau));
	error_d = (double)(2*exp(-t4/tau)-exp(-(t9+delta)/tau)-exp(-(t3+d4+delta)/tau));

return((float)(error_a*error_b*error_c*error_d));


	
/** return(R*gamma*amp*tau*tau*(1-exp(t1/tau))*
(1-exp(t2/tau))*(2*exp(-t4/tau)-exp(-(t9+delta)/tau)-exp(-(t3+d4+delta)/tau)));

**/

}

float g_error(float R,
              float amp,
              float tau,
              float t1,
              float t2,
              float t5,
              float t10)
{

double error_a, error_b, error_c, error_d;

        error_a = 0.01*(double)R*(double)(amp*tau);  /* 0.01 comes from
							the % expression of
							amp */
	error_b = 1-exp((double)(t1/tau));
	error_c = 1-exp((double)(t2/tau));
	error_d = (1+exp((double)(t5/tau)))*exp(-(double)(t10/tau));

/** return(R*amp*tau*(1-exp(t1/tau))*(1-exp(t2/tau))*(1+exp(t5/tau))*exp(-t10/tau));
**/ 

 return((float)(error_a*error_b*error_c*error_d));


}

/* end of file -- XJZ */ 


/* Functions that calculate per unit, per axis contribution to delta grad and freq */

/* Some arrays used in CalcPsdReconHoecCorr() and SaveHoecDebugInfo() */
float ****dwi_hoec_coef_phy = NULL;
float ****dwi_hoec_coef_phy_R = NULL;
float ****dwi_hoec_coef_log = NULL;
float **phy2log_F = NULL;

/*
   CalcPsdReconHoecCorr() takes (alpha, tau) HOEC basis coefficients and gradient timing
   (simplified to 2 DW gradients) as input to calculate correction gradients and frequencies
   for PSD as well as the correction coefficients for recon. PSD correction is done on a per
   slice per echo basis, and here we only calculate the contribution from each gradient axis
   assuming unit gradient (ie. 1 G/cm). In diffstep(), actual gradient amplitude is multiplied
   to the numbers calculated here and summed over all 3 axes to get the total contribution to
   delta gradients and frequencies. The PSD correction is similar to partially linearie the
   HOEC bases at a given slice. For recon correction, no linearization is needed as recon can
   handle arbitrary bases. The contribution of the remaining terms after PSD correction is
   calculated using the actual DW gradient amplitudes (one setting for each rep) and saved in
   a file later read by recon. Note all the calculation here takes into account of rotation as
   well, ie. logical gradients are first converted to physical coordinates to compute HOEC and
   then combined and converted back to logical gradients. Final outputs for PSD and recon are
   both in logical coordinates.

Input:
  All the input parameters of the function (see below for detailed comments)
  Global variables or arrays (their meanings are in the HoecGlobal section):
    hoec_cal_info.fit_order;
    hoec_cal_info.total_bases_per_axis;
    hoec_cal_info.num_terms[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES];
    hoec_cal_info.alpha[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES][HOEC_MAX_NUM_TERMS];
    hoec_cal_info.tau[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES][HOEC_MAX_NUM_TERMS];
    ext_corr_term[HOEC_TOTAL_NUM_AXES][HOEC_MAX_NUM_BASES];

Output:
  dwi_hoec_gcor_XonX[ileave][nslice][necho], dwi_hoec_gcor_YonX[nslice][necho], dwi_hoec_gcor_ZonX[nslice][necho],
  dwi_hoec_gcor_XonY[ileave][nslice][necho], dwi_hoec_gcor_YonY[nslice][necho], dwi_hoec_gcor_ZonY[nslice][necho],
  dwi_hoec_bcor_XonB0[ileave][nslice][necho], dwi_hoec_bcor_YonB0[nslice][necho], and dwi_hoec_bcor_ZonB0[nslice][necho],
  for PSD correction (per slice, echo and donor axis; assume unit gradient amplitude), which are applied 
  in diffstep(). Note that dwi_hoec_gcor_XonZ, dwi_hoec_gcor_YonZ, and dwi_hoec_gcor_ZonZ are also defined
  but not used in the current implementation.
  
  rhhoec_bases.hoec_coef[hoec_cal_info.total_bases_per_axis][3] for recon correction (not per slice as
  recon deals high order bases directly; only k-space center; all donors with actual amplitudes are
  calculated and summed).
*/

STATUS
CalcPsdReconHoecCorr(
    int control_psd, /* same as the cv hoecc_psd_flag */
    int control_recon, /* same as the cv hoecc_recon_flag */
    int per_echo_corr,  /* same as the cv psd_per_echo_corr */
    int numSlices,
    long rsprot[DATA_ACQ_MAX][9],  /* unscaled rotation matrices */
    float t_array[7],  /* DW gradient timing parametrers */
    int echoSpacing,
    int nechoBeforeTE,  /* this determines location of the k-space center */
    int echoTrainLength,
    int interleaves)
{
    int i, j, k, m, n, pp;    /* counter */
    float r[3][3];        /* normalized rotation matrix */
    float t1, t2, t3, t4, t5, t9, t10, d4;   /* timing parameters */
    float curEchoCenter;  /* time between start of first diffusion gradient lobe and the center of the current echo */
    float R = 0.0;            /* normalized slew-rate in 1.0/us */
    float amp, tau;     /* subroutine variables */
    float cur_dw_gx, cur_dw_gy, cur_dw_gz;  /* DW gradient amplitude in G/cm of the current pass */
    int xorder, yorder, zorder;
    int ileave_shift;
    int status;

    /*** SVBranch: HCSDM00259119  -eco mpg case:
         In eco-MPG case, the down-ramp
         and up-ramp of MPG are not the same ***/
    float R1 = 0.0; /* ramp-up SR of 1st diff, abs value */
    float R2 = 0.0; /* ramp-down SR of 1st diff, abs value */
    float R3 = 0.0; /* ramp-up SR of 2nd diff, abs value */
    float R4 = 0.0; /* ramp-down SR of 2nd diff, abs value */
    float t6 = 0.0; /* start time of plateau of 2nd diff */
    float t7 = 0.0; /* end time of plateau of 2nd diff */
    float t8 = 0.0; /* end time of 2nd diff */
    /*******************************************/        
    
    /* I. Initialization */
    /* Initialize PSD correction coefficients as zeros. The recon correction coefficients 
       rhhoec_bases.hoec_coef are already initialized as zeros in the HoecCalcCorrectionPredownload
       section before the CalcPsdReconHoecCorr() call. */
    for (pp=0; pp<interleaves; pp++)
    { 
        for (i=0; i<numSlices; i++) /* slice */
        {
            for (j=0; j<echoTrainLength; j++)  /* echo */
            {
                dwi_hoec_gcor_XonX[pp][i][j] = 0.0;
                dwi_hoec_gcor_YonX[pp][i][j] = 0.0;
                dwi_hoec_gcor_ZonX[pp][i][j] = 0.0;
                dwi_hoec_gcor_XonY[pp][i][j] = 0.0;
                dwi_hoec_gcor_YonY[pp][i][j] = 0.0;
                dwi_hoec_gcor_ZonY[pp][i][j] = 0.0;
                dwi_hoec_gcor_XonZ[pp][i][j] = 0.0;
                dwi_hoec_gcor_YonZ[pp][i][j] = 0.0;
                dwi_hoec_gcor_ZonZ[pp][i][j] = 0.0;
                dwi_hoec_bcor_XonB0[pp][i][j] = 0.0;
                dwi_hoec_bcor_YonB0[pp][i][j] = 0.0;
                dwi_hoec_bcor_ZonB0[pp][i][j] = 0.0;
            }
        }
    }
    
    /* Initialize status to be returned */
    status = SUCCESS;
        
    /* allocate memory for dwi_hoec_coef_phy[hoec_cal_info.total_bases_per_axis][HOEC_TOTAL_NUM_AXES][interleaves] [necho] */
    dwi_hoec_coef_phy = (float ****)malloc(hoec_cal_info.total_bases_per_axis*sizeof(float ***));
    if (dwi_hoec_coef_phy == NULL) 
    {
        status = FAILURE;
        goto graceful_exit;
    } 
    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
    {
        dwi_hoec_coef_phy[i] = (float ***)malloc(HOEC_TOTAL_NUM_AXES*sizeof(float **));
        if (dwi_hoec_coef_phy[i] == NULL) 
        {
            status = FAILURE;
            goto graceful_exit;
        }
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
        {
            dwi_hoec_coef_phy[i][j] = (float **)malloc(interleaves*sizeof(float *));
            if (dwi_hoec_coef_phy[i][j] == NULL)
            {
                status = FAILURE;
                goto graceful_exit;
            }
           for (pp=0; pp<interleaves; pp++)
           {
                dwi_hoec_coef_phy[i][j][pp] = (float *)malloc(echoTrainLength*sizeof(float));
                if (dwi_hoec_coef_phy[i][j][pp] == NULL) 
                {
                    status = FAILURE;
                    goto graceful_exit;
                }
            }            
        }
    }

    /* allocate memory for dwi_hoec_coef_phy_R[hoec_cal_info.total_bases_per_axis][HOEC_TOTAL_NUM_AXES][necho] */
    dwi_hoec_coef_phy_R = (float ****)malloc(hoec_cal_info.total_bases_per_axis*sizeof(float ***));
    if (dwi_hoec_coef_phy_R == NULL) 
    {
        status = FAILURE;
        goto graceful_exit;
    }     
    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
    {
        dwi_hoec_coef_phy_R[i] = (float ***)malloc(HOEC_TOTAL_NUM_AXES*sizeof(float **));
        if (dwi_hoec_coef_phy_R[i] == NULL) 
        {
            status = FAILURE;
            goto graceful_exit;
        }         
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
        {
            dwi_hoec_coef_phy_R[i][j] = (float **)malloc(interleaves*sizeof(float *));
            if (dwi_hoec_coef_phy_R[i][j] == NULL) 
            {
                status = FAILURE;
                goto graceful_exit;
            }
            for (pp=0; pp<interleaves; pp++)
            {
                dwi_hoec_coef_phy_R[i][j][pp] = (float *)malloc(echoTrainLength*sizeof(float));
                if (dwi_hoec_coef_phy_R[i][j][pp] == NULL)
                {
                    status = FAILURE;
                    goto graceful_exit;
                }
            }
               
        }
    }

    /* allocate memory for dwi_hoec_coef_log[hoec_cal_info.total_bases_per_axis][HOEC_TOTAL_NUM_AXES][interleaves][necho] */
    dwi_hoec_coef_log = (float ****)malloc(hoec_cal_info.total_bases_per_axis*sizeof(float ***));
    if (dwi_hoec_coef_log == NULL) 
    {
        status = FAILURE;
        goto graceful_exit;
    }     
    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
    {
        dwi_hoec_coef_log[i] = (float ***)malloc(HOEC_TOTAL_NUM_AXES*sizeof(float **));
        if (dwi_hoec_coef_log[i] == NULL) 
        {
            status = FAILURE;
            goto graceful_exit;
        }             
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
        {
            dwi_hoec_coef_log[i][j] = (float **)malloc(interleaves*sizeof(float *));
            if (dwi_hoec_coef_log[i][j] == NULL)
            {
                status = FAILURE;
                goto graceful_exit;
            }
            for (pp=0; pp<interleaves; pp++)
            {
                dwi_hoec_coef_log[i][j][pp] = (float *)malloc(echoTrainLength*sizeof(float));
                if (dwi_hoec_coef_log[i][j][pp] == NULL)
                {
                    status = FAILURE;
                    goto graceful_exit;
                }
            }
 
        }
    }

    /* allocate memory for phy2log_F[hoec_cal_info.total_bases_per_axis][HOEC_TOTAL_NUM_AXES] */
    phy2log_F = (float **)malloc(hoec_cal_info.total_bases_per_axis*sizeof(float *));
    if (phy2log_F == NULL) 
    {
        status = FAILURE;
        goto graceful_exit;
    }        
    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
    {
        phy2log_F[i] = (float *)malloc(hoec_cal_info.total_bases_per_axis*sizeof(float));
        if (phy2log_F[i] == NULL) 
        {
            status = FAILURE;
            goto graceful_exit;
        }        
    }

    /* Initialize dwi_hoec_coef_phy, dwi_hoec_coef_phy_R, dwi_hoec_coef_log, and phy2log_F as zeros */
    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++) /* basis */
    {
        for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)  /* donor */
        {
            for (pp=0; pp<interleaves; pp++)
            {
                for (k=0; k<echoTrainLength; k++)  /* echo */
                {
                    dwi_hoec_coef_phy[i][j][pp][k] = 0.0;
                    dwi_hoec_coef_phy_R[i][j][pp][k] = 0.0;
                    dwi_hoec_coef_log[i][j][pp][k] = 0.0;
                }
            }
        }
    }

    for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
    {
        for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
        {
            phy2log_F[i][j] = 0.0;
        }
    }

    if (control_psd != 0 || control_recon != 0)  /* when correction is needed (no matter if it's at PSD or recon or both */
    {
        /* II. Calculate the timing paramters */
        /***  SVBranch: HCSDM00259119  eco mpg case:
             In eco-MPG case, the down-ramp
             and up-ramp of MPG are not the
             same ***/
        if (mpg_opt_flag) 
        {
            t1 = t_array[0];         /* all time units are in us */
            t2 = t_array[0] + t_array[1];
            t3 = t_array[0] + t_array[1] + (float)pw_gxdld;
            t4 = t_array[3];
            t5 = t3 + t_array[2];
            t6 = t5 + (float)pw_gxdra;
            t7 = t6 + (float)pw_gxdr;
            t8 = t7 + (float)pw_gxdrd;
            t9= 2*t3 + t_array[2] + t_array[4];
            d4= t_array[4];
            t10 = t9+t_array[5];
            ileave_shift = t_array[6];
            R1 = 1.0/ t1;
            R2 = 1.0/ (t3-t2);
            R3 = 1.0/ (t6-t5); 
            R4 = 1.0/ (t8-t7); 
        }
        else /* original case */
        {
            t1= t_array[0];         /* all time units are in us */
            t2= t_array[0]+t_array[1];
            t3= 2*t_array[0]+t_array[1];
            t4= t_array[3];
            t5= t3+t_array[2];
            t9= 2*t3+t_array[2]+t_array[4];
            d4= t_array[4];
            t10 = t9+t_array[5];
            ileave_shift = t_array[6];
            R = 1.0/t1;         /* slew rate in 1.0/us */
        }

        /* III. Compute the E(t) matrix (hoec_cal_info.total_bases_per_axis-by-3-by-necho), i.e. fill in
                the dwi_hoec_coef_phy array */
        for (i=0; i<HOEC_TOTAL_NUM_AXES; i++) /* donor */
        {
            for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)  /* basis */
            {
                for (m=0; m<hoec_cal_info.num_terms[i][j]; m++)  /* term */
                {
                    amp = hoec_cal_info.alpha[i][j][m]*alpha_scale[i][j][m];  /* alpha_scale is 1 for auto mode,
                                                                                 and can be 0 for some terms in manual mode */
                    tau = hoec_cal_info.tau[i][j][m];
                    for (pp=0; pp<interleaves; pp++)
                    {
                        for (n=0; n<echoTrainLength; n++)  /* echo */
                        {
                            if(n < iref_etl) continue; /* interref echoes played out before diffusion gradient */
    
                            if (per_echo_corr == 0)  /* same compensation for all echoes (DC model) */
                            {
                                curEchoCenter = (t10+(pp*ileave_shift))-(float)(echoSpacing)/2.0;
                            }
                            else  /* per echo compensation (piece-wise constant model) */
                            {
                                curEchoCenter = (t10+(pp*ileave_shift))-(float)(echoSpacing)*((float)(nechoBeforeTE-1-n)+0.5);
                            }

                            /* Note that dwi_hoec_coef_phy means the correction coefficients (i.e. these
                               coefficients, when added to the nominal gradient/frequency, will correct
                               the HOEC error). There is a difference in sign convention between the product
                               and ATD prototype HOEC cal tool, and hoec_cal_data_sign is used to adjust for
                               such difference (1.0 for product, -1.0 for the ATD prototype; default to 1.0) */
                            if (mpg_opt_flag) /*  SVBranch: HCSDM00259119  eco mpg case */
                            {
                                dwi_hoec_coef_phy[j][i][pp][n] = dwi_hoec_coef_phy[j][i][pp][n] + 
                                                         hoec_cal_data_sign *
                                                         g_error_kcenter2(R1, R2, 
                                                                          R3, R4, 
                                                                          amp, tau, 
                                                                          t1, t2, t3, 
                                                                          t5, t6, t7, 
                                                                          t8, curEchoCenter);                            
                            }
                            else /* original case */
                            {
                                dwi_hoec_coef_phy[j][i][pp][n] = dwi_hoec_coef_phy[j][i][pp][n] + 
                                                         hoec_cal_data_sign *
                                                         g_error_kcenter(R, amp, tau, 
                                                                         t1, t2, t5, 
                                                                         curEchoCenter);
                            }
                        }  /* end for echo */
                    } /* end for interleave */
                }  /* end for term */
            }  /* end for basis */
        }  /* end for donor */

        /* IV. Obtain normalized rotation matrix R */
#ifdef SIM
        /* just for test purpose */
        r[0][0] = r[1][1] = r[2][2] = 1.0;
        r[0][1] = r[0][2] = r[1][0] = r[1][2] = r[2][0] = r[2][1] = 1.0;
#else   /* Note: multigroup acquisition is locked out for HOEC correction */
        r[0][0] = (float)rsprot[0][0]/(float)max_pg_iamp;
        r[0][1] = (float)rsprot[0][1]/(float)max_pg_iamp;
        r[0][2] = (float)rsprot[0][2]/(float)max_pg_iamp;
        r[1][0] = (float)rsprot[0][3]/(float)max_pg_iamp;
        r[1][1] = (float)rsprot[0][4]/(float)max_pg_iamp;
        r[1][2] = (float)rsprot[0][5]/(float)max_pg_iamp;
        r[2][0] = (float)rsprot[0][6]/(float)max_pg_iamp;
        r[2][1] = (float)rsprot[0][7]/(float)max_pg_iamp;
        r[2][2] = (float)rsprot[0][8]/(float)max_pg_iamp;
#endif

        /* V. Compute the F matrix (phy to log matrix, hoec_cal_info.total_bases_per_axis-by-hoec_cal_info.total_bases_per_axis,
               actual form given by the output "phy2LogStrNonZeroOneCol" in GetPolyPhy2LogMat.m. Here we use a recursive formula
               to fill in the F matrix) */
        {
            int matPos;
            int numTerms;
            int orderIndex, termIndex;

            matPos = 0;
            for (orderIndex=0; orderIndex<=hoec_cal_info.fit_order; orderIndex++)
            {
                numTerms = (orderIndex+1)*(orderIndex+2)/2;
                for (termIndex=0; termIndex<numTerms; termIndex++)
                {
                    convertPhy2Log(phy2log_F[matPos+termIndex], termIndex+matPos, orderIndex, r);
                }
                matPos += numTerms;
            }
        }

        /* VI. Compute E(t)*R */
        for (pp=0; pp<interleaves; pp++)
        {
            for (n=0; n<echoTrainLength; n++)
            {
                for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
                {
                    for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
                    {

                        for (k=0; k<HOEC_TOTAL_NUM_AXES; k++)
                        {
                            dwi_hoec_coef_phy_R[i][j][pp][n] += dwi_hoec_coef_phy[i][k][pp][n]*r[k][j];
                        }
                    }
                }
            }
        }

        /* VII. Compute D = transpose(F)*(E(t)*R), result is hoec_cal_info.total_bases_per_axis-by-3 matrix */
        for (pp=0; pp<interleaves; pp++)
        {
            for (n=0; n<echoTrainLength; n++)  /* echo */
            {
                for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)  /* basis */
                {
                    for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)  /* donor */
                    {
                        for (k=0; k<hoec_cal_info.total_bases_per_axis; k++)
                        {
                            dwi_hoec_coef_log[i][j][pp][n] += phy2log_F[k][i]*dwi_hoec_coef_phy_R[k][j][pp][n];
                        }
                    }
                }
            }
        }
        /* VIII. Split dwi_hoec_coef_log into PSD corr, recon corr, and no corr (in some hoec_comp mode)
           coefficients according to basis_correction_mode set up in the previous section.
           dwi_hoec_coef_log[nbases][ndonors][nechoes] is the input array. For those bases corrected
           in PSD, we evaluate them at their slice location and add bases that are linearized to Gx
           together (same for Gy, B0), and finally get dwi_hoec_bcor_XonB0, dwi_hoec_bcor_YonB0, 
           dwi_hoec_bcor_ZonB0 for B0 term, dwi_hoec_gcor_XonX, dwi_hoec_gcor_YonX, dwi_hoec_gcor_ZonX for Gx, 
           and dwi_hoec_gcor_XonY, dwi_hoec_gcor_YonY, dwi_hoec_gcor_ZonY for Gy. For bases corrected in recon, 
           we directly take the high order bases coefficients dwi_hoec_coef_log because the linearization
           is done in recon processing and not here. The only difference is that we only use the echo
           at the k-space center. The end result for recon is rhhoec_bases.hoec_coef[nbases][ndonors],
           which will be passed to recon for processing later. Note all the calculate here assumes 1G/cm
           driver gradient amplitude, so the actual DW gradient amplitudes need to be multiplied to get
           the true eddy current amplitude. For PSD correction, this is done in diffstep(), where the
           instruction amplitude ia_incdifx of the DW Gx amplitude incdifx is multiplied to the proper 
           dwi_hoec_gcor before adding to the ideal instruction amplitude (same for Gy, B0). For recon
           correction, this is done by saving the DW X, Y, Z gradient amplitude components for each rep to
           rhdiffusion_grad_amp and multiplying them to rhhoec_bases.hoec_coef in recon processing */

        for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)  /* bases */
        {
            xorder = hoec_cal_info.termIndex2xyzOrderMapping[0][i];
            yorder = hoec_cal_info.termIndex2xyzOrderMapping[1][i];
            zorder = hoec_cal_info.termIndex2xyzOrderMapping[2][i];

            for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)  /* donor */
            {
                switch (ext_corr_term[j][i])
                {
                    case 0:  /* no correction */
                        break;

                    case 1:  /* PSD correction: per-slice linearization, per echo */
                        for (pp=0; pp<interleaves; pp++)
                        {
                            for (k=0; k<numSlices; k++)  /* slice */
                            {
                                for (n=0; n<echoTrainLength; n++)  /* echo */
                                {
                                    if(n < iref_etl) continue; /* interref echoes played before diffusion gradients */

                                    if (xorder==0 && yorder==0) /* donor  (X, Y, Z) on Z and B0 */
                                    {
                                        switch(j)
                                        {
                                            case 0:
                                                dwi_hoec_bcor_XonB0[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);

                                                if (zorder==0) break;
                                                dwi_hoec_gcor_XonZ[pp][k][n] +=
                                                         zorder*dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder-1);

                                                break;
                                            case 1:
                                                dwi_hoec_bcor_YonB0[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);

                                                if (zorder==0) break;
                                                dwi_hoec_gcor_YonZ[pp][k][n] +=
                                                        zorder*dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder-1);

                                                break;
                                            case 2:
                                                dwi_hoec_bcor_ZonB0[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);

                                                if (zorder==0) break;
                                                dwi_hoec_gcor_ZonZ[pp][k][n] +=
                                                        zorder*dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder-1);

                                                break;
                                        }
                                    }
                                    else if (xorder==1 && yorder==0) /* donor (X, Y, Z) on logical X */
                                    {
                                        switch(j)
                                        {
                                            case 0:
                                                dwi_hoec_gcor_XonX[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                            case 1:
                                                dwi_hoec_gcor_YonX[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                            case 2:
                                                dwi_hoec_gcor_ZonX[pp][k][n] +=
                                                         dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                        }
                                    }
                                    else if (xorder==0 && yorder==1) /* donor (X, Y, Z) on logical Y */
                                    {
                                        switch(j)
                                        {
                                            case 0:
                                                dwi_hoec_gcor_XonY[pp][k][n] += 
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                            case 1:
                                                dwi_hoec_gcor_YonY[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                            case 2:
                                                dwi_hoec_gcor_ZonY[pp][k][n] +=
                                                        dwi_hoec_coef_log[i][j][pp][n]*pow(rsp_info[k].rsptloc/10.0, zorder);
                                                break;
                                        }
                                    }
                                }  /* end for n, echo */
                            }  /* end for k, slice */
                        }  /* end for pp, interleave */

                        break;

                    case 2:  /* recon correction */
                    /* recon only uses the coef at the center echo, whose index is nechoBeforeTE-1.
                       Note that for PSD we calculate the correction amplitudes and not the offset amplitudes.
                       However, recon correction assumes the input to be the offset amplitudes, so we need
                       the extra minus sign here.     */

                        rhhoec_bases.hoec_coef[i][j] = -dwi_hoec_coef_log[i][j][interleaves/2][nechoBeforeTE-1];
                        break;

                    default:
                        break;

                }  /* end switch (basis_correction_mode[j][i]) */

            }  /* end for j, donor */

            rhhoec_bases.hoec_xorder[i] = xorder;
            rhhoec_bases.hoec_yorder[i] = yorder;
            rhhoec_bases.hoec_zorder[i] = zorder;
        }  /* end for i, basis */

        /* IX. Calculate diffusion gradient amplitudes */
        if (inversRspRot(inversRR, rsprot[0]) == FAILURE)  /* HOECC needs inversRR in the getDiffGradAmp call*/
        {
            epic_error(use_ermes,"inversRspRot failed", EM_PSD_SUPPORT_FAILURE, EE_ARGS(1), STRING_ARG," inversRspRot");
            status = FAILURE;
            goto graceful_exit;        
        }   
        
        for (i=0; i<pass_reps; i++)
        {
            if (opdiffuse == PSD_ON && tensor_flag == PSD_OFF)  /* non tensor DWI */
            {
                getDiffGradAmp(&cur_dw_gx, &cur_dw_gy, &cur_dw_gz, i - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
            }
            else if (tensor_flag == PSD_ON)  /* DTI */
            {
                if (ref_in_scan_flag && i==0) /* ref */
                {
                    cur_dw_gx = 0;
                    cur_dw_gy = 0;
                    cur_dw_gz = 0;
                }
                else if (rpg_in_scan_flag && (i<(ref_in_scan_flag ? 1:0)+rpg_in_scan_num))
                {
                    cur_dw_gx = 0;
                    cur_dw_gy = 0;
                    cur_dw_gz = 0;
                }
                else
                {
                    int pass_offset = (ref_in_scan_flag ? 1:0) + (rpg_in_scan_flag?rpg_in_scan_num:0);
                    cur_dw_gx = incdifx*TENSOR_HOST[0][i-pass_offset];
                    cur_dw_gy = incdify*TENSOR_HOST[1][i-pass_offset];
                    cur_dw_gz = incdifz*TENSOR_HOST[2][i-pass_offset];
                }
            }

            rhdiffusion_grad_amp[i][0] = cur_dw_gx;
            rhdiffusion_grad_amp[i][1] = cur_dw_gy;
            rhdiffusion_grad_amp[i][2] = cur_dw_gz;
        }

        /* X. Save intermediate results for debug purpose */
        SaveHoecDebugInfo(control_psd, control_recon, numSlices, t_array, r);

    }  /* end if control_psd or control_recon flags */

    /* Free allocated memory */
    graceful_exit:
    if (dwi_hoec_coef_phy != NULL)
    {
        for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
        {
            if (dwi_hoec_coef_phy[i] != NULL)
            {            
                for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
                {
                    if (dwi_hoec_coef_phy[i][j] != NULL)
                    {
                        for(pp=0; pp<interleaves; pp++)
                        {
                            if (dwi_hoec_coef_phy[i][j][pp] != NULL)
                            {
                                free(dwi_hoec_coef_phy[i][j][pp]);
                                dwi_hoec_coef_phy[i][j][pp] = NULL;
                            }
                        }
                        free(dwi_hoec_coef_phy[i][j]);
                        dwi_hoec_coef_phy[i][j] = NULL;
                    }
                } 
                free(dwi_hoec_coef_phy[i]);
                dwi_hoec_coef_phy[i] = NULL;
            }
        }       
        
        free(dwi_hoec_coef_phy);
        dwi_hoec_coef_phy = NULL;        
    }

    if (dwi_hoec_coef_phy_R != NULL)
    {
        for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
        {
            if (dwi_hoec_coef_phy_R[i] != NULL)
            {            
                for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
                {
                    if (dwi_hoec_coef_phy_R[i][j] != NULL)
                    {
                        for(pp=0; pp<interleaves; pp++)
                        {
                            if (dwi_hoec_coef_phy_R[i][j][pp] != NULL)
                            {
                                free(dwi_hoec_coef_phy_R[i][j][pp]);
                                dwi_hoec_coef_phy_R[i][j][pp] = NULL;
                            }
                        }

                        free(dwi_hoec_coef_phy_R[i][j]);
                        dwi_hoec_coef_phy_R[i][j] = NULL;
                    }
                }
                free(dwi_hoec_coef_phy_R[i]);
                dwi_hoec_coef_phy_R[i] = NULL;
            }
        }       
        
        free(dwi_hoec_coef_phy_R);
        dwi_hoec_coef_phy_R = NULL;        
    }
    
    if (dwi_hoec_coef_log != NULL)
    {
        for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
        {
            if (dwi_hoec_coef_log[i] != NULL)
            {            
                for (j=0; j<HOEC_TOTAL_NUM_AXES; j++)
                {
                    if (dwi_hoec_coef_log[i][j] != NULL)
                    {
                        for(pp=0; pp<interleaves; pp++)
                        {
                            if (dwi_hoec_coef_log[i][j][pp] != NULL)
                            {
                                free(dwi_hoec_coef_log[i][j][pp]);
                                dwi_hoec_coef_log[i][j][pp] = NULL;
                            }
                        }
                        free(dwi_hoec_coef_log[i][j]);
                        dwi_hoec_coef_log[i][j] = NULL;
                    }
                }
                free(dwi_hoec_coef_log[i]);
                dwi_hoec_coef_log[i] = NULL;
            }
        }       
        free(dwi_hoec_coef_log);
        dwi_hoec_coef_log = NULL;        
    }                       
    
    if (phy2log_F != NULL)
    {
        for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
        {
            if (phy2log_F[i] != NULL)
            {
                free(phy2log_F[i]);
                phy2log_F[i] = NULL;
            }
        }
        
        free(phy2log_F);
        phy2log_F = NULL;
    }
    
    if (status == FAILURE)
    {
        printf("CalcPsdReconHoecCorr() failed.\n");
    }
    
    return status;
}  /* end of the CalcPsdReconHoecCorr routine */

void convertPhy2Log(float * output, int logTermIndex, int orderIndex, float rotm[3][3])
{
    int i, j, k;
    int nx, ny, nz;
    int numTerms_x, numTerms_y, numTerms_z;

    float xCoef[HOEC_MAX_BASES_PER_ORDER]; /* coeffients of trinomial expansion for x axis */
    float yCoef[HOEC_MAX_BASES_PER_ORDER]; /* coeffients of trinomial expansion for y axis */
    float zCoef[HOEC_MAX_BASES_PER_ORDER]; /* coeffients of trinomial expansion for z axis */
    int xIndex[3][HOEC_MAX_BASES_PER_ORDER]; /* base index of trinomial expansion for x axis */
    int yIndex[3][HOEC_MAX_BASES_PER_ORDER]; /* base index of trinomial expansion for y axis */
    int zIndex[3][HOEC_MAX_BASES_PER_ORDER]; /* base index of trinomial expansion for z axis */

    nx = hoec_cal_info.termIndex2xyzOrderMapping[0][logTermIndex];
    ny = hoec_cal_info.termIndex2xyzOrderMapping[1][logTermIndex];
    nz = hoec_cal_info.termIndex2xyzOrderMapping[2][logTermIndex];

    numTerms_x = (nx+1)*(nx+2)/2;
    numTerms_y = (ny+1)*(ny+2)/2;
    numTerms_z = (nz+1)*(nz+2)/2;

    for (i=0; i<numTerms_x; i++)
    {
        xCoef[i] = 0;
    }
    for (i=0; i<numTerms_y; i++)
    {
        yCoef[i] = 0;
    }
    for (i=0; i<numTerms_z; i++)
    {
        zCoef[i] = 0;
    }
    
    expandTrinomial(xCoef, xIndex, nx, rotm[0]);
    expandTrinomial(yCoef, yIndex, ny, rotm[1]);
    expandTrinomial(zCoef, zIndex, nz, rotm[2]);

    for (i=0; i<numTerms_x; i++)
        for (j=0; j<numTerms_y; j++)
            for (k=0; k<numTerms_z; k++)
            {
                nx = xIndex[0][i]+yIndex[0][j]+zIndex[0][k];
                ny = xIndex[1][i]+yIndex[1][j]+zIndex[1][k];
                nz = xIndex[2][i]+yIndex[2][j]+zIndex[2][k];

                output[hoec_cal_info.xyzOrder2termIndexMapping[nx][ny][nz]] += xCoef[i]*yCoef[j]*zCoef[k];
            }
}

void expandTrinomial(float output[HOEC_MAX_BASES_PER_ORDER], int index[3][HOEC_MAX_BASES_PER_ORDER], int num, float rotm[3])
{
    int i, j;
    int cc1, cc2;
    int count;
    
    count = 0;
    for (i=0; i<=num; i++)
    {
        cc1 = fractorial(num)/(fractorial(num-i)*fractorial(i));
        for (j=0; j<=i; j++)
        {
            cc2 = fractorial(i)/(fractorial(i-j)*fractorial(j));
            index[0][count] = num-i;
            index[1][count] = i-j;
            index[2][count] = j;
            output[count] = cc1*pow(rotm[0], num-i)*cc2*pow(rotm[1], i-j)*pow(rotm[2], j);
            count++;
        }
    }
}

int fractorial(int n)
{
    if(n<=0) return 1;
    return n*fractorial(n-1);
}

/* g_error_kcenter: compute the HOEC amplitude (normalized to donar gradient amplitude at k-space center)
   Assume the output is a, then G*a*basisFunction would give the EC magnitude field. a is dimensionless.
   This function assumes a singla spin echo model with two diffusion gradients. It approximately equals
   a more accurate calculation using gradient cornder point file and convolution */

float g_error_kcenter(float R,
                      float amp,
                      float tau,
                      float t1,
                      float t2,
                      float t5,
                      float t10)
{
    double error_a, error_b, error_c, error_d;

    error_a = 0.01*(double)R*(double)(amp*tau);  /* 0.01 comes from the percentage expression of amp */
    error_b = 1-exp((double)(t1/tau));
    error_c = 1-exp((double)(t2/tau));
    error_d = (1+exp((double)(t5/tau)))*exp(-(double)(t10/tau));

    return((float)(error_a*error_b*error_c*error_d));
}

/*  SVBranch: HCSDM00259119  eco mpg:
   g_error_kcenter2: computes the HOEC normalized amplitude in eco-MPG 
                     case, where diff grad has multiple slew rate; */
float g_error_kcenter2(float R1,
                       float R2,
                       float R3,
                       float R4,
                       float amp,
                       float tau,
                       float t1, float t2, 
                       float t3, float t5, 
                       float t6, float t7, 
                       float t8, float t10)
{
    /* R1: abs slew rate for ramp-up of left diff grad;
       R2: abs slew rate for ramp-down of left diff grad;
       R3: abs slew rate for ramp-up of right diff grad;
       R4: abs slew rate for ramp-down of right diff grad; */
       
    float error_a, error_b, error_c, error_d, error_sum;
    
    amp = amp * 0.01; /* 0.01 comes from the percentage expression of amp */
    
    error_a = -R1 * amp * tau * ( exp((t1-t10)/tau) - exp(-t10/tau) );   
    error_b =  R2 * amp * tau * ( exp((t3-t10)/tau) - exp((t2-t10)/tau) );
    error_c = -R3 * amp * tau * ( exp((t6-t10)/tau) - exp((t5-t10)/tau) );
    error_d =  R4 * amp * tau * ( exp((t8-t10)/tau) - exp((t7-t10)/tau) );
    
    /* error terms standard for different meanings here,
       comparing to those in g_error_kcenter(). So plus
       is used here, not multiply. The difference comes
       from the fact that R1, R2, R3, and R4 may be not
       identical in this function */
    error_sum = error_a + error_b + error_c + error_d;
    
    return error_sum;
}

/* SaveHoecDebugInfo: Save intermediate results for debug purposes.
                      Two files are saved:
                      HOEC_DEBUG_FILE contains the main debug information, including
                      the rotation matrices, HOEC coefficients, HOEC PSD/recon correction schedule etc.
                      HOEC_COEF_RECON_FILE contains recon specific information, which is primarily
                      used for debugging recon code, and is only available when hoecc_recon_flag is 1. */

void SaveHoecDebugInfo(int control_psd, int control_recon, int numSlices, float t_array[7], float r[3][3])
{
    FILE *dwi_outfile;
    int i,j, k;
    int xorder, yorder, zorder;
    float start_val, inc_val, end_val;  /* some variables for defining X, Y, and Z grids */
    char basisStr[32], tempStr[32], corrScheduleStr[32], linearizedAxisInPsdStr[32], extraZExpInPsdStr[10];

    /* HOEC_COEF_RECON_FILE file: saves recon specific information */
    if (control_recon == 1 && hoecc_debug == PSD_ON)
    {
        dwi_outfile = fopen(HOEC_COEF_RECON_FILE, "w");

        if (dwi_outfile != NULL)
        {
            /* determine if recon based distortion is needed */
            fprintf(dwi_outfile, "Section 1: Flag for recon based distortion correction (1 = on, 0 = off)\n");
            fprintf(dwi_outfile, "1\n");
            fprintf(dwi_outfile, "\n");
            
            /* stores parameters which recon need for distortion correction */
            fprintf(dwi_outfile, "Section 2: Parameters that are related to recon processing\n");
            if (ky_dir == 2)
            {
                fprintf(dwi_outfile, "1     // acquisition mode (1=bottom-up 0=top-down)\n");
            }
            else
            {
                fprintf(dwi_outfile, "0     // acquisition mode (1=bottom-up 0=top-down)\n");
            }
            fprintf(dwi_outfile, "%d     // fit order\n", hoec_cal_info.fit_order);
            fprintf(dwi_outfile, "%d     // hoecc_flag (0=off, 1=on, 2=manual, 3=recon for all)\n", hoecc_flag);
            fprintf(dwi_outfile, "%d     // ASSET acceleration\n", (int)(ceil(1.0/asset_factor)));
            fprintf(dwi_outfile, "%.1f  // fov in cm\n", opfov*opphasefov/10.0);
            fprintf(dwi_outfile, "%d   // echo spacing in us\n", esp);
            fprintf(dwi_outfile, "%d     // patient entry (1=head first, 2=feet first)\n", opentry);
            fprintf(dwi_outfile, "%d     // patient position (1=supine, 2=prone, 3=left decub, 4=right decub)\n", oppos);
            fprintf(dwi_outfile, "%d     // scan plane (1=ax, 2=sag, 3=cor, 4=obl, 5=3plane)\n", opplane);
            fprintf(dwi_outfile, "%d     // most like plane for obliques (1=ax, 2=sag, 3=cor)\n", opobplane);
            fprintf(dwi_outfile, "%d     // swap phase and frequency (0=no swap, 1=swap)\n", opspf);
            fprintf(dwi_outfile, "%d     // hoec_recon_debug (1 = save intermediate recon result, 0 = do not save)\n", 0);
            fprintf(dwi_outfile, "%d     // recon_debug_slice_index (slice index to save recon result)\n", 0);
            fprintf(dwi_outfile, "\n");
            
            fprintf(dwi_outfile, "Section 3: X, Y, Z DW gradient vector in Gauss/cm\n");  /* HOEC coefficients at k-space center */
            fprintf(dwi_outfile, "%d     // Number of reps (T2, DW Z, X, Y etc.) \n", pass_reps);
            
            for (i=0; i<pass_reps; i++) /* Each row is a length-3 vector representing X, Y, and Z DW
                                           gradients for each pass */
            {
                fprintf(dwi_outfile, "%7.5f  \t  %7.5f  \t  %7.5f\n", rhdiffusion_grad_amp[i][0],
                        rhdiffusion_grad_amp[i][1], rhdiffusion_grad_amp[i][2]);
            }   /* end for*/
            fprintf(dwi_outfile, "\n");
            
            /* HOEC coefficients at k-space center */
            fprintf(dwi_outfile, "Section 4: HOEC coefficients at TE for recon based correction (logical axes)\n");
            for (i=0; i<3; i++) /* donor axes */
            {
                for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                {
                    xorder = hoec_cal_info.termIndex2xyzOrderMapping[0][j];
                    yorder = hoec_cal_info.termIndex2xyzOrderMapping[1][j];
                    zorder = hoec_cal_info.termIndex2xyzOrderMapping[2][j];
            
                    strcpy(basisStr, "");    /* start with empty string */
            
                    switch (xorder)  /* add x component */
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "x"); break;
                        default: sprintf(tempStr, "x%d", xorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    switch (yorder)  /* add y component */
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "y"); break;
                        default: sprintf(tempStr, "y%d", yorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    switch (zorder)  /* add z component */
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "z"); break;
                        default: sprintf(tempStr, "z%d", zorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    if (strcmp(basisStr, "")==0)  /* set the basis name to "1" if there is no x,y, or z component */
                    {
                        strcpy(basisStr, "1");
                    }
            
                    if (j==0)
                    {
                        switch (i)
                        {
                            case 0:
                                fprintf(dwi_outfile, "%.4e   // %s; starting row of donor X\n",
                                        rhhoec_bases.hoec_coef[j][i], basisStr);
                                break;
                            case 1:
                                fprintf(dwi_outfile, "%.4e   // %s; starting row of donor Y\n",
                                        rhhoec_bases.hoec_coef[j][i], basisStr);
                                break;
                            case 2:
                                fprintf(dwi_outfile, "%.4e   // %s; starting row of donor Z\n",
                                        rhhoec_bases.hoec_coef[j][i], basisStr);
                                break;
                        }
                    }
                    else
                    {
                        fprintf(dwi_outfile, "%.4e   // %s\n", rhhoec_bases.hoec_coef[j][i], basisStr);
                    }
                } /* end for j*/
            }  /* end for i*/
            fprintf(dwi_outfile, "\n");
            
            /* save logical X, Y, Z coordinates so that recon based post processing can use */
            fprintf(dwi_outfile, "Section 5: Logical X, Y, Z coordinates\n");
            start_val = (float)(rhrcxres/2)*get_act_freq_fov()/(10.0*(float)rhrcxres)+rsp_info[0].rsprloc/10.0-
                        (float)(rhrcxres-1)*get_act_freq_fov()/(10.0*(float)rhrcxres);  /* 10.0 is to convert mm to cm */
            inc_val = opfov/(10.0*(float)rhrcxres);
            end_val = start_val + ((float)(rhrcxres-1))*inc_val;
            fprintf(dwi_outfile, "%d          // Number of pixels in X axis\n", rhrcxres); /* X axis */
            fprintf(dwi_outfile, "%.4f   // Start X loc\n", start_val);
            fprintf(dwi_outfile, "%.4f   // End X loc\n", end_val);
            
            start_val = (float)(rhrcyres/2)*get_act_phase_fov()/(10.0*(float)rhrcyres)+rsp_info[0].rspphasoff/10.0;
            inc_val = -get_act_phase_fov()/(10.0*(float)rhrcyres);
            end_val = start_val + ((float)(rhrcyres-1))*inc_val;
            fprintf(dwi_outfile, "%d          // Number of pixels in Y axis\n", rhrcyres); /* Y axis */
            fprintf(dwi_outfile, "%.4f   // Start Y loc\n", start_val);
            fprintf(dwi_outfile, "%.4f   // End Y loc\n", end_val);
            
            if (rsp_info[0].rsptloc > 0)
            {
                start_val = (float)(opslquant-1)*(opslthick+opslspace)/(10.0*2);
                inc_val = -(opslthick+opslspace)/10.0;
            }
            else
            {
                start_val = -(float)(opslquant-1)*(opslthick+opslspace)/(10.0*2);
                inc_val = (opslthick+opslspace)/10.0;
            }
            end_val = start_val + ((float)(opslquant-1))*inc_val;
            fprintf(dwi_outfile, "%d          // Number of slices in Z axis\n", opslquant);  /* Z axis */
            fprintf(dwi_outfile, "%.4f   // Start Z loc\n", start_val);
            fprintf(dwi_outfile, "%.4f   // End Z loc\n", end_val);
            
            fclose(dwi_outfile); 
        }
        
        else
        {        	
            printf("Failed to open %s.\n", HOEC_COEF_RECON_FILE);
        }        
    }
    
    /* HOEC_DEBUG_FILE: save intermediate matrices that convert physical to logical axes, rotation matrix,
                        and psd/recon corr schedule*/
    if (hoecc_debug == PSD_ON)
    {
        dwi_outfile = fopen(HOEC_DEBUG_FILE, "a");  /* phy to log matrices*/
 
        if (dwi_outfile != NULL)
        {
            fprintf(dwi_outfile, "\nNormalized rotation matrix:\n");
            fprintf(dwi_outfile, "%5.2f %5.2f %5.2f\n", r[0][0], r[0][1], r[0][2]);
            fprintf(dwi_outfile, "%5.2f %5.2f %5.2f\n", r[1][0], r[1][1], r[1][2]);
            fprintf(dwi_outfile, "%5.2f %5.2f %5.2f\n", r[2][0], r[2][1], r[2][2]);
            fprintf(dwi_outfile, "\n\n");
            
            fprintf(dwi_outfile, "F Matrix (physical to logical conversion matrix)\n");
            for (k=0; k<hoec_cal_info.total_bases_per_axis; k++)
            {
                for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
                {
                    fprintf(dwi_outfile, "%5.2f ", phy2log_F[k][i]);
                }
                fprintf(dwi_outfile, "\n");
            }
            fprintf(dwi_outfile, "\n\n");

            fprintf(dwi_outfile, "E Matrix - Interleave %d  Echo %d:\n", psd_ileave_for_debug, psd_echo_for_debug);
            for (i=0; i<hoec_cal_info.total_bases_per_axis; i++) /* basis */
            {
                fprintf(dwi_outfile, "%2d  %12.3e %12.3e %12.3e\n", i,
                    dwi_hoec_coef_phy[i][0][psd_ileave_for_debug][psd_echo_for_debug], 
                    dwi_hoec_coef_phy[i][1][psd_ileave_for_debug][psd_echo_for_debug],
                    dwi_hoec_coef_phy[i][2][psd_ileave_for_debug][psd_echo_for_debug]);
            }
            fprintf(dwi_outfile, "\n\n");

            fprintf(dwi_outfile, "E*r Matrix - - Interleave %d Echo %d:\n", psd_ileave_for_debug,psd_echo_for_debug);
            for (i=0; i<hoec_cal_info.total_bases_per_axis; i++) /* basis */
            {
                fprintf(dwi_outfile, "%2d  %12.3e %12.3e %12.3e\n", i,
                        dwi_hoec_coef_phy_R[i][0][psd_ileave_for_debug][psd_echo_for_debug], 
                        dwi_hoec_coef_phy_R[i][1][psd_ileave_for_debug][psd_echo_for_debug],
                        dwi_hoec_coef_phy_R[i][2][psd_ileave_for_debug][psd_echo_for_debug]);
            }
            fprintf(dwi_outfile, "\n\n");
            
            fprintf(dwi_outfile, "D Matrix - Interleave %d  Echo %d:\n", psd_ileave_for_debug,psd_echo_for_debug);
            for (i=0; i<hoec_cal_info.total_bases_per_axis; i++) /* basis */
            {
                fprintf(dwi_outfile, "%2d  %12.3e %12.3e %12.3e\n", i,
                        dwi_hoec_coef_log[i][0][psd_ileave_for_debug][psd_echo_for_debug], 
                        dwi_hoec_coef_log[i][1][psd_ileave_for_debug][psd_echo_for_debug],
                        dwi_hoec_coef_log[i][2][psd_ileave_for_debug][psd_echo_for_debug]);
            }
            fprintf(dwi_outfile, "\n\n");
            
            fprintf(dwi_outfile, "time array elements:\n\n");
            for (i=0; i<7; i++)
            {
                fprintf(dwi_outfile, "t[%d]=%d\n", i, (int)t_array[i]);
            }
            
            fprintf(dwi_outfile, "\nHOEC control_psd = %d\n", control_psd);
            fprintf(dwi_outfile, "HOEC control_recon = %d\n", control_recon);
            
            fprintf(dwi_outfile, "\nLamda matrix for gradient and B0 (PSD) - Ileave  %d Echo %d:\n", psd_ileave_for_debug,psd_echo_for_debug);
            for (i=0; i<numSlices; i++) /* note dwi_hoec_gcor is the same for all echoes when per_echo_corr = 0,
                                           which enables us to use the same code below for per_echo_corr = 1 and 0 */
            {
                fprintf(dwi_outfile, "Slice %d:\n", i);
                fprintf(dwi_outfile, "onX =%12.3e XonY =%12.3e XonZ =%12.3e\n", dwi_hoec_gcor_XonX[psd_ileave_for_debug][i][psd_echo_for_debug],
                        dwi_hoec_gcor_XonY[psd_ileave_for_debug][i][psd_echo_for_debug], dwi_hoec_gcor_XonZ[psd_ileave_for_debug][i][psd_echo_for_debug]);
                fprintf(dwi_outfile, "YonX =%12.3e YonY =%12.3e YonZ =%12.3e\n", dwi_hoec_gcor_YonX[psd_ileave_for_debug][i][psd_echo_for_debug],
                        dwi_hoec_gcor_YonY[psd_ileave_for_debug][i][psd_echo_for_debug], dwi_hoec_gcor_YonZ[psd_ileave_for_debug][i][psd_echo_for_debug]);
                fprintf(dwi_outfile, "ZonX =%12.3e ZonY =%12.3e ZonZ =%12.3e\n", dwi_hoec_gcor_ZonX[psd_ileave_for_debug][i][psd_echo_for_debug],
                        dwi_hoec_gcor_ZonY[psd_ileave_for_debug][i][psd_echo_for_debug], dwi_hoec_gcor_ZonZ[psd_ileave_for_debug][i][psd_echo_for_debug]);
                fprintf(dwi_outfile, "XonB0=%12.3e YonB0=%12.3e ZonB0=%12.3e\n", dwi_hoec_bcor_XonB0[psd_ileave_for_debug][i][psd_echo_for_debug],
                        dwi_hoec_bcor_YonB0[psd_ileave_for_debug][i][psd_echo_for_debug], dwi_hoec_bcor_ZonB0[psd_ileave_for_debug][i][psd_echo_for_debug]);
            }
            
            fprintf(dwi_outfile, "\n\nLamda matrix for all bases (recon):\n");
            for (i=0; i<hoec_cal_info.total_bases_per_axis; i++)
            {
                fprintf(dwi_outfile, "%2d %12.3e %12.3e %12.3e\n",
                        i, rhhoec_bases.hoec_coef[i][0], rhhoec_bases.hoec_coef[i][1], rhhoec_bases.hoec_coef[i][2]);
            }
            
            /* save how psd and recon split up the bases */
            
            /* HOEC coefficients at k-space center */
            fprintf(dwi_outfile, "\n\n");
            fprintf(dwi_outfile, "PSD and recon HOEC correction schedule (all bases are in logical axes):\n");
            fprintf(dwi_outfile, "Polyorder = %d\n", hoec_cal_info.fit_order);
            fprintf(dwi_outfile, "Number of bases per donor axis = %d\n", hoec_cal_info.total_bases_per_axis);
            fprintf(dwi_outfile, "Max number of PSD correctable (type A) bases = %d\n", 3*hoec_cal_info.fit_order+1);
            fprintf(dwi_outfile, "HOEC correction flag = %d  // 0=off, 1=no, 2=manual, 3=recon for all\n", hoecc_flag);
            fprintf(dwi_outfile, "\n");
            for (i=0; i<3; i++) /* donor axes */
            {
                switch (i)
                {
                    case 0: fprintf(dwi_outfile, "X Donor\n"); break;
                    case 1: fprintf(dwi_outfile, "Y Donor\n"); break;
                    case 2: fprintf(dwi_outfile, "Z Donor\n"); break;
                }
            
                fprintf(dwi_outfile, "-------------------------------------------------------------------------\n");
                fprintf(dwi_outfile, "Index    Basis      CorrSchedule      GradAxisPsdCorr    ExtraZExpPsdCorr\n");
                fprintf(dwi_outfile, "-------------------------------------------------------------------------\n");
                for (j=0; j<hoec_cal_info.total_bases_per_axis; j++)
                {
                    xorder = hoec_cal_info.termIndex2xyzOrderMapping[0][j];
                    yorder = hoec_cal_info.termIndex2xyzOrderMapping[1][j];
                    zorder = hoec_cal_info.termIndex2xyzOrderMapping[2][j];
            
                    strcpy(basisStr, "");    /* start with empty string */
            
                    switch (xorder)  /* add x component */
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "x"); break;
                        default: sprintf(tempStr, "x%d", xorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    switch (yorder)  /* add y component*/
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "y"); break;
                        default: sprintf(tempStr, "y%d", yorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    switch (zorder)  /* add z component */
                    {
                        case 0: strcpy(tempStr, ""); break;
                        case 1: strcpy(tempStr, "z"); break;
                        default: sprintf(tempStr, "z%d", zorder); break;
                    }
                    strcat(basisStr, tempStr);
            
                    if (strcmp(basisStr, "")==0)  /* set the basis name to "1" if there is no x,y, or z component */
                    {
                        strcpy(basisStr, "1");
                    }
            
                    strcpy(corrScheduleStr, "");
                    strcpy(linearizedAxisInPsdStr, "");
                    strcpy(extraZExpInPsdStr, "");
                    switch(ext_corr_term[i][j])
                    {
                        case 0: strcpy(corrScheduleStr, "NoCorr"); break;
                        case 1:
                            strcpy(corrScheduleStr, "PSD");
                            if (xorder==0 && yorder==0)
                            {
                                strcpy(linearizedAxisInPsdStr, "B0");
                            }
                            else if (xorder==1 && yorder==0)
                            {
                                strcpy(linearizedAxisInPsdStr, "X");
                            }
                            else if (xorder==0 && yorder==1)
                            {
                                strcpy(linearizedAxisInPsdStr, "Y");
                            }
                            sprintf(extraZExpInPsdStr, "%d", zorder);
                        break;
                        case 2:
                            strcpy(corrScheduleStr, "Recon");
                            break;
                        default:
                            strcpy(corrScheduleStr, "UnknownState");
                            break;
                    }
            
                    fprintf(dwi_outfile, "%-5d    %-10s %-17s %-15s    %-10s      \n", j+1, basisStr,
                              corrScheduleStr, linearizedAxisInPsdStr, extraZExpInPsdStr);
                } /* end for j*/
                fprintf(dwi_outfile, "\n\n");
            }  /* end for i*/
            fclose(dwi_outfile);    
        }
        else
        {        	
            printf("Failed to open %s.\n", HOEC_DEBUG_FILE);
        }
        
    }  /* if (hoecc_debug == PSD_ON) */
}

/* defined in pg section */

float get_fa_scaling_factor_ir(float act_fa, float nom_fa, float nom_max_b1)
{
    double max_b1_limit, cur_b1_limit, act_b1;
    INT txIndex[MAX_TX_COIL_SETS];
    INT exciterIndex[MAX_TX_COIL_SETS];
    INT exciterUsed[MAX_TX_COIL_SETS];
    INT numTxIndexUsed = 0;
    INT i;

    if (act_fa <= 0.0 || nom_fa <= 0.0 || nom_max_b1 <= 0.0)
    {
        return 1.0;
    }

    getTxAndExciter(txIndex, exciterIndex, exciterUsed, &numTxIndexUsed, coilInfo, opncoils);
    coilB1Limit(&max_b1_limit, txCoilInfo[txIndex[0]]);

    /* handle cases with multiple transmit coils (not supposed to be executed for now) */
    for (i = 1; i < numTxIndexUsed; i++)
    {
        coilB1Limit(&cur_b1_limit, txCoilInfo[txIndex[i]]);

        if (cur_b1_limit < max_b1_limit)
        {
            max_b1_limit = cur_b1_limit;
        }
    }

    max_b1_limit = max_b1_limit/100; /* uT to Gauss conversion */
    act_b1 = nom_max_b1*act_fa/nom_fa;

    if (act_b1 <= max_b1_limit)
    {
        return 1.0;
    }

    return (float)(max_b1_limit/act_b1);
}


/**************************************************************************/
/**************************************************************************/
#ifndef sys_psdiopt_h
#define sys_psdiopt_h
#include "psdIF.h"
#include "psdiopt.h"
#endif
#ifndef _SYSCHECK_
#define _SYSCHECK_
STATUS syscheck(INT *p_syscheck_limit, int *p_status_flag)
{
    /* Variables to hold the minseq  values. These are local to syscheck*/
    INT syscheck_min_seqgrad = 0;
    INT syscheck_min_seqrfamp = 0; 

    /* Flag to turn on or off syscheck logging */
    int syschecklog_on = 0;

    /* The file pointer to enable or disable RF check with the help of a file*/
    FILE *fp_rfon;
    FILE *fp_syschecklog_on;

    int iopt_num=0;/* Imaging option Num*/

    char im_opt_name[128];/* Imaging option String*/
    char logValues[1024];

    INT seq_entry_index = 0;

    char path[128] = "/usr/g/service/log/";
    char filename[64] = "psd_syscheck_error.log";
    char macro_name[32];
    float tolerance_percentage = 0.0;
    const int TOLERANCE_LIMIT = 5;
    int syscheck_limit = 0;
    float syscheck_limit_tolerance = 0.0;
    int debug_syscheck;
    debug_syscheck = (getenv("DEBUG_SYSCHECK")!='\0');

if(debug_syscheck){
        printf(" Calling minseq from macro\n");
        fflush(stdout);
        }
    strcpy(macro_name,"SYSCHECK_MINSEQ_PGOH");
    if (FAILURE == minseq(&syscheck_min_seqgrad,
                                gradx, GX_FREE,
                                grady, GY_FREE,
                                gradz, GZ_FREE,
                                &loggrd, seq_entry_index, tsamp,
                                avail_image_time,
                                use_ermes, seg_debug ) )
             {
        log_error(path,filename,1,"%s %d %d  %d","Minseq failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
        if(debug_syscheck){
            printf(" Minseq failed in syscheck \n");
            fflush(stdout);
        }
        *p_status_flag=1;
    }
    else
    {
        if(debug_syscheck){
            printf("minseq completed successfully with values\n syscheck_min_seqgrad : %d\n",syscheck_min_seqgrad);
            fflush(stdout);
        }
    }
    /****** To include Rf calculation based on the choice made ****/

    fp_rfon = fopen("/usr/g/bin/.RFCHECKON","r");
    if(fp_rfon !=NULL)
    {
       if(debug_syscheck){
           printf("Calling minseqrfamp from macro\n");
           fflush(stdout);
       }
       if(minseqrfamp(&syscheck_min_seqrfamp,(int)RF_FREE,rfpulse,L_SCAN) == FAILURE)
         {
             log_error(path,filename,1,"%s \n file:%s line:%d Error no:%d","Minseqrfamp failed in syscheck",__FILE__,__LINE__,EM_PSD_SUPPORT_FAILURE);
             if(debug_syscheck){
                 printf(" Minseqrfamp failed in syscheck\n");
                 fflush(stdout);
             }
             *p_status_flag= 1;
         }
         else
         {
            if(debug_syscheck){
                printf("Completed minseqrfamp successfully with syscheck_min_seqrfamp %d\n",syscheck_min_seqrfamp);
                fflush(stdout);
            }
        }
    }

    /** to check for the environment variable whether logging has to be done or not ***/

    fp_syschecklog_on = fopen("/usr/g/bin/.SYSCHECKLOGON","r");
    syschecklog_on =((getenv("SYSCHECKLOGON")!='\0') || (fp_syschecklog_on!=NULL));
    /*** if RF check is on include the min_seqrfamp for syscheck_safety_limit and for comparison with optr ***/

        if(fp_rfon !=NULL)
        {
            if(debug_syscheck){
                printf("\nRF included");
                fflush(stdout);
            }
            syscheck_limit = IMax(2,syscheck_min_seqgrad,syscheck_min_seqrfamp);
        }
        else
        {
           if(debug_syscheck){
               printf("\nRf calculation not included");
               fflush(stdout);
           }
           syscheck_limit = syscheck_min_seqgrad;
        }
        if (9000 == cfgradamp) 
           syscheck_limit = syscheck_min_seqrfamp; 
        /*** Calculate the tolerance percentage to allow a maximum of 5% tolerance before comparision***/
        tolerance_percentage = 1-(TOLERANCE_LIMIT * 0.01);
        if(psd_tol_value!=0){
            if((((oppseq == PSD_GE) || (oppseq == PSD_SPGR) || (oppseq == PSD_TOF) || (oppseq == PSD_TOFSP) || (oppseq == PSD_SSFP)) &&
                (opfast == PSD_ON) && (opimode == PSD_3D) && ((opirprep == PSD_ON) || ((opgirmode == PSD_GIRMANUAL) && (opnumgir > 0)))) ||
               (((oppseq == PSD_GE) || (oppseq == PSD_SPGR)) && (opimode == PSD_2D) && (oprealtime == PSD_ON) && (opfast == PSD_ON))){
                if(debug_syscheck){
                    printf("Special case for syscheck considered");
                    printf(" VALUE OF PSD_TOL_VALUE = %d",psd_tol_value);
                    fflush(stdout);
                }
            }
            else{
                if(debug_syscheck){
                    printf("Not allowing a tolerance.Not a  special cases");
                }
                cvoverride(psd_tol_value,0,PSD_FIX_ON,PSD_EXIST_ON);
           }
        }
        syscheck_limit_tolerance = (syscheck_limit * tolerance_percentage) - psd_tol_value;
        *p_syscheck_limit = (int)(syscheck_limit_tolerance);
        /*** Compare the optr with the minseq values if found less than max of minseq values,log an error ***/
        /*** MRIhc37381: Bypass the optr check for Phase Contrast to avoid the download failure ***/
        /*** MRIhc42193: remove the code added by MRIhc37381, enable syscheck for Phase Contrast ***/
        if( (exist(optr)) < (*p_syscheck_limit) || (optr) < (*p_syscheck_limit ) )
        {
            log_error(path,filename,1,"%s \nfile:%s line:%d","ERROR : PSD SAFETY CHECK ERROR!!! ILLEGAL OPTR DETECTED IN SYSCHECK!!!",__FILE__,__LINE__);
            *p_status_flag = 2;
            if(debug_syscheck){
                printf("Illegal optr  value found %d\n",exist(optr));
                fflush(stdout);
            }
        }
        else
        {
            /**** Log a positive message for no error case *****/
            log_error(path,filename,1,"%s", "SAFETY CHECK RAN SUCCESSFULLY!OPTR VALUES FOUND SAFE!");
            *p_status_flag = 0;
        }
        if(((*p_status_flag ==0) && (syschecklog_on)) || (*p_status_flag ==2))
        {
            sprintf(logValues,"\noptr : %d\ntmin : %d\t\ttmin_total : %d\nmin_seqgrad : %d\tsyscheck_min_seqgrad : %d\nsyscheck_safety_limit : %d",exist(optr),tmin,tmin_total,min_seqgrad,syscheck_min_seqgrad,*p_syscheck_limit);
            log_error(path,filename,0,"%s %s","Values found:",logValues);
            if(fp_rfon!=NULL)
            {
                sprintf(logValues,"min_seqrfamp : %d\t syscheck_min_seqrfamp : %d\n",min_seqrfamp,syscheck_min_seqrfamp);
                log_error(path,filename,0,"%s",logValues);
            }
        }
            /************** Log the PSD name & IOPT selected *****/
            log_error(path,filename,0,"%s %s ","PSD:",get_psd_name());
            for(iopt_num = 0;iopt_num < PSD_NUM_IOPTS; iopt_num++){
                if(is_iopt_selected(iopt_num)){
                return_iopt_name(iopt_num,im_opt_name);
                log_error(path,filename,0,"%s %s","Imaging Option :",im_opt_name);
            }
        }

    log_error(path,filename,0,"%s",macro_name);
    if((*p_status_flag) != 0)
    {
        return FAILURE;
    }
    else
    {
        return SUCCESS;
    }
}
#endif
/***************************************************************/

/*********************************************************************
 *                       EPI2.E PULSEGEN SECTION                     *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
/* MRIge55206 - change memory allocation if in SIM for multi-dim array support */
#ifdef SIM
#include <stdlib.h>
#define AllocMem malloc
#else
#define AllocMem AllocNode
#endif

#include <math.h>

long rsprot_orig[DATA_ACQ_MAX][9]; /* rotation matrix for SAT */
extern PSD_EXIT_ARG psdexitarg;
short *acq_ptr;               /* first slice in a pass */
int   *ctlend_tab;            /* table of cardiac deadtimes */
short *slc_in_acq;            /* number of slices in each pass */
/* Frequency/Phase offsets */
int   *rf1_freq;
int   *theta_freq;
int   *rf2_freq;
int   *thetarf2_freq;
int   ***recv_freq;
int   ***recv_phase;
double ***recv_phase_ang_nom;   /* nominal receiver phase angle - XJZ */
double ***recv_phase_angle;
int *rf1_pha;
int *rf2_pha;
int *rf2left_pha;
int *rf2right_pha;
WF_PULSE tmppulse,*tmppulseptr;
WF_INSTR_HDR *tmpinstr;
int **diff_order;
int *diff_order_pass;
int *diff_order_nex;
int *diff_order_dif;

/* update for external gradient waveforms for QTI granty 9/28/2017 */
/* holds QTI waveforms */
WF_PULSE gxdlbuff = INITPULSE;
WF_PULSE gxdrbuff = INITPULSE;
WF_PULSE gydlbuff = INITPULSE;
WF_PULSE gydrbuff = INITPULSE;
WF_PULSE gzdlbuff = INITPULSE;
WF_PULSE gzdrbuff = INITPULSE;

WF_PULSE gxiso1 = INITPULSE;
WF_PULSE gxiso2 = INITPULSE;
WF_PULSE gyiso1 = INITPULSE;
WF_PULSE gyiso2 = INITPULSE;
WF_PULSE gziso1 = INITPULSE;
WF_PULSE gziso2 = INITPULSE;

/* bipolar trapezoidal waveform */
WF_PULSE gbpbuffx = INITPULSE;
WF_PULSE gbpbuffy = INITPULSE;
WF_PULSE gbpbuffz = INITPULSE;
/* Single trapezoidal waveform */
WF_PULSE gtrapbuffx = INITPULSE;
WF_PULSE gtrapbuffy = INITPULSE;
WF_PULSE gtrapbuffz = INITPULSE;
/* daiep comment because of error when simulating */

WF_PULSE gxdr = INITPULSE;
WF_PULSE gxdl = INITPULSE;
WF_PULSE gydr = INITPULSE;
WF_PULSE gydl = INITPULSE;
WF_PULSE gzdr = INITPULSE;
WF_PULSE gzdl = INITPULSE;

/* daiep end */
/* declare delta grad and freq arrays */

/* delta grad and freq arrays */
int ***ia_gx_hoec_comp, ***ia_gy_hoec_comp;  /* final value for gradient amplitude correction */
double ***recv_phase_b0_hoec_comp;  /* final value for frequency correction */

/* Allocate memory for PSD correction in AGP */

int   **rf_phase_spgr;
WF_PULSE **echotrainxtr;
WF_PULSE **echotrainrba;
int *echotrainramp1;
int *echotrainramp2;

/*RTB0 correction*/
WF_PULSE_ADDR rtb0echoxtr;

/* invertGy1 = 1 or -1, for rpg_flag.
   We need this for setting gy1f because this is init in PG by ileaveinit and 
   depends on pepolar. For the RPG volume, gy1 needs to be inverted because
   it is not initialized properly. */
int invertGy1 = 1;

/* The following arrays are indexed by intleave: */
int *gy1f;      /* amplitude of gy1f pulse */
int *gymn;      /* amplitude of y gradient moment nulling pulses */
int *view1st;   /* 1st view to acquire */
int *viewskip;  /* number of views to skip */
int *tf;        /* time factor shift */
int *rfpol;     /* rf polarity */
int *blippol;   /* blip gradient polarity */
int *gradpol;   /* readout gradient polarity */
float *b0ditherval;/* B0 dither value, per slice basis */
float *delayval;   /* delay values, per slice basis */
int *gldelaycval;  /* per slice gldelayc valuse */
float *gldelayfval; /* per slice gldelayf values */
int defaultdelay = 0; /* default delay */
int mintf;         /* most negative tfon value, for echo train positioning */
int sp_satindex, cs_satindex;  /* index for multiple calls to spsat
                                  and chemsat routines */
int rcvrunblankpos;
WF_PULSE gx1a = INITPULSE;
WF_PULSE gx1 = INITPULSE;
WF_PULSE gx1d = INITPULSE;

WF_PULSE rs_omega_attack = INITPULSE;
WF_PULSE rs_omega_decay = INITPULSE;
WF_PULSE omega_flat = INITPULSE;

WF_PULSE rho_killer = INITPULSE;

long scan_deadtime_inv;      /* deadtime in ir prep loop */
long scan_deadlast;          /* deadtime in last seqcore loop in 
                                Interleaved IR EPI*/
long prescan_trigger;        /* save the prescan slice's trigger */
long rsptrigger_temp[1];     /* temp trigger array for pass packets 
                                sequences and other misc */
/* Original scan info */
RSP_INFO orig_rsp_info[DATA_ACQ_MAX];
long origrot[DATA_ACQ_MAX][9];
WF_INSTR_HDR *instrtemp;

char psddbgstr[256] = "";

/* t1flair_stir */

int **real_slice_acq_seq;
int *physical_slice_acq_seq_reg;
int *physical_slice_acq_seq_enh;
int **T1flair_slice_flag;

STATUS
T1flair_sliceordering(void)
{
    if (PSD_ON == t1flair_flag)
    {
        int p, s, s1, n, tmpdummyslices, kk;
        int tmp_real_slice_acq_seq[128];
        FILE *fp = NULL;

        if (PSD_ON == debug_t1flairenh)
        {
#ifdef PSD_HW
            fp = fopen("/usr/g/service/log/t1flairsliceorder.txt", "w+");
#else
            fp = fopen("t1flairsliceorder.txt", "w+");
#endif
        }

        for (p = 0; p < acqs; p++)
        {
            /* read slice information including dummy and edge slices */
            if (t1flair_slice_info_enh[0] == slquant1)
            {
                for (s = 1; s <= slquant1; s++)
                {
                    physical_slice_acq_seq_enh[t1flair_slice_info_enh[s]] = s;
                }
            }
            else /* this should not happen */
            {
                for (s = 0; s < slquant1; s++)
                {
                    physical_slice_acq_seq_enh[s] = s + 1;
                }
            }

            /* read slice information of img slice */
            if (t1flair_slice_info_reg[0] == slquant1-dummyslices - 2*act_edge_slice_enh_flag)
            {
                for (s = 1; s <= slquant1-dummyslices - 2*act_edge_slice_enh_flag; s++)
                {
                    physical_slice_acq_seq_reg[t1flair_slice_info_reg[s]] = s;
                }
            }
            else /* this should not happen */
            {
                for (s = 0; s < slquant1-dummyslices - 2*act_edge_slice_enh_flag; s++)
                {
                    physical_slice_acq_seq_reg[s] = s + 1;
                }
            }

            /* initialization */
            for (s = 0; s < slquant1; s++)
            {
                tmp_real_slice_acq_seq[s] = s;
            }

            /* extra dummy slice due to multiple pass */
            tmpdummyslices = ((slc_in_acq[p] == slc_in_acq[0])? 0:1);

            /* determine dummy slices */
            if (dummyslices >= 0)
            {
                tmpdummyslices += dummyslices;

                kk = 0;
                for (s = 0; s < slquant1; s++)
                {
                    if (physical_slice_acq_seq_enh[s] > (slquant1 - tmpdummyslices))
                    {
                        physical_slice_acq_seq_enh[s] = -1;
                        tmp_real_slice_acq_seq[s] = slc_in_acq[p] + 2* act_edge_slice_enh_flag + kk;
                        kk++;
                        for (s1 = s+1; s1 < slquant1; s1++)
                        {
                            tmp_real_slice_acq_seq[s1] -= 1;
                        }
                    }
                }
            }

            /* adjust slice ordering for multipass scan */
            if (slc_in_acq[p] != slc_in_acq[0])
            {
                int m, tmps;
                for (n = 0; n < slquant1 - dummyslices - 2*act_edge_slice_enh_flag - 1; n++)
                {
                    if (physical_slice_acq_seq_reg[n] == slquant1 - dummyslices - 2*act_edge_slice_enh_flag)
                    {
                        tmps = physical_slice_acq_seq_reg[n];
                        for (m = n; m < slquant1 - dummyslices - 2*act_edge_slice_enh_flag -1; m++)
                        {
                            physical_slice_acq_seq_reg[m] = physical_slice_acq_seq_reg[m+1];
                        }
                        physical_slice_acq_seq_reg[slquant1 - dummyslices - 2*act_edge_slice_enh_flag -1] = tmps;
                        break;
                    }
                }
            }

            /* determine edge slice and set flag */
            for (s = 0; s < slquant1; s++)
            {
                if (-1 == physical_slice_acq_seq_enh[s])
                {
                    T1flair_slice_flag[p][s] = DUMMYSLICE;
                    real_slice_acq_seq[p][s] = tmp_real_slice_acq_seq[s];
                }
                else if (PSD_OFF == act_edge_slice_enh_flag)
                {
                    T1flair_slice_flag[p][s] = IMGSLICE;
                    real_slice_acq_seq[p][s] = tmp_real_slice_acq_seq[s];
                }
                else
                {
                    if (1 == physical_slice_acq_seq_enh[s])
                    {
                        T1flair_slice_flag[p][s] = EDGESLICE;
                        for (n = 0; n < slquant1- tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s] == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                    else if (physical_slice_acq_seq_enh[s] == (slc_in_acq[p]+2*act_edge_slice_enh_flag))
                    {
                        T1flair_slice_flag[p][s] = EDGESLICE;
                        for (n = 0; n < slquant1-tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s]-2 == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                    else
                    {
                        T1flair_slice_flag[p][s] = IMGSLICE;
                        for (n = 0; n < slquant1-tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s] -1 == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                }
            }

            if (fp != NULL)
            {
                fprintf(fp, "Pass #%d\nenhreal enhphy  act_real  flag origreal\n",p);
                for (s = 0; s < slquant1; s++)
                {
                    if (s < slquant1 - dummyslices - 2*act_edge_slice_enh_flag)
                    {
                       fprintf(fp,"%2d      %2d     %2d     %2d    %2d \n",
                               tmp_real_slice_acq_seq[s], physical_slice_acq_seq_enh[s],
                               real_slice_acq_seq[p][s], T1flair_slice_flag[p][s],
                               physical_slice_acq_seq_reg[s]);
                    }
                    else
                    {
                       fprintf(fp,"%2d      %2d     %2d     %2d\n",
                               tmp_real_slice_acq_seq[s], physical_slice_acq_seq_enh[s],
                               real_slice_acq_seq[p][s], T1flair_slice_flag[p][s]);
                    }
                }
            }
        }
        if (fp != NULL)
        {
            fclose(fp);
        }
    }
    return SUCCESS;
}



/*RTB0 correction*/
short sspwm_dynr1[4]={SSPDS,SSPOC,SSPD,SSPDS};


/* Frequency offsets */
int *rf0_freq;
int *rf0_pha;


WF_PULSE gyrf1a = INITPULSE;
WF_PULSE gyrf1  = INITPULSE;
WF_PULSE gyrf1d = INITPULSE;
WF_PULSE thrf1  = INITPULSE;
WF_PULSE *thrf1sl;
WF_HW_WAVEFORM_PTR *thrf1slp;

EXTERN_FILENAME rf1_filename;
EXTERN_FILENAME gz_filename;
EXTERN_FILENAME th_filename;
EXTERN_FILENAME gy_filename;

/* SVBranch HCSDM00155611 Use Type I pulse, pos lobes and 
   neg lobes may be different */
WF_PULSE gyrf1pa = INITPULSE;
WF_PULSE gyrf1p  = INITPULSE;
WF_PULSE gyrf1pd = INITPULSE;
WF_PULSE gyrf1na = INITPULSE;
WF_PULSE gyrf1n  = INITPULSE;
WF_PULSE gyrf1nd = INITPULSE;

/* for walk sat */
EXTERN_FILENAME rho_file;
EXTERN_FILENAME pha_file;
WF_PULSE rfwk = INITPULSE;
WF_PULSE thrfwk = INITPULSE;
WF_PULSE gyrfwk = INITPULSE;
WF_PULSE gyrfwka = INITPULSE;
WF_PULSE gyrfwkd = INITPULSE;
WF_PULSE *rfwksl;
WF_PULSE *thrfwksl;
WF_HW_WAVEFORM_PTR *rfwkslp;
WF_HW_WAVEFORM_PTR *thrfwkslp;

/* pointers to temporary waveforms for omega */
short *temp_wave1; short *temp_wave2; short *temp_wavep; short *temp_wavesum;
char pnstr[40];

void integrate2_add_phasewave (short *thwaveout, short *phasewave, short *omegawave1,
                               float ia_omegawave1, short *omegawave2, float ia_omegawave2, int npoints)
{
    /* TARDIS_FREQ_RES : Resiolution of frequency (about .596Hz/Unit)
       PSD_THETAFREQ_SHIFT : 4, Theta frequency path multiplier */
    int count;
    int current_integral = 0;
    float bits_to_hz = TARDIS_FREQ_RES * PSD_THETAFREQ_SHIFT * 64;
    float maxia_to_2pi = 2.0;
    int delta_t = pw_rf1/npoints;
 
    for (count = 0; count < npoints; count++)
    {
        current_integral += (int)(maxia_to_2pi*bits_to_hz*delta_t/1E6*ia_omegawave1*(*omegawave1++));
        current_integral += (int)(maxia_to_2pi*bits_to_hz*delta_t/1E6*ia_omegawave2*(*omegawave2++));
        *thwaveout++ = ((short)((current_integral + (*phasewave++))) & 0xfffe);
    }

    thwaveout--;               /* Back pointer up to last point */
    *thwaveout = *thwaveout+1; /* Set EOS bit */
    thwaveout++;               /* Advance pointer again. */
}

/*** SVBranch HCSDM00155611 Pulsegen for walk sat ***/
STATUS walk_sat_pulsegen(void)
{  

    /* declare the space for rho/pha waves */
    short *temp_waver_orig;
    short *temp_waver;
    short *temp_waver_ha;
    short *temp_wavep_orig;
    short *temp_wavep; 
    short *temp_wavep_ha;
    short *temp_wavep_sum; 
 
    /* update resolution after RF stretch */
    if (rfpulseInfo[RFWK_SLOT].change==PSD_ON)     
    {
        res_rfwk  = _res_rfwk.fixedflag ?  ((void)(rfpulseInfo[RFWK_SLOT].newres), res_rfwk) : rfpulseInfo[RFWK_SLOT].newres;
    }
    else
    {
        res_rfwk  = _res_rfwk.fixedflag ?  ((void)(res_rfwk_orig), res_rfwk) : res_rfwk_orig;
    }     
     
    /* allocate space for rho/pha waves */
    temp_waver_orig = (short *)AllocNode(res_rfwk_orig*sizeof(short));   
    temp_wavep_orig = (short *)AllocNode(res_rfwk_orig*sizeof(short)); 
    temp_waver      = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_waver_ha   = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_wavep      = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_wavep_ha   = (short *)AllocNode(res_rfwk*sizeof(short)); 
    temp_wavep_sum  = (short *)AllocNode(res_rfwk*sizeof(short));    
  
    /* name the pulses */
    pulsename(&rfwk, "rfwk");
    pulsename(&thrfwk, "thrfwk");  
    pulsename(&gyrfwk, "gyrfwk");
    pulsename(&gyrfwka, "gyrfwka");
    pulsename(&gyrfwkd, "gyrfwkd");      
   
    /* external file names */
    sprintf(rho_file, "satqptbw12.rho");
    sprintf(pha_file, "satqptbw12.the");
   
    /* read in rho & pha wave */
    uextwave(temp_waver_orig, res_rfwk_orig, rho_file);
    uextwave(temp_wavep_orig, res_rfwk_orig, pha_file);                  
    
    /* stretch rf if needed */
    if (rfpulseInfo[RFWK_SLOT].change==PSD_ON) 
    {  
        /* stretch rho */    
        stretchpulse(res_rfwk_orig, 
                     res_rfwk,
                     temp_waver_orig,
                     temp_waver);
        /* stretch pha */
        stretchpulse(res_rfwk_orig, 
                     res_rfwk,
                     temp_wavep_orig,
                     temp_wavep);        
    } 
    else
    {
        temp_waver = temp_waver_orig; 
        temp_wavep = temp_wavep_orig;  
    }           
    
    /* create RHO waveform */
    createreserve(&rfwk, RHO, res_rfwk);
    rfwksl = (WF_PULSE *) AllocNode(sizeof(WF_PULSE));
    rfwkslp = (WF_HW_WAVEFORM_PTR *) AllocNode(sizeof(WF_HW_WAVEFORM_PTR));
    pulsename(&rfwksl[0], "rfwksl0");
    createreserve(&rfwksl[0], RHO, res_rfwk);    
     
    /* create THETA waveform */
    createreserve(&thrfwk, THETA, res_rfwk);
    thrfwksl = (WF_PULSE *) AllocNode(sizeof(WF_PULSE));
    thrfwkslp = (WF_HW_WAVEFORM_PTR *) AllocNode(sizeof(WF_HW_WAVEFORM_PTR));
    pulsename(&thrfwksl[0], "thrfwksl0");
    createreserve(&thrfwksl[0], THETA, res_rfwk); 
  
    /* create Hadamard waveforms */
	altcomplexrfgen((INT)TYPLINEAR, 
                    res_rfwk, 
                    temp_waver, 
                    temp_wavep, 
                    cyc_rfwk,
                    sep_sat_ratio, 
                    1.0, 
                    NULL, 
                    (FLOAT)0, 
                    temp_waver_ha, 
                    temp_wavep_ha,
                    65536/(float)res_rfwk);                
    movewaveimm(temp_waver_ha, &rfwksl[0], 0, res_rfwk, TOHARDWARE); 
    movewaveimm(temp_wavep_ha, &thrfwksl[0], 0, res_rfwk, TOHARDWARE);    
    rfwkslp[0] = rfwksl[0].wave_addr; 
    thrfwkslp[0] = thrfwksl[0].wave_addr;      

    /* set instructions for RHO waves */
    createinstr(&rfwk, pos_rfwk + psd_rf_wait, pw_rfwk, ia_rfwk);   
    setwave(rfwkslp[0], &rfwk, 0);
    addrfbits(&rfwk, off_rfwk, (LONG)pos_rfwk + psd_rf_wait, pw_rfwk);    

    /* set instructions for THETA waves */
    createinstr(&thrfwk, pos_rfwk + psd_rf_wait, pw_rfwk, ia_thrfwk);   
    setwave(thrfwkslp[0], &thrfwk, 0); 
    addrfbits(&thrfwk, off_thrfwk, (LONG)pos_rfwk + psd_rf_wait, pw_rfwk);   
 
    /* slice selective gradients */
    /* ramp up */
    createramp(&gyrfwka,
               YGRAD,
               pw_gyrfwka,
               (short)0,
               MAX_PG_WAMP,
               (short)(maxGradRes*(pw_gyrfwka/GRAD_UPDATE_TIME)), 
               loggrd.ybeta);
    createinstr(&gyrfwka,
                (long)(pos_rfwk-pw_gyrfwka),
                pw_gyrfwka,
                ia_gyrfwk);
    /* plateau */
    createconst(&gyrfwk,
                YGRAD,
                pw_gyrfwk,
                MAX_PG_WAMP);
    createinstr(&gyrfwk,
                (long)(pos_rfwk),
                pw_gyrfwk,
                ia_gyrfwk);
    /* ramp down */
    createramp(&gyrfwkd,
               YGRAD,
               pw_gyrfwkd,
               MAX_PG_WAMP,
               (short)0,
               (short)(maxGradRes*(pw_gyrfwkd/GRAD_UPDATE_TIME)),
               loggrd.ybeta);
    createinstr(&gyrfwkd,
                (long)(pos_rfwk+pw_gyrfwk),
                pw_gyrfwkd,
                ia_gyrfwk);    
 
    /* spoilers */
         

  trapezoid((WF_PROCESSOR)wg_gxwksp, "gxwksp", &gxwksp, &gxwkspa,
                        &gxwkspd, pw_gxwksp, pw_gxwkspa, pw_gxwkspd,
                        ia_gxwksp, 0, 0, 0, 0, pos_sp_wk+pw_gxwkspa-pw_gxwkspa, TRAP_ALL,
                        &loggrd);
   
         

  trapezoid((WF_PROCESSOR)wg_gywksp, "gywksp", &gywksp, &gywkspa,
                        &gywkspd, pw_gywksp, pw_gywkspa, pw_gywkspd,
                        ia_gywksp, 0, 0, 0, 0, pos_sp_wk+pw_gywkspa-pw_gywkspa, TRAP_ALL,
                        &loggrd);

         

  trapezoid((WF_PROCESSOR)wg_gzwksp, "gzwksp", &gzwksp, &gzwkspa,
                        &gzwkspd, pw_gzwksp, pw_gzwkspa, pw_gzwkspd,
                        ia_gzwksp, 0, 0, 0, 0, pos_sp_wk+pw_gzwkspa-pw_gzwkspa, TRAP_ALL,
                        &loggrd);
 
 
    /* link pulses */
    linkpulses(4,
               &rfwk,
               &gyrfwk,
               &gyrfwka,
               &gyrfwkd);  
               
    /* Deallocate space */
    FreeNode(temp_waver_orig);   
    FreeNode(temp_wavep_orig);     
    FreeNode(temp_waver);
    FreeNode(temp_waver_ha);    
    FreeNode(temp_wavep);     
    FreeNode(temp_wavep_ha);             

    return SUCCESS;    
}
/****************************************************/

STATUS rfov_pulsegen(void)
{
    INT i;

    if(res_rf1 <= 0)
    {
        return FAILURE;
    }

    /* Timing of the pulses */
    start_rf1  = _start_rf1.fixedflag ?  ((void)(pos_start), start_rf1) : pos_start;

    /* SVBranch HCSDM00155611 walk sat pulsegen */
    if (walk_sat_flag)
    {
        if (FAILURE == walk_sat_pulsegen()) return FAILURE;
        start_rf1  = _start_rf1.fixedflag ?    ((void)(start_rf1+pw_wksat_tot), start_rf1) : start_rf1+pw_wksat_tot;
    }    
    
    /* Name the pulses */
    pulsename(&rf1, "rf1");
    pulsename(&thrf1, "thrf1");

    /* External filenames */
    sprintf(rf1_filename, "2drf_%d.rho", rfov_type);
    sprintf(gz_filename, "2drf_%d.gz", rfov_type);
    sprintf(gy_filename, "2drf_%d.gy", rfov_type);
    sprintf(th_filename, "2drf_%d.theta", rfov_type);

    /* Read external rho waveform in */
    createextwave(&rf1, RHO, res_rf1, rf1_filename);

    /* Create instructions for external waveforms */
    createinstr(&rf1, start_rf1 + psd_rf_wait + addrfdel, pw_rf1, ia_rf1);
    addrfbits(&rf1, 0, start_rf1 + psd_rf_wait + addrfdel, pw_rf1);

    /* Allocate space for theta waveforms to be summed */
    temp_wavep = (short *) AllocNode(res_rf1 * sizeof(short));
    temp_wavesum = (short *) AllocNode(res_rf1 * sizeof(short));

    /* Read waveform into local memory */
    /* SVBranch HCSDM00155611 Type I case: no extra phase wave */
    /* Starter HCSDM00522509 Type-II FOCUS pulse case: no extra phase wave */
    if (type1_flag || (rfov_type == 155016098))
    {
        for (i=0; i<res_rf1; i++)
        {
            temp_wavep[i] = (short)0; 
        }
    }    
    else /* regular case */
    {
        uextwave(temp_wavep, res_rf1, th_filename); 
    }

    /* Allocate space and set-up gradients here since they are used in RF setup */
    temp_wave1 = (short *) AllocNode(res_rf1 * sizeof(short));
    temp_wave2 = (short *) AllocNode(res_rf1 * sizeof(short));
    uextwave(temp_wave1, res_rf1, gy_filename);
    uextwave(temp_wave2, res_rf1, gz_filename);

    /* Create theta waveform for shifting the excitation */
    createreserve(&thrf1, THETA, res_rf1);
    thrf1sl = (WF_PULSE *) AllocNode(opslquant*sizeof(WF_PULSE));
    thrf1slp = (WF_HW_WAVEFORM_PTR *) AllocNode(opslquant*sizeof(WF_HW_WAVEFORM_PTR));

    for (i = 0; i < opslquant; i++)
    {
        /* Integrate and add Gy and Gz, add phase as theta waveforms
           Then move the summed waveform to waveform memory */
        sprintf(pnstr, "thrf1sl%d", i);
        pulsename(&thrf1sl[i], pnstr);
        createreserve(&thrf1sl[i], THETA, res_rf1);
        integrate2_add_phasewave(temp_wavesum, temp_wavep, temp_wave1, y_to_omscale[i]*shift_to_omscale[i],
                                 temp_wave2, z_to_omscale[i]*shift_to_omscale[i], res_rf1);
        movewaveimm(temp_wavesum, &thrf1sl[i], 0, res_rf1, TOHARDWARE);
        thrf1slp[i] = thrf1sl[i].wave_addr;
    }

    createinstr(&thrf1, start_rf1 + psd_rf_wait + addrfdel, pw_rf1, ia_thrf1);
    setwave(thrf1slp[0], &thrf1, 0);

    /* Now let's do the gradients */
    pulsename(&gzrf1, "gzrf1");
    pulsename(&gyrf1a, "gyrf1a");
    pulsename(&gyrf1, "gyrf1");
    pulsename(&gyrf1d, "gyrf1d");
    
    /* SVBranch HCSDM00155611 For Type I pulse */
    /* positive lobes */
    pulsename(&gyrf1pa, "gyrf1pa");
    pulsename(&gyrf1p,  "gyrf1p");
    pulsename(&gyrf1pd, "gyrf1pd");
    /* negative lobes */
    pulsename(&gyrf1na, "gyrf1na");
    pulsename(&gyrf1n,  "gyrf1n");
    pulsename(&gyrf1nd, "gyrf1nd");    
 
#ifdef IPG /* Execute only on IPG - we'll use trapezoids on the Host for pgen_on_host
              accurate with gradient heating calcs. */
    createextwave(&gzrf1, ZGRAD, res_rf1, gz_filename);
    createextwave(&gyrf1, YGRAD, res_rf1, gy_filename);
    createinstr(&gyrf1, start_rf1, pw_rf1, ia_gyrf1);
    createinstr(&gzrf1, start_rf1, pw_rf1, ia_gzrf1);
#else
    {
        if (type1_flag) /* SVBranch HCSDM00155611 For Type I pulse */
        {
            int pulsepos_rf1y = RUP_GRD(start_rf1);
            int pulsepos_rf1z = RUP_GRD(start_rf1 + 
                                        ex_pw_constanty_pos + 
                                        2*ex_pw_rampy_pos);
	                                         
            /************* Fast Grad ************/  			
            for (i = 1; i <= ex_num_gzlobe; i++)
            {            
                /* First, positive lobe */
                trapezoid( YGRAD, 
                           "gyrf1p", 
                           &gyrf1p, 
                           &gyrf1pa, 
                           &gyrf1pd,
                           ex_pw_constanty_pos, 
                           ex_pw_rampy_pos, 
                           ex_pw_rampy_pos,
                           ia_gys_pos, 
                           ia_gys_pos, 
                           ia_gys_pos, 
                           0, 
                           0,
                           pulsepos_rf1y, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1y += ex_pw_rampy_pos + 
                                 ex_pw_constanty_pos + 
                                 ex_pw_rampy_pos;	
                
                /* Next, negative lobe */
                trapezoid( YGRAD, 
                           "gyrf1n", 
                           &gyrf1n, 
                           &gyrf1na, 
                           &gyrf1nd,
                           ex_pw_constanty, 
                           ex_pw_rampy, 
                           ex_pw_rampy,
                           -ia_gyrf1, 
                           -ia_gyrf1, 
                           -ia_gyrf1, 
                           0, 
                           0,
                           pulsepos_rf1y, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1y += ex_pw_rampy + 
                                 ex_pw_constanty + 
                                 ex_pw_rampy;                				
            }
            
            /* The last positive lobe */
            trapezoid( YGRAD, 
                       "gyrf1p", 
                       &gyrf1p, 
                       &gyrf1pa, 
                       &gyrf1pd,
                       ex_pw_constanty_pos, 
                       ex_pw_rampy_pos, 
                       ex_pw_rampy_pos,
                       ia_gys_pos, 
                       ia_gys_pos, 
                       ia_gys_pos, 
                       0, 
                       0,
                       pulsepos_rf1y, 
                       TRAP_ALL, 
                       &loggrd );  
            pulsepos_rf1y += ex_pw_rampy_pos + 
                             ex_pw_constanty_pos + 
                             ex_pw_rampy_pos;                       

            /********** Blip Grad ***********/
            for (i = 1; i <= ex_num_gzlobe; i++)
            {		
                trapezoid( ZGRAD, 
                           "gzrf1", 
                           &gzrf1, 
                           &gzrf1a, 
                           &gzrf1d,
                           ex_pw_constantz, 
                           ex_pw_rampz, 
                           ex_pw_rampz,
                           ia_gzrf1, 
                           ia_gzrf1, 
                           ia_gzrf1, 
                           0, 
                           0,
                           pulsepos_rf1z, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1z += ex_pw_rampy_pos + 
                                 ex_pw_constanty_pos + 
                                 ex_pw_rampy_pos + 
                                 ex_pw_rampz + 
                                 ex_pw_constantz + 
                                 ex_pw_rampz; 
            }
        }
        else /* regular case */
        {        
            int polarity = 1;
            int pulsepos_rf1y = RUP_GRD(start_rf1);
            int pulsepos_rf1z = RUP_GRD(start_rf1 + ex_pw_constanty + 2*ex_pw_rampy -
                                        ex_pw_rampz - ex_pw_constantz/2);
            int intertype = (int)((float)ex_num_gylobe/(float)ex_num_gzlobe);
            int deltapos_rf1y = RUP_GRD(ex_pw_constanty + 2 * ex_pw_rampy);
            int deltapos_rf1z = intertype * deltapos_rf1y;

            for (i = 1; i <= ex_num_gylobe; i++)
            {
                trapezoid( YGRAD, "gyrf1", &gyrf1, &gyrf1a, &gyrf1d,
                           ex_pw_constanty, ex_pw_rampy, ex_pw_rampy,
                           (polarity*ia_gyrf1), (polarity*ia_gyrf1), (polarity*ia_gyrf1), 0, 0,
                           pulsepos_rf1y, TRAP_ALL, &loggrd );
                polarity *= -1;
                pulsepos_rf1y += deltapos_rf1y;
            }

            for (i = 1; i <= ex_num_gzlobe; i++)
            {
                trapezoid( ZGRAD, "gzrf1", &gzrf1, &gzrf1a, &gzrf1d,
                           ex_pw_constantz, ex_pw_rampz, ex_pw_rampz,
                           ia_gzrf1, ia_gzrf1, ia_gzrf1, 0, 0,
                           pulsepos_rf1z, TRAP_ALL, &loggrd );
                pulsepos_rf1z += deltapos_rf1z;
            }
        }
    }
#endif

    /* Refocusing y gradient, if needed. Refocusing z is combined with spin-echo crusher. */
    if (fabs(area_gyex1) > 0.0)
    {
        int temp_gy;   
        
        if (type1_flag) /* SVBranch HCSDM00155611 For Type I pulse */
        {
            temp_gy = pw_rf1 + RUP_GRD(start_rf1) + pw_gyex1a;         
        }
        else /* regular case */
        {
            temp_gy = RUP_GRD(pendall(&gyrf1, gyrf1.ninsts-1) + pw_gyex1a);
        }
        
               

  trapezoid((WF_PROCESSOR)wg_gyex1, "gyex1", &gyex1, &gyex1a,
                        &gyex1d, pw_gyex1, pw_gyex1a, pw_gyex1d,
                        ia_gyex1, 0, 0, 0, 0, temp_gy-pw_gyex1a, TRAP_ALL,
                        &loggrd);

    }

    /* Deallocate space */
    FreeNode(temp_wave1);
    FreeNode(temp_wave2);
    FreeNode(temp_wavep);
    FreeNode(temp_wavesum);

    return SUCCESS;
}

/***********************************/

#include "receiverunblankpulse.h"

WF_PULSE             index_rf1[10]; /* Multi-band indexed */
WF_HW_WAVEFORM_PTR   ptr_rf1[10];   /* pointer to waveform within Multi-band */

EXTERN_FILENAME ext_grad_filename; /* filename holder for externals - MUX */
EXTERN_FILENAME ext_mux_filename;  /* filename holder for externals - MUX */

short *temp_grad_space;   /* temporary waveform space for multi-band VERSEd gradients  - MUX */
short *temp_mux_space;    /* temporary waveform space for frequency modulation of VERSEd gradient - MUX */
short *this_modulated_rf; /* temporary waveform space for MUX modulated RF */

int grad_wave_ptr;      /* hardware wave pointer - MUX */
float iG_sum, kz;       /* keep track of excitation k-space total area */
float mux_modulation;   /* MUX modulation */
float iG2k;             /* integer gradient value to delta kz */
int   pair, pairs;      /* Pairs of side lobes */
char  instrname[128];   /* name the MUX RF waveforms */
int mux_index  = 0 ;      /* Multiband phase index */


/* Memory for multiplexed RF waveform */
short   srtrf_rf1[32768];



STATUS Multiband_pulsegen_rf1(void)
{
    if(res_rf1 <= 0)
    {
        return FAILURE;
    }

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1", (WF_PROCESSOR)wg_rf1);

    /* Select proper filename */
    grad_zrf1=  ssgzfile;
    rf_rf1 =  ssrffile;
    theta_rf1 = ssgzfile;

    /* Now create the pulses */
    pulsename(&gzrf1a,"gzrf1a");
    pulsename(&gzrf1,"gzrf1");
    pulsename(&gzrf1d,"gzrf1d");
    pulsename(&rf1,"rf1");
    pulsename(&thetarf1, "thetarf1");

    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

    if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
        /* Use external gradient file for now */
        createextwave( &gzrf1, ZGRAD, res_gzrf1,
                       grad_zrf1 );

        createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                     pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
        /* Create train of trapezoids on the Host side */
        int i;
        int polarity = 1;

        pulsepos  = _pulsepos.fixedflag ?  ((void)(pos_start+pw_gzrf1a), pulsepos) : pos_start+pw_gzrf1a;

        for(i = 1; i <= num_rf1lobe; i++) {
            polarity *= -1;

            trapezoid( ZGRAD,"gzrf1", &gzrf1,
                       &gzrf1a, &gzrf1d,
                       pw_constant, pw_ss_rampz, pw_ss_rampz,
                       (polarity*(ia_gzrf1)),
                       (polarity*(ia_gzrf1)),
                       (polarity*(ia_gzrf1)), 0, 0,
                       pulsepos, TRAP_ALL, &loggrd );

            pulsepos  = _pulsepos.fixedflag ?      ((void)(pw_constant+2*pw_ss_rampz), pulsepos) : pulsepos+pw_constant+2*pw_ss_rampz;
        }
#endif

    } else {

        /* Create simple trapezoid for chem sat + rf */
        createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                    (short)0, max_pg_wamp,
                    (short)(maxGradRes *
                        (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                        pg_beta );

        createinstr( &gzrf1a,
                     (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                     pw_gzrf1a, ia_gzrf1 );

        createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
        createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                     pw_gzrf1, ia_gzrf1 );

        createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                    max_pg_wamp, (short)0,
                    (short)(maxGradRes *
                        (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                        pg_beta );
        createinstr( &gzrf1d,
                     (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                     pw_gzrf1d, ia_gzrf1 );

    }

    /* Now create the rf pulse */
    if ( rftype == PLAY_RFFILE) {
        createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                       rf_rf1);
    } else {

        /* Runtime generated multiplexed RF pulse */

        { /* Copy multiplexed RF waveform to waveform memory */
            int indx,indy;
            for (indx=0; indx < res_rf1; indx++){
                srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1[indx];
            }
            createreserve(&rf1, RHO, res_rf1);
            movewaveimm(srtrf_rf1,&rf1, (int)0, res_rf1, TOHARDWARE);
            setweos(EOS_DEAD, &rf1, res_rf1-1);
            if (mux_slices_rf1 >1){    /* Now prepare for the multiple indices of the multi-band pulse */
                for (indy=0; indy < mux_slices_rf1; indy++){
                    char instrname[256];
                    if (indy==0) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1a[indx];
                    if (indy==1) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1b[indx];
                    if (indy==2) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1c[indx];
                    if (indy==3) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1d[indx];
                    if (indy==4) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1e[indx];
                    if (indy==5) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1f[indx];
                    if (indy==6) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1g[indx];
                    if (indy==7) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1h[indx];
                    if (indy==8) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1i[indx];

                    /* create space for this index of the multiband pulse */
                    sprintf(instrname, "index_rf1_%d",indy);
                    pulsename(&index_rf1[indy],instrname);                     /* Name the pulse */
                    createreserve(&index_rf1[indy],RHO,res_rf1);     /* Reserve the memory */
                    movewaveimm(srtrf_rf1,&index_rf1[indy], (int)0,
                                res_rf1,TOHARDWARE);                    /* Copy the waveform into the memory space */
                    setweos(EOS_DEAD,&index_rf1[indy],res_rf1-1);    /* Make the last word odd */
                    ptr_rf1[indy] = index_rf1[indy].wave_addr;       /* Save the pointer to memory */

                }
            }
        }

    }

    createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                 ss_rf_wait,  pw_rf1,ia_rf1);

    addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
               psd_rf_wait + ss_rf_wait, pw_rf1 );

    /* Now create the theta pulse */
    if ( thetatype == PLAY_THETA) {
        createextwave( &thetarf1, (wg_rf1==TYPRHO1)?TYPOMEGA:TYPTHETA,
                       res_thetarf1, theta_rf1 );

        createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                     ss_rf_wait, pw_thetarf1,
                     ia_thetarf1 );

    }
    if ( gztype == PLAY_GFILE) {
#if defined(IPG_TGT) || defined(MGD_TGT)
        linkpulses( 3,
                    &rf1, &gzrf1, &thetarf1);
#endif
    } else {
        linkpulses( 4,
                    &rf1, &gzrf1,
                    &gzrf1a, &gzrf1d);
    }

    if ( oppseq == PSD_GE && PSD_ON == opepi )
    {
        if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
        {
            /* Stretch RF1 if needed */
            short *wave_space;
            short *orig_wave_space;
            short orig_res = PSD_SE_RF1_PW/2;
            orig_wave_space = (short *)AllocNode(orig_res*sizeof(short));
            movewaveimm(orig_wave_space, &index_rf1[0], (int)0, orig_res, FROMHARDWARE);
            res_rf1  = _res_rf1.fixedflag ?  ((void)(rfpulseInfo[RF1_SLOT].newres), res_rf1) : rfpulseInfo[RF1_SLOT].newres;
            wave_space = (short *)AllocNode(res_rf1*sizeof(short));
            stretchpulse((int)orig_res, (int)res_rf1, orig_wave_space, wave_space);
            FreeNode(orig_wave_space);
            movewaveimm(wave_space, &index_rf1[0], (int)0, res_rf1, TOHARDWARE);
            FreeNode(wave_space);
        }
    }

    return SUCCESS;
}

STATUS Multiband_pulsegen_rf2(int *Rf2Location, short *temp_wave_space)
{
    int i;

    if (mux_flag)
    {
        if(res_rf2 <= 0)
        {
            return FAILURE;
        }

        gscale_rf2  = _gscale_rf2.fixedflag ?  ((void)(1.0), gscale_rf2) : 1.0;
        if (verse_rf2) {
            sprintf(ext_grad_filename, "verse_sb%d_rf2.grd",mux_slices_rf2);
            sprintf(ext_mux_filename,  "verse_sb%d_rf2.frq",mux_slices_rf2); /* 2us gradient file for modulation calculation */
        }
        if (debug_mux_rf)
        {
            printf("MB: RF2 Pulse: %s\n", ext_mux_filename);
        }

        temp_grad_space = (short *)AllocNode(res_gzrf2*sizeof(short)); /* 4us boundaries */
        uextwave(temp_grad_space, res_gzrf2, ext_grad_filename);

        temp_mux_space = (short *)AllocNode(res_rf2*sizeof(short)); /* 2us boundaries */
        uextwave(temp_mux_space, res_rf2, ext_mux_filename);

#ifdef EPI2_FLAG
        if( PSD_OFF == dualspinecho_flag)
        {
#endif
            if (verse_rf2) {

                if (use_omegatheta) {
                          
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2 = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2 = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2 = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2[slidx]),
                                 &(om_wave_omthrf2[slidx]), &(th_wave_omthrf2[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2), "om_omthrf2");

      createreserve(&(om_omthrf2), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2), (LONG) (Rf2Location[0] + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2[0]);

      pulsename(&(th_omthrf2), "th_omthrf2");

      createreserve(&(th_omthrf2), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2), (LONG) (Rf2Location[0] + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

                    pulsename(&thetarf2a,"thetarf2a");
                    pulsename(&thetarf2, "thetarf2");
                    pulsename(&thetarf2d,"thetarf2d");

                    /* frequency modulation waveform attack ramp */
                    createramp(&thetarf2a,OMEGA,pw_gzrf2a,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2a/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2a,(long)(Rf2Location[0] - pw_gzrf2a + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2a,ia_thetarf2);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2, (long)(Rf2Location[0] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2d,OMEGA,pw_gzrf2d,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_thetarf2d/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2d,(long)(Rf2Location[0] + pw_gzrf2 + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2d,ia_thetarf2);

                    linkpulses(3, &thetarf2a, &thetarf2, &thetarf2d);
                }
            }
#ifdef EPI2_FLAG
        }
        else
        {
            if (verse_rf2) { /* versed gradients need ramps to be created separately */

                if (use_omegatheta) {
                            
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2left = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2left = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2left = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2left[slidx]),
                                 &(om_wave_omthrf2left[slidx]), &(th_wave_omthrf2left[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2left), "om_omthrf2left");

      createreserve(&(om_omthrf2left), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2left), (LONG) (Rf2Location[1]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2left[0]);

      pulsename(&(th_omthrf2left), "th_omthrf2left");

      createreserve(&(th_omthrf2left), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2left), (LONG) (Rf2Location[1]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
                    pulsename(&thetarf2lefta,"thetarf2lefta");
                    pulsename(&thetarf2left, "thetarf2left");
                    pulsename(&thetarf2leftd,"thetarf2leftd");

                    /* frequency modulation waveform */
                    createramp(&thetarf2lefta,OMEGA,pw_gzrf2lefta,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2lefta/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2lefta,(long)(Rf2Location[1] - pw_gzrf2lefta + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2lefta,ia_thetarf2left);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2left, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2left, (long)(Rf2Location[1] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2leftd,OMEGA,pw_gzrf2leftd,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_gzrf2leftd/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2leftd,(long)(Rf2Location[1] + pw_gzrf2left + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2leftd,ia_thetarf2left);

                    linkpulses(3, &thetarf2lefta, &thetarf2left, &thetarf2leftd);
                }

                if (use_omegatheta) {
                            
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2right = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2right = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2right = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2right[slidx]),
                                 &(om_wave_omthrf2right[slidx]), &(th_wave_omthrf2right[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2right), "om_omthrf2right");

      createreserve(&(om_omthrf2right), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2right), (LONG) (Rf2Location[2]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2right[0]);

      pulsename(&(th_omthrf2right), "th_omthrf2right");

      createreserve(&(th_omthrf2right), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2right), (LONG) (Rf2Location[2]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

                    pulsename(&thetarf2righta,"thetarf2righta");
                    pulsename(&thetarf2right, "thetarf2right");
                    pulsename(&thetarf2rightd,"thetarf2rightd");

                    /* frequency modulation waveform */
                    createramp(&thetarf2righta,OMEGA,pw_gzrf2righta,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2righta/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2righta,(long)(Rf2Location[2] - pw_gzrf2righta + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2righta,ia_thetarf2right);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2right, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2right, (long)(Rf2Location[2] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2rightd,OMEGA,pw_gzrf2rightd,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_gzrf2rightd/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2rightd,(long)(Rf2Location[2] + pw_gzrf2right + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2rightd,ia_thetarf2right);

                    linkpulses(3, &thetarf2righta, &thetarf2right, &thetarf2rightd);
                }
            }
        } /*end dualspinecho_flag*/
#endif

        /* reset the bit */
        initializeReceiverUnblankPacket();

        if (verse_rf2) {
            res_rf2_gradient_waveform  = _res_rf2_gradient_waveform.fixedflag ?  ((void)(res_gzrf2), res_rf2_gradient_waveform) : res_gzrf2;
              
  {
    pulsename(&rf2_gradient_waveform,"rf2_gradient_waveform");
    createreserve(&rf2_gradient_waveform,(WF_PROCESSOR)wg_rf2_gradient_waveform,
		  res_rf2_gradient_waveform);
  }

            movewaveimm(temp_grad_space, &rf2_gradient_waveform, (int)0, res_gzrf2, TOHARDWARE);
            setweos(EOS_DEAD,&rf2_gradient_waveform,res_gzrf2-1);

            this_modulated_rf = (short *)AllocNode(res_rf2*sizeof(short)); /* to hold current 2us modulated MUX RF */

            iG_sum = 0.0;
            for (i=0; i< res_rf2; i++) {
                iG_sum += (float)temp_mux_space[i]; /* integrate the gradient waveform to find center of excitation k-space */
            }
            iG2k = pw_rf2/res_rf2 * GAM/((float)MAX_PG_WAMP)*a_gzrf2*1e-7; /* conversion from integers to delta k in cycles per mm */
            pairs = mux_slices_rf2/2;
            {
                for (mux_index = 0; mux_index < mux_slices_rf2; mux_index++) {

                    /* create an RF waveform for each phase index of the mux for DFT slice separation */
                    sprintf(instrname, "mux_rf_index_%d", mux_index);
                    pulsename(&index_rf2[mux_index],instrname);
                    createreserve(&index_rf2[mux_index],RHO,res_rf2);

                    kz = -iG_sum/2.0;
                    for (i=0; i < res_rf2; i++) {
                        kz += (float)temp_mux_space[i];
                        mux_modulation = (mux_slices_rf2 & 1); /* 1 if odd number of bands */
                        for (pair = 0; pair < pairs; pair++) {
                            mux_modulation += 2.0*cos(2.0*PI*kz*iG2k * mux_slice_shift_mm_rf1 * (pair + 1 - 0.5*((mux_slices_rf2+1)&1) ) /* frequency */
                                                      + 2.0 * PI * mux_index * (pair + 1 - 0.5*((mux_slices_rf2+1)&1))/mux_slices_rf2); /* phase */
                        } /* pairs of bands */
                        mux_modulation/= mux_slices_rf2;
                        this_modulated_rf[i] = ( (short)floor(temp_wave_space[i]*mux_modulation + 0.5) ) & ~WEOS_BIT;
                    } /* i - points in RF waveform */
                    this_modulated_rf[res_rf2-1] |= WEOS_BIT;
                    movewaveimm(this_modulated_rf, &index_rf2[mux_index], (long)0, (short)res_rf2, TOHARDWARE);
                    ptr_rf2[mux_index] = index_rf2[mux_index].wave_addr;
                } /* mux_index */
            }

            FreeNode(this_modulated_rf);
        }
        FreeNode(temp_mux_space);
        FreeNode(temp_grad_space); 

    } /*end mux_flag*/


    return SUCCESS;
}

#ifdef __STDC__ 
void dummyssi( void )
#else /* !__STDC__ */
    void dummyssi() 
#endif /* __STDC__ */
{
    return;
}

/* Added for Inversion.e */
#ifdef __STDC__
STATUS setupphases ( INT *phase, INT *freq, INT slice, FLOAT rel_phase, INT time_delay, INT sign_flag)
#else /* !__STDC__ */
    STATUS setupphases (phase, freq, slice, rel_phase, time_delay)
    INT *phase;                /* output phase offsets */
    INT *freq;                 /* precomputed frequency offsets */
    INT slice;                 /* slice number */
    FLOAT rel_phase;           /* in cycles */
    INT time_delay;            /* in micro seconds */
#endif /* __STDC__ */
{
    double ftime_delay;           /* floating point time delay in seconds */
    double temp_freq;             /* frequency offset */
    float tmpphase;
    int   intphase;
    int   sign;

    ftime_delay = ((double)time_delay)/((double)(1000000));

    /* Convert tardis int to frequency */
    temp_freq = sign_flag*((double)(freq[slice]))*TARDIS_FREQ_RES;

    /* determine phase change in radians */
    tmpphase = (rel_phase - ( temp_freq * ftime_delay ))*2.0*PI;

    tmpphase/= (float)PI;    /* unwrap this phase bits */
    if (tmpphase < 0) {
        sign = -1;
        tmpphase *= -1;
    }
    else
        sign = 1;

    if ( ((int)floor((double)tmpphase) % 2) == 1) {
        sign *= -1;
        intphase = sign * (long)
            ( (1.0-(tmpphase - (float)floor((double)tmpphase)) ) * ((double)FSI));
    }
    else
        intphase = sign * (long)
            ( (tmpphase - (float)floor((double)tmpphase)) * ((double)FSI));

    phase[slice] = intphase;

    return SUCCESS;
}

void
#ifdef __STDC__ 
ssisat( void )
#else /* !__STDC__ */
    ssisat()
#endif /* __STDC__ */
{
#ifdef IPG
    int next_slice;

    next_slice = sp_sat_index;
    sp_update_rot_matrix( &rsprot_orig[next_slice][0], sat_rot_matrices,
                          sat_rot_ex_num, sat_rot_df_num );
#endif /* IPG */
    return;
}

/***************************** setreadpolarity *************************/
#ifdef __STDC__ 
STATUS setreadpolarity( void )
#else /* !__STDC__ */
    STATUS setreadpolarity()
#endif /* __STDC__ */
{
    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    }

    tia_gx1  = _tia_gx1.fixedflag ?  ((void)(gradpol[ileave]*ia_gx1), tia_gx1) : gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw  = _tia_gxw.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxw), tia_gxw) : polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk  = _tia_gxk.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxk), tia_gxk) : polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */

    setiamp(tia_gx1, &gx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &gx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &gx1d, 0);        /* x dephaser decay  */

    if(iref_etl > 0)
    {
        tia_gxiref1  = _tia_gxiref1.fixedflag ?  ((void)(polarity*gradpol[ileave]*ia_gxiref1), tia_gxiref1) : polarity*gradpol[ileave]*ia_gxiref1; /* temporary interref x dephaser amp */ 
        tia_gxirefr  = _tia_gxirefr.fixedflag ?      ((void)((iref_etl%2?1:-1)*polarity*gradpol[ileave]*ia_gxirefr), tia_gxirefr) : (iref_etl%2?1:-1)*polarity*gradpol[ileave]*ia_gxirefr; /* temporary interref x rephaser amp */
        setiampt(tia_gxiref1, &gxiref1, 0);  /* interref x dephaser */
        setiampt(tia_gxirefr, &gxirefr, 0);  /* interref x rephaser */
    }

    if(iref_etl > 0)
    {
        setiamp(tia_gxw, &gxw, 0); /* gx_dwi cross term correction */
    }
    else
    {
        setiamp(tia_gxw-ia_gx_dwi, &gxw, 0); /* gx_dwi cross term correction */
    }

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN macro.  Please refer to epic.h
       for more details. */

    for (echo=1; echo < tot_etl; echo++) {
        if(echo < iref_etl)
        {
            if ((echo % 2) == 1) {  /* Even echo within interleave */
                setiamp(-tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(-tia_gxw, &gxwd, echo-1);
                setiamp(-tia_gxw, &gxw, echo);    /* const   */
            } else {                    /* Odd echo within interleave */
                setiamp(tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(tia_gxw, &gxwd, echo-1);
                setiamp(tia_gxw, &gxw, echo);     /* flattop   */
            }
        }
        else
        {
            if ((echo % 2) == 1) {  /* Even echo within interleave */ 
                setiamp(-tia_gxw-ia_gx_dwi, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(-tia_gxw-ia_gx_dwi, &gxwd, echo-1);
                setiamp(-tia_gxw-ia_gx_dwi, &gxw, echo);    /* const   */
            } else {                    /* Odd echo within interleave */
                setiamp(tia_gxw-ia_gx_dwi, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(tia_gxw-ia_gx_dwi, &gxwd, echo-1);
                setiamp(tia_gxw-ia_gx_dwi, &gxw, echo);     /* flattop   */
            }
        }
    }

    if ((tot_etl % 2) == 1) {
        setiamp(-tia_gxw-ia_gx_dwi,&gxwde, 0);  /* decay,end */
        if (eosxkiller == 1) {
            setiamp(-tia_gxk,&gxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&gxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&gxkd, 0);   /* killer decay  */
        }
    } else {
        setiamp(tia_gxw-ia_gx_dwi,&gxwde, 0);   /* decay,end */
        if (eosxkiller == 1) {
            setiamp(tia_gxk,&gxka, 0);    /* killer attack */
            setiamp(tia_gxk,&gxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&gxkd, 0);    /* killer decay  */
        }
    }

    return SUCCESS;
} /* end setreadpolarity */

#ifdef __STDC__ 
STATUS pulsegen( void )
#else /* !__STDC__ */
    STATUS pulsegen() 
#endif /* __STDC__ */ 
{
    EXTERN_FILENAME ext_filename; /* filename holder for externals */
    int Rf2Location[NECHO_MAX]; /* time locations of Rf2 */
    short slmod_acqs;           /* slices%acqs */
    int tempx, tempy, tempz, temps, tempiref = 0;
    int temp1, temp2 = 0;
    int echoloop;
    int psd_icnt,psd_jcnt;
    int psd_seqtime;      /* sequence time */
    short *wave_space;
    short *temp_wave_space = NULL; /* temporary waveform space for rf scaling */
    short temp_res;         /* temporary resolution */
    int wave_ptr;           /* hardware wave pointer */
    float temp_gmnamp;  /* temporary amplitudes for y gmn calc */
    float tempa, tempb;
    LONG pulsePos;
    int lpfval = -1;
    float betax;
    EXTERN_FILENAME test_wave_file; /* granty edit for qti */

    tot_etl  = _tot_etl.fixedflag ?    ((void)(etl+iref_etl), tot_etl) : etl+iref_etl; /* internref */

    /* Added for Inversion.e InversionPG1 */
    int i;

    /* Set HPC timer set to 10 seconds (5 sec. per count) */
    setwatchdogrsp(watchdogcount); /* First give pulsegen a little extra time */
#ifdef MGD_TGT		/* if this is MGD */
    SetHWMem();		/* reset MGD instruction and waveform mem */
#endif	
 
    /*MRIhc18005*/
    sspinit(psd_board_type);

    /* Initialize TGlimit */
    TGlimit  = _TGlimit.fixedflag ?  ((void)(MAX_SYS_TG), TGlimit) : MAX_SYS_TG;

#ifdef IPG 
    /*
     * Execute this code only on the Tgt side
     */
#ifdef SIM
    /* 7/17/96 RJL: Initialization for Simulators. Only required for simulation builds.
       This is not compiled in during HW builds. This is taken care of in Makefile */
    simulationInit( rsprot[0] );
    /* rsprot code */
    {
        int j;

        for (i=0; i<opslquant*opphases; i++) {
            for (j=0; j<9; j++) {
                rsprot_unscaled[i][j] = rsprot[i][j];
            }
        }
    }

#endif /* SIM */
#endif /* IPG */

    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */


    debugstate = debugipg;

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    acq_ptr = (short *)AllocNode((act_acqs*pass_reps + 2)*sizeof(short));
    ctlend_tab = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
    slc_in_acq = (short *)AllocNode((act_acqs*pass_reps + 2)*sizeof(short));
    rf1_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    theta_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    thetarf2_freq = (int *)AllocNode((mux_slquant + 2)*sizeof(int));
    rf1_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2left_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2right_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));

    recv_freq = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_freq[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_freq[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
        }
    }

    recv_phase = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_phase[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_phase[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
        }
    }

    recv_phase_angle = (double ***)AllocMem(opslquant*sizeof(double **));
    recv_phase_ang_nom = (double ***)AllocMem(opslquant*sizeof(double **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_phase_angle[psd_icnt] = (double **)AllocMem(intleaves* sizeof(double *));
        recv_phase_ang_nom[psd_icnt] = (double **)AllocMem(intleaves*sizeof(double *)); 
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_phase_angle[psd_icnt][psd_jcnt] = (double *)AllocMem(tot_etl*sizeof(double));
            recv_phase_ang_nom[psd_icnt][psd_jcnt] = (double *)AllocMem(tot_etl*sizeof(double));
        }
    }

    rf_phase_spgr = (int **)AllocMem(opslquant*sizeof(int *));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	rf_phase_spgr[psd_icnt] = (int *)AllocMem(intleaves*sizeof(int));
    }

{   int pp;

    ia_gx_hoec_comp = (int ***)AllocMem(intleaves*sizeof(int **));
    ia_gy_hoec_comp = (int ***)AllocMem(intleaves*sizeof(int **));
    recv_phase_b0_hoec_comp = (double ***)AllocMem(intleaves*sizeof(double **));

    for (pp=0; pp<intleaves; pp++)
    {

        ia_gx_hoec_comp[pp] = (int **)AllocMem(opslquant*sizeof(int *));
        for (i=0; i<opslquant; i++)
        {
            ia_gx_hoec_comp[pp][i] = (int *)AllocMem(tot_etl*sizeof(int));
        }
        ia_gy_hoec_comp[pp] = (int **)AllocMem(opslquant*sizeof(int *));
        for (i=0; i<opslquant; i++)
        {
            ia_gy_hoec_comp[pp][i] = (int *)AllocMem(tot_etl*sizeof(int));
        }
        recv_phase_b0_hoec_comp[pp] = (double **)AllocMem(opslquant*sizeof(double *));
        for (i=0; i<opslquant; i++)
        {
             recv_phase_b0_hoec_comp[pp][i] = (double *)AllocMem(tot_etl*sizeof(double));
        }
    }
}

/* functions that set blip amplitude and receiver phase */

    echotrainxtr = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainramp1 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp2 = (int *)AllocNode(tot_etl*sizeof(int));

    gy1f = (int *)AllocNode((intleaves+1)*sizeof(int));
    gymn = (int *)AllocNode((intleaves+1)*sizeof(int));
    view1st = (int *)AllocNode((intleaves+1)*sizeof(int));
    viewskip = (int *)AllocNode((intleaves+1)*sizeof(int));
    tf = (int *)AllocNode((intleaves+1)*sizeof(int));
    rfpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    gradpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    blippol = (int *)AllocNode((intleaves+1)*sizeof(int));
    b0ditherval = (float *)AllocNode((opslquant+1)*sizeof(float));
    delayval = (float *)AllocNode((opslquant+1)*sizeof(float));
    gldelaycval = (int *)AllocNode((opslquant+1)*sizeof(int));
    gldelayfval = (float *)AllocNode((opslquant+1)*sizeof(float));

    /* t1flair_stir */
    if (t1flair_flag == PSD_ON)
    {
        physical_slice_acq_seq_reg = (int *)AllocNode((slquant1 + 2)*sizeof(int));
        physical_slice_acq_seq_enh = (int *)AllocNode((slquant1 + 2)*sizeof(int));
        real_slice_acq_seq = (int **)AllocNode((acqs + 2)*sizeof(int*));

        T1flair_slice_flag = (int **)AllocNode((acqs + 2)*sizeof(int*));
        for (i = 0; i < acqs + 2; i++)
        {
            real_slice_acq_seq[i] = (int *)AllocNode((slquant1 + 1)*sizeof(int));
            T1flair_slice_flag[i] = (int *)AllocNode((slquant1 + 1)*sizeof(int));
        }
    }

    if (opdiffuse == PSD_ON && diff_order_flag)
    {
        if (flair_flag == PSD_OFF)
        {
            diff_order_nslices  = _diff_order_nslices.fixedflag ?    ((void)((mux_flag?mux_slquant:slquant1)*acqs), diff_order_nslices) : (mux_flag?mux_slquant:slquant1)*acqs;
        }
        else
        {
            diff_order_nslices  = _diff_order_nslices.fixedflag ?      ((void)(false_slquant1*false_acqs*acqs), diff_order_nslices) : false_slquant1*false_acqs*acqs;
        }

        if ((diff_order_flag == 1) || (diff_order_flag == 2 && tensor_flag == PSD_ON))
        {
            diff_order_size  = _diff_order_size.fixedflag ?  ((void)(pass_reps), diff_order_size) : pass_reps;
        }
        else if (diff_order_flag == 2)
        {
            diff_order_size  = _diff_order_size.fixedflag ?              ((void)((int)(opdifnext2*opdifnumt2+num_dif*total_difnex+(ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0))), diff_order_size) : (int)(opdifnext2*opdifnumt2+num_dif*total_difnex+(ref_in_scan_flag?1:0)+(rpg_in_scan_flag?rpg_in_scan_num:0));
            diff_order_pass = (int *)AllocNode(diff_order_size*sizeof(int));
            diff_order_nex = (int *)AllocNode(diff_order_size*sizeof(int));
            diff_order_dif = (int *)AllocNode(diff_order_size*sizeof(int));
        }

        /* diff_order[pass][slice] */
        diff_order = (int **)AllocNode(diff_order_size*sizeof(int *));

        for (psd_icnt = 0; psd_icnt < diff_order_size; psd_icnt++)
        {
            diff_order[psd_icnt] = (int *)AllocNode(diff_order_nslices*sizeof(int));
        }

        if ( FAILURE == set_diff_order() )
        {
            return FAILURE;
        }
    }

#ifdef ERMES_DEBUG
    debugileave  = _debugileave.fixedflag ?  ((void)(1), debugileave) : 1;
#else
    debugileave  = _debugileave.fixedflag ?  ((void)(0), debugileave) : 0;
#endif
  
    switch (ky_dir) {
    case PSD_TOP_DOWN:
	readpolar  = _readpolar.fixedflag ?  ((void)(1), readpolar) : 1;
	break;
    case PSD_BOTTOM_UP:
    case PSD_CENTER_OUT:
    default:
	if (etl % 2 == 1)  /* odd */
            readpolar  = _readpolar.fixedflag ?  ((void)(1), readpolar) : 1;
	else               /* even */
            readpolar  = _readpolar.fixedflag ?  ((void)(-1), readpolar) : -1;  
	break;
    }

    /* BJM: MRIge60610 - added num_overscan */ 
    /* MRIge89403: added one more argument for EPI internal ref
       scan but set to 0 */
    if (FAILURE == ileaveinit( fullk_nframes, ky_dir,
                               intleaves, ep_alt, readpolar, blippolar, debugileave, ia_rf1,
                               ia_gyb, pepolar, etl, seq_data, delt, tfon, fract_ky,
                               ky_offset, num_overscan, endview_iamp, esp, tsp, rhfrsize,
                               a_gxw, rhrcxres, slquant1, lpfval, iref_etl, gy1f, view1st,
                               viewskip, tf, rfpol, gradpol, blippol, &mintf ))
    {
        return FAILURE;
    }

    for (ileave = 0; ileave < intleaves; ileave++){
        if (ygmn_type == CALC_GMN1) {
            tempa = a_gy1a * (float)gy1f[ileave]/(float)endview_iamp;
            tempb = a_gy1b * (float)gy1f[ileave]/(float)endview_iamp;
	  
            amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                      pw_gy1d, tempa, tempb, loggrd.ty_xyz, (float)loggrd.yrt*loggrd.scale_3axis_risetime,
                      1, _pw_gymn1a.fixedflag ? (_temp1286_pw_gymn1a=pw_gymn1a,&_temp1286_pw_gymn1a) : &pw_gymn1a, _pw_gymn1.fixedflag ? (_temp1287_pw_gymn1=pw_gymn1,&_temp1287_pw_gymn1) : &pw_gymn1, _pw_gymn1d.fixedflag ? (_temp1288_pw_gymn1d=pw_gymn1d,&_temp1288_pw_gymn1d) : &pw_gymn1d, &temp_gmnamp);
	  
            gymn[ileave] = (int)((float)ia_gymn1 * a_gymn1/ temp_gmnamp);
          
            if (debugileave == 1)
                printf("gymn[%d] = %d, temp_gmnamp = %f\n",
                       ileave,gymn[ileave],temp_gmnamp);
        } else
            gymn[ileave] = 0;
    }


#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    rdx = dx;
    rdy = dy;
    rdz = dz;

    dlyx = gldelayx;
    dlyy = gldelayy;
    dlyz = gldelayz;

    b0Dither_ifile(b0ditherval, ditheron, rdx, rdy, rdz, a_gxw, esp, opslquant,
                   debugdither, rsprot_unscaled, ccinx, cciny, ccinz, esp_in, 
                   fesp_in, &g0, &num_elements, &file_exist);

    calcdelay(delayval, delayon, dlyx, dlyy, dlyz,
              &defaultdelay, opslquant, opgradmode,debugdelay, rsprot_unscaled);

    for (slice = 0; slice < opslquant; slice++)
        delayval[slice] += dacq_adjust;

    if (oppseq == PSD_SPGR)
	spgr_flag  = _spgr_flag.fixedflag ?  ((void)(1), spgr_flag) : 1;
    else
	spgr_flag  = _spgr_flag.fixedflag ?  ((void)(0), spgr_flag) : 0;

    for (slice = 0; slice < opslquant; slice++) {
        for (ileave = 0; ileave < intleaves; ileave++)
            rf_phase_spgr[slice][ileave] = 0;  /* call spgr function in future */
    }
#endif /* IPG */

    /*RTB0 correction*/
    if(rtb0_flag)
    {
        
  {
    pulsename(&dynr1,"dynr1");
    createbits(&dynr1,TYPSSP,sizeof(sspwm_dynr1)/2,sspwm_dynr1);
    createinstr( &dynr1,(long)(tlead-pw_dynr1-GRAD_UPDATE_TIME),
		pw_dynr1,ia_dynr1);
  }

    }

       
  {
    pulsename(&x_td0,"x_td0");
    createconst(&x_td0,(WF_PROCESSOR)wg_x_td0,pw_x_td0,(short)0); 
    createinstr( &x_td0,(long)(tlead),pw_x_td0,0);
  }

       
  {
    pulsename(&y_td0,"y_td0");
    createconst(&y_td0,(WF_PROCESSOR)wg_y_td0,pw_y_td0,(short)0); 
    createinstr( &y_td0,(long)(tlead),pw_y_td0,0);
  }

       
  {
    pulsename(&z_td0,"z_td0");
    createconst(&z_td0,(WF_PROCESSOR)wg_z_td0,pw_z_td0,(short)0); 
    createinstr( &z_td0,(long)(tlead),pw_z_td0,0);
  }

       
  {
    pulsename(&rho_td0,"rho_td0");
    createconst(&rho_td0,(WF_PROCESSOR)wg_rho_td0,pw_rho_td0,(short)0); 
    createinstr( &rho_td0,(long)(tlead),pw_rho_td0,0);
  }

       
  {
    pulsename(&theta_td0,"theta_td0");
    createconst(&theta_td0,(WF_PROCESSOR)wg_theta_td0,pw_theta_td0,(short)0); 
    createinstr( &theta_td0,(long)(tlead),pw_theta_td0,0);
  }
 /* YMSmr07445 */
       
  {
    pulsename(&omega_td0,"omega_td0");
    createconst(&omega_td0,(WF_PROCESSOR)wg_omega_td0,pw_omega_td0,(short)0); 
    createinstr( &omega_td0,(long)(tlead),pw_omega_td0,0);
  }

       
  {
    pulsename(&ssp_td0,"ssp_td0");
    createconst(&ssp_td0,(WF_PROCESSOR)wg_ssp_td0,pw_ssp_td0,(short)0); 
    createinstr( &ssp_td0,(long)(tlead),pw_ssp_td0,0);
  }

  
#ifdef IPG
    for (slice = 0; slice < opslquant; slice++) 
    {
        if (delayval[slice] < 0.0)
	    gldelaycval[slice] = (int)(delayval[slice] - 0.5);
        else
	    gldelaycval[slice] = (int)(delayval[slice] + 0.5);
    }
#endif /* IPG */  

    /* Spatial Sat *******************************************************/
    sp_satindex = 0;
    SpSatPG(vrgsat,sp_satstart, &sp_satindex, sp_satcard_loc);
  
    /* Chem Sat **********************************************************/
    cs_satindex = 0;
    if (cs_sat)
	ChemSatPG(cs_satstart, &cs_satindex);

    if (rfov_flag)
    {
        if(FAILURE == rfov_pulsegen())
        {
            return FAILURE;
        }
    }
    else if (mux_flag)
    {
        if(FAILURE == Multiband_pulsegen_rf1())
        {
            return FAILURE;
        }
    }
    else
    {
        /* spsp 90 RF slice select pulse *******************************************/
        if(rftype && (!ss_rf1))
        {
            temp_wave_space = (short *)AllocNode(res_rf1*sizeof(short));
            uextwave(temp_wave_space, res_rf1, ssrffile);
        }

        temp_res = res_rf1;
        if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
            res_rf1  = _res_rf1.fixedflag ?  ((void)(rfpulseInfo[RF1_SLOT].newres), res_rf1) : rfpulseInfo[RF1_SLOT].newres;

        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
           unblank the receiver - see EpicConf.c for defaults. Will unblank
           the receiver later - MRIge28778 */ /*CLARIFY*/

        leaveReceiverBlanked();

           
                             
                              
                              
  {
      /* Check for RF waveform generator */
      RFEnvelopeWaveformGeneratorCheck("rf1", 
                                       (WF_PROCESSOR)wg_rf1);

      /* Select proper filename */
      grad_zrf1=  ssgzfile;
      rf_rf1 =  ssrffile;
      theta_rf1 = ssgzfile;

      /* Now create the pulses */
      pulsename(&gzrf1a,"gzrf1a");
      pulsename(&gzrf1,"gzrf1");
      pulsename(&gzrf1d,"gzrf1d");
      pulsename(&rf1,"rf1");
      pulsename(&thetarf1, "thetarf1");

      /*  Now create the slice select trapezoid */
      pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1, ZGRAD, res_gzrf1,
                         grad_zrf1 );

          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos  = _pulsepos.fixedflag ?  ((void)(pos_start+pw_gzrf1a), pulsepos) : pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1", &gzrf1, 
                         &gzrf1a, &gzrf1d,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos  = _pulsepos.fixedflag ?      ((void)(pw_constant+2*pw_ss_rampz), pulsepos) : pulsepos+pw_constant+2*pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1a,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1d,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( (rftype&&ss_rf1) == PLAY_RFFILE) {
          createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          createextwave( &thetarf1, (wg_rf1==TYPRHO1)?TYPOMEGA:TYPTHETA,
                         res_thetarf1, theta_rf1 );

          createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1 );

          addrfbits( &thetarf1, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
      if ( gztype == PLAY_GFILE) {
          #if defined(IPG_TGT) || defined(MGD_TGT)
          linkpulses( 3,
                      &rf1, &gzrf1, &thetarf1);
          #endif
      } else {
          linkpulses( 4,
                      &rf1, &gzrf1,
                      &gzrf1a, &gzrf1d);
      }
  }


        /* reset the bit */
        initializeReceiverUnblankPacket();

        if(rftype && (!ss_rf1))
        {
             /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_SLOT].change==PSD_ON) 
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_SLOT].newres,temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } 
            else
            {
                wave_space = temp_wave_space;
            }

            /* move immediately into permanent memory */
            movewaveimm(wave_space, &rf1, (int)0, res_rf1, TOHARDWARE);
            FreeNode(wave_space);
        }

        if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
            res_rf1  = _res_rf1.fixedflag ?  ((void)(temp_res), res_rf1) : temp_res;
    }

    /* 180 RF refocusing pulse ********************************************/
    if (oppseq == PSD_SE) {
        Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
 
        /* DTI */
        if (PSD_ON == dualspinecho_flag)
        {
            /* BJM: place the 180's at t & 3t with echo center at 4t... */
            /*      Note: this increases the TE slightly since minTE = 4* azminb  */
            Rf2Location[1] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte/4 - pw_rf2/2) - psd_rf_wait);
            Rf2Location[2] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + 3*opte/4 - pw_rf2/2) - psd_rf_wait);
        }

        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
        if (PSD_OFF == mux_flag)
        {
            strcpy(ext_filename, "rfse1b4.rho");
        }
        else
        {
            sprintf(ext_filename, "verse_sb%d_rf2.rho",mux_slices_rf2);
        }

        /* Create some RHO waveform space, read in the
       se1b4 spin echo 180 to local memory, and then move
       the local memory to the reserved RHO memory.
        */
        temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
        uextwave(temp_wave_space, res_rf2, ext_filename);

        /* MRIge58235: save orig. res_rf2 for scaling */
        short orig_res;

        orig_res = res_rf2;
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
            res_rf2  = _res_rf2.fixedflag ?  ((void)(rfpulseInfo[RF2_SLOT].newres), res_rf2) : rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */

        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
               unblank the receiver - see EpicConf.c for defaults. Will unblank
               the receiver later - MRIge28778 */
        leaveReceiverBlanked();

        /*  180 slice sel pulse  */
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2", 
                                     (WF_PROCESSOR)wg_rf2);

    /* First create the pulses */
    pulsename(&gzrf2a,"gzrf2a");
    pulsename(&gzrf2,"gzrf2");
    pulsename(&gzrf2d,"gzrf2d");
    pulsename(&rf2,"rf2");
    
    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrf2a,ZGRAD,pw_gzrf2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2a,(long)(Rf2Location[0]-pw_gzrf2a),
                pw_gzrf2a,ia_gzrf2);
    createconst(&gzrf2,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
    createinstr( &gzrf2,(long)(Rf2Location[0]),
                pw_gzrf2,ia_gzrf2);
    createramp(&gzrf2d,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2d,(long)(Rf2Location[0]+pw_gzrf2),
                pw_gzrf2d,ia_gzrf2);
    
    /* Now create the rf pulse */
    createsinc(&rf2,(WF_PROCESSOR)wg_rf2,res_rf2,
	       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
    createinstr( &rf2,(long)(Rf2Location[0]) + psd_rf_wait,
		pw_rf2,ia_rf2);
    linkpulses(4,&rf2,&gzrf2,&gzrf2a,
	       &gzrf2d);
    addrfbits(&rf2,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
	      pw_rf2);
  }


        } else {
            /* If pw_rf2 is scaled...DTI BJM (dsp) */
            if (PSD_ON == dualspinecho_flag)
            {
                res_rf2left  = _res_rf2left.fixedflag ?  ((void)(res_rf2), res_rf2left) : res_rf2;
                res_rf2right  = _res_rf2right.fixedflag ?  ((void)(res_rf2left), res_rf2right) : res_rf2left;
            }

              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2left", 
                                     (WF_PROCESSOR)wg_rf2left);

    /* First create the pulses */
    pulsename(&gzrf2lefta,"gzrf2lefta");
    pulsename(&gzrf2left,"gzrf2left");
    pulsename(&gzrf2leftd,"gzrf2leftd");
    pulsename(&rf2left,"rf2left");
    
    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrf2lefta,ZGRAD,pw_gzrf2lefta,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2lefta/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2lefta,(long)(Rf2Location[1]-pw_gzrf2lefta),
                pw_gzrf2lefta,ia_gzrf2left);
    createconst(&gzrf2left,ZGRAD,pw_gzrf2left,MAX_PG_WAMP);
    createinstr( &gzrf2left,(long)(Rf2Location[1]),
                pw_gzrf2left,ia_gzrf2left);
    createramp(&gzrf2leftd,ZGRAD,pw_gzrf2leftd,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2leftd/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2leftd,(long)(Rf2Location[1]+pw_gzrf2left),
                pw_gzrf2leftd,ia_gzrf2left);
    
    /* Now create the rf pulse */
    createsinc(&rf2left,(WF_PROCESSOR)wg_rf2left,res_rf2left,
	       MAX_PG_WAMP,cyc_rf2left, alpha_rf2left);
    createinstr( &rf2left,(long)(Rf2Location[1]) + psd_rf_wait,
		pw_rf2left,ia_rf2left);
    linkpulses(4,&rf2left,&gzrf2left,&gzrf2lefta,
	       &gzrf2leftd);
    addrfbits(&rf2left,off_rf2left,(long)(Rf2Location[1]) + psd_rf_wait, 
	      pw_rf2left);
  }



              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2right", 
                                     (WF_PROCESSOR)wg_rf2right);

    /* First create the pulses */
    pulsename(&gzrf2righta,"gzrf2righta");
    pulsename(&gzrf2right,"gzrf2right");
    pulsename(&gzrf2rightd,"gzrf2rightd");
    pulsename(&rf2right,"rf2right");
    
    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrf2righta,ZGRAD,pw_gzrf2righta,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2righta/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2righta,(long)(Rf2Location[2]-pw_gzrf2righta),
                pw_gzrf2righta,ia_gzrf2right);
    createconst(&gzrf2right,ZGRAD,pw_gzrf2right,MAX_PG_WAMP);
    createinstr( &gzrf2right,(long)(Rf2Location[2]),
                pw_gzrf2right,ia_gzrf2right);
    createramp(&gzrf2rightd,ZGRAD,pw_gzrf2rightd,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2rightd/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2rightd,(long)(Rf2Location[2]+pw_gzrf2right),
                pw_gzrf2rightd,ia_gzrf2right);
    
    /* Now create the rf pulse */
    createsinc(&rf2right,(WF_PROCESSOR)wg_rf2right,res_rf2right,
	       MAX_PG_WAMP,cyc_rf2right, alpha_rf2right);
    createinstr( &rf2right,(long)(Rf2Location[2]) + psd_rf_wait,
		pw_rf2right,ia_rf2right);
    linkpulses(4,&rf2right,&gzrf2right,&gzrf2righta,
	       &gzrf2rightd);
    addrfbits(&rf2right,off_rf2right,(long)(Rf2Location[2]) + psd_rf_wait, 
	      pw_rf2right);
  }

        }

        if(mux_flag)
        {
            if(FAILURE == Multiband_pulsegen_rf2(Rf2Location, temp_wave_space))
            {
                return FAILURE;
            }
            FreeNode(temp_wave_space);
        }
        else
        {
            /* reset the bit */
            initializeReceiverUnblankPacket();

            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
                wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                             temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } else
                wave_space = temp_wave_space;

            /* Assign temporary board memory and move immediately into permanent
               memory */
            res_rf2se1b4  = _res_rf2se1b4.fixedflag ?  ((void)(res_rf2), res_rf2se1b4) : res_rf2;
              
  {
    pulsename(&rf2se1b4,"rf2se1b4");
    createreserve(&rf2se1b4,(WF_PROCESSOR)wg_rf2se1b4,
		  res_rf2se1b4);
  }

            movewaveimm(wave_space, &rf2se1b4, (int)0, res_rf2, TOHARDWARE);
            FreeNode(wave_space);
        }

        /* MRIge58235: reset res_rf2 after scaling */
        res_rf2  = _res_rf2.fixedflag ?  ((void)(orig_res), res_rf2) : orig_res;

        /* DTI BJM (dsp) */
        if (PSD_ON == dualspinecho_flag)
        {
            res_rf2left  = _res_rf2left.fixedflag ?  ((void)(res_rf2), res_rf2left) : res_rf2;
            res_rf2right  = _res_rf2right.fixedflag ?  ((void)(res_rf2left), res_rf2right) : res_rf2left;
        }

        if (innerVol == PSD_ON)
        {
                 

  trapezoid((WF_PROCESSOR)wg_gyrf2iv, "gyrf2iv", &gyrf2iv, &gyrf2iva,
                        &gyrf2ivd, pw_gyrf2iv, pw_gyrf2iva, pw_gyrf2ivd,
                        ia_gyrf2iv, 0, 0, 0, 0, Rf2Location[0]-pw_gyrf2iva, TRAP_ALL,
                        &loggrd);

            ia_gzrf2  = _ia_gzrf2.fixedflag ?  ((void)(0), ia_gzrf2) : 0;
        }

        /* DTI BJM (dsp) */
        if (PSD_OFF == dualspinecho_flag)
        {
            setphase((float)(PI/-2.0), &rf2, 0);       /* Apply 90 phase shift to  180 */
        } else {
            setphase((float)(PI/-2.0), &rf2right, 0);  /* Apply 90 phase shift to  180 */
            setphase((float)(PI/-2.0), &rf2left, 0);   /* Apply 90 phase shift to  180 */
        }

        attenflagon(&rf1, 0);                 /* Assert ESSP flag on rf1 pulse */

        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            attenflagon(&rf2, 0);                 /* Assert ESSP flag on 1st rf2 */
        } else {
            attenflagon(&rf2right, 0);            /* Assert ESSP flag on rigth rf2 */
        }

        /* Z crushers (echo 1) ***********************************************/
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
             
                         
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2l1, "gzrf2l1", &gzrf2l1, &gzrf2l1a,
                        &gzrf2l1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
                        ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
                        &loggrd);


                 

  trapezoid((WF_PROCESSOR)wg_gzrf2r1, "gzrf2r1", &gzrf2r1, &gzrf2r1a,
                        &gzrf2r1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
                        ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2,"gzrf2d",0)-pw_gzrf2r1a, TRAP_ALL,
                        &loggrd);

            if( PSD_ON == xygradCrusherFlag ) {
                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradCrusherL, "xgradCrusherL", &xgradCrusherL, &xgradCrusherLa,
                        &xgradCrusherLd, pw_xgradCrusherL, pw_xgradCrusherLa, pw_xgradCrusherLd,
                        ia_xgradCrusherL, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_xgradCrusherL+pw_xgradCrusherLd)-pw_xgradCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradCrusherR, "xgradCrusherR", &xgradCrusherR, &xgradCrusherRa,
                        &xgradCrusherRd, pw_xgradCrusherR, pw_xgradCrusherRa, pw_xgradCrusherRd,
                        ia_xgradCrusherR, 0, 0, 0, 0, pend(&gzrf2,"gzrf2",0)+pw_xgradCrusherRa-pw_xgradCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradCrusherL, "ygradCrusherL", &ygradCrusherL, &ygradCrusherLa,
                        &ygradCrusherLd, pw_ygradCrusherL, pw_ygradCrusherLa, pw_ygradCrusherLd,
                        ia_ygradCrusherL, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_ygradCrusherL+pw_ygradCrusherLd)-pw_ygradCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradCrusherR, "ygradCrusherR", &ygradCrusherR, &ygradCrusherRa,
                        &ygradCrusherRd, pw_ygradCrusherR, pw_ygradCrusherRa, pw_ygradCrusherRd,
                        ia_ygradCrusherR, 0, 0, 0, 0, pend(&gzrf2,"gzrf2",0)+pw_ygradCrusherRa-pw_ygradCrusherRa, TRAP_ALL,
                        &loggrd);

            }
        } else {
             
                         
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2leftl1, "gzrf2leftl1", &gzrf2leftl1, &gzrf2leftl1a,
                        &gzrf2leftl1d, pw_gzrf2leftl1, pw_gzrf2leftl1a, pw_gzrf2leftl1d,
                        ia_gzrf2leftl1, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_gzrf2leftl1+pw_gzrf2leftl1d)-pw_gzrf2leftl1a, TRAP_ALL,
                        &loggrd);


              
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2leftr1, "gzrf2leftr1", &gzrf2leftr1, &gzrf2leftr1a,
                        &gzrf2leftr1d, pw_gzrf2leftr1, pw_gzrf2leftr1a, pw_gzrf2leftr1d,
                        ia_gzrf2leftr1, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2leftd",0)-pw_gzrf2leftr1a, TRAP_ALL,
                        &loggrd);


             
                        
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2rightl1, "gzrf2rightl1", &gzrf2rightl1, &gzrf2rightl1a,
                        &gzrf2rightl1d, pw_gzrf2rightl1, pw_gzrf2rightl1a, pw_gzrf2rightl1d,
                        ia_gzrf2rightl1, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_gzrf2rightl1+pw_gzrf2rightl1d)-pw_gzrf2rightl1a, TRAP_ALL,
                        &loggrd);


              
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2rightr1, "gzrf2rightr1", &gzrf2rightr1, &gzrf2rightr1a,
                        &gzrf2rightr1d, pw_gzrf2rightr1, pw_gzrf2rightr1a, pw_gzrf2rightr1d,
                        ia_gzrf2rightr1, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2rightd",0)-pw_gzrf2rightr1a, TRAP_ALL,
                        &loggrd);


            /* MRIhc05227 */
            /* Create Crushers on Left and Right 180s for X & Y axes */ 
            if( PSD_ON == xygradRightCrusherFlag ) { 
                  
                            
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradRightCrusherL, "xgradRightCrusherL", &xgradRightCrusherL, &xgradRightCrusherLa,
                        &xgradRightCrusherLd, pw_xgradRightCrusherL, pw_xgradRightCrusherLa, pw_xgradRightCrusherLd,
                        ia_xgradRightCrusherL, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_xgradRightCrusherL+pw_xgradRightCrusherLd)-pw_xgradRightCrusherLa, TRAP_ALL,
                        &loggrd);


                  
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradRightCrusherR, "xgradRightCrusherR", &xgradRightCrusherR, &xgradRightCrusherRa,
                        &xgradRightCrusherRd, pw_xgradRightCrusherR, pw_xgradRightCrusherRa, pw_xgradRightCrusherRd,
                        ia_xgradRightCrusherR, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2right",0)+pw_xgradRightCrusherRa-pw_xgradRightCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradRightCrusherL, "ygradRightCrusherL", &ygradRightCrusherL, &ygradRightCrusherLa,
                        &ygradRightCrusherLd, pw_ygradRightCrusherL, pw_ygradRightCrusherLa, pw_ygradRightCrusherLd,
                        ia_ygradRightCrusherL, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_ygradRightCrusherL+pw_ygradRightCrusherLd)-pw_ygradRightCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradRightCrusherR, "ygradRightCrusherR", &ygradRightCrusherR, &ygradRightCrusherRa,
                        &ygradRightCrusherRd, pw_ygradRightCrusherR, pw_ygradRightCrusherRa, pw_ygradRightCrusherRd,
                        ia_ygradRightCrusherR, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2right",0)+pw_ygradRightCrusherRa-pw_ygradRightCrusherRa, TRAP_ALL,
                        &loggrd);

            }
            if( PSD_ON == xygradLeftCrusherFlag ) {
                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradLeftCrusherL, "xgradLeftCrusherL", &xgradLeftCrusherL, &xgradLeftCrusherLa,
                        &xgradLeftCrusherLd, pw_xgradLeftCrusherL, pw_xgradLeftCrusherLa, pw_xgradLeftCrusherLd,
                        ia_xgradLeftCrusherL, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_xgradLeftCrusherL+pw_xgradLeftCrusherLd)-pw_xgradLeftCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradLeftCrusherR, "xgradLeftCrusherR", &xgradLeftCrusherR, &xgradLeftCrusherRa,
                        &xgradLeftCrusherRd, pw_xgradLeftCrusherR, pw_xgradLeftCrusherRa, pw_xgradLeftCrusherRd,
                        ia_xgradLeftCrusherR, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2left",0)+pw_xgradLeftCrusherRa-pw_xgradLeftCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradLeftCrusherL, "ygradLeftCrusherL", &ygradLeftCrusherL, &ygradLeftCrusherLa,
                        &ygradLeftCrusherLd, pw_ygradLeftCrusherL, pw_ygradLeftCrusherLa, pw_ygradLeftCrusherLd,
                        ia_ygradLeftCrusherL, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_ygradLeftCrusherL+pw_ygradLeftCrusherLd)-pw_ygradLeftCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradLeftCrusherR, "ygradLeftCrusherR", &ygradLeftCrusherR, &ygradLeftCrusherRa,
                        &ygradLeftCrusherRd, pw_ygradLeftCrusherR, pw_ygradLeftCrusherRa, pw_ygradLeftCrusherRd,
                        ia_ygradLeftCrusherR, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2left",0)+pw_ygradLeftCrusherRa-pw_ygradLeftCrusherRa, TRAP_ALL,
                        &loggrd);

            }
        }   
    } /* end PSD_SE check */

    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/
  
    /* For now assume a simple retiling. */
    if (fract_ky == PSD_FRACT_KY) {
	echoOffset  = num_overscan/intleaves;
    } else {
	if (ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP)
            echoOffset  = fullk_nframes/intleaves/2;
	else
            echoOffset  = 0;
    }
  
    if (rampsamp == PSD_ON) {  /* Ramp sampling on CERD, HOUP */
        if ( mux_flag == PSD_ON && use_slice_fov_shift_blips == PSD_ON ) {
            dacq_offset  = _dacq_offset.fixedflag ?           
                                                     ((void)(pkt_delay+pw_gxwad-(int)IMax(2,(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5),(int)(fbhw*((float)pw_gzb/2.0+(float)pw_gzbd)+0.5))), dacq_offset) : pkt_delay+pw_gxwad-(int)IMax(2,(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5),(int)(fbhw*((float)pw_gzb/2.0+(float)pw_gzbd)+0.5));
        } else {
            dacq_offset  = _dacq_offset.fixedflag ?       
                                                               ((void)(pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5)), dacq_offset) : pkt_delay+pw_gxwad-(int)(fbhw*((float)pw_gyb/2.0+(float)pw_gybd)+0.5);
        }
    } else {
        dacq_offset  = _dacq_offset.fixedflag ?  ((void)(pkt_delay), dacq_offset) : pkt_delay;
    }

    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == fullk_nframes)
    {
        tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte -
                              pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    }
    else
    {
        tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte -
                              echoOffset * esp - ky_offset*esp/intleaves));
    }

    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;
  
    if(iref_etl > 0)
    {
        if(rtb0_flag && dpc_flag)
        {   
            tempiref = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+
                       rtb0_acq_delay+esp+pw_gxiref1_tot;
        }
        else
        {
            tempiref = pendall(&rf1, 0) + IMax(3, pw_gz1_tot, rfupd+4  +pw_gxiref1_tot, pw_gyex1_tot);
        }
        tempiref = RUP_GRD(tempiref);
    }

    /* MRIge89403: added one more argument for EPI internal ref
     * but set it to 0 */
    /* EP_TRAIN */
    /* internref: use tot_etl instead of etl; added iref_etl */
      
             
             
             
             
             
                 
               
             
             
             
             
             
             
                     
    {
      int psd_gxwcnt;
      int psd_pulsepos;
      int psd_eparity;
      long psd_epxtroff;
      long psd_epdaboff;
      float psd_etbetax;
      float psd_etbetay;
      float psd_etbetaz;
      char psd_epstring[EPSTRING_LENGTH];

      if( (iref_etl > 0) && ((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS) != DEFAULTPOS) )
      {
          psd_pulsepos = RUP_GRD((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS));
      }
      else
      {
      psd_pulsepos = RUP_GRD((LONG)tempx+pw_gxwad);
      }
      if( (iref_etl == 0) || ((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS) != DEFAULTPOS) ){
          pw_iref_gxwait  = _pw_iref_gxwait.fixedflag ?  ((void)(0), pw_iref_gxwait) : 0;
      }
      /* allocate on 1st pass only  */
      if ( 0 == 0 ) {
          echotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
      }

      pulsename(&gxcla, "gxcla");
      pulsename(&gxcl, "gxcl");
      pulsename(&gxcld, "gxcld");
 
      pulsename(&gxwa, "gxwa");
      pulsename(&gxw, "gxw");
      pulsename(&gxwd, "gxwd");
      pulsename(&gxwde, "gxwde");
 
      pulsename(&gxgap, "gxgap");
 
      pulsename(&gyba, "gyba");
      pulsename(&gyb, "gyb");
      pulsename(&gybd, "gybd");
 
      if (1)
      {
          pulsename(&gzba, "gzba");
          pulsename(&gzb, "gzb");
          pulsename(&gzbd, "gzbd");
      }
 
      pulsename(&gxcra, "gxcra");
      pulsename(&gxcr, "gxcr");
      pulsename(&gxcrd, "gxcrd");
 
      getbeta(&psd_etbetax, XGRAD, &epiloggrd);
      getbeta(&psd_etbetay, YGRAD, &epiloggrd);
      if (1)
      {
          getbeta(&psd_etbetaz, ZGRAD, &epiloggrd);
      }
 
      if (pw_gxcla >= GRAD_UPDATE_TIME) 
      {
          createramp(&gxcla, XGRAD, pw_gxcla, (short)0, (short)ia_gxcl, 
                      (short)(maxGradRes*(pw_gxcla/GRAD_UPDATE_TIME)), psd_etbetax);
          createinstr(&gxcla, (long)psd_pulsepos, pw_gxcla, max_pg_iamp);
          psd_pulsepos += pw_gxcla;
      }
    
      if (pw_gxcl >= GRAD_UPDATE_TIME) 
      {
          createconst(&gxcl, XGRAD, pw_gxcl, max_pg_wamp);
          createinstr(&gxcl, (long)psd_pulsepos, pw_gxcl, ia_gxcl);
          psd_pulsepos += pw_gxcl;
      }
    
      if (pw_gxcld >= GRAD_UPDATE_TIME) 
      {
          createramp(&gxcld, XGRAD, pw_gxcld, (short)ia_gxcl, (short)ia_gxw, 
                     (short)(maxGradRes*(pw_gxcld/GRAD_UPDATE_TIME)), psd_etbetax);
          createinstr(&gxcld, (long)psd_pulsepos, pw_gxcld, max_pg_iamp);
          psd_pulsepos += pw_gxcld;
      }
    
      createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
      createinstr(&gxw, (long)psd_pulsepos, pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
      psd_pulsepos += pw_gxwl;
    
      sprintf(psd_epstring, "echo%04d", 0);
      pulsename(&(echotrain[0]), psd_epstring);
    
      if (dab_offset == 0)
          psd_epdaboff = 0;
      else
          psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
     
      if (xtr_offset == 0)
          psd_epxtroff = 0;
      else
          psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
    
      epiacqq(&(echotrain[0]),
          (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
          psd_epdaboff, psd_epxtroff,
          (long)scanslot,
          (TYPDAB_PACKETS)DABNORM,
          (long)fast_rec,
          (long)hsdab>0?0:1);
    
      psd_pulsepos += pw_gxw + pw_gxwr;
    
      psd_eparity = 1;
      for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) 
      {
          psd_eparity *= -1;
          if( psd_gxwcnt - 1 > iref_etl )
          {
              createramp(&gyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                         (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
              createinstr(&gyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                         (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);

      if (pw_gyb >= GRAD_UPDATE_TIME) {
        createconst(&gyb, YGRAD, pw_gyb, max_pg_wamp);
        createinstr(&gyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                        pw_gyb/2), pw_gyb, ia_gyb);
      }

      createramp(&gybd, YGRAD, pw_gybd, max_pg_wamp, 0,
             (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
      createinstr(&gybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                       pw_gyb/2), pw_gybd, ia_gyb);

      linkpulses(3,&gyb,&gyba,&gybd);

      /* Make Z blip */
      if (1)
      {
          if ((pw_gzba + pw_gzb + pw_gzbd) > 0) {
              createramp(&gzba, ZGRAD, pw_gzba, 0, max_pg_wamp,
                         (short)((maxGradRes*pw_gzba)/GRAD_UPDATE_TIME), psd_etbetaz);
              createinstr(&gzba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                               (pw_gzba + pw_gzb/2)), pw_gzba, ia_gzb);

              if (pw_gzb >= GRAD_UPDATE_TIME) {
                  createconst(&gzb, ZGRAD, pw_gzb, max_pg_wamp);
                  createinstr(&gzb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                                  pw_gzb/2), pw_gzb, ia_gzb);
              }

              createramp(&gzbd, ZGRAD, pw_gzbd, max_pg_wamp, 0,
                         (short)((maxGradRes*pw_gzbd)/GRAD_UPDATE_TIME), psd_etbetaz);
              createinstr(&gzbd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                                               pw_gzb/2), pw_gzbd, ia_gzb);

              linkpulses(3,&gzb,&gzba,&gzbd);
          }
      }
    }

    createramp(&gxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME),
           psd_etbetax);
    createinstr(&gxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
    psd_pulsepos += pw_gxwad;


    if( (iref_etl > 0) && (psd_gxwcnt == iref_etl+1) && (DEFAULTPOS != (iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS)) ){
        psd_pulsepos = (LONG)tempx+pw_gxwad - pw_gxwad;
    }
    else if( pw_gxgap == 0 ){
      if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){
        createconst(&gxgap, XGRAD, pw_iref_gxwait, 0);
        createinstr(&gxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
        psd_pulsepos += pw_iref_gxwait;
      }
    }else{
      int gapgap;
      if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
        gapgap = pw_gxgap;
      }else{
        gapgap = pw_gxgap+pw_iref_gxwait;
      }
      createconst(&gxgap, XGRAD, gapgap, 0);
      createinstr(&gxgap, (long)psd_pulsepos, gapgap, 0);
      psd_pulsepos += gapgap;
    }

    createramp(&gxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
    createinstr(&gxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
    psd_pulsepos += pw_gxwad;

    createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
    createinstr(&gxw, (long)psd_pulsepos,
            pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
    psd_pulsepos += pw_gxwl;
        
    sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
    pulsename(&(echotrain[psd_gxwcnt-1+0]), psd_epstring);
        
    if (dab_offset == 0)
      psd_epdaboff = 0;
    else
      psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
    if (xtr_offset == 0)
      psd_epxtroff = 0;
    else
      psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
            
    epiacqq(&(echotrain[psd_gxwcnt-1+0]),
        (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
        psd_epdaboff, psd_epxtroff,
        (long)scanslot,
        (TYPDAB_PACKETS)DABNORM,
        (long)fast_rec,
        (long)hsdab>0?0:1);
        
    psd_pulsepos += pw_gxw + pw_gxwr;
      }
      if ((tot_etl % 2) == 1) {    /* views per shot is odd */
    if (pw_gxcra >= GRAD_UPDATE_TIME) {
      createramp(&gxcra, XGRAD, pw_gxcra, (short)ia_gxw,
             (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                             GRAD_UPDATE_TIME)), psd_etbetax);
      createinstr(&gxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
      psd_pulsepos += pw_gxcra;
    }
      } else { /* views per shot is even */
    /* single transition ramp into crusher */
    if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
      createramp(&gxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
             (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME),
             psd_etbetax);
      createinstr(&gxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
      psd_pulsepos += 2*pw_gxwad;
    } else {    /* two separate ramps, decay ramp needs new waveform */
      createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
             (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
      createinstr(&gxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
      psd_pulsepos += pw_gxwad;

      if (pw_gxcra >= GRAD_UPDATE_TIME) {
        createramp(&gxcra, XGRAD, pw_gxcra, (short)0,
               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                               GRAD_UPDATE_TIME)),psd_etbetax);
        createinstr(&gxcra, (long)(psd_pulsepos),pw_gxcra, max_pg_iamp);
        psd_pulsepos += pw_gxcra;
      }
    }
      }
      if (pw_gxcr >= GRAD_UPDATE_TIME) {
    createconst(&gxcr, XGRAD, pw_gxcr, max_pg_wamp);
    createinstr(&gxcr, (long)psd_pulsepos,pw_gxcr, ia_gxcr);
    psd_pulsepos += pw_gxcr;
      }

      if (pw_gxcrd >= GRAD_UPDATE_TIME) {
    createramp(&gxcrd, XGRAD, pw_gxcrd, (short)ia_gxcr,
           (short)0, (short)(maxGradRes*(pw_gxcrd/
                         GRAD_UPDATE_TIME)), psd_etbetax);
    createinstr(&gxcrd, (long)psd_pulsepos,pw_gxcrd, max_pg_iamp);
    psd_pulsepos += pw_gxcrd;
      }
    }


    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    /*  rec_unblank_pack[2] = SSPD+RUBL;*/
    getssppulse(&(echotrainxtr[0]), &(echotrain[0]), "xtr", 0);
    rcvrunblankpos = echotrainxtr[0]->inst_hdr_tail->start;
    rcvrunblankpos += rcvr_ub_off;
     
  {
    rec_unblank_pack[0] = SSPDS+RDC;
    rec_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank_pack[2] = SSPD+RUBL;
    rec_unblank_pack[3] = SSPDS;

    pulsename(&rec_unblank,"rec_unblank");
    createbits(&rec_unblank,TYPSSP,4,rec_unblank_pack);
    createinstr( &rec_unblank,(long)(rcvrunblankpos),4,ia_rec_unblank);
  }

    if(iref_etl>0)
    {
        getssppulse(&(echotrainxtr[iref_etl]), &(echotrain[iref_etl]), "xtr", 0);
        rcvrunblankpos = echotrainxtr[iref_etl]->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank3_pack[0] = SSPDS+RDC;
    rec_unblank3_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank3_pack[2] = SSPD+RUBL;
    rec_unblank3_pack[3] = SSPDS;

    pulsename(&rec_unblank3,"rec_unblank3");
    createbits(&rec_unblank3,TYPSSP,4,rec_unblank3_pack);
    createinstr( &rec_unblank3,(long)(rcvrunblankpos),4,ia_rec_unblank3);
  }

    }

    if (tot_etl % 2 == 1) {
        getbeta(&betax, XGRAD, &epiloggrd);
        pulsePos = pend(&gxw, "gxw", tot_etl-1);
        createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
        createinstr(&gxwde, (LONG)pulsePos, pw_gxwad, -ia_gxw-ia_gx_dwi);
        pulsePos += pw_gxwad;
    }

    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
  
    if (gx1pos == PSD_POST_180)
        temp1 = RUP_GRD((int)(pbeg(&gxw,"gxw",iref_etl) - (pw_gxwad + pw_gx1a +
            pw_gx1 + pw_gx1d)));
    else
        temp1 = RUP_GRD((int)(pend(&gzrf1,"gzrf1",0) + pw_gx1a + pw_wgx + rfupd));

    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;

    pulsename(&gx1a,"gx1a");
    createramp(&gx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/
                                               GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&gx1a, (LONG)temp1, pw_gx1a, ia_gx1);

    if (pw_gx1 >= GRAD_UPDATE_TIME) {
        pulsename(&gx1,"gx1");
        createconst(&gx1,XGRAD,pw_gx1,max_pg_wamp);
        createinstr( &gx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }

    pulsename(&gx1d, "gx1d");
    if (single_ramp_gx1d == PSD_ON) {   /* Single ramp for gx1 decay into gxw
                                           attack */
        createramp(&gx1d, XGRAD, pw_gxwad, max_pg_wamp, -max_pg_wamp,
                   (short)(maxGradRes*(2*pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        createinstr(&gx1d, (LONG)(temp1+pw_gx1a+pw_gx1), 2*pw_gxwad, ia_gx1);
    } else {                     /* decay ramp for gx1 */
        createramp(&gx1d,XGRAD,pw_gx1d,max_pg_wamp,
                   (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                     pw_gx1d,ia_gx1);

        pulsename(&gxwa, "gxwa");  /* attack ramp for epi train */
        createramp(&gxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
                   (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        if(iref_etl > 0)
        {
            tempx = tempiref;
        }
        if ( tot_etl%2 == 0 )
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, -ia_gxw-ia_gx_dwi);
        else
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, ia_gxw-ia_gx_dwi);
    }

    /*RTB0 correction*/
    if(rtb0_flag)
    {
        temp2 = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+rtb0_acq_delay;
            
  {
    pulsename(&rtb0echo,"rtb0echo");
    acqq(&rtb0echo, (long)(temp2),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rtb0echo,
        (TYPDAB_PACKETS)DABNORM);
  }

        attenflagon( &(rtb0echo), 0 );

        getssppulse(&(rtb0echoxtr), &(rtb0echo), "xtr", 0);
        rcvrunblankpos = rtb0echoxtr->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank2_pack[0] = SSPDS+RDC;
    rec_unblank2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank2_pack[2] = SSPD+RUBL;
    rec_unblank2_pack[3] = SSPDS;

    pulsename(&rec_unblank2,"rec_unblank2");
    createbits(&rec_unblank2,TYPSSP,4,rec_unblank2_pack);
    createinstr( &rec_unblank2,(long)(rcvrunblankpos),4,ia_rec_unblank2);
  }


        temp2 += esp;
    }

    /* Hyperscan and diff DAB packet */
    if (hsdab > 0) {
        if (rtb0_flag == PSD_OFF)
        {
            temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        }

        if(hsdab == 1)
	         
{
    pulsename(&hyperdab,"hyperdab");

        createhsdab(&hyperdab, (long)(temp2));
  }

        else
             
{
    pulsename(&diffdab,"diffdab");

    creatediffdab(&diffdab, (long)(temp2));
}

    }  

    if(iref_etl > 0)
    {
             

  trapezoid((WF_PROCESSOR)wg_gxiref1, "gxiref1", &gxiref1, &gxiref1a,
                        &gxiref1d, pw_gxiref1, pw_gxiref1a, pw_gxiref1d,
                        ia_gxiref1, 0, 0, 0, 0, tempiref-pw_gxiref1_tot+pw_gxiref1a-pw_gxiref1a, TRAP_ALL,
                        &loggrd);
    
             

  trapezoid((WF_PROCESSOR)wg_gxirefr, "gxirefr", &gxirefr, &gxirefra,
                        &gxirefrd, pw_gxirefr, pw_gxirefra, pw_gxirefrd,
                        ia_gxirefr, 0, 0, 0, 0, tempiref+pw_gxiref_tot+pw_gxirefra-pw_gxirefra, TRAP_ALL,
                        &loggrd);

    }

    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity();

    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */
 
    if (oppseq == PSD_SE) {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            temp2 = pendall(&rf2, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        } else {
            temp2 = pendall(&rf2right, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        }
    } else {
        temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }

    /* Y prephaser ************************************************************/
    if (gy1pos == PSD_POST_180) {
	temp1 = pbeg(&gxw, "gxw", iref_etl) - pw_gxwad - pw_gy1_tot;
	temp1 = RDN_GRD(temp1);
    } else {
	temp1 = RDN_GRD(pend(&rf1,"rf1",0) + rfupd);
    }

        
    trapezoid((WF_PROCESSOR)wg_gy1,"gy1",
              &gy1,&gy1a,&gy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED,
                          &loggrd);


    if (ygmn_type == CALC_GMN1) {
        temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2 - pw_gymn2d;
             

  trapezoid((WF_PROCESSOR)wg_gymn2, "gymn2", &gymn2, &gymn2a,
                        &gymn2d, pw_gymn2, pw_gymn2a, pw_gymn2d,
                        ia_gymn2, 0, 0, 0, 0, temp1-pw_gymn2a, TRAP_ALL,
                        &loggrd);

        temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2_tot - pw_gymn1 - pw_gymn1d;
             

  trapezoid((WF_PROCESSOR)wg_gymn1, "gymn1", &gymn1, &gymn1a,
                        &gymn1d, pw_gymn1, pw_gymn1a, pw_gymn1d,
                        ia_gymn1, 0, 0, 0, 0, temp1-pw_gymn1a, TRAP_ALL,
                        &loggrd);

    }

    /* Z prephaser ************************************************************/
    if (oppseq != PSD_SE || zgmn_type == CALC_GMN1 || rtb0_flag || dpc_flag || ((oppseq == PSD_SE) && mux_flag && (use_slice_fov_shift_blips) && (mux_slices_rf1>1)) ) {
        if(ss_rf1 == PSD_ON)
        {
#if defined(IPG_TGT) || defined(MGD_TGT)
            temp1 = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gz1a);
#elif defined(HOST_TGT)
            temp1 = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gz1a);
#endif
        }
        else
        {
            temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a);
        }
	      

  trapezoid((WF_PROCESSOR)wg_gz1, "gz1", &gz1, &gz1a,
                        &gz1d, pw_gz1, pw_gz1a, pw_gz1d,
                        ia_gz1, 0, 0, 0, 0, temp1-pw_gz1a, TRAP_ALL,
                        &loggrd);

	if (zgmn_type == CALC_GMN1) {
            temp1 += (pw_gz1 + pw_gz1d + pw_gzmna);
                  

  trapezoid((WF_PROCESSOR)wg_gzmn, "gzmn", &gzmn, &gzmna,
                        &gzmnd, pw_gzmn, pw_gzmna, pw_gzmnd,
                        ia_gzmn, 0, 0, 0, 0, temp1-pw_gzmna, TRAP_ALL,
                        &loggrd);
 
	}
    }

    /* Added for Inversion.e */
      
  {
    pulsename(&rf2se1,"rf2se1");
    createreserve(&rf2se1,(WF_PROCESSOR)wg_rf2se1,
		  res_rf2se1);
  }


    /* X diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {
      
        if (PSD_OFF == dualspinecho_flag)
        {
/* maybe granty */
	    res_gxdl  = _res_gxdl.fixedflag ?  ((void)(res_gd1), res_gxdl) : res_gd1;
	    pw_gxdl  = _pw_gxdl.fixedflag ?  ((void)(pw_gd1), pw_gxdl) : pw_gd1;
/* granty end */
            if(xygradCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&xgradCrusherL,"xgradCrusherLa",0)) - pw_gxdl - pw_gxdld - pw_wgxdl);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gxdl - pw_gxdld - pw_wgxdl);
            }
            /* TRAPEZOID(XGRAD, gxdl, tempx, 0, TYPNDEF, loggrd); */ /* maybe grant, daiep */

/* maybe granty */
    	    pulsename(&gxdl,"gxdl");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_x1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_x1.bin",(int)opuser12);
#endif 
	    printf("pg 16497 ia_gxdl = %d\n", ia_gxdl);
	    printf("max_bval = %f\n", max_bval);
	    printf("ide_max_bval = %f\n", ide_max_bval);
            fflush( stdout );
	    
	    if(waveform_type == 3){ /* used to change which pulsed gets used to calculate the b-mat in dti predownload */
            	createextwave(&gxdl,(WF_PROCESSOR)XGRAD,
                           res_gxdl,test_wave_file);
	    	createinstr( &gxdl,(long)tempx,
                           pw_gxdl,ia_gxdl);
	     }



    	    pulsename(&gxiso1,"gxiso1");
            createextwave(&gxiso1,(WF_PROCESSOR)wg_gxdl,
                           res_gxdl,test_wave_file);


    	    pulsename(&gxdlbuff,"gxdlbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif 
            createextwave(&gxdlbuff,(WF_PROCESSOR)wg_gxdl,
                           res_gxdl,test_wave_file);

	    if(waveform_type != 3){ /* used to change which pulsed gets used to calculate the b-mat in dti predownload */
            	createextwave(&gxdl,(WF_PROCESSOR)XGRAD,
                           res_gxdl,test_wave_file);
	    	createinstr( &gxdl,(long)tempx,
                           pw_gxdl,ia_gxdl);
	     }
/* granty end */
#if defined(HOST_TGT)
            /* setiamptiter(xamp_iters, cur_num_iters, &gxdl, 0, 1);*/ /* maybe granty, daiep*/
			setiampiter(xamp_iters, cur_num_iters, &gxdl, 0, 1);
#endif
/* maybe granty */
	    res_gxdr  = _res_gxdr.fixedflag ?  ((void)(res_gd2), res_gxdr) : res_gd2;
	    pw_gxdr  = _pw_gxdr.fixedflag ?  ((void)(pw_gd2), pw_gxdr) : pw_gd2;
/* granty end */
            if(xygradCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&xgradCrusherR,"xgradCrusherRd",0)) + pw_gxdra + pw_wgxdr);
            } else {
                tempx = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gxdra + pw_wgxdr);
            }
            /* TRAPEZOID(XGRAD, gxdr, tempx, 0, TYPNDEF, loggrd); */ /* maybe granty, daiep */
/* maybe granty */
    	    pulsename(&gxdr,"gxdr");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_x2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_x2.bin",(int)opuser12);
#endif 

	    if(waveform_type == 3){
            	createextwave(&gxdr,(WF_PROCESSOR)XGRAD,
                           res_gxdr,test_wave_file);
            	createinstr( &gxdr,(long)tempx,
                           pw_gxdr,ia_gxdr);
	    }

    	    pulsename(&gxiso2,"gxiso2");
            createextwave(&gxiso2,(WF_PROCESSOR)wg_gxdr,
                           res_gxdr,test_wave_file);

    	    pulsename(&gxdlbuff,"gxdrbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif
 
            createextwave(&gxdrbuff,(WF_PROCESSOR)wg_gxdr,
                           res_gxdr,test_wave_file);

	    if(waveform_type != 3){
            	createextwave(&gxdr,(WF_PROCESSOR)XGRAD,
                           res_gxdr,test_wave_file);
            	createinstr( &gxdr,(long)tempx,
                           pw_gxdr,ia_gxdr);
	    }
 /* granty end */
#if defined(HOST_TGT)
            /* setiamptiter(xamp_iters, cur_num_iters, &gxdr, 0, 1);*/ /* maybe granty, daiep*/
			setiampiter(xamp_iters, cur_num_iters, &gxdr, 0, 1);
#endif

        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gxdl1 - pw_gxdl1d - pw_wgxdl1);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                                pw_gxdl1 - pw_gxdl1d - pw_wgxdl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempx = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gxdl1a +pw_wgxdl1);
#elif defined(HOST_TGT)
        tempx = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
#endif
    }
    else if (rfov_flag)
    {
        tempx = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
    }
    else
    {
        tempx = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
    }
}

                 

  trapezoid((WF_PROCESSOR)wg_gxdl1, "gxdl1", &gxdl1, &gxdl1a,
                        &gxdl1d, pw_gxdl1, pw_gxdl1a, pw_gxdl1d,
                        ia_gxdl1, 0, 0, 0, 0, tempx-pw_gxdl1a, TRAP_ALL,
                        &loggrd);

         
#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gxdr1a + pw_wgxdr1);
            } else {
                tempx = RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                                pw_gxdr1a + pw_wgxdr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdr1, "gxdr1", &gxdr1, &gxdr1a,
                        &gxdr1d, pw_gxdr1, pw_gxdr1a, pw_gxdr1d,
                        ia_gxdr1, 0, 0, 0, 0, tempx-pw_gxdr1a, TRAP_ALL,
                        &loggrd);

         
#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) { 
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gxdl2 - pw_gxdl2d - pw_wgxdl2);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gxdl2 - pw_gxdl2d - pw_wgxdl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdl2, "gxdl2", &gxdl2, &gxdl2a,
                        &gxdl2d, pw_gxdl2, pw_gxdl2a, pw_gxdl2d,
                        ia_gxdl2, 0, 0, 0, 0, tempx-pw_gxdl2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gxdr2a + pw_wgxdr2);
            } else {
                tempx = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gxdr2a + pw_wgxdr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdr2, "gxdr2", &gxdr2, &gxdr2a,
                        &gxdr2d, pw_gxdr2, pw_gxdr2a, pw_gxdr2d,
                        ia_gxdr2, 0, 0, 0, 0, tempx-pw_gxdr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdr2, 0, -1);
#endif

        }
    }

    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
	tempx = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gxka);
	     

  trapezoid((WF_PROCESSOR)wg_gxk, "gxk", &gxk, &gxka,
                        &gxkd, pw_gxk, pw_gxka, pw_gxkd,
                        ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                        &loggrd);

    }
  
    /* Y diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
/* maybe granty */
	    res_gydl  = _res_gydl.fixedflag ?  ((void)(res_gd1), res_gydl) : res_gd1;
	    pw_gydl  = _pw_gydl.fixedflag ?  ((void)(pw_gd1), pw_gydl) : pw_gd1;
/* granty end */
            if(xygradCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&ygradCrusherL,"ygradCrusherLa",0)) - pw_gydl - pw_gydld - pw_wgydl);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gydl - pw_gydld - pw_wgydl);
            }
            /* TRAPEZOID(YGRAD, gydl, tempy, 0, TYPNDEF, loggrd); */ /* maybe granty, daiep */
/* maybe granty */
    	    pulsename(&gydl,"gydl");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_y1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_y1.bin",(int)opuser12);
#endif
	    if(waveform_type == 3){
            	createextwave(&gydl,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);
            	createinstr( &gydl,(long)tempy,
                           pw_gydl,ia_gydl);
	    }

    	    pulsename(&gyiso1,"gyiso1");
            createextwave(&gyiso1,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);

    	    pulsename(&gydlbuff,"gydlbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif
            createextwave(&gydlbuff,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);

	    if(waveform_type != 3){
            	createextwave(&gydl,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);
            	createinstr( &gydl,(long)tempy,
                           pw_gydl,ia_gydl);
	    }
/* granty end */         
#if defined(HOST_TGT)
            /* setiamptiter(yamp_iters, cur_num_iters, &gydl, 0, 1); */ /* maybe granty, daiep */
			setiampiter(yamp_iters, cur_num_iters, &gydl, 0, 1);
#endif
/* maybe granty */
	    res_gydr  = _res_gydr.fixedflag ?  ((void)(res_gd2), res_gydr) : res_gd2;
	    pw_gydr  = _pw_gydr.fixedflag ?  ((void)(pw_gd2), pw_gydr) : pw_gd2;
/* granty end */
            if(xygradCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&ygradCrusherR,"ygradCrusherRd",0)) + pw_gydra + pw_wgydr);
            } else {
                tempy = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gydra + pw_wgydr);
            }
            /* TRAPEZOID(YGRAD, gydr, tempy, 0, TYPNDEF, loggrd); */ /* maybe granty, daiep */
/* granty edit custom pulse */



    	    pulsename(&gydr,"gydr");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_y2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_y2.bin",(int)opuser12);
#endif

	    if( waveform_type == 3){
            	createextwave(&gydr,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);
            	createinstr( &gydr,(long)tempy,
                           pw_gydr,ia_gydr);
	    }

    	    pulsename(&gyiso2,"gyiso2");
            createextwave(&gyiso2,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);

    	    pulsename(&gydrbuff,"gydrbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif 
            createextwave(&gydrbuff,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);

	    if( waveform_type != 3){
            	createextwave(&gydr,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);
            	createinstr( &gydr,(long)tempy,
                           pw_gydr,ia_gydr);
	    }

#if defined(HOST_TGT)
            /* setiamptiter(yamp_iters, cur_num_iters, &gydr, 0, 1); */ /* maybe granty, daiep */
			setiampiter(yamp_iters, cur_num_iters, &gydr, 0, 1);
#endif

        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gydl1 - pw_gydl1d - pw_wgydl1);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                                pw_gydl1 - pw_gydl1d - pw_wgydl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempy = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gydl1a + pw_wgydl1);
#elif defined(HOST_TGT)
        tempy = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gydl1a + pw_wgydl1);
#endif
    }
    else if (rfov_flag)
    {
        tempy = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gydl1a + pw_wgydl1);
    }    
    else
    {
        tempy = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gydl1a +pw_wgydl1);
    }
}

                 

  trapezoid((WF_PROCESSOR)wg_gydl1, "gydl1", &gydl1, &gydl1a,
                        &gydl1d, pw_gydl1, pw_gydl1a, pw_gydl1d,
                        ia_gydl1, 0, 0, 0, 0, tempy-pw_gydl1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gydr1a + pw_wgydr1);
            } else {
                tempy = RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                                pw_gydr1a + pw_wgydr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydr1, "gydr1", &gydr1, &gydr1a,
                        &gydr1d, pw_gydr1, pw_gydr1a, pw_gydr1d,
                        ia_gydr1, 0, 0, 0, 0, tempy-pw_gydr1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gydl2 - pw_gydl2d - pw_wgydl2);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gydl2 - pw_gydl2d - pw_wgydl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydl2, "gydl2", &gydl2, &gydl2a,
                        &gydl2d, pw_gydl2, pw_gydl2a, pw_gydl2d,
                        ia_gydl2, 0, 0, 0, 0, tempy-pw_gydl2a, TRAP_ALL,
                        &loggrd);

       
#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gydr2a + pw_wgydr2);
            } else {
                tempy = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gydr2a + pw_wgydr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydr2, "gydr2", &gydr2, &gydr2a,
                        &gydr2d, pw_gydr2, pw_gydr2a, pw_gydr2d,
                        ia_gydr2, 0, 0, 0, 0, tempy-pw_gydr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydr2, 0, -1);
#endif
        }
    }

    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
	tempy = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gyka);
	     

  trapezoid((WF_PROCESSOR)wg_gyk, "gyk", &gyk, &gyka,
                        &gykd, pw_gyk, pw_gyka, pw_gykd,
                        ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                        &loggrd);

    }
  
    /* Z diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
/* maybe granty */
	    res_gzdl  = _res_gzdl.fixedflag ?  ((void)(res_gd1), res_gzdl) : res_gd1;
	    pw_gzdl  = _pw_gzdl.fixedflag ?  ((void)(pw_gd1), pw_gzdl) : pw_gd1;
/* granty end */
            if(xygradCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&xgradCrusherL,"xgradCrusherLa",0)) - pw_gzdl - pw_gzdld - pw_wgzdl);
            } else {
                tempz = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gzdl - pw_gzdld - pw_wgzdl);
            }
            /* TRAPEZOID(ZGRAD, gzdl, tempz, 0, TYPNDEF, loggrd);*/ /* maybe granty, daiep */
/* granty edit custom pulse */

    	    pulsename(&gzdl,"gzdl");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_z1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_z1.bin",(int)opuser12);
#endif 

	    if( waveform_type == 3){
            	createextwave(&gzdl,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

            	createinstr( &gzdl,(long)tempz,
                           pw_gzdl,ia_gzdl);
	    }

    	    pulsename(&gziso1,"gziso1");
            createextwave(&gziso1,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

    	    pulsename(&gzdlbuff,"gzdlbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif 

            createextwave(&gzdlbuff,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

	    if( waveform_type != 3){
            	createextwave(&gzdl,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

            	createinstr( &gzdl,(long)tempz,
                           pw_gzdl,ia_gzdl);
	    }

#if defined(HOST_TGT)
            /* setiamptiter(zamp_iters, cur_num_iters, &gzdl, 0, 1); */ /*maybe granty, daiep */
			setiampiter(zamp_iters, cur_num_iters, &gzdl, 0, 1);
#endif
/* maybe granty */
	    res_gzdr  = _res_gzdr.fixedflag ?  ((void)(res_gd2), res_gzdr) : res_gd2;
	    pw_gzdr  = _pw_gzdr.fixedflag ?  ((void)(pw_gd2), pw_gzdr) : pw_gd2;
/* granty end */
            if(xygradCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&xgradCrusherR,"xgradCrusherRd",0)) + pw_gzdra + pw_wgzdr);
            } else {
                tempz = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gzdra + pw_wgzdr);
            }
            /* TRAPEZOID(ZGRAD, gzdr, tempz, 0, TYPNDEF, loggrd); */ /* maybe granty, daiep */
/* maybe granty */
    	    pulsename(&gzdr,"gzdr");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_z2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_z2.bin",(int)opuser12);
#endif 

	    if( waveform_type == 3){
	            createextwave(&gzdr,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);
	            createinstr( &gzdr,(long)tempz,
                           pw_gzdr,ia_gzdr);
	    }

    	    pulsename(&gziso2,"gziso2");
            createextwave(&gziso2,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);

    	    pulsename(&gzdrbuff,"gzdrbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif 
            createextwave(&gzdrbuff,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);

	    if( waveform_type != 3){
	            createextwave(&gzdr,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);
	            createinstr( &gzdr,(long)tempz,
                           pw_gzdr,ia_gzdr);
	    }
/* granty end */

#if defined(HOST_TGT)
            /* setiamptiter(zamp_iters, cur_num_iters, &gzdr, 0, 1);*/ /*maybe granty, daiep */
			setiampiter(zamp_iters, cur_num_iters, &gzdr, 0, 1);
#endif

        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gzdl1 - pw_gzdl1d - pw_wgzdl1);
            }
            else {
                tempz=RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                              pw_gzdl1 - pw_gzdl1d - pw_wgzdl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempz = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gzdl1a +pw_wgzdl1);
#elif defined(HOST_TGT)
        tempz = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
#endif
    }
    else if (rfov_flag)
    {
        tempz = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
    }    
    else
    {
        tempz = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
    }
}
                 

  trapezoid((WF_PROCESSOR)wg_gzdl1, "gzdl1", &gzdl1, &gzdl1a,
                        &gzdl1d, pw_gzdl1, pw_gzdl1a, pw_gzdl1d,
                        ia_gzdl1, 0, 0, 0, 0, tempz-pw_gzdl1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gzdr1a + pw_wgzdr1);
            }
            else {
                tempz=RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                              pw_gzdr1a + pw_wgzdr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdr1, "gzdr1", &gzdr1, &gzdr1a,
                        &gzdr1d, pw_gzdr1, pw_gzdr1a, pw_gzdr1d,
                        ia_gzdr1, 0, 0, 0, 0, tempz-pw_gzdr1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gzdl2 - pw_gzdl2d - pw_wgzdl2);
            } else {
                tempz = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gzdl2 - pw_gzdl2d - pw_wgzdl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdl2, "gzdl2", &gzdl2, &gzdl2a,
                        &gzdl2d, pw_gzdl2, pw_gzdl2a, pw_gzdl2d,
                        ia_gzdl2, 0, 0, 0, 0, tempz-pw_gzdl2a, TRAP_ALL,
                        &loggrd);

       
#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gzdr2a + pw_wgzdr2);
            } else {
                tempz = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gzdr2a + pw_wgzdr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdr2, "gzdr2", &gzdr2, &gzdr2a,
                        &gzdr2d, pw_gzdr2, pw_gzdr2a, pw_gzdr2d,
                        ia_gzdr2, 0, 0, 0, 0, tempz-pw_gzdr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdr2, 0, -1);
#endif
        }

    }

    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
        tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
             

  trapezoid((WF_PROCESSOR)wg_gzk, "gzk", &gzk, &gzka,
                        &gzkd, pw_gzk, pw_gzka, pw_gzkd,
                        ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                        &loggrd);

    }

    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a seqeuncer issue.                                          */
    if (eosrhokiller == PSD_ON) {
        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

        tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killer,"rho_killer");
        createconst(&rho_killer,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killer,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }

    /* Major "Wait" Pulses ************************************************/
    /* DTI */
    if (opdiffuse == PSD_ON || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
            tempx = pendall(&gxdr,0);
            tempy = pendall(&gydr,0);
        } else {
            tempx = pendall(&gxdr2,0);
            tempy = pendall(&gydr2,0);
        }	
    } else {
        if (gy1pos == PSD_POST_180)
            tempy = pbeg(&gy1a, "gy1a", 0) - pw_wgy;
        else
            tempy = pbeg(&gyba, "gyba", 0) - pw_wgy;

        if (ygmn_type == CALC_GMN1)
            tempy = pbeg(&gymn1a, "gymn1a", 0) - pw_wgy;

        if (gx1pos == PSD_POST_180)
            tempx = pbeg(&gx1a, "gx1a", 0) - pw_wgx;
        else
            tempx = pbeg(&gxwa, "gxwa", 0) - pw_wgx;
    }

    /* TFON sliding data acq. window wait intervals */
        
  {
    pulsename(&wgx,"wgx");
    createconst(&wgx,(WF_PROCESSOR)wg_wgx,pw_wgx,(short)0); 
    createinstr( &wgx,(long)(tempx),pw_wgx,0);
  }

        
  {
    pulsename(&wgy,"wgy");
    createconst(&wgy,(WF_PROCESSOR)wg_wgy,pw_wgy,(short)0); 
    createinstr( &wgy,(long)(tempy),pw_wgy,0);
  }


    if (oppseq == PSD_SE) {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            tempz = pendall(&gzrf2r1, 0);
        } else {
            tempz = pendall(&gzrf2rightr1, 0);
        }	
    } else {
        if (zgmn_type == CALC_GMN1)
            tempz = pendall(&gzmnd, 0);
        else
            tempz = pendall(&gz1d, 0);
    }

    /* DTI */
    if (opdiffuse == PSD_ON || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
            tempz = pendall(&gzdr,0);
        }
        else {
            tempz = pendall(&gzdr2,0);
        }
    }

       
  {
    pulsename(&wgz,"wgz");
    createconst(&wgz,(WF_PROCESSOR)wg_wgz,pw_wgz,(short)0); 
    createinstr( &wgz,(long)(tempz),pw_wgz,0);
  }


    if (oppseq == PSD_SE)
    {
        if (PSD_OFF == dualspinecho_flag)
        {
            temps = pendall(&rf2, 0) + rfupd + 4  ;
        }
        else
        {
            temps = pendall(&rf2right, 0) + rfupd + 4  ;
        }
    }
    else
    {
        if (hsdab == 2)
            temps = pendall(&rf1, 0) + rfupd + 4   + (int)DIFFDAB_length;
        else
        temps = pendall(&rf1, 0) + rfupd + 4   + (int)HSDAB_length;
    }

    if (mux_flag && verse_rf2)
    {
        temps = temps + 40  ;
    }

       
  {
    pulsename(&wssp,"wssp");
    createconst(&wssp,(WF_PROCESSOR)wg_wssp,pw_wssp,(short)0); 
    createinstr( &wssp,(long)(temps),pw_wssp,0);
  }

    pw_sspdelay  = _pw_sspdelay.fixedflag ?      ((void)(defaultdelay+1), pw_sspdelay) : defaultdelay+1;
         
  {
    pulsename(&sspdelay,"sspdelay");
    createconst(&sspdelay,(WF_PROCESSOR)wg_sspdelay,pw_sspdelay,(short)0); 
    createinstr( &sspdelay,(long)(temps+pw_wssp),pw_sspdelay,0);
  }

    pw_omegadelay  = _pw_omegadelay.fixedflag ?    ((void)(RUP_RF(defaultdelay+2)), pw_omegadelay) : RUP_RF(defaultdelay+2);
        
  {
    pulsename(&omegadelay,"omegadelay");
    createconst(&omegadelay,(WF_PROCESSOR)wg_omegadelay,pw_omegadelay,(short)0); 
    createinstr( &omegadelay,(long)(RUP_GRD(temps)),pw_omegadelay,0);
  }

       
  {
    pulsename(&womega,"womega");
    createconst(&womega,(WF_PROCESSOR)wg_womega,pw_womega,(short)0); 
    createinstr( &womega,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);
  }
 /* ufi2_ypd */

    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attack, "rs_omega_attack");
    pulsename(&rs_omega_decay, "rs_omega_decay");
    pulsename(&omega_flat, "omega_flat");
  
    /* These thress pulses are for receive */
    setrxflag(&rs_omega_attack, 1);
    setrxflag(&rs_omega_decay, 1);
    setrxflag(&omega_flat, 1);
  
    /* internref: use tot_etl instead of etl */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);
      
        {   /* local scope */
          
            int time_offset = 0;
            pulsepos  = _pulsepos.fixedflag ?   ((void)(pendallssp(echotrainrba[echoloop],0)), pulsepos) : pendallssp(echotrainrba[echoloop],0); 
            time_offset = pw_gxwad - dacq_offset;  
          
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0) 
  {
    e1entns_pack[0] = SSPDS+EDC;
    pulsename(&e1entns,"e1entns");
    createbits(&e1entns,TYPSSP,4,e1entns_pack);
    createinstr( &e1entns,(LONG)(pulsepos),4,0);
  }

            if ( echoloop == tot_etl-1)   
  {
    e1distns_pack[0] = SSPDS+EDC;
    pulsename(&e1distns,"e1distns");
    createbits(&e1distns,TYPSSP,4,e1distns_pack);
    createinstr( &e1distns,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
  }

          
            if (vrgfsamp) {
                trapezoid( OMEGA,"omega", &omega_flat, 
                           &rs_omega_attack, &rs_omega_decay,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset+rba_act_start), TRAP_ALL, &loggrd);    
            } else {
              
                /* BJM: to offset frequency, play constant on omega */
                createconst(&omega_flat, OMEGA, pw_gxwl+pw_gxw+pw_gxwr, 
                            max_pg_wamp);
                createinstr(&omega_flat, RUP_RF(pulsepos+rba_act_start),
                            pw_gxwl+pw_gxw+pw_gxwr, ia_omega);            
            }
          
        }
    }
  
    /* 4us for the e1distns pack */
    temps = pendallssp(&echotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 

     
  {
  pulsename(&atten,"atten");
  createatten(&atten, (long)(temps));
}


    /* spring for sspdelay */
         
  {
    pulsename(&sspshift,"sspshift");
    createconst(&sspshift,(WF_PROCESSOR)wg_sspshift,pw_sspshift,(short)0); 
    createinstr( &sspshift,(long)(temps+7  ),pw_sspshift,0);
  }


    temps = pendallssp(&sspshift, 0);

    for (i=0; i<num_passdelay; i++) { 
           
  {
    pulsename(&ssp_pass_delay,"ssp_pass_delay");
    createconst(&ssp_pass_delay,(WF_PROCESSOR)wg_ssp_pass_delay,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delay,(long)(temps),pw_ssp_pass_delay,0);
  }

        temps = pendallssp(&ssp_pass_delay, i);
    }

     
  {
    pulsename(&pass_pulse,"pass_pulse");
    createpass(&pass_pulse,(long)(temps));
  }


    /* Actual deadtimes for cardiac scans will be rewritten later */
    if((opcgate==PSD_ON) || (oprtcgate==PSD_ON))
    {
        psd_seqtime = RUP_GRD(tmin);
    }
    else if(navtrig_flag == PSD_ON)
    {
        psd_seqtime = RUP_GRD(nav_image_interval - time_ssi);
    }
    else
    {
        psd_seqtime = RUP_GRD(avail_se_time/(mux_flag?mux_slquant:false_slquant1) - time_ssi);

        if (t1flair_flag == PSD_ON)
        {
            psd_seqtime = RUP_GRD(act_tr/false_slquant1 - time_ssi);
        }
    }

    /*  Code to estimate the phase error accumulation for the 90-180-180
        SE sequence so as to maintain the CPMG condotion...this code based
        off the correction in fse-xl.e and fixes the slice-to-slice signal 
        variation issue with dualspinecho ALP */
    getssppulse(&tmppulseptr, &rf1,"frq", 0); /* Get beginning of rf1 */
    tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
    sync1_pos = (tmpinstr->start);
    rf1_pos = pbeg(&rf1,"rf1",0);
    sync_to_rf1 = rf1_pos - ( sync1_pos + frq2sync_dly ); 
    t_rf1_phase = sync_to_rf1 + hrf1a;

    if (PSD_OFF == dualspinecho_flag)
    {
        getssppulse(&tmppulseptr, &rf2,"frq", 0); /* Get beginning of rf2 */
        tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
        sync2_pos = (tmpinstr->start);
        rf2_pos = pbeg(&rf2,"rf2",0);
        sync_to_rf2 = rf2_pos - ( sync2_pos + frq2sync_dly ); 
        t_rf2_phase = sync_to_rf2 + pw_rf2/2;
    }
    else {
        getssppulse(&tmppulseptr, &rf2left,"frq", 0); /* Get beginning of rf2 */
        tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
        sync2_pos = (tmpinstr->start);
        rf2_pos = pbeg(&rf2left,"rf2left",0);
        sync_to_rf2 = rf2_pos - ( sync2_pos + frq2sync_dly ); 
        t_rf2_phase = sync_to_rf2 + pw_rf2left/2;
    }

    if(!irprep_flag) 
    {
        
  {
    pulsename(&seqcore,"seqcore");
    createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcore = %d\n", idx_seqcore );
#endif
  }


        getperiod((long*)&scan_deadtime, &seqcore, 0);
        scan_deadlast = deadlast;
    }

    if(ir_on)
    {
    { /* Start of code inlined from Inversion_new.e InversionPG */
        if (ir_on == PSD_ON)
        {

            for (ir_index = _ir_index.fixedflag ? ((void)(0), ir_index) : 0;ir_index<irslquant;ir_index  = _ir_index.fixedflag ?    ((void)(ir_index+1), ir_index) : ir_index+1) {

	        /*MRIhc26154 Support Routine Failure PopUp.*/
                 
                                 
                                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0", 
                                     (WF_PROCESSOR)wg_rf0);

    /* First create the pulses */
    pulsename(&gzrf0a,"gzrf0a");
    pulsename(&gzrf0,"gzrf0");
    pulsename(&gzrf0d,"gzrf0d");
    pulsename(&rf0,"rf0");

    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrf0a,ZGRAD,pw_gzrf0a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0a,(LONG)(ir_start+ir_index*psd_seqtime-pw_gzrf0a),
		pw_gzrf0a,ia_gzrf0);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0,ZGRAD,rfpulseInfo[RF0_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0.type = TYPEXTERNAL;
	    createinstr(&gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
			pw_gzrf0,ia_gzrf0);

                movestretchedwave( grad_zrf0, res_gzrf0,
                                   &gzrf0, 0, rfpulseInfo[RF0_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0,ZGRAD, 
			  res_gzrf0, grad_zrf0);
	    createinstr(&gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
			pw_gzrf0,ia_gzrf0);
	  }
      }
    else
      {
	createconst(&gzrf0,ZGRAD, pw_rf0,MAX_PG_WAMP);
	createinstr( &gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
		    pw_gzrf0,ia_gzrf0);
      }
    /* Decay ramp */
    createramp(&gzrf0d,ZGRAD,pw_gzrf0d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0d/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0d,(LONG)(ir_start+ir_index*psd_seqtime+pw_gzrf0),
		pw_gzrf0d,ia_gzrf0);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_SLOT].change==PSD_ON)
      {
	cyc_rf0  = _cyc_rf0.fixedflag ?  ((void)(1.0), cyc_rf0) : 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0,(WF_PROCESSOR)wg_rf0,rfpulseInfo[RF0_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0,alpha_rf0);
	createinstr(&rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		    pw_rf0,ia_rf0);
	linkpulses(4,&rf0,&gzrf0,&gzrf0a,
		   &gzrf0d);
	addrfbits(&rf0,off_rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		  pw_rf0);

            movestretchedwave( rf_rf0, res_rf0,
                               &rf0, 0, rfpulseInfo[RF0_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0,(WF_PROCESSOR)wg_rf0,
		      res_rf0,rf_rf0);
	createinstr(&rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		    pw_rf0,ia_rf0);
	linkpulses(4,&rf0,&gzrf0,&gzrf0a,
		   &gzrf0d);
	addrfbits(&rf0,off_rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		  pw_rf0);
      }
}


                
                        
  {
        INT old_res =  res_omegarf0; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0 != TYPRHO1)  && (wg_omegarf0 != TYPRHO2) &&
         (wg_omegarf0 != TYPTHETA) && (wg_omegarf0 != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0  = _n_omegarf0.fixedflag ?  ((void)(1), n_omegarf0) : n_omegarf0+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0,"omegarf0");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0, (WF_PROCESSOR)wg_omegarf0, new_res);

                movestretchedwave( fileloc_omegarf0, old_res,
                                   &omegarf0, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0  = _res_omegarf0.fixedflag ?  ((void)(new_res), res_omegarf0) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0,(WF_PROCESSOR)wg_omegarf0,
                          old_res,fileloc_omegarf0);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait, 
                 pw_omegarf0,ia_omegarf0);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0,off_omegarf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
              pw_omegarf0);
    

    /*** Reset Resolution ***/
    res_omegarf0  = _res_omegarf0.fixedflag ?  ((void)(old_res), res_omegarf0) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


                    

  trapezoid((WF_PROCESSOR)wg_gyk0, "gyk0", &gyk0, &gyk0a,
                        &gyk0d, pw_gyk0, pw_gyk0a, pw_gyk0d,
                        ia_gyk0, 0, 0, 0, 0, RUP_GRD(pend(&rf0,"rf0",ir_index)+pw_gyk0a)+((rfupd>>2)<<2)-pw_gyk0a, TRAP_ALL,
                        &loggrd);

            }
 
        }
    } /* End of code inlined from Inversion_new.e InversionPG */
        if(irprep_flag)
        {
            pulsename(&seqcore,"seqcore");
            createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
            /* Update sequence counter and get current sequence entry index */
            updateIndex( &idx_seqcore );
            printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                        "idx_seqcore = %d\n", idx_seqcore );
#endif
            getperiod((long*)&scan_deadtime, &seqcore, 0);
            scan_deadlast = deadlast;
        }
        else
        {
              
  {
    pulsename(&seqinv,"seqinv");
    createseq(&seqinv,invseqtime, off_seqinv);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqinv );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqinv = %d\n", idx_seqinv );
#endif
  }

            buildinstr();
            getperiod(&scan_deadtime_inv, &seqinv, 0);
            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqinv, 0);
        }
    }

    /* PS **************************************************************/
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();
AutoCoilpulsegen();
ExtCalpulsegen();

  
    if (SatRelaxers) /* Create Null sequence for Relaxers */
        SpSatCatRelaxPG(time_ssi);

    /* Baseline Acquisition *********************************************/
     
  {
    bline_unblank_pack[0] = SSPDS+RDC;
    bline_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    bline_unblank_pack[2] = SSPD+RUBL;
    bline_unblank_pack[3] = SSPDS;

    pulsename(&bline_unblank,"bline_unblank");
    createbits(&bline_unblank,TYPSSP,4,bline_unblank_pack);
    createinstr( &bline_unblank,(long)((LONG)(3000)),4,ia_bline_unblank);
  }

    
                     
                    
                        
                    
                    
                    
  {
    pulsename(&blineacq1,"blineacq1");
 
    epiacqq(&blineacq1, (long)((LONG)(5000)),(long)((LONG)0),
             (long)((LONG)0), (long)(filter_blineacq1),
             (TYPDAB_PACKETS)((TYPDAB_PACKETS)DABNORM), (long)((LONG)fast_rec),
                         (long)((LONG)(hsdab>0?0:1)));
  }

				 


    if (hsdab == 1)
         
{
    pulsename(&hyperdabbl,"hyperdabbl");

        createhsdab(&hyperdabbl, (long)(1000));
  }

    else if (hsdab == 2)
         
{
    pulsename(&diffdabbl,"diffdabbl");

    creatediffdab(&diffdabbl, (long)(1000));
}

  
      
  {
    pulsename(&seqblineacq,"seqblineacq");
    createseq(&seqblineacq,bl_acq_tr2, off_seqblineacq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqblineacq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqblineacq = %d\n", idx_seqblineacq );
#endif
  }


/*RTB0 correction*/
    /*MF B0 correction*/
    if ( rtb0_flag == PSD_ON )
    {
          
  {
    pulsename(&seqrtb0dummy,"seqrtb0dummy");
    createseq(&seqrtb0dummy,rtb0dummy_time, off_seqrtb0dummy);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtb0dummy );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtb0dummy = %d\n", idx_seqrtb0dummy );
#endif
  }
 /*dummy time for rtpinit()*/
          
  {
    pulsename(&seqrtb0fitwait,"seqrtb0fitwait");
    createseq(&seqrtb0fitwait,rtb0fittingwaittime, off_seqrtb0fitwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtb0fitwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtb0fitwait = %d\n", idx_seqrtb0fitwait );
#endif
  }
 /*dummy time for polynomial slice-by-slice CF fitting*/
          
  {
    pulsename(&seqrtprtb0,"seqrtprtb0");
    createseq(&seqrtprtb0,rtb0resultwaittime, off_seqrtprtb0);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtprtb0 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtprtb0 = %d\n", idx_seqrtprtb0 );
#endif
  }
 /*1ms wait time cycle for rtp result return*/
    }


#ifdef IPG
    if (FAILURE == Monitor_pulsegen())
    {
        return FAILURE;
    }
#endif

#ifdef NOT_MGD

    /* Move the instruction memory around a bit */
    /* There are essentially two memory banks: (1) XGRAD, YGRAD, ZGRAD, and SSP
       and      (2) RHO1, RHO2, THETA, OMEGA, AUX
       (Originally there were 4096 instructions assigned to each of x, z and ssp,
       and 4032 instructions to y.) */

    ipg_alloc_instr[0] = 4608;  /* XGRAD */
    ipg_alloc_instr[1] = 4544;  /* YGRAD */
    ipg_alloc_instr[2] = 2560;  /* ZGRAD */
    ipg_alloc_instr[3] = 4096;  /* RHO1  */
    ipg_alloc_instr[4] = 4096;  /* RHO2  */
    ipg_alloc_instr[5] = 4096;  /* THETA */
    ipg_alloc_instr[6] = 4096;  /* OMEGA */
    ipg_alloc_instr[7] = 4608;  /* SSP   */
    ipg_alloc_instr[8]  = 64;   /* AUX   */

#endif

    buildinstr();              /* load the sequencer memory */

    if (SatRelaxers) /* Use X and Z Grad offsets from off seqcore */
        SpSatCatRelaxOffsets(off_seqcore);

    { /* Start of code inlined from Inversion_new.e InversionPG */
        if( ir_sys_type == 1 )
        {
            rfupa = ir_rfupa; /* vmx 3/13/95 YI */
        }

        if( ir_on == PSD_ON )
        {
            int newres;

            newres = res_rf0;
            if(PSD_ON == rfpulseInfo[RF0_SLOT].change) {
                newres = rfpulseInfo[RF0_SLOT].newres;
            }

            setperiod((int)pw_rf0/newres, &rf0, 0);

            rf0_freq = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
            rf0_pha = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));

            setupslices(rf0_freq, rsp_info, opslquant, a_gzrf0,
                        (float)1, rhfreqscale*opfov, TYPTRANSMIT);

            for (i=0; i<opslquant; i++)
                setupphases(rf0_pha, rf0_freq, i, rf0_phase, 0, freqSign);
        }
    } /* End of code inlined from Inversion_new.e InversionPG */

/* irprep_support */


    /*  ***********************************************************
        Initialization
        ********************************************************** */

    if (oppseq == PSD_SE) {   /* point to proper waveform */

        if (mux_flag && verse_rf2) {
            getwave(&wave_ptr, &index_rf2[0]);                /* VERSEd envelope */
            getwave(&grad_wave_ptr, &rf2_gradient_waveform);  /* VERSEd gradient waveform */
        } else {
            getwave(&wave_ptr, &rf2se1b4);          /* use this for non-VERSEd RF pulses */
        }
        /* DTI */
        if( opdualspinecho == PSD_OFF) {
            setwave(wave_ptr,   &rf2, 0);
            if (mux_flag && verse_rf2) {
                setwave(grad_wave_ptr, &gzrf2, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2, 0);
            }
        } else {
            setwave(wave_ptr,   &rf2left, 0);
            setwave(wave_ptr,   &rf2right, 0);
            if (mux_flag && verse_rf2) {
                setwave(grad_wave_ptr, &gzrf2left, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2left, 0);
                setwave(grad_wave_ptr, &gzrf2right, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2right, 0);
            }
        }
    }

    rspdex = dex;
    rspech = 0;
    rspchp = CHOP_ALL;
    rsp_preview = 0;
  
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    if (rfov_flag)
    {
        /* Slice shift controlled though theta */
        for (temps = 0; temps < opslquant; ++temps)
        {
            rf1_freq[temps] = 0;
        }

        /* TG limit calc based on Tx freq offset */
        calcTGLimitAtOffset((int)rfov_max_freq_shift, _TGlimit.fixedflag ? (_temp1289_TGlimit=TGlimit,&_temp1289_TGlimit) : &TGlimit, psddebugcode2);
    }
    else if (mux_flag)
    {
        setupslices(rf1_freq, rsp_info, mux_slquant, a_gzrf1,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
        setupslices(theta_freq, rsp_info, mux_slquant, a_gzrf1/omega_scale,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);

    }
    else
    {
        /* Find frequency offsets */
        setupslices(rf1_freq, rsp_info, opslquant, a_gzrf1,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
        setupslices(theta_freq, rsp_info, opslquant, a_gzrf1/omega_scale,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
    }

    if (oppseq == PSD_SE)
    {
        if (mux_flag)
        {
            setupslices(rf2_freq, rsp_info, mux_slquant, a_gzrf2,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            setupslices(thetarf2_freq, rsp_info, mux_slquant, a_gzrf2/omega_scale,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);

        }
        else
        {
            setupslices(rf2_freq, rsp_info, opslquant, a_gzrf2,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
        }
    }

    /* BJM: dualspinecho */
    for (i=0; i<opslquant; i++) {
        if (ss_rf1 == PSD_ON) {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, 0, freqSign);
        } else {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, t_rf1_phase, freqSign);
        }

        if(PSD_OFF == dualspinecho_flag)
        {
            setupphases(rf2_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2);
        }
        else
        {
            setupphases(rf2left_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2left);
            setupphases(rf2right_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2right);
        }
    }
  
    settriggerarray((short)(opslquant*opphases),rsptrigger);
  
    if (FAILURE == Monitor_Download())
    {
        return FAILURE;
    }

    /* Inform the Tgt of the rotation matrix array to be used.
       For everything but CFH and CFL the sat pulses are played
       out so load the sat rotation matrix. Otherwise
       the original slice rotation matrix is used. */
    SpSat_set_sat1_matrix(rsprot_orig, rsprot, opslquant*opphases,
                          sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num,
                          sp_satcard_loc, 0);

    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray((short)(opslquant*opphases),rsprot[0]);

    /* update RSP maxTG with min TGlimit value */
    maxTGAtOffset = updateTGLimitAtOffset(TGlimit, sat_TGlimit);

#endif /* IPG */
    sl_rcvcf = (int)((float)cfreceiveroffsetfreq/ TARDIS_FREQ_RES);

    /* Set up SlcInAcq and AcqPtr tables for multipass scans and
     * multi-repetition scans, including cardiac gating, interleaved,
     * and sequential multi-rep modes.
     * SlcInAcq array gives number of slices per array.
     * AcqPtr array gives index to the first slice in the 
     * multislice tables for each pass. */
  
    /* cardiac gated multi-slice, multi-phase, multi-rep */
    if (opcgate==PSD_ON) 
    {
        rspcardiacinit((short)ophrep, (short)piclckcnt);
        sliceindex = acqs - 1; /* with cardiac gating, acqs is the no. of slices */
        for (pass = 0; pass < acqs; pass++) 
	{
            slc_in_acq[pass] = slquant1*opphases;
            if (pass == 0)
                acq_ptr[pass] = 0;
            else 
	    {
                acq_ptr[pass] = sliceindex;
                sliceindex = sliceindex - 1;
	    }
  	} /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) 
	{
            for (pass = 0; pass < acqs; pass++) 
	    {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
	    }
	}
    }
    /* RTG */
    else if ((oprtcgate == PSD_ON) || (navtrig_flag == PSD_ON))
    {
        rspcardiacinit((short)oprtrep, (short)piclckcnt);

        slmod_acqs = (opslquant * reps) % act_acqs;

        for (pass = 0; pass < act_acqs; pass++)
        {
            slc_in_acq[pass] = (opslquant * reps)/ act_acqs;
            acq_ptr[pass] = 0;

            if (slmod_acqs > pass)
            {
                slc_in_acq[pass] = slc_in_acq[pass] + 1;
            }

            acq_ptr[pass] = (int)(opslquant/ act_acqs) * pass;

            if (slmod_acqs <= pass)
            {
                acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
            }
            else
            {
                acq_ptr[pass] = acq_ptr[pass] + pass;
            }
        }

        /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) {
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
            }
        }
    }
    else 
    {
        if ( mph_flag==PSD_OFF ) 
	{  /* single-rep interleaved multi-slice */
            slmod_acqs = (opslquant*reps)%act_acqs;
            for (pass = 0; pass < act_acqs; pass++) 
	    {
                slc_in_acq[pass] = (opslquant*reps)/act_acqs;
                if (slmod_acqs > pass)
                    slc_in_acq[pass] = slc_in_acq[pass] + 1;
                acq_ptr[pass] = (int)(opslquant/act_acqs) *pass;
                if (slmod_acqs <= pass)
                    acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                else
                    acq_ptr[pass] = acq_ptr[pass] + pass;
	    }
	}
        if ( (mph_flag==PSD_ON) && (acqmode==1)) 
	{  /* mph, sequential */
            for (pass=0; pass<act_acqs; pass++) 
	    {  /* for sequential, acqs=opslquant */
                slc_in_acq[pass] = reps;
                acq_ptr[pass] = pass;
	    }
	}
        if ( (mph_flag==PSD_ON) && (acqmode==0) ) 
	{  /* mph, interleaved, single pass */
            for (pass = 0; pass < act_acqs; pass++) 
	    {
                slc_in_acq[pass] = slquant1;
                acq_ptr[pass] = 0;
                slmod_acqs = (opslquant*reps)%act_acqs;
                for (pass = 0; pass < act_acqs; pass++) 
		{
                    slc_in_acq[pass] = (opslquant*reps)/act_acqs;
                    if (slmod_acqs > pass)
                        slc_in_acq[pass] = slc_in_acq[pass] + 1;
                    acq_ptr[pass] = (int)(opslquant/act_acqs) *pass;
                    if (slmod_acqs <= pass)
                        acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                    else
                        acq_ptr[pass] = acq_ptr[pass] + pass;
		}
	    }
            for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) 
	    { /* repeat the table for multi-reps */
                for (pass = 0; pass < act_acqs; pass++) 
		{
                    slc_in_acq[pass + pass_rep*act_acqs] = slc_in_acq[pass];
                    acq_ptr[pass + pass_rep*act_acqs] = acq_ptr[pass];
		}
	    }
	}
    }
    
    /* t1flair_stir */
    if (t1flair_flag == PSD_ON)
    {
        if (FAILURE == T1flair_sliceordering())
        {
            return FAILURE;
        }
    }
  
    /* Save the trigger for the prescan slice. */
    prescan_trigger = rsptrigger[acq_ptr[pre_pass] + pre_slice];

    rsptrigger_temp[0] = TRIG_INTERN;
    
    /* Save copy of scan_info table */ 
    for(temp1=0; temp1<opslquant; temp1++) {
        orig_rsp_info[temp1].rsptloc = rsp_info[temp1].rsptloc;
        orig_rsp_info[temp1].rsprloc = rsp_info[temp1].rsprloc;
        orig_rsp_info[temp1].rspphasoff = rsp_info[temp1].rspphasoff;
        for (temp2=0; temp2<9; temp2++)
            origrot[temp1][temp2] = rsprot[temp1][temp2];
    }

    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr[echoloop]), &(echotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);
    }

    hsdabmask = PSD_LOAD_HSDAB_ALL;
    diffdabmask = PSD_LOAD_DIFFDAB_ALL;
    dabmask = PSD_LOAD_DAB_ALL;
    scaleomega = 0;

    return SUCCESS;

} /* end pulsegen */


#include <stdlib.h>

STATUS
ChemSatPG( INT chemsat_start,
           INT *cssat_index )
{
    CHAR rhoFile[256], phaFile[256];
    SHORT *rhoPulse, *phaPulse;
    SHORT *tempPulse;
    SHORT temp_res;
    /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
    INT gxkcs_start, gykcs_start, gzkcs_start;


    if(csat_sys_type == 1) rfupa = csat_rfupa; /* vmx 3/13/95 YI */
  
    /* Check to see if pw scaled during predownload. If TRUE then set resolution to
    ** scaled resolution.
    */
    temp_res = res_rfcssat;
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON)
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
    /*  Create skeleton chemsat pulse. */
      
  {
    pulsename(&rfcssat,"rfcssat");
    createreserve(&rfcssat,(WF_PROCESSOR)wg_rfcssat,
		  res_rfcssat);
  }


    createinstr(&rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_rfcssat);

    addrfbits(&rfcssat, off_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat);

    /* Reset resolution to old resolution in case of external rf pulse */
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
        res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(temp_res), res_rfcssat) : temp_res;
    }

    switch (ChemSatPulse) {
   
    case SINC_PULSE:
    default:
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
        }
        rhoPulse = (short *)AllocNode(res_rfcssat*sizeof(short));
        usinc(rhoPulse, res_rfcssat, (short)max_pg_wamp, cyc_rfcssat, alpha_rfcssat);
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    case DB_CS_PULSE:

        strcpy(rhoFile, "multiband_cs_rf.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        if(PSD_ON == DBgrad_flag)
        {
                  

  trapezoid((WF_PROCESSOR)wg_dbgxrfcssat, "dbgxrfcssat", &dbgxrfcssat, &dbgxrfcssata,
                        &dbgxrfcssatd, pw_dbgxrfcssat, pw_dbgxrfcssata, pw_dbgxrfcssatd,
                        ia_dbgxrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgxrfcssata, TRAP_ALL,
                        &loggrd);

                  

  trapezoid((WF_PROCESSOR)wg_dbgyrfcssat, "dbgyrfcssat", &dbgyrfcssat, &dbgyrfcssata,
                        &dbgyrfcssatd, pw_dbgyrfcssat, pw_dbgyrfcssata, pw_dbgyrfcssatd,
                        ia_dbgyrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgyrfcssata, TRAP_ALL,
                        &loggrd);

                  

  trapezoid((WF_PROCESSOR)wg_dbgzrfcssat, "dbgzrfcssat", &dbgzrfcssat, &dbgzrfcssata,
                        &dbgzrfcssatd, pw_dbgzrfcssat, pw_dbgzrfcssata, pw_dbgzrfcssatd,
                        ia_dbgzrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgzrfcssata, TRAP_ALL,
                        &loggrd);

        } 
        break;


    case CSM_PULSE:

        strcpy(rhoFile, "rfcsm.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMIN8_PULSE:

        strcpy(rhoFile, "rfcsmin8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMAX8_PULSE:

        strcpy(rhoFile, "rfcsmax8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else { 
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;

    case CS3T_PULSE:				/*YH*/

        strcpy(rhoFile, "rfcs3t.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    case CS_HS:	
    case CS_HS_20MS:
    case CS_HSLS:
        if (ChemSatPulse == CS_HS_20MS)
        {
            strcpy(rhoFile, "hs.rho");
            strcpy(phaFile, "hs.pha");
        }
        else if (ChemSatPulse == CS_HS)
        {
            strcpy(rhoFile, "hs_40ms.rho");
            strcpy(phaFile, "hs_40ms.pha");
        }
        else if (CS_HSLS == ChemSatPulse)
        {
            strcpy(rhoFile, "hs40ls.rho" );
            strcpy(phaFile, "hs40ls.pha");
        }

        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat  = _res_rfcssat.fixedflag ?  ((void)(rfpulseInfo[RFCSSAT_SLOT].newres), res_rfcssat) : rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* THETA pulse */
        {
              
  {
    pulsename(&omega_hs_rfcssat,"omega_hs_rfcssat");
    createreserve(&omega_hs_rfcssat,(WF_PROCESSOR)wg_omega_hs_rfcssat,
		  res_omega_hs_rfcssat);
  }


            createinstr(&omega_hs_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_omega_hs_rfcssat);

            tempPulse =(short *)AllocNode(temp_res*sizeof(short));
            uextwave(tempPulse, temp_res, phaFile);
            if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
                phaPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,phaPulse);
                FreeNode(tempPulse);
            } else {
                phaPulse = tempPulse;
            }
            movewaveimm(phaPulse, &omega_hs_rfcssat, 0, res_rfcssat, TOHARDWARE);
            FreeNode(phaPulse);
        }
        break;
    }
   
    if (selectiveChemsat) 
    { 
             

  trapezoid((WF_PROCESSOR)wg_gzrfcs, "gzrfcs", &gzrfcs, &gzrfcsa,
                        &gzrfcsd, pw_gzrfcs, pw_gzrfcsa, pw_gzrfcsd,
                        ia_gzrfcs, 0, 0, 0, 0, chemsat_start-pw_gzrfcsa, TRAP_ALL,
                        &loggrd);
	
    }

    /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
    /* Initialize X, Y, Z axis crusher start position */
    gykcs_start = 0;
    gxkcs_start = 0;
    gzkcs_start = 0;

    /*  Y board crusher for Chem Sat pulse  */
    /* MRIge62364 : karun Rounded up the postion for the pulses */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gykcs_start = RUP_GRD(pendall(&dbgyrfcssat,*cssat_index)  +  pw_gykcsa);
    }
    else
    {
        gykcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) +  pw_gykcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gykcs, "gykcs", &gykcs, &gykcsa,
                        &gykcsd, pw_gykcs, pw_gykcsa, pw_gykcsd,
                        ia_gykcs, 0, 0, 0, 0, gykcs_start-pw_gykcsa, TRAP_ALL,
                        &loggrd);


#ifdef CSXKILLER
    /*  X board crusher for Chem Sat pulse  */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gxkcs_start = RUP_GRD(pendall(&dbgxrfcssat,*cssat_index) + pw_gxkcs);
    }
    else
    {
        gxkcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) +  pw_gxkcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gxkcs, "gxkcs", &gxkcs, &gxkcsa,
                        &gxkcsd, pw_gxkcs, pw_gxkcsa, pw_gxkcsd,
                        ia_gxkcs, 0, 0, 0, 0, gxkcs_start-pw_gxkcsa, TRAP_ALL,
                        &loggrd);

#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
    if(duo_cs_flag)
    {
#endif   
    /*  Z board crusher for Chem Sat pulse  */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gzkcs_start = RUP_GRD(pendall(&dbgzrfcssat,*cssat_index) + pw_gzkcsa);
    }
    else
    {
        gzkcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) + pw_gzrfcsd + pw_gzkcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gzkcs, "gzkcs", &gzkcs, &gzkcsa,
                        &gzkcsd, pw_gzkcs, pw_gzkcsa, pw_gzkcsd,
                        ia_gzkcs, 0, 0, 0, 0, gzkcs_start-pw_gzkcsa, TRAP_ALL,
                        &loggrd);

#ifdef DCS_ZKILLER_ENH
    }
#endif
#endif

    if(psd_chemsat_seq_flag)
    {
        if ((*cssat_index == 0) || cs_dda_per_trig_flag)
        {
              
  {
    pulsename(&seqcssat,"seqcssat");
    createseq(&seqcssat,RUP_GRD(cs_sattime/n_cspulses+cs_satstart), off_seqcssat);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcssat );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcssat = %d\n", idx_seqcssat );
#endif
  }

            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqcssat, 0);
        }
    }
	
    /* Initialize for RSP */
    cstun = 0;
    amp_gykcs = ia_gykcs;
#ifdef CSXKILLER
    amp_gxkcs = ia_gxkcs;
#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
    if(duo_cs_flag)
    {
        amp_gzkcs = ia_gzkcs;
    }
#else
    amp_gzkcs = ia_gzkcs;
#endif
#endif
    csa = a_rfcssat * 1000;
    csf = off_rfcssat;
    *cssat_index += 1;

    /* Set the maximum of the csa corresponds to 360 degree */      
    max_csa = csa * CS_MAXFLIP/ flip_sat;  
	
    return SUCCESS;
} 
    
    
#include <float.h>
STATUS
SpSatPG( INT sat_type,
         INT start_time,
         INT *sat_index,
         INT cardiacsat_pos )
{
    SHORT *kernel_tab_rho = NULL; 
    SHORT *hadamard_tab_rho = NULL;
    SHORT *temp_wave_rho = NULL;
    SHORT *wave_space_rho = NULL;
    SHORT *kernel_tab_theta = NULL;
    SHORT *hadamard_tab_theta = NULL;
    SHORT *temp_wave_theta = NULL;
    EXTERN_FILENAME rho_file;
    EXTERN_FILENAME theta_file;  

    INT    skip_next_sat;
    long    ctrl_word;

    INT    sp_sattemp;
    FLOAT  separation; /* slice separation of hadamards in slice thickness */
    INT    sp_pos_killer;
    FLOAT  freqstep;
    INT  temp_sat_index;
  
    int rot_update_time;

    int ending;

    if(spsat_sys_type == 1) rfupa = spsat_rfupa; /* vmx 3/13/95 YI */

    sp_first_scan  = _sp_first_scan.fixedflag ?  ((void)(1), sp_first_scan) : 1;  /* First scan since download. This flag is used
                           to determine when rotation matrices need to
                           be copied over. This needs to be set even if
                           sat is off. */

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return(SUCCESS);

    /* Change resolutions since SpSatPG can be called multiple times. i.e. sat1, sat2, sat3 
       conditions*/
    switch (sat_type)
    {
    case SINC_SAT:
	{
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse1) : RES_NVRGSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse2) : RES_NVRGSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse3) : RES_NVRGSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse4) : RES_NVRGSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse5) : RES_NVRGSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_NVRGSAT), res_rfse6) : RES_NVRGSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx1) : RES_NVRGSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsx2) : RES_NVRGSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy1) : RES_NVRGSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsy2) : RES_NVRGSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz1) : RES_NVRGSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_NVRGSAT), res_rfsz2) : RES_NVRGSAT;
	    /* YMSmr09579 04-Oct-2006 HK */
            if (pw_rfse1==4800 ) res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
            if (pw_rfse2==4800 ) res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
            if (pw_rfse3==4800 ) res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
            if (pw_rfse4==4800 ) res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
            if (pw_rfse5==4800 ) res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
            if (pw_rfse6==4800 ) res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;
            if (pw_rfsx1==4800 ) res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
            if (pw_rfsx2==4800 ) res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
            if (pw_rfsy1==4800 ) res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
            if (pw_rfsy2==4800 ) res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
            if (pw_rfsz1==4800 ) res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
            if (pw_rfsz2==4800 ) res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
            break;
	}
    case SLR_SAT:
	{
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRSAT), res_rfse1) : RES_SLRSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRSAT), res_rfse2) : RES_SLRSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRSAT), res_rfse3) : RES_SLRSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRSAT), res_rfse4) : RES_SLRSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRSAT), res_rfse5) : RES_SLRSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRSAT), res_rfse6) : RES_SLRSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx1) : RES_SLRSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsx2) : RES_SLRSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy1) : RES_SLRSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsy2) : RES_SLRSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz1) : RES_SLRSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRSAT), res_rfsz2) : RES_SLRSAT;
            break;
	}
    case SLR_CSAT:
        {
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse1) : RES_SLRCSAT;
            res_rfse2  = _res_rfse2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse2) : RES_SLRCSAT;
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse3) : RES_SLRCSAT;
            res_rfse4  = _res_rfse4.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse4) : RES_SLRCSAT;
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse5) : RES_SLRCSAT;
            res_rfse6  = _res_rfse6.fixedflag ?  ((void)(RES_SLRCSAT), res_rfse6) : RES_SLRCSAT;
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx1) : RES_SLRCSAT;
            res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsx2) : RES_SLRCSAT;
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy1) : RES_SLRCSAT;
            res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsy2) : RES_SLRCSAT;
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz1) : RES_SLRCSAT;
            res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(RES_SLRCSAT), res_rfsz2) : RES_SLRCSAT;
            break;
        }
    default:
	break;
    }

    sp_sattemp = start_time;

    /* In cardiac scan, there may not be enough time at the beginning
       of the scan for the sat pulses. In this case, the sats are moved
       to the end of the sequence. (i.e. cardiacsat_pos != 0 ) For this
       case an isi interrupt is added before the sats the prepare the
       first rotation matrix.

       If the sats are played at the beginning of a sequence, the first
       rotation matrix is loaded by the psd. 

       Note that the sat index is 0. Since only one sat sequence will
       use this extra SSP packet, the index is 0 not sat_index. */

    /* ************************************************************ *
     * MRIge50713 - change the index to sat_index instead of using  *
     * index 0 always.                                              *
     *                                                              *
     * This is necessary because in the new FSE phase correction,   *
     * two copies of SpSat instructions are generated. The first    *
     * is for fse pulse sequence (seqcore), the 2nd copy is for fse *
     * phase correction pulse sequence (seqfseps). If the index     *
     * remains always 0, the seqfseps will overwrite the seqcore.   *
     * ************************************************************ */
 
    if (cardiacsat_pos != 0)
    {

    	/*
          MRIge51141 - Use sat_index only for FAST sequences.
	*/

        if ( opfast==PSD_ON )	{
            temp_sat_index = *sat_index ;
	} else 	{
            temp_sat_index = 0;
	}

           
  {
    pulsename(&isi_cardiacsat,"isi_cardiacsat");
    createconst(&isi_cardiacsat,(WF_PROCESSOR)wg_isi_cardiacsat,pw_isi_cardiacsat,(short)0); 
    createinstr( &isi_cardiacsat,(long)(sp_sattemp),pw_isi_cardiacsat,0);
  }

        getctrl(&ctrl_word, &isi_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_isisat;

           
  {
    pulsename(&rot_update_cardiacsat,"rot_update_cardiacsat");
    createconst(&rot_update_cardiacsat,(WF_PROCESSOR)wg_rot_update_cardiacsat,pw_rot_update_cardiacsat,(short)0); 
    createinstr( &rot_update_cardiacsat,(long)(sp_sattemp),pw_rot_update_cardiacsat,0);
  }

        getctrl(&ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_rotupdate;

    }
 
    /****************************************************************

            EXPLICIT SAT GRADIENTS

       1. Slice selection gradient
       2. Killer on y gradient
       3. If there are 2 sat bands that are parallel but do not have
          the same thickness, create a separate slice select & killer
          for the second band.
    ******************************************************************/

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse1", 
                                     (WF_PROCESSOR)wg_rfse1);

    /* Modify resolution if scaling required */
    temp_res_rfse1  = _temp_res_rfse1.fixedflag ?  ((void)(res_rfse1), temp_res_rfse1) : res_rfse1;
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse1a,"gzrfse1a");
    pulsename(&gzrfse1,"gzrfse1");
    pulsename(&gzrfse1d,"gzrfse1d");
    pulsename(&rfse1,"rfse1");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse1a,ZGRAD,pw_gzrfse1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse1a,(LONG)(sp_sattemp+pw_gzrfse1a-pw_gzrfse1a),
                pw_gzrfse1a,ia_gzrfse1);
    createconst(&gzrfse1,ZGRAD,pw_gzrfse1,MAX_PG_WAMP);
    createinstr( &gzrfse1,(LONG)(sp_sattemp+pw_gzrfse1a),
                pw_gzrfse1,ia_gzrfse1);
    createramp(&gzrfse1d,ZGRAD,pw_gzrfse1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse1d,(LONG)(sp_sattemp+pw_gzrfse1a+pw_gzrfse1),
                pw_gzrfse1d,ia_gzrfse1);

    /* Now create the rf pulse */
    createsinc(&rfse1,(WF_PROCESSOR)wg_rfse1,res_rfse1,
               MAX_PG_WAMP,cyc_rfse1, alpha_rfse1);

    createinstr( &rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
                pw_rfse1,ia_rfse1);
    linkpulses(4,&rfse1,&gzrfse1,&gzrfse1a,
               &gzrfse1d);
    addrfbits(&rfse1,off_rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
              pw_rfse1);



    pulsename(&rfse1Theta, "rfse1Theta");
    createreserve(&rfse1Theta, THETA, res_rfse1);
    addrfbits(&rfse1Theta, off_rfse1, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait , pw_rfse1);
    createinstr(&rfse1Theta, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait, pw_rfse1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1  = _res_rfse1.fixedflag ?  ((void)(temp_res_rfse1), res_rfse1) : temp_res_rfse1;
  }


        sp_sattemp = pend(&gzrfse1d, "gzrfse1d", *sat_index);

        ending = pendallssp(&rfse1, *sat_index);
 
           
  {
    pulsename(&isi_sate1,"isi_sate1");
    createconst(&isi_sate1,(WF_PROCESSOR)wg_isi_sate1,pw_isi_sate1,(short)0); 
    createinstr( &isi_sate1,(long)(ending),pw_isi_sate1,0);
  }

        getctrl(&ctrl_word, &isi_sate1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_sate1, *sat_index);

        rot_update_time = RUP_GRD(IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
           
  {
    pulsename(&rot_update_e1,"rot_update_e1");
    createconst(&rot_update_e1,(WF_PROCESSOR)wg_rot_update_e1,pw_rot_update_e1,(short)0); 
    createinstr( &rot_update_e1,(long)(rot_update_time),pw_rot_update_e1,0);
  }

        getctrl(&ctrl_word, &rot_update_e1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e1, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse1a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse1, "gykse1", &gykse1, &gykse1a,
                        &gykse1d, pw_gykse1, pw_gykse1a, pw_gykse1d,
                        ia_gykse1, 0, 0, 0, 0, sp_pos_killer-pw_gykse1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse1d, "gykse1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse1, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse1, "gxkse1", &gxkse1, &gxkse1a,
                        &gxkse1d, pw_gxkse1, pw_gxkse1a, pw_gxkse1d,
                        ia_gxkse1, 0, 0, 0, 0, sp_pos_killer-pw_gxkse1a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse1d, "gxkse1d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse1d, "gxkse1d", *sat_index);
        }
	  
             
  {
    pulsename(&isi_satek1,"isi_satek1");
    createconst(&isi_satek1,(WF_PROCESSOR)wg_isi_satek1,pw_isi_satek1,(short)0); 
    createinstr( &isi_satek1,(long)(sp_sattemp-isi_satdelay),pw_isi_satek1,0);
  }

        getctrl(&ctrl_word, &isi_satek1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_satek1, *sat_index);
	  
               
  {
    pulsename(&rot_update_ek1,"rot_update_ek1");
    createconst(&rot_update_ek1,(WF_PROCESSOR)wg_rot_update_ek1,pw_rot_update_ek1,(short)0); 
    createinstr( &rot_update_ek1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek1,0);
  }

        getctrl(&ctrl_word, &rot_update_ek1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek1, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse2", 
                                     (WF_PROCESSOR)wg_rfse2);

    /* Modify resolution if scaling required */
    temp_res_rfse2  = _temp_res_rfse2.fixedflag ?  ((void)(res_rfse2), temp_res_rfse2) : res_rfse2;
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2  = _res_rfse2.fixedflag ?  ((void)(rfpulseInfo[RFSE2_SLOT].newres), res_rfse2) : rfpulseInfo[RFSE2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse2a,"gzrfse2a");
    pulsename(&gzrfse2,"gzrfse2");
    pulsename(&gzrfse2d,"gzrfse2d");
    pulsename(&rfse2,"rfse2");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse2a,ZGRAD,pw_gzrfse2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse2a,(LONG)(sp_sattemp+pw_gzrfse2a-pw_gzrfse2a),
                pw_gzrfse2a,ia_gzrfse2);
    createconst(&gzrfse2,ZGRAD,pw_gzrfse2,MAX_PG_WAMP);
    createinstr( &gzrfse2,(LONG)(sp_sattemp+pw_gzrfse2a),
                pw_gzrfse2,ia_gzrfse2);
    createramp(&gzrfse2d,ZGRAD,pw_gzrfse2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse2d,(LONG)(sp_sattemp+pw_gzrfse2a+pw_gzrfse2),
                pw_gzrfse2d,ia_gzrfse2);

    /* Now create the rf pulse */
    createsinc(&rfse2,(WF_PROCESSOR)wg_rfse2,res_rfse2,
               MAX_PG_WAMP,cyc_rfse2, alpha_rfse2);

    createinstr( &rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
                pw_rfse2,ia_rfse2);
    linkpulses(4,&rfse2,&gzrfse2,&gzrfse2a,
               &gzrfse2d);
    addrfbits(&rfse2,off_rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
              pw_rfse2);



    pulsename(&rfse2Theta, "rfse2Theta");
    createreserve(&rfse2Theta, THETA, res_rfse2);
    addrfbits(&rfse2Theta, off_rfse2, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait , pw_rfse2);
    createinstr(&rfse2Theta, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait, pw_rfse2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2  = _res_rfse2.fixedflag ?  ((void)(temp_res_rfse2), res_rfse2) : temp_res_rfse2;
  }

        sp_sattemp = pend(&gzrfse2d, "gzrfse2d" , *sat_index);

        ending = pendallssp(&rfse2, *sat_index);

           
  {
    pulsename(&isi_sate2,"isi_sate2");
    createconst(&isi_sate2,(WF_PROCESSOR)wg_isi_sate2,pw_isi_sate2,(short)0); 
    createinstr( &isi_sate2,(long)(ending),pw_isi_sate2,0);
  }

        getctrl(&ctrl_word, &isi_sate2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate2, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e2,"rot_update_e2");
    createconst(&rot_update_e2,(WF_PROCESSOR)wg_rot_update_e2,pw_rot_update_e2,(short)0); 
    createinstr( &rot_update_e2,(long)(rot_update_time),pw_rot_update_e2,0);
  }

        getctrl(&ctrl_word, &rot_update_e2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e2, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse2a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse2, "gykse2", &gykse2, &gykse2a,
                        &gykse2d, pw_gykse2, pw_gykse2a, pw_gykse2d,
                        ia_gykse2, 0, 0, 0, 0, sp_pos_killer-pw_gykse2a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse2d, "gykse2d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse2, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse2, "gxkse2", &gxkse2, &gxkse2a,
                        &gxkse2d, pw_gxkse2, pw_gxkse2a, pw_gxkse2d,
                        ia_gxkse2, 0, 0, 0, 0, sp_pos_killer-pw_gxkse2a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse2d, "gxkse2d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse2d, "gxkse2d", *sat_index);
        }

             
  {
    pulsename(&isi_satek2,"isi_satek2");
    createconst(&isi_satek2,(WF_PROCESSOR)wg_isi_satek2,pw_isi_satek2,(short)0); 
    createinstr( &isi_satek2,(long)(sp_sattemp-isi_satdelay),pw_isi_satek2,0);
  }

        getctrl(&ctrl_word, &isi_satek2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek2, *sat_index);

               
  {
    pulsename(&rot_update_ek2,"rot_update_ek2");
    createconst(&rot_update_ek2,(WF_PROCESSOR)wg_rot_update_ek2,pw_rot_update_ek2,(short)0); 
    createinstr( &rot_update_ek2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek2,0);
  }

        getctrl(&ctrl_word, &rot_update_ek2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek2, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse3", 
                                     (WF_PROCESSOR)wg_rfse3);

    /* Modify resolution if scaling required */
    temp_res_rfse3  = _temp_res_rfse3.fixedflag ?  ((void)(res_rfse3), temp_res_rfse3) : res_rfse3;
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse3a,"gzrfse3a");
    pulsename(&gzrfse3,"gzrfse3");
    pulsename(&gzrfse3d,"gzrfse3d");
    pulsename(&rfse3,"rfse3");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse3a,ZGRAD,pw_gzrfse3a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse3a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse3a,(LONG)(sp_sattemp+pw_gzrfse3a-pw_gzrfse3a),
                pw_gzrfse3a,ia_gzrfse3);
    createconst(&gzrfse3,ZGRAD,pw_gzrfse3,MAX_PG_WAMP);
    createinstr( &gzrfse3,(LONG)(sp_sattemp+pw_gzrfse3a),
                pw_gzrfse3,ia_gzrfse3);
    createramp(&gzrfse3d,ZGRAD,pw_gzrfse3d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse3d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse3d,(LONG)(sp_sattemp+pw_gzrfse3a+pw_gzrfse3),
                pw_gzrfse3d,ia_gzrfse3);

    /* Now create the rf pulse */
    createsinc(&rfse3,(WF_PROCESSOR)wg_rfse3,res_rfse3,
               MAX_PG_WAMP,cyc_rfse3, alpha_rfse3);

    createinstr( &rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
                pw_rfse3,ia_rfse3);
    linkpulses(4,&rfse3,&gzrfse3,&gzrfse3a,
               &gzrfse3d);
    addrfbits(&rfse3,off_rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
              pw_rfse3);



    pulsename(&rfse3Theta, "rfse3Theta");
    createreserve(&rfse3Theta, THETA, res_rfse3);
    addrfbits(&rfse3Theta, off_rfse3, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait , pw_rfse3);
    createinstr(&rfse3Theta, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait, pw_rfse3, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3  = _res_rfse3.fixedflag ?  ((void)(temp_res_rfse3), res_rfse3) : temp_res_rfse3;
  }


        sp_sattemp = pend(&gzrfse3d, "gzrfse3d" , *sat_index);

        ending = pendallssp(&rfse3, *sat_index);

           
  {
    pulsename(&isi_sate3,"isi_sate3");
    createconst(&isi_sate3,(WF_PROCESSOR)wg_isi_sate3,pw_isi_sate3,(short)0); 
    createinstr( &isi_sate3,(long)(ending),pw_isi_sate3,0);
  }

        getctrl(&ctrl_word, &isi_sate3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate3, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e3,"rot_update_e3");
    createconst(&rot_update_e3,(WF_PROCESSOR)wg_rot_update_e3,pw_rot_update_e3,(short)0); 
    createinstr( &rot_update_e3,(long)(rot_update_time),pw_rot_update_e3,0);
  }

        getctrl(&ctrl_word, &rot_update_e3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e3, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse3a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse3, "gykse3", &gykse3, &gykse3a,
                        &gykse3d, pw_gykse3, pw_gykse3a, pw_gykse3d,
                        ia_gykse3, 0, 0, 0, 0, sp_pos_killer-pw_gykse3a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse3d, "gykse3d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse3, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse3, "gxkse3", &gxkse3, &gxkse3a,
                        &gxkse3d, pw_gxkse3, pw_gxkse3a, pw_gxkse3d,
                        ia_gxkse3, 0, 0, 0, 0, sp_pos_killer-pw_gxkse3a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse3d, "gxkse3d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse3d, "gxkse3d", *sat_index);
        }

              
  {
    pulsename(&isi_satek3,"isi_satek3");
    createconst(&isi_satek3,(WF_PROCESSOR)wg_isi_satek3,pw_isi_satek3,(short)0); 
    createinstr( &isi_satek3,(long)(sp_sattemp-isi_satdelay),pw_isi_satek3,0);
  }

        getctrl(&ctrl_word, &isi_satek3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek3, *sat_index);

                
  {
    pulsename(&rot_update_ek3,"rot_update_ek3");
    createconst(&rot_update_ek3,(WF_PROCESSOR)wg_rot_update_ek3,pw_rot_update_ek3,(short)0); 
    createinstr( &rot_update_ek3,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek3,0);
  }

        getctrl(&ctrl_word, &rot_update_ek3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek3, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal &  PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse4", 
                                     (WF_PROCESSOR)wg_rfse4);

    /* Modify resolution if scaling required */
    temp_res_rfse4  = _temp_res_rfse4.fixedflag ?  ((void)(res_rfse4), temp_res_rfse4) : res_rfse4;
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4  = _res_rfse4.fixedflag ?  ((void)(rfpulseInfo[RFSE4_SLOT].newres), res_rfse4) : rfpulseInfo[RFSE4_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse4a,"gzrfse4a");
    pulsename(&gzrfse4,"gzrfse4");
    pulsename(&gzrfse4d,"gzrfse4d");
    pulsename(&rfse4,"rfse4");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse4a,ZGRAD,pw_gzrfse4a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse4a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse4a,(LONG)(sp_sattemp+pw_gzrfse4a-pw_gzrfse4a),
                pw_gzrfse4a,ia_gzrfse4);
    createconst(&gzrfse4,ZGRAD,pw_gzrfse4,MAX_PG_WAMP);
    createinstr( &gzrfse4,(LONG)(sp_sattemp+pw_gzrfse4a),
                pw_gzrfse4,ia_gzrfse4);
    createramp(&gzrfse4d,ZGRAD,pw_gzrfse4d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse4d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse4d,(LONG)(sp_sattemp+pw_gzrfse4a+pw_gzrfse4),
                pw_gzrfse4d,ia_gzrfse4);

    /* Now create the rf pulse */
    createsinc(&rfse4,(WF_PROCESSOR)wg_rfse4,res_rfse4,
               MAX_PG_WAMP,cyc_rfse4, alpha_rfse4);

    createinstr( &rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
                pw_rfse4,ia_rfse4);
    linkpulses(4,&rfse4,&gzrfse4,&gzrfse4a,
               &gzrfse4d);
    addrfbits(&rfse4,off_rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
              pw_rfse4);



    pulsename(&rfse4Theta, "rfse4Theta");
    createreserve(&rfse4Theta, THETA, res_rfse4);
    addrfbits(&rfse4Theta, off_rfse4, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait , pw_rfse4);
    createinstr(&rfse4Theta, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait, pw_rfse4, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4  = _res_rfse4.fixedflag ?  ((void)(temp_res_rfse4), res_rfse4) : temp_res_rfse4;
  }


        sp_sattemp = pend(&gzrfse4d, "gzrfse4d" , *sat_index);

        ending = pendallssp(&rfse4, *sat_index);
           
  {
    pulsename(&isi_sate4,"isi_sate4");
    createconst(&isi_sate4,(WF_PROCESSOR)wg_isi_sate4,pw_isi_sate4,(short)0); 
    createinstr( &isi_sate4,(long)(ending),pw_isi_sate4,0);
  }

        getctrl(&ctrl_word, &isi_sate4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate4, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e4,"rot_update_e4");
    createconst(&rot_update_e4,(WF_PROCESSOR)wg_rot_update_e4,pw_rot_update_e4,(short)0); 
    createinstr( &rot_update_e4,(long)(rot_update_time),pw_rot_update_e4,0);
  }

        getctrl(&ctrl_word, &rot_update_e4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e4, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse4a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse4, "gykse4", &gykse4, &gykse4a,
                        &gykse4d, pw_gykse4, pw_gykse4a, pw_gykse4d,
                        ia_gykse4, 0, 0, 0, 0, sp_pos_killer-pw_gykse4a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse4d, "gykse4d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse4, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse4, "gxkse4", &gxkse4, &gxkse4a,
                        &gxkse4d, pw_gxkse4, pw_gxkse4a, pw_gxkse4d,
                        ia_gxkse4, 0, 0, 0, 0, sp_pos_killer-pw_gxkse4a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse4d, "gxkse4d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse4d, "gxkse4d", *sat_index);
        }

              
  {
    pulsename(&isi_satek4,"isi_satek4");
    createconst(&isi_satek4,(WF_PROCESSOR)wg_isi_satek4,pw_isi_satek4,(short)0); 
    createinstr( &isi_satek4,(long)(sp_sattemp-isi_satdelay),pw_isi_satek4,0);
  }

        getctrl(&ctrl_word, &isi_satek4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek4, *sat_index);

                
  {
    pulsename(&rot_update_ek4,"rot_update_ek4");
    createconst(&rot_update_ek4,(WF_PROCESSOR)wg_rot_update_ek4,pw_rot_update_ek4,(short)0); 
    createinstr( &rot_update_ek4,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek4,0);
  }

        getctrl(&ctrl_word, &rot_update_ek4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek4, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse5", 
                                     (WF_PROCESSOR)wg_rfse5);

    /* Modify resolution if scaling required */
    temp_res_rfse5  = _temp_res_rfse5.fixedflag ?  ((void)(res_rfse5), temp_res_rfse5) : res_rfse5;
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse5a,"gzrfse5a");
    pulsename(&gzrfse5,"gzrfse5");
    pulsename(&gzrfse5d,"gzrfse5d");
    pulsename(&rfse5,"rfse5");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse5a,ZGRAD,pw_gzrfse5a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse5a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse5a,(LONG)(sp_sattemp+pw_gzrfse5a-pw_gzrfse5a),
                pw_gzrfse5a,ia_gzrfse5);
    createconst(&gzrfse5,ZGRAD,pw_gzrfse5,MAX_PG_WAMP);
    createinstr( &gzrfse5,(LONG)(sp_sattemp+pw_gzrfse5a),
                pw_gzrfse5,ia_gzrfse5);
    createramp(&gzrfse5d,ZGRAD,pw_gzrfse5d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse5d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse5d,(LONG)(sp_sattemp+pw_gzrfse5a+pw_gzrfse5),
                pw_gzrfse5d,ia_gzrfse5);

    /* Now create the rf pulse */
    createsinc(&rfse5,(WF_PROCESSOR)wg_rfse5,res_rfse5,
               MAX_PG_WAMP,cyc_rfse5, alpha_rfse5);

    createinstr( &rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
                pw_rfse5,ia_rfse5);
    linkpulses(4,&rfse5,&gzrfse5,&gzrfse5a,
               &gzrfse5d);
    addrfbits(&rfse5,off_rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
              pw_rfse5);



    pulsename(&rfse5Theta, "rfse5Theta");
    createreserve(&rfse5Theta, THETA, res_rfse5);
    addrfbits(&rfse5Theta, off_rfse5, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait , pw_rfse5);
    createinstr(&rfse5Theta, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait, pw_rfse5, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5  = _res_rfse5.fixedflag ?  ((void)(temp_res_rfse5), res_rfse5) : temp_res_rfse5;
  }


        sp_sattemp = pend(&gzrfse5d, "gzrfse5d" , *sat_index);

        ending = pendallssp(&rfse5, *sat_index);
           
  {
    pulsename(&isi_sate5,"isi_sate5");
    createconst(&isi_sate5,(WF_PROCESSOR)wg_isi_sate5,pw_isi_sate5,(short)0); 
    createinstr( &isi_sate5,(long)(ending),pw_isi_sate5,0);
  }

        getctrl(&ctrl_word, &isi_sate5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate5, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e5,"rot_update_e5");
    createconst(&rot_update_e5,(WF_PROCESSOR)wg_rot_update_e5,pw_rot_update_e5,(short)0); 
    createinstr( &rot_update_e5,(long)(rot_update_time),pw_rot_update_e5,0);
  }

        getctrl(&ctrl_word, &rot_update_e5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e5, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse5a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse5, "gykse5", &gykse5, &gykse5a,
                        &gykse5d, pw_gykse5, pw_gykse5a, pw_gykse5d,
                        ia_gykse5, 0, 0, 0, 0, sp_pos_killer-pw_gykse5a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse5d, "gykse5d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse5, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse5, "gxkse5", &gxkse5, &gxkse5a,
                        &gxkse5d, pw_gxkse5, pw_gxkse5a, pw_gxkse5d,
                        ia_gxkse5, 0, 0, 0, 0, sp_pos_killer-pw_gxkse5a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse5d, "gxkse5d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse5d, "gxkse5d", *sat_index);
        }

              
  {
    pulsename(&isi_satek5,"isi_satek5");
    createconst(&isi_satek5,(WF_PROCESSOR)wg_isi_satek5,pw_isi_satek5,(short)0); 
    createinstr( &isi_satek5,(long)(sp_sattemp-isi_satdelay),pw_isi_satek5,0);
  }

        getctrl(&ctrl_word, &isi_satek5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek5, *sat_index);

                
  {
    pulsename(&rot_update_ek5,"rot_update_ek5");
    createconst(&rot_update_ek5,(WF_PROCESSOR)wg_rot_update_ek5,pw_rot_update_ek5,(short)0); 
    createinstr( &rot_update_ek5,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek5,0);
  }

        getctrl(&ctrl_word, &rot_update_ek5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek5, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse6", 
                                     (WF_PROCESSOR)wg_rfse6);

    /* Modify resolution if scaling required */
    temp_res_rfse6  = _temp_res_rfse6.fixedflag ?  ((void)(res_rfse6), temp_res_rfse6) : res_rfse6;
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6  = _res_rfse6.fixedflag ?  ((void)(rfpulseInfo[RFSE6_SLOT].newres), res_rfse6) : rfpulseInfo[RFSE6_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse6a,"gzrfse6a");
    pulsename(&gzrfse6,"gzrfse6");
    pulsename(&gzrfse6d,"gzrfse6d");
    pulsename(&rfse6,"rfse6");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(satloggrd.zbeta), pg_beta) : satloggrd.zbeta;
    createramp(&gzrfse6a,ZGRAD,pw_gzrfse6a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse6a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse6a,(LONG)(sp_sattemp+pw_gzrfse6a-pw_gzrfse6a),
                pw_gzrfse6a,ia_gzrfse6);
    createconst(&gzrfse6,ZGRAD,pw_gzrfse6,MAX_PG_WAMP);
    createinstr( &gzrfse6,(LONG)(sp_sattemp+pw_gzrfse6a),
                pw_gzrfse6,ia_gzrfse6);
    createramp(&gzrfse6d,ZGRAD,pw_gzrfse6d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse6d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse6d,(LONG)(sp_sattemp+pw_gzrfse6a+pw_gzrfse6),
                pw_gzrfse6d,ia_gzrfse6);

    /* Now create the rf pulse */
    createsinc(&rfse6,(WF_PROCESSOR)wg_rfse6,res_rfse6,
               MAX_PG_WAMP,cyc_rfse6, alpha_rfse6);

    createinstr( &rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
                pw_rfse6,ia_rfse6);
    linkpulses(4,&rfse6,&gzrfse6,&gzrfse6a,
               &gzrfse6d);
    addrfbits(&rfse6,off_rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
              pw_rfse6);



    pulsename(&rfse6Theta, "rfse6Theta");
    createreserve(&rfse6Theta, THETA, res_rfse6);
    addrfbits(&rfse6Theta, off_rfse6, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait , pw_rfse6);
    createinstr(&rfse6Theta, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait, pw_rfse6, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6  = _res_rfse6.fixedflag ?  ((void)(temp_res_rfse6), res_rfse6) : temp_res_rfse6;
  }


        sp_sattemp = pend(&gzrfse6d, "gzrfse6d" , *sat_index);

        ending = pendallssp(&rfse6, *sat_index);
           
  {
    pulsename(&isi_sate6,"isi_sate6");
    createconst(&isi_sate6,(WF_PROCESSOR)wg_isi_sate6,pw_isi_sate6,(short)0); 
    createinstr( &isi_sate6,(long)(ending),pw_isi_sate6,0);
  }

        getctrl(&ctrl_word, &isi_sate6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate6, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e6,"rot_update_e6");
    createconst(&rot_update_e6,(WF_PROCESSOR)wg_rot_update_e6,pw_rot_update_e6,(short)0); 
    createinstr( &rot_update_e6,(long)(rot_update_time),pw_rot_update_e6,0);
  }

        getctrl(&ctrl_word, &rot_update_e6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e6, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse6a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse6, "gykse6", &gykse6, &gykse6a,
                        &gykse6d, pw_gykse6, pw_gykse6a, pw_gykse6d,
                        ia_gykse6, 0, 0, 0, 0, sp_pos_killer-pw_gykse6a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse6d, "gykse6d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse6, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse6, "gxkse6", &gxkse6, &gxkse6a,
                        &gxkse6d, pw_gxkse6, pw_gxkse6a, pw_gxkse6d,
                        ia_gxkse6, 0, 0, 0, 0, sp_pos_killer-pw_gxkse6a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse6d, "gxkse6d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse6d, "gxkse6d", *sat_index);
        }

              
  {
    pulsename(&isi_satek6,"isi_satek6");
    createconst(&isi_satek6,(WF_PROCESSOR)wg_isi_satek6,pw_isi_satek6,(short)0); 
    createinstr( &isi_satek6,(long)(sp_sattemp-isi_satdelay),pw_isi_satek6,0);
  }

        getctrl(&ctrl_word, &isi_satek6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek6, *sat_index);

                
  {
    pulsename(&rot_update_ek6,"rot_update_ek6");
    createconst(&rot_update_ek6,(WF_PROCESSOR)wg_rot_update_ek6,pw_rot_update_ek6,(short)0); 
    createinstr( &rot_update_ek6,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek6,0);
  }

        getctrl(&ctrl_word, &rot_update_ek6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek6, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
    } 

    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */

    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT. The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/
    
    switch (sat_type)
    {
    case SINC_SAT:
	
	/* Handle rf scaling */
	if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
	if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
	if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
	
	if ((opexsatparal & PSD_1_PARALLEL) != 0)
        {
	    separation = 2 * satspace1/exsatthick1;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse1, max_pg_wamp, separation,
		      cyc_rfse1, alpha_rfse1);
	    movewaveimm(wave_space_rho, &rfse1, (INT)0, res_rfse1, 
			TOHARDWARE);
        }
	
	if ((opexsatparal & PSD_2_PARALLEL) != 0)
        {
	    separation = 2 * satspace3/exsatthick3;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse3*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse3, max_pg_wamp, separation,
		      cyc_rfse3, alpha_rfse3);
	    movewaveimm(wave_space_rho, &rfse3, (INT)0, res_rfse3, 
			TOHARDWARE);

        }
	
	if ((opexsatparal & PSD_3_PARALLEL) != 0)
        {
	    separation = 2 * satspace5/exsatthick5;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse5*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse5, max_pg_wamp, separation,
		      cyc_rfse5, alpha_rfse5);
	    movewaveimm(wave_space_rho, &rfse5, (INT)0, res_rfse5, 
			TOHARDWARE);

        }
	
	FreeNode(wave_space_rho);
	break;
	
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type) 
        {
        case SLR_SAT:        	
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;
        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;
        default:
             break;
        }
	
	skip_next_sat = 0;
	if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse1  = _res_rfse1.fixedflag ?  ((void)(rfpulseInfo[RFSE1_SLOT].newres), res_rfse1) : rfpulseInfo[RFSE1_SLOT].newres;
            }
	    else
            {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                }

            }

	    /* Check if hadamard or pulse ON */
	    if ((opexsatparal & PSD_1_PARALLEL) != 0)
	      {
		separation = satspace1/2.0/exsatthick1;
		freqstep = 65536.0/(float)res_rfse1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, kernel_tab_theta, cyc_rfse1,
			 separation, gscale_rfse1, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse1Theta, (INT)0, res_rfse1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, cyc_rfse1,
                         separation, gscale_rfse1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse1, (INT)0, res_rfse1,
                            TOHARDWARE);
             
		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse1, (INT) 0, res_rfse1,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse1Theta, (INT) 0, res_rfse1,
                            TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
	      FreeNode(kernel_tab_rho);
              if (sat_pulse_type == COMPLEX_RF)
              {
                 FreeNode(kernel_tab_theta);
              }
            }
	  }
	

	if (((opexsatmask & PSD_EXPLICIT_2) != 0) && 
	    (skip_next_sat == 0))
	  {
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_rho,kernel_tab_rho);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse2  = _res_rfse2.fixedflag ?  ((void)(rfpulseInfo[RFSE2_SLOT].newres), res_rfse2) : rfpulseInfo[RFSE2_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse2, (INT)0, res_rfse2,
			TOHARDWARE);

            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse2Theta, (INT) 0, res_rfse2,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
	  }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse3  = _res_rfse3.fixedflag ?  ((void)(rfpulseInfo[RFSE3_SLOT].newres), res_rfse3) : rfpulseInfo[RFSE3_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));
                }
	      }
	    if ((opexsatparal & PSD_2_PARALLEL) != 0)
	      {
		separation = satspace3/2.0/exsatthick3;
		freqstep = 65536.0/(float) res_rfse3;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, kernel_tab_theta, cyc_rfse3,
			 separation, gscale_rfse3, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse3Theta, (INT)0, res_rfse3,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfse3, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse3, (INT)0, res_rfse3,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse3, (INT) 0, res_rfse3,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse3Theta, (INT) 0, res_rfse3,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_4) != 0) && 
	    (skip_next_sat == 0))
        {
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse4  = _res_rfse4.fixedflag ?  ((void)(rfpulseInfo[RFSE4_SLOT].newres), res_rfse4) : rfpulseInfo[RFSE4_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho; 
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse4, (INT)0, res_rfse4,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse4Theta, (INT)0, res_rfse4,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON) 
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse5  = _res_rfse5.fixedflag ?  ((void)(rfpulseInfo[RFSE5_SLOT].newres), res_rfse5) : rfpulseInfo[RFSE5_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                }
	      }
	    
	    if ((opexsatparal & PSD_3_PARALLEL) != 0)
	      {
		separation = satspace5/2.0/exsatthick5;
		freqstep = 65536.0/(float) res_rfse5;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, kernel_tab_theta, cyc_rfse5,
			 separation, gscale_rfse5, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse5Theta, (INT)0, res_rfse5,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, cyc_rfse5,
                         separation, gscale_rfse5, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }
                movewaveimm(hadamard_tab_rho, &rfse5, (INT)0, res_rfse5,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse5, (INT) 0, res_rfse5,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse5Theta, (INT) 0, res_rfse5,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_6) != 0) && 
	    (skip_next_sat == 0))
        {
	    /* Check pulse scaling */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse6  = _res_rfse6.fixedflag ?  ((void)(rfpulseInfo[RFSE6_SLOT].newres), res_rfse6) : rfpulseInfo[RFSE6_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse6, (INT)0, res_rfse6,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse6Theta, (INT)0, res_rfse6,
                           TOHARDWARE);
            }
	    /* Free Memory */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
	    } 
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    /****************************************************************
      DEFAULT SAT GRADEINTS
      
      1. Slice selection gradient
      2. Killer on y gradient
      3. If there are 2 sat bands that are parallel but do not have
      the same thickness, create a separate slice select & killer
      for the second band.
      
    ******************************************************************/
    
    if (opsatx != PSD_OFF)    /* X board */
    {
        if (opsatx == PSD_SATNEG)
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
        else if (opsatx == PSD_SATPOS)
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx2), satthickdfx) : satthickx2;
        else
            satthickdfx  = _satthickdfx.fixedflag ?  ((void)(satthickx1), satthickdfx) : satthickx1;
	
           
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx1", 
                                     (WF_PROCESSOR)wg_rfsx1);

    /* Modify resolution if scaling required */
    temp_res_rfsx1  = _temp_res_rfsx1.fixedflag ?  ((void)(res_rfsx1), temp_res_rfsx1) : res_rfsx1;
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx1a,"gxrfsx1a");
    pulsename(&gxrfsx1,"gxrfsx1");
    pulsename(&gxrfsx1d,"gxrfsx1d");
    pulsename(&rfsx1,"rfsx1");

    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    createramp(&gxrfsx1a,XGRAD,pw_gxrfsx1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx1a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx1a,(LONG)(sp_sattemp+pw_gxrfsx1a-pw_gxrfsx1a),
                pw_gxrfsx1a,ia_gxrfsx1);
    createconst(&gxrfsx1,XGRAD,pw_gxrfsx1,MAX_PG_WAMP);
    createinstr( &gxrfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a),
                pw_gxrfsx1,ia_gxrfsx1);
    createramp(&gxrfsx1d,XGRAD,pw_gxrfsx1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx1d,(LONG)(sp_sattemp+pw_gxrfsx1a+pw_gxrfsx1),
                pw_gxrfsx1d,ia_gxrfsx1);

    /* Now create the rf pulse */
    createsinc(&rfsx1,(WF_PROCESSOR)wg_rfsx1,res_rfsx1,
               MAX_PG_WAMP,cyc_rfsx1, alpha_rfsx1);
    createinstr( &rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
                pw_rfsx1,ia_rfsx1);
    linkpulses(4,&rfsx1,&gxrfsx1,&gxrfsx1a,
               &gxrfsx1d);
    addrfbits(&rfsx1,off_rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
              pw_rfsx1);


    pulsename(&rfsx1Theta, "rfsx1Theta");
    createreserve(&rfsx1Theta, THETA, res_rfsx1);
    addrfbits(&rfsx1Theta, off_rfsx1, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait , pw_rfsx1);
    createinstr(&rfsx1Theta, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait, pw_rfsx1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(temp_res_rfsx1), res_rfsx1) : temp_res_rfsx1;
}

	
        sp_sattemp = pend(&gxrfsx1d, "gxrfsx1d", *sat_index);
	
        ending = pendallssp(&rfsx1, *sat_index);
           
  {
    pulsename(&isi_satx1,"isi_satx1");
    createconst(&isi_satx1,(WF_PROCESSOR)wg_isi_satx1,pw_isi_satx1,(short)0); 
    createinstr( &isi_satx1,(long)(ending),pw_isi_satx1,0);
  }

        getctrl(&ctrl_word, &isi_satx1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satx1, *sat_index);
	rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_x1,"rot_update_x1");
    createconst(&rot_update_x1,(WF_PROCESSOR)wg_rot_update_x1,pw_rot_update_x1,(short)0); 
    createinstr( &rot_update_x1,(long)(rot_update_time),pw_rot_update_x1,0);
  }

        getctrl(&ctrl_word, &rot_update_x1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_x1, *sat_index);
	sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksx1, "gyksx1", &gyksx1, &gyksx1a,
                        &gyksx1d, pw_gyksx1, pw_gyksx1a, pw_gyksx1d,
                        ia_gyksx1, 0, 0, 0, 0, sp_pos_killer-pw_gyksx1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksx1d, "gyksx1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxksx1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksx1, "gxksx1", &gxksx1, &gxksx1a,
                        &gxksx1d, pw_gxksx1, pw_gxksx1a, pw_gxksx1d,
                        ia_gxksx1, 0, 0, 0, 0, sp_pos_killer-pw_gxksx1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksx1d, "gxksx1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksx1d, "gxksx1d", *sat_index);
        }

              
  {
    pulsename(&isi_satxk1,"isi_satxk1");
    createconst(&isi_satxk1,(WF_PROCESSOR)wg_isi_satxk1,pw_isi_satxk1,(short)0); 
    createinstr( &isi_satxk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk1,0);
  }

        getctrl(&ctrl_word, &isi_satxk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satxk1, *sat_index);

                
  {
    pulsename(&rot_update_xk1,"rot_update_xk1");
    createconst(&rot_update_xk1,(WF_PROCESSOR)wg_rot_update_xk1,pw_rot_update_xk1,(short)0); 
    createinstr( &rot_update_xk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk1,0);
  }

        getctrl(&ctrl_word, &rot_update_xk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_xk1, *sat_index);
       
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsatx == PSD_SATPARA)
        {
                
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx2", 
                                     (WF_PROCESSOR)wg_rfsx2);

    /* Modify resolution if scaling required */
    temp_res_rfsx2  = _temp_res_rfsx2.fixedflag ?  ((void)(res_rfsx2), temp_res_rfsx2) : res_rfsx2;
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(rfpulseInfo[RFSX2_SLOT].newres), res_rfsx2) : rfpulseInfo[RFSX2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx2a,"gxrfsx2a");
    pulsename(&gxrfsx2,"gxrfsx2");
    pulsename(&gxrfsx2d,"gxrfsx2d");
    pulsename(&rfsx2,"rfsx2");

    /*  Now create the slice select trapezoid */
    pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.xbeta), pg_beta) : loggrd.xbeta;
    createramp(&gxrfsx2a,XGRAD,pw_gxrfsx2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx2a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx2a,(LONG)(sp_sattemp+pw_gxrfsx2a-pw_gxrfsx2a),
                pw_gxrfsx2a,ia_gxrfsx2);
    createconst(&gxrfsx2,XGRAD,pw_gxrfsx2,MAX_PG_WAMP);
    createinstr( &gxrfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a),
                pw_gxrfsx2,ia_gxrfsx2);
    createramp(&gxrfsx2d,XGRAD,pw_gxrfsx2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx2d,(LONG)(sp_sattemp+pw_gxrfsx2a+pw_gxrfsx2),
                pw_gxrfsx2d,ia_gxrfsx2);

    /* Now create the rf pulse */
    createsinc(&rfsx2,(WF_PROCESSOR)wg_rfsx2,res_rfsx2,
               MAX_PG_WAMP,cyc_rfsx2, alpha_rfsx2);
    createinstr( &rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
                pw_rfsx2,ia_rfsx2);
    linkpulses(4,&rfsx2,&gxrfsx2,&gxrfsx2a,
               &gxrfsx2d);
    addrfbits(&rfsx2,off_rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
              pw_rfsx2);


    pulsename(&rfsx2Theta, "rfsx2Theta");
    createreserve(&rfsx2Theta, THETA, res_rfsx2);
    addrfbits(&rfsx2Theta, off_rfsx2, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait , pw_rfsx2);
    createinstr(&rfsx2Theta, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait, pw_rfsx2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(temp_res_rfsx2), res_rfsx2) : temp_res_rfsx2;
}


	    sp_sattemp = pend(&gxrfsx2d, "gxrfsx2d", *sat_index) ;
	    
	    ending = pendallssp(&rfsx2, *sat_index);
	       
  {
    pulsename(&isi_satx2,"isi_satx2");
    createconst(&isi_satx2,(WF_PROCESSOR)wg_isi_satx2,pw_isi_satx2,(short)0); 
    createinstr( &isi_satx2,(long)(ending),pw_isi_satx2,0);
  }

	    getctrl(&ctrl_word, &isi_satx2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satx2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_x2,"rot_update_x2");
    createconst(&rot_update_x2,(WF_PROCESSOR)wg_rot_update_x2,pw_rot_update_x2,(short)0); 
    createinstr( &rot_update_x2,(long)(rot_update_time),pw_rot_update_x2,0);
  }

	    getctrl(&ctrl_word, &rot_update_x2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_x2, *sat_index);
	    sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);	    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx2a + isi_extra);
	         

  trapezoid((WF_PROCESSOR)wg_gyksx2, "gyksx2", &gyksx2, &gyksx2a,
                        &gyksx2d, pw_gyksx2, pw_gyksx2a, pw_gyksx2d,
                        ia_gyksx2, 0, 0, 0, 0, sp_pos_killer-pw_gyksx2a, TRAP_ALL,
                        &loggrd);

	    sp_sattemp = pend(&gyksx2d, "gyksx2d",*sat_index) ;
	    
            if (!floatsAlmostEqualEpsilons(area_gxksx2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksx2, "gxksx2", &gxksx2, &gxksx2a,
                        &gxksx2d, pw_gxksx2, pw_gxksx2a, pw_gxksx2d,
                        ia_gxksx2, 0, 0, 0, 0, sp_pos_killer-pw_gxksx2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksx2d, "gxksx2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksx2d, "gxksx2d", *sat_index);
            }
	    
	         
  {
    pulsename(&isi_satxk2,"isi_satxk2");
    createconst(&isi_satxk2,(WF_PROCESSOR)wg_isi_satxk2,pw_isi_satxk2,(short)0); 
    createinstr( &isi_satxk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk2,0);
  }

	    getctrl(&ctrl_word, &isi_satxk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satxk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_xk2,"rot_update_xk2");
    createconst(&rot_update_xk2,(WF_PROCESSOR)wg_rot_update_xk2,pw_rot_update_xk2,(short)0); 
    createinstr( &rot_update_xk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_xk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_xk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra);
        }
    }

    if (opsaty != PSD_OFF)   /* Y Board */
    {
        if (opsaty == PSD_SATNEG)
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;
        else if (opsaty == PSD_SATPOS)
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky2), satthickdfy) : satthicky2;
        else
            satthickdfy  = _satthickdfy.fixedflag ?  ((void)(satthicky1), satthickdfy) : satthicky1;

             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy1", 
                                     (WF_PROCESSOR)wg_rfsy1);

    /* Modify resolution if scaling required */
    temp_res_rfsy1  = _temp_res_rfsy1.fixedflag ?  ((void)(res_rfsy1), temp_res_rfsy1) : res_rfsy1;
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy1a,"gyrfsy1a");
    pulsename(&gyrfsy1,"gyrfsy1");
    pulsename(&gyrfsy1d,"gyrfsy1d");
    pulsename(&rfsy1,"rfsy1");

        /*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.ybeta), pg_beta) : loggrd.ybeta;
  createramp(&gyrfsy1a,YGRAD,pw_gyrfsy1a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy1a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy1a,(LONG)(sp_sattemp+pw_gyrfsy1a-pw_gyrfsy1a),
      pw_gyrfsy1a,ia_gyrfsy1);
  createconst(&gyrfsy1,YGRAD,pw_gyrfsy1,MAX_PG_WAMP);
  createinstr( &gyrfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a),
      pw_gyrfsy1,ia_gyrfsy1);
  createramp(&gyrfsy1d,YGRAD,pw_gyrfsy1d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy1d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy1d,(LONG)(sp_sattemp+pw_gyrfsy1a+pw_gyrfsy1),
      pw_gyrfsy1d,ia_gyrfsy1);

    /* Now create the rf pulse */
    createsinc(&rfsy1,(WF_PROCESSOR)wg_rfsy1,res_rfsy1,
               MAX_PG_WAMP,cyc_rfsy1, alpha_rfsy1);
    createinstr( &rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
                pw_rfsy1,ia_rfsy1);
    linkpulses(4,&rfsy1,&gyrfsy1,&gyrfsy1a,&gyrfsy1d);
    addrfbits(&rfsy1,off_rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
              pw_rfsy1);

    pulsename(&rfsy1Theta, "rfsy1Theta");
    createreserve(&rfsy1Theta, THETA, res_rfsy1);
    addrfbits(&rfsy1Theta, off_rfsy1, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait , pw_rfsy1);
    createinstr(&rfsy1Theta, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait, pw_rfsy1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(temp_res_rfsy1), res_rfsy1) : temp_res_rfsy1;
}


        sp_sattemp = pend(&gyrfsy1d, "gyrfsy1d" , *sat_index);

        ending = pendallssp(&rfsy1, *sat_index);
           
  {
    pulsename(&isi_saty1,"isi_saty1");
    createconst(&isi_saty1,(WF_PROCESSOR)wg_isi_saty1,pw_isi_saty1,(short)0); 
    createinstr( &isi_saty1,(long)(ending),pw_isi_saty1,0);
  }

        getctrl(&ctrl_word, &isi_saty1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_saty1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_y1,"rot_update_y1");
    createconst(&rot_update_y1,(WF_PROCESSOR)wg_rot_update_y1,pw_rot_update_y1,(short)0); 
    createinstr( &rot_update_y1,(long)(rot_update_time),pw_rot_update_y1,0);
  }

        getctrl(&ctrl_word, &rot_update_y1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_y1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy1a + isi_extra);
              

  trapezoid((WF_PROCESSOR)wg_gyksy1, "gyksy1", &gyksy1, &gyksy1a,
                        &gyksy1d, pw_gyksy1, pw_gyksy1a, pw_gyksy1d,
                        ia_gyksy1, 0, 0, 0, 0, sp_pos_killer-pw_gyksy1a, TRAP_ALL,
                        &loggrd);
 
        sp_sattemp = pend(&gyksy1d, "gyksy1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxksy1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksy1, "gxksy1", &gxksy1, &gxksy1a,
                        &gxksy1d, pw_gxksy1, pw_gxksy1a, pw_gxksy1d,
                        ia_gxksy1, 0, 0, 0, 0, sp_pos_killer-pw_gxksy1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksy1d, "gxksy1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksy1d, "gxksy1d", *sat_index);
        }

              
  {
    pulsename(&isi_satyk1,"isi_satyk1");
    createconst(&isi_satyk1,(WF_PROCESSOR)wg_isi_satyk1,pw_isi_satyk1,(short)0); 
    createinstr( &isi_satyk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk1,0);
  }

        getctrl(&ctrl_word, &isi_satyk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satyk1, *sat_index);

                
  {
    pulsename(&rot_update_yk1,"rot_update_yk1");
    createconst(&rot_update_yk1,(WF_PROCESSOR)wg_rot_update_yk1,pw_rot_update_yk1,(short)0); 
    createinstr( &rot_update_yk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk1,0);
  }

        getctrl(&ctrl_word, &rot_update_yk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_yk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsaty == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy2", 
                                     (WF_PROCESSOR)wg_rfsy2);

    /* Modify resolution if scaling required */
    temp_res_rfsy2  = _temp_res_rfsy2.fixedflag ?  ((void)(res_rfsy2), temp_res_rfsy2) : res_rfsy2;
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(rfpulseInfo[RFSY2_SLOT].newres), res_rfsy2) : rfpulseInfo[RFSY2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy2a,"gyrfsy2a");
    pulsename(&gyrfsy2,"gyrfsy2");
    pulsename(&gyrfsy2d,"gyrfsy2d");
    pulsename(&rfsy2,"rfsy2");

        /*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.ybeta), pg_beta) : loggrd.ybeta;
  createramp(&gyrfsy2a,YGRAD,pw_gyrfsy2a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy2a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy2a,(LONG)(sp_sattemp+pw_gyrfsy2a-pw_gyrfsy2a),
      pw_gyrfsy2a,ia_gyrfsy2);
  createconst(&gyrfsy2,YGRAD,pw_gyrfsy2,MAX_PG_WAMP);
  createinstr( &gyrfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a),
      pw_gyrfsy2,ia_gyrfsy2);
  createramp(&gyrfsy2d,YGRAD,pw_gyrfsy2d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy2d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy2d,(LONG)(sp_sattemp+pw_gyrfsy2a+pw_gyrfsy2),
      pw_gyrfsy2d,ia_gyrfsy2);

    /* Now create the rf pulse */
    createsinc(&rfsy2,(WF_PROCESSOR)wg_rfsy2,res_rfsy2,
               MAX_PG_WAMP,cyc_rfsy2, alpha_rfsy2);
    createinstr( &rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
                pw_rfsy2,ia_rfsy2);
    linkpulses(4,&rfsy2,&gyrfsy2,&gyrfsy2a,&gyrfsy2d);
    addrfbits(&rfsy2,off_rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
              pw_rfsy2);

    pulsename(&rfsy2Theta, "rfsy2Theta");
    createreserve(&rfsy2Theta, THETA, res_rfsy2);
    addrfbits(&rfsy2Theta, off_rfsy2, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait , pw_rfsy2);
    createinstr(&rfsy2Theta, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait, pw_rfsy2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(temp_res_rfsy2), res_rfsy2) : temp_res_rfsy2;
}


	    sp_sattemp = pend(&gyrfsy2d, "gyrfsy2d", *sat_index);
	    ending = pendallssp(&rfsy2, *sat_index);
	       
  {
    pulsename(&isi_saty2,"isi_saty2");
    createconst(&isi_saty2,(WF_PROCESSOR)wg_isi_saty2,pw_isi_saty2,(short)0); 
    createinstr( &isi_saty2,(long)(ending),pw_isi_saty2,0);
  }

	    getctrl(&ctrl_word, &isi_saty2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_saty2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_y2,"rot_update_y2");
    createconst(&rot_update_y2,(WF_PROCESSOR)wg_rot_update_y2,pw_rot_update_y2,(short)0); 
    createinstr( &rot_update_y2,(long)(rot_update_time),pw_rot_update_y2,0);
  }

	    getctrl(&ctrl_word, &rot_update_y2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_y2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy2a + isi_extra);
	           

  trapezoid((WF_PROCESSOR)wg_gyksy2, "gyksy2", &gyksy2, &gyksy2a,
                        &gyksy2d, pw_gyksy2, pw_gyksy2a, pw_gyksy2d,
                        ia_gyksy2, 0, 0, 0, 0, sp_pos_killer-pw_gyksy2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksy2d, "gyksy2d", *sat_index);
	    
            if (!floatsAlmostEqualEpsilons(area_gxksy2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksy2, "gxksy2", &gxksy2, &gxksy2a,
                        &gxksy2d, pw_gxksy2, pw_gxksy2a, pw_gxksy2d,
                        ia_gxksy2, 0, 0, 0, 0, sp_pos_killer-pw_gxksy2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksy2d, "gxksy2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksy2d, "gxksy2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satyk2,"isi_satyk2");
    createconst(&isi_satyk2,(WF_PROCESSOR)wg_isi_satyk2,pw_isi_satyk2,(short)0); 
    createinstr( &isi_satyk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk2,0);
  }

	    getctrl(&ctrl_word, &isi_satyk2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satyk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_yk2,"rot_update_yk2");
    createconst(&rot_update_yk2,(WF_PROCESSOR)wg_rot_update_yk2,pw_rot_update_yk2,(short)0); 
    createinstr( &rot_update_yk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_yk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_yk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);
        }
    }

    if (opsatz != PSD_OFF)  /* Z Board */
    {
	if (opsatz == PSD_SATNEG)
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
        else if (opsatz == PSD_SATPOS)
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz2), satthickdfz) : satthickz2;
        else
            satthickdfz  = _satthickdfz.fixedflag ?  ((void)(satthickz1), satthickdfz) : satthickz1;
	
             
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz1", 
                                     (WF_PROCESSOR)wg_rfsz1);

    /* Modify resolution if scaling required */
    temp_res_rfsz1  = _temp_res_rfsz1.fixedflag ?  ((void)(res_rfsz1), temp_res_rfsz1) : res_rfsz1;
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz1a,"gzrfsz1a");
    pulsename(&gzrfsz1,"gzrfsz1");
    pulsename(&gzrfsz1d,"gzrfsz1d");
    pulsename(&rfsz1,"rfsz1");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrfsz1a,ZGRAD,pw_gzrfsz1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz1a,(LONG)(sp_sattemp+pw_gzrfsz1a-pw_gzrfsz1a),
                pw_gzrfsz1a,ia_gzrfsz1);
    createconst(&gzrfsz1,ZGRAD,pw_gzrfsz1,MAX_PG_WAMP);
    createinstr( &gzrfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a),
                pw_gzrfsz1,ia_gzrfsz1);
    createramp(&gzrfsz1d,ZGRAD,pw_gzrfsz1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz1d,(LONG)(sp_sattemp+pw_gzrfsz1a+pw_gzrfsz1),
                pw_gzrfsz1d,ia_gzrfsz1);

    /* Now create the rf pulse */
    createsinc(&rfsz1,(WF_PROCESSOR)wg_rfsz1,res_rfsz1,
               MAX_PG_WAMP,cyc_rfsz1, alpha_rfsz1);

    createinstr( &rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
                pw_rfsz1,ia_rfsz1);
    linkpulses(4,&rfsz1,&gzrfsz1,&gzrfsz1a,
               &gzrfsz1d);
    addrfbits(&rfsz1,off_rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
              pw_rfsz1);



    pulsename(&rfsz1Theta, "rfsz1Theta");
    createreserve(&rfsz1Theta, THETA, res_rfsz1);
    addrfbits(&rfsz1Theta, off_rfsz1, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait , pw_rfsz1);
    createinstr(&rfsz1Theta, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait, pw_rfsz1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(temp_res_rfsz1), res_rfsz1) : temp_res_rfsz1;
  }


        sp_sattemp = pend(&gzrfsz1d, "gzrfsz1d", *sat_index);
	
        ending = pendallssp(&rfsz1, *sat_index);
           
  {
    pulsename(&isi_satz1,"isi_satz1");
    createconst(&isi_satz1,(WF_PROCESSOR)wg_isi_satz1,pw_isi_satz1,(short)0); 
    createinstr( &isi_satz1,(long)(ending),pw_isi_satz1,0);
  }

        getctrl(&ctrl_word, &isi_satz1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satz1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_z1,"rot_update_z1");
    createconst(&rot_update_z1,(WF_PROCESSOR)wg_rot_update_z1,pw_rot_update_z1,(short)0); 
    createinstr( &rot_update_z1,(long)(rot_update_time),pw_rot_update_z1,0);
  }

        getctrl(&ctrl_word, &rot_update_z1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_z1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;
	
        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksz1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksz1, "gyksz1", &gyksz1, &gyksz1a,
                        &gyksz1d, pw_gyksz1, pw_gyksz1a, pw_gyksz1d,
                        ia_gyksz1, 0, 0, 0, 0, sp_pos_killer-pw_gyksz1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksz1d, "gyksz1d", *sat_index);
	
        if (!floatsAlmostEqualEpsilons(area_gxksz1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksz1, "gxksz1", &gxksz1, &gxksz1a,
                        &gxksz1d, pw_gxksz1, pw_gxksz1a, pw_gxksz1d,
                        ia_gxksz1, 0, 0, 0, 0, sp_pos_killer-pw_gxksz1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksz1d, "gxksz1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksz1d, "gxksz1d", *sat_index);
        }

              
  {
    pulsename(&isi_satzk1,"isi_satzk1");
    createconst(&isi_satzk1,(WF_PROCESSOR)wg_isi_satzk1,pw_isi_satzk1,(short)0); 
    createinstr( &isi_satzk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk1,0);
  }

        getctrl(&ctrl_word, &isi_satzk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satzk1, *sat_index);
	
                
  {
    pulsename(&rot_update_zk1,"rot_update_zk1");
    createconst(&rot_update_zk1,(WF_PROCESSOR)wg_rot_update_zk1,pw_rot_update_zk1,(short)0); 
    createinstr( &rot_update_zk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk1,0);
  }

        getctrl(&ctrl_word, &rot_update_zk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_zk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;
	
        if (opsatz == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz2", 
                                     (WF_PROCESSOR)wg_rfsz2);

    /* Modify resolution if scaling required */
    temp_res_rfsz2  = _temp_res_rfsz2.fixedflag ?  ((void)(res_rfsz2), temp_res_rfsz2) : res_rfsz2;
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(rfpulseInfo[RFSZ2_SLOT].newres), res_rfsz2) : rfpulseInfo[RFSZ2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz2a,"gzrfsz2a");
    pulsename(&gzrfsz2,"gzrfsz2");
    pulsename(&gzrfsz2d,"gzrfsz2d");
    pulsename(&rfsz2,"rfsz2");

    /*  Now create the slice select trapezoid */
        pg_beta  = _pg_beta.fixedflag ?  ((void)(loggrd.zbeta), pg_beta) : loggrd.zbeta;
    createramp(&gzrfsz2a,ZGRAD,pw_gzrfsz2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz2a,(LONG)(sp_sattemp+pw_gzrfsz2a-pw_gzrfsz2a),
                pw_gzrfsz2a,ia_gzrfsz2);
    createconst(&gzrfsz2,ZGRAD,pw_gzrfsz2,MAX_PG_WAMP);
    createinstr( &gzrfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a),
                pw_gzrfsz2,ia_gzrfsz2);
    createramp(&gzrfsz2d,ZGRAD,pw_gzrfsz2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz2d,(LONG)(sp_sattemp+pw_gzrfsz2a+pw_gzrfsz2),
                pw_gzrfsz2d,ia_gzrfsz2);

    /* Now create the rf pulse */
    createsinc(&rfsz2,(WF_PROCESSOR)wg_rfsz2,res_rfsz2,
               MAX_PG_WAMP,cyc_rfsz2, alpha_rfsz2);

    createinstr( &rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
                pw_rfsz2,ia_rfsz2);
    linkpulses(4,&rfsz2,&gzrfsz2,&gzrfsz2a,
               &gzrfsz2d);
    addrfbits(&rfsz2,off_rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
              pw_rfsz2);



    pulsename(&rfsz2Theta, "rfsz2Theta");
    createreserve(&rfsz2Theta, THETA, res_rfsz2);
    addrfbits(&rfsz2Theta, off_rfsz2, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait , pw_rfsz2);
    createinstr(&rfsz2Theta, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait, pw_rfsz2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(temp_res_rfsz2), res_rfsz2) : temp_res_rfsz2;
  }


	    sp_sattemp = pend(&gzrfsz2d, "gzrfsz2d", *sat_index);
	    
	    ending = pendallssp(&rfsz2, *sat_index);
	       
  {
    pulsename(&isi_satz2,"isi_satz2");
    createconst(&isi_satz2,(WF_PROCESSOR)wg_isi_satz2,pw_isi_satz2,(short)0); 
    createinstr( &isi_satz2,(long)(ending),pw_isi_satz2,0);
  }

	    getctrl(&ctrl_word, &isi_satz2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satz2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_z2,"rot_update_z2");
    createconst(&rot_update_z2,(WF_PROCESSOR)wg_rot_update_z2,pw_rot_update_z2,(short)0); 
    createinstr( &rot_update_z2,(long)(rot_update_time),pw_rot_update_z2,0);
  }

	    getctrl(&ctrl_word, &rot_update_z2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_z2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;	    

	    sp_pos_killer = sp_sattemp + pw_gyksz2a + isi_extra;
	          

  trapezoid((WF_PROCESSOR)wg_gyksz2, "gyksz2", &gyksz2, &gyksz2a,
                        &gyksz2d, pw_gyksz2, pw_gyksz2a, pw_gyksz2d,
                        ia_gyksz2, 0, 0, 0, 0, sp_pos_killer-pw_gyksz2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksz2d, "gyksz2d", *sat_index);
	    
            if (!floatsAlmostEqualEpsilons(area_gxksz2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksz2, "gxksz2", &gxksz2, &gxksz2a,
                        &gxksz2d, pw_gxksz2, pw_gxksz2a, pw_gxksz2d,
                        ia_gxksz2, 0, 0, 0, 0, sp_pos_killer-pw_gxksz2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksz2d, "gxksz2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksz2d, "gxksz2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satzk2,"isi_satzk2");
    createconst(&isi_satzk2,(WF_PROCESSOR)wg_isi_satzk2,pw_isi_satzk2,(short)0); 
    createinstr( &isi_satzk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk2,0);
  }

	    getctrl(&ctrl_word, &isi_satzk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satzk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_zk2,"rot_update_zk2");
    createconst(&rot_update_zk2,(WF_PROCESSOR)wg_rot_update_zk2,pw_rot_update_zk2,(short)0); 
    createinstr( &rot_update_zk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_zk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_zk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
        }
    }
    
    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */
    
    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT.  The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/

    switch (sat_type) 
    {
        /* If hadamard, create and load in hadamard */
    case SINC_SAT:
	
	/* Change resolutions if rfpulse scaled */
	if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
            res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
	if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
            res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
	if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
            res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;

	if (opsatx == PSD_SATHAD) 
	  {
	    separation = 2*satspacex1/satthickx1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsx1, max_pg_wamp, separation,
		      cyc_rfsx1, alpha_rfsx1);
	    movewaveimm(wave_space_rho, &rfsx1, (INT)0, res_rfsx1, TOHARDWARE);
	  }
	
	if (opsaty == PSD_SATHAD) 
	  {
	    separation = 2*satspacey1/satthicky1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsy1, max_pg_wamp, separation,
		      cyc_rfsy1, alpha_rfsy1);
	    movewaveimm(wave_space_rho, &rfsy1, (INT)0, res_rfsy1, TOHARDWARE);
	  }
	
	if (opsatz == PSD_SATHAD) 
	  {
	    separation = 2*satspacez1/satthickz1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsz1, max_pg_wamp, separation,
		      cyc_rfsz1, alpha_rfsz1);
	    movewaveimm(wave_space_rho, &rfsz1, (INT)0, res_rfsz1, TOHARDWARE);
	  }
	
	FreeNode(wave_space_rho);
	break;
	
	/* Include SLR RF files  */
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type)
        {
        case SLR_SAT:
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;

        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;

        default:
             break;
        }
	
	if (opsatx != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsx1  = _res_rfsx1.fixedflag ?  ((void)(rfpulseInfo[RFSX1_SLOT].newres), res_rfsx1) : rfpulseInfo[RFSX1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
                }
	      }

	    if (opsatx == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacex1/2.0/satthickx1;
		freqstep = 65536.0/(float) res_rfsx1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, kernel_tab_theta, cyc_rfsx1,
			 separation, gscale_rfsx1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                  
                   movewaveimm(hadamard_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                         TOHARDWARE);

                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfsx1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
				TOHARDWARE); 

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
	      }
	    else
	      { 
		movewaveimm(kernel_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                               TOHARDWARE);
                }

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
		/* Check for parallel sat region */
		if (opsatx == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }

			res_rfsx2  = _res_rfsx2.fixedflag ?  ((void)(rfpulseInfo[RFSX2_SLOT].newres), res_rfsx2) : rfpulseInfo[RFSX2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsx2, (INT)0, res_rfsx2,
				TOHARDWARE); 
                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsx2Theta, (INT)0, res_rfsx2,
                                   TOHARDWARE);
                    }
		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsaty != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsy1  = _res_rfsy1.fixedflag ?  ((void)(rfpulseInfo[RFSY1_SLOT].newres), res_rfsy1) : rfpulseInfo[RFSY1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
                }
	      }

	    if (opsaty == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacey1/2.0/satthicky1;
		freqstep = 65536.0/(float) res_rfsy1;

                if (sat_pulse_type == COMPLEX_RF)
                {
    		   altcomplexrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, kernel_tab_theta, cyc_rfsy1,
			 separation, gscale_rfsy1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, cyc_rfsy1,
                         separation, gscale_rfsy1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }
		movewaveimm(hadamard_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE); 

		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                               TOHARDWARE);
                }
		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);  
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta); 
                   }
                }
		if (opsaty == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }
			res_rfsy2  = _res_rfsy2.fixedflag ?  ((void)(rfpulseInfo[RFSY2_SLOT].newres), res_rfsy2) : rfpulseInfo[RFSY2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho;  
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta; 
                        }
                      }
		  movewaveimm(kernel_tab_rho, &rfsy2, (INT)0, res_rfsy2, 
			      TOHARDWARE);
                  if (sat_pulse_type == COMPLEX_RF)
                  {
                     movewaveimm(kernel_tab_theta, &rfsy2Theta, (INT)0, res_rfsy2,
                                 TOHARDWARE);
                  }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsatz != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsz1  = _res_rfsz1.fixedflag ?  ((void)(rfpulseInfo[RFSZ1_SLOT].newres), res_rfsz1) : rfpulseInfo[RFSZ1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
                }
	      }

	    if (opsatz == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacez1/2.0/satthickz1;
		freqstep = 65536.0/(float) res_rfsz1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, kernel_tab_theta, cyc_rfsz1,
			 separation, gscale_rfsz1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                   movewaveimm(hadamard_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, cyc_rfsz1,
                         separation, gscale_rfsz1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                              TOHARDWARE);
                }
		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
		if (opsatz == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        } 

			res_rfsz2  = _res_rfsz2.fixedflag ?  ((void)(rfpulseInfo[RFSZ2_SLOT].newres), res_rfsz2) : rfpulseInfo[RFSZ2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsz2, (INT)0, res_rfsz2, 
				TOHARDWARE); 

                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsz2Theta, (INT)0, res_rfsz2,
                                   TOHARDWARE);
                    }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    *sat_index += 1;
    
    return SUCCESS;
}

STATUS
SpSatPG_fgre( INT sat_type,
              INT start_time,
              INT *sat_index,
              INT cardiacsat_pos,
              INT seq_time )
{
    SpSatPG(sat_type, start_time, sat_index, cardiacsat_pos);
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return (SUCCESS);
    else
    {
          
  {
    pulsename(&seqsat_fgre,"seqsat_fgre");
    createseq(&seqsat_fgre,seq_time, off_seqsat_fgre);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsat_fgre );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsat_fgre = %d\n", idx_seqsat_fgre );
#endif
  }

        return (SUCCESS);
    }
}

/* Create a null sequence */
STATUS
SpSatCatRelaxPG( INT ssi_time )
{
    INT seq_time;
  
       
  {
    pulsename(&y_ccs_null,"y_ccs_null");
    createconst(&y_ccs_null,(WF_PROCESSOR)wg_y_ccs_null,pw_y_ccs_null,(short)0); 
    createinstr( &y_ccs_null,(long)(RUP_GRD(8  )),pw_y_ccs_null,0);
  }

  
    seq_time = RUP_GRD(ccs_relaxseqtime - ssi_time);
    
  {
    pulsename(&cat_seq,"cat_seq");
    createseq(&cat_seq,seq_time, off_cat_seq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_cat_seq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_cat_seq = %d\n", idx_cat_seq );
#endif
  }

  
    return SUCCESS;
}

STATUS
SpSatCatRelaxOffsets( SEQUENCE_ENTRIES sequence_offsets )
{
    off_cat_seq[(int)TYPXGRAD]= sequence_offsets[(int)TYPXGRAD];
    off_cat_seq[(int)TYPZGRAD]= sequence_offsets[(int)TYPZGRAD];
  
    return SUCCESS;
}

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/

#include "addrfbits.h"
#include "rfsspsummary.h"

int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short dyntg_txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1  = _temp_res_rf2mps1.fixedflag ?  ((void)(res_rf2mps1), temp_res_rf2mps1) : res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(rfpulseInfo[RF2_APS1_SLOT].newres), res_rf2mps1) : rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1  = _res_rf2mps1.fixedflag ?  ((void)(temp_res_rf2mps1), res_rf2mps1) : temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl  = _temp_res_rf1cfl.fixedflag ?  ((void)(res_rf1cfl), temp_res_rf1cfl) : res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(rfpulseInfo[RF1_CFL_SLOT].newres), res_rf1cfl) : rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cflloggrd.zbeta), pg_beta) : cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl  = _res_rf1cfl.fixedflag ?  ((void)(temp_res_rf1cfl), res_rf1cfl) : temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


        if(3 == rcvn_flag)   /* Additional gradient waveform for Grad prognostic */
        {
            long ctrl_word;

               
  {
    pulsename(&grd_trig,"grd_trig");
    createconst(&grd_trig,(WF_PROCESSOR)wg_grd_trig,pw_grd_trig,(short)0); 
    createinstr( &grd_trig,(long)(posstart),pw_grd_trig,0);
  }

            getctrl(&ctrl_word, &grd_trig, 0);
            ctrl_word = ctrl_word | PSD_GRADR_SYNC;
            setctrl(ctrl_word, &grd_trig, 0);
            posstart = RUP_GRD(pendallssp(&grd_trig, 0)); 

            postemp = RUP_GRD(pend(&gxkrcvnd,"gxkrcvnd",0) + pw_gxk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gxk2rcvn, "gxk2rcvn", &gxk2rcvn, &gxk2rcvna,
                        &gxk2rcvnd, pw_gxk2rcvn, pw_gxk2rcvna, pw_gxk2rcvnd,
                        ia_gxk2rcvn, 0, 0, 0, 0, postemp-pw_gxk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gykrcvnd,"gykrcvnd",0) + pw_gyk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gyk2rcvn, "gyk2rcvn", &gyk2rcvn, &gyk2rcvna,
                        &gyk2rcvnd, pw_gyk2rcvn, pw_gyk2rcvna, pw_gyk2rcvnd,
                        ia_gyk2rcvn, 0, 0, 0, 0, postemp-pw_gyk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gzkrcvnd,"gzkrcvnd",0) + pw_gzk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gzk2rcvn, "gzk2rcvn", &gzk2rcvn, &gzk2rcvna,
                        &gzk2rcvnd, pw_gzk2rcvn, pw_gzk2rcvna, pw_gzk2rcvnd,
                        ia_gzk2rcvn, 0, 0, 0, 0, postemp-pw_gzk2rcvna, TRAP_ALL,
                        &rcvnloggrd);

        }
    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);

                movestretchedwave( grad_zrf0cfh, res_gzrf0cfh,
                                   &gzrf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh  = _cyc_rf0cfh.fixedflag ?  ((void)(1.0), cyc_rf0cfh) : 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

            movestretchedwave( rf_rf0cfh, res_rf0cfh,
                               &rf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {
        INT old_res =  res_omegarf0cfh; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0cfh  = _n_omegarf0cfh.fixedflag ?  ((void)(1), n_omegarf0cfh) : n_omegarf0cfh+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

                movestretchedwave( fileloc_omegarf0cfh, old_res,
                                   &omegarf0cfh, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(new_res), res_omegarf0cfh) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh  = _res_omegarf0cfh.fixedflag ?  ((void)(old_res), res_omegarf0cfh) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh  = _temp_res_rf1cfh.fixedflag ?  ((void)(res_rf1cfh), temp_res_rf1cfh) : res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(rfpulseInfo[RF1_CFH_SLOT].newres), res_rf1cfh) : rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(cfhloggrd.zbeta), pg_beta) : cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh  = _res_rf1cfh.fixedflag ?  ((void)(temp_res_rf1cfh), res_rf1cfh) : temp_res_rf1cfh;
  }


    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (int)(0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                       + IMax(2, min_ssp,
                              (pw_gzrf1cfhd + pw_gzrf2lcfha
                               + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                       + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                       + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                            + IMax(2, min_ssp,
                                   (pw_gzrf1cfhd + pw_gzrf2lcfha
                                    + pw_gzrf2lcfh + pw_gzrf2lcfhd)));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                                 IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                                 + presscfh_wait_rf12);

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = (int)(0.5 * pw_rf3cfh
                                    + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                                    + presscfh_wait_rf23);
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = (int)(0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                                    + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                                    + presscfh_wait_rf34);

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh  = _res_rf2cfh.fixedflag ?  ((void)(rfpulseInfo[RF2_CFH_SLOT].newres), res_rf2cfh) : rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


      
  {
    pulsename(&seqcfhwait,"seqcfhwait");
    createseq(&seqcfhwait,wait_time_before_cfh, off_seqcfhwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfhwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfhwait = %d\n", idx_seqcfhwait );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr  = _csw_tr.fixedflag ?          
           ((void)(15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi), csw_tr) : 15+delay_rfhubsel+pw_contrfhubsel+pw_contrfsel+SSP_UPDATE_TIME+csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr  = _csw_tr.fixedflag ?  ((void)(RUP_GRD(1000)), csw_tr) : RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg  = _temp_res_rf1ftg.fixedflag ?  ((void)(res_rf1ftg), temp_res_rf1ftg) : res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(rfpulseInfo[RF1_FTG_SLOT].newres), res_rf1ftg) : rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg  = _res_rf1ftg.fixedflag ?  ((void)(temp_res_rf1ftg), res_rf1ftg) : temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg  = _temp_res_rf2ftg.fixedflag ?  ((void)(res_rf2ftg), temp_res_rf2ftg) : res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(rfpulseInfo[RF2_FTG_SLOT].newres), res_rf2ftg) : rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg  = _res_rf2ftg.fixedflag ?  ((void)(temp_res_rf2ftg), res_rf2ftg) : temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg  = _temp_res_rf3ftg.fixedflag ?  ((void)(res_rf3ftg), temp_res_rf3ftg) : res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(rfpulseInfo[RF3_FTG_SLOT].newres), res_rf3ftg) : rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg  = _res_rf3ftg.fixedflag ?  ((void)(temp_res_rf3ftg), res_rf3ftg) : temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGyKXTG;          /* Y Killer pulse location          */
    INT PosOffResXTG;       /* Off resonance pulse location     */
    INT PosGzDephaserXTG;   /* Slice dephaser location          */
    INT PosGzRephaserXTG;   /* Slice rephaser location          */
    INT PosReadoutWindow;   /* Readout window location          */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

    }

    /* Set timing for YKillerL */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerL at same time as ZDephaser */
        PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                            pw_rf2xtg/2 - IMax(2, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld,
                            pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga) + pw_gykxtgla);
    }
    else
    {
        /* Apply YKillerL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gyrf1xtgd + pw_gykxtgla);
        }
        else
        {
            /* RF1 + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gykxtgla);
        }
    }
    /* Create YKillerL */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiL, accounting for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gyrf1xtgd));
        }
        else
        {
            /* RF1 + GzRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gzrf1xtgd));
        }
    }
    else
    {
        /* Apply FermiL after YKillerL */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf1xtg,"rf1xtg",0) + min_ssp, pendall(&gykxtgl,0)));
    }
    /* Create FermiL */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    /* theta1 Slice Dephaser */
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzDephaserXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                               pw_rf2xtg/2 - pw_gzrf2xtga - pw_gz1xtgd - pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGzDephaserXTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* rf2xtg Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 - pw_rf2xtg/2);
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg  = _temp_res_rf2xtg.fixedflag ?  ((void)(res_rf2xtg), temp_res_rf2xtg) : res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(rfpulseInfo[RF2_XTG_SLOT].newres), res_rf2xtg) : rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(ps1loggrd.zbeta), pg_beta) : ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg  = _res_rf2xtg.fixedflag ?  ((void)(temp_res_rf2xtg), res_rf2xtg) : temp_res_rf2xtg;
  }


    /* theta2 Slice Rephaser */ 
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzRephaserXTG = pendall(&gzrf2xtg, 0) + pw_gz2xtga;
           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGzRephaserXTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiR, account for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiR after both ZRephaser and YKillerR */
        PosOffResXTG = RUP_GRD(pendall(&gzrf2xtg,0) - pw_gzrf2xtgd +
                               IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd,
                                                     pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd)));
    }
    else
    {
        /* Apply FermiR after ZRephaser */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf2xtg,"rf2xtg",0) + min_ssp, pendall(&gz2xtg,0)));
    }
    /* Create FermiR */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    /* Set timing for YKillerR */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerR after GzRF2 */
        PosGyKXTG = pendall(&gzrf2xtg,0) + pw_gykxtgra;
    }
    else
    {
        /* Apply YKillerR after FermiR */
        PosGyKXTG = RUP_GRD(pendall(&rf4xtg,0) + pw_gykxtgra);
    }
    /* Create YKillerR */
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout dephaser */
    postemp = RUP_GRD(pendall(&rf2xtg,0) - pw_rf2xtg/2 + XTGtau1 - 
                      pw_gxw1xtg/2-pw_gxw1xtga - pw_gx1bxtgd - pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout window */
    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 +
                                   2*XTGtau1 - pw_gxw1xtg/2));
    /* HD--Error Check For Gradient Overlap. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga))
    {
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }
           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0))); /* Update PosReadoutWindow to final value */
         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);
     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as  = _temp_res_rf1as.fixedflag ?  ((void)(res_rf1as), temp_res_rf1as) : res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(rfpulseInfo[RF1_AUTOSHIM].newres), res_rf1as) : rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(asloggrd.zbeta), pg_beta) : asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as  = _res_rf1as.fixedflag ?  ((void)(temp_res_rf1as), res_rf1as) : temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    disableRfSspControl();
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }

    enableRfSspControl();

        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(PSTR_PASS), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay  = _DD_delay.fixedflag ?  ((void)(2000), DD_delay) : 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(rfpulseInfo[RF1_RFSHIM_SLOT].newres), res_rf1rs) : rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs  = _res_rf1rs.fixedflag ?  ((void)(temp_res), res_rf1rs) : temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbrs; /* temp holder for old pulse resolution */

    if ( (wg_rfbrs != TYPRHO1)  && (wg_rfbrs != TYPRHO2) &&
         (wg_rfbrs != TYPTHETA) && (wg_rfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbrs  = _n_rfbrs.fixedflag ?  ((void)(1), n_rfbrs) : n_rfbrs+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbrs,"rfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbrs, (WF_PROCESSOR)wg_rfbrs, new_res);

                movestretchedwave( fileloc_rfbrs, old_res,
                                   &rfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(new_res), res_rfbrs) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
                          old_res,fileloc_rfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbrs,ia_rfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbrs,off_rfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbrs);
    

    /*** Reset Resolution ***/
    res_rfbrs  = _res_rfbrs.fixedflag ?  ((void)(old_res), res_rfbrs) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbrs; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbrs != TYPRHO1)  && (wg_thetarfbrs != TYPRHO2) &&
         (wg_thetarfbrs != TYPTHETA) && (wg_thetarfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbrs  = _n_thetarfbrs.fixedflag ?  ((void)(1), n_thetarfbrs) : n_thetarfbrs+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbrs,"thetarfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbrs, (WF_PROCESSOR)wg_thetarfbrs, new_res);

                movestretchedwave( fileloc_thetarfbrs, old_res,
                                   &thetarfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(new_res), res_thetarfbrs) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
                          old_res,fileloc_thetarfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbrs,ia_thetarfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbrs,off_thetarfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbrs);
    

    /*** Reset Resolution ***/
    res_thetarfbrs  = _res_thetarfbrs.fixedflag ?  ((void)(old_res), res_thetarfbrs) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbrs, &rfbrs, 0);
    setiamp(ia_thetarfbrs, &thetarfbrs, 0);

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(rfpulseInfo[RF1_DYNTG_SLOT].newres), res_rf1dtg) : rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg  = _res_rf1dtg.fixedflag ?  ((void)(temp_res), res_rf1dtg) : temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     minimumPreRfSspTime() + minimumPostRfSspTime() );

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_rfbdtg != TYPRHO1)  && (wg_rfbdtg != TYPRHO2) &&
         (wg_rfbdtg != TYPTHETA) && (wg_rfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbdtg  = _n_rfbdtg.fixedflag ?  ((void)(1), n_rfbdtg) : n_rfbdtg+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbdtg,"rfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbdtg, (WF_PROCESSOR)wg_rfbdtg, new_res);

                movestretchedwave( fileloc_rfbdtg, old_res,
                                   &rfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(new_res), res_rfbdtg) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
                          old_res,fileloc_rfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbdtg,ia_rfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbdtg,off_rfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbdtg);
    

    /*** Reset Resolution ***/
    res_rfbdtg  = _res_rfbdtg.fixedflag ?  ((void)(old_res), res_rfbdtg) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbdtg != TYPRHO1)  && (wg_thetarfbdtg != TYPRHO2) &&
         (wg_thetarfbdtg != TYPTHETA) && (wg_thetarfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbdtg  = _n_thetarfbdtg.fixedflag ?  ((void)(1), n_thetarfbdtg) : n_thetarfbdtg+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbdtg,"thetarfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbdtg, (WF_PROCESSOR)wg_thetarfbdtg, new_res);

                movestretchedwave( fileloc_thetarfbdtg, old_res,
                                   &thetarfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(new_res), res_thetarfbdtg) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
                          old_res,fileloc_thetarfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbdtg,ia_thetarfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbdtg,off_thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbdtg);
    

    /*** Reset Resolution ***/
    res_thetarfbdtg  = _res_thetarfbdtg.fixedflag ?  ((void)(old_res), res_thetarfbdtg) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbdtg, &rfbdtg, 0);
    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}



/*
 *  ExtCalpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcalwa  = _ia_gzcombcalwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzcombcalwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcalwb  = _ia_gzcombcalwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzcombcalwb) : max_pg_wamp;

    ia_gzprcalwa  = _ia_gzprcalwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzprcalwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcalwb  = _ia_gzprcalwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzprcalwb) : max_pg_wamp;

    /* selective RF1 */
    PosStart = td0cal + pw_gzrf1cala;

         
               
  {
        INT old_res =  res_rf1cal; /* temp holder for old pulse resolution */

    if ( (wg_rf1cal != TYPRHO1)  && (wg_rf1cal != TYPRHO2) &&
         (wg_rf1cal != TYPTHETA) && (wg_rf1cal != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1cal  = _n_rf1cal.fixedflag ?  ((void)(1), n_rf1cal) : n_rf1cal+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1cal.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1cal,"rf1cal");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1cal].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1cal].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1cal, (WF_PROCESSOR)wg_rf1cal, new_res);

                movestretchedwave( fileloc_rf1cal, old_res,
                                   &rf1cal, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(new_res), res_rf1cal) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1cal,(WF_PROCESSOR)wg_rf1cal,
                          old_res,fileloc_rf1cal);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1cal,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1cal,ia_rf1cal);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1cal,off_rf1cal,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1cal);
    

    /*** Reset Resolution ***/
    res_rf1cal  = _res_rf1cal.fixedflag ?  ((void)(old_res), res_rf1cal) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1cal, &rf1cal, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1cal, "gzrf1cal", &gzrf1cal, &gzrf1cala,
                        &gzrf1cald, pw_gzrf1cal, pw_gzrf1cala, pw_gzrf1cald,
                        ia_gzrf1cal, 0, 0, 0, 0, pbeg(&rf1cal,"rf1cal",0)-psd_rf_wait-pw_gzrf1cala, TRAP_ALL,
                        &calloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) + pw_gzrf1cald);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcal_mem[res_gzcombcal];
        s16 gzcombcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1290_pg_beta=pg_beta,&_temp1290_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcombcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcalf != 0))
        {
            uramp( (&gzcombcal_mem[gzcombcal_indx]),
                   (pw_gzcombcalf/per_gzcombcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcal_indx = ( pw_gzcombcalf/ per_gzcombcal );
            gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcala/per_gzcombcal),
               (short) 0, ia_gzcombcalwa , pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcalf)/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcal_mem[gzcombcal_indx]),
              (pw_gzcombcal/per_gzcombcal),
              ia_gzcombcalwa, ia_gzcombcalwb, pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcal + pw_gzcombcalf )/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcald/per_gzcombcal),
               ia_gzcombcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcal, "gzcombcal" );
        createreserve( &gzcombcal, (WF_PROCESSOR)wg_gzcombcal, res_gzcombcal );
        createinstr( &gzcombcal,(LONG)(PosTemp+pw_gzcombcala-pw_gzcombcala - 
                                         pw_gzcombcalf),
                     (pw_gzcombcalf + pw_gzcombcala + 
                      pw_gzcombcal + pw_gzcombcald), 
                     ia_gzcombcal );
        /* Move user pulse into waveform mem */
        gzcombcal_mem[res_gzcombcal-1] |= WEOS_BIT;  
        movewaveimm(gzcombcal_mem, &gzcombcal, 
                    (int)0, res_gzcombcal, TOHARDWARE);
        if ((wg_gzcombcal==TYPRHO1)||(wg_gzcombcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcal,0,(LONG)(PosTemp+pw_gzcombcala),
                      (pw_gzcombcala + pw_gzcombcal + pw_gzcombcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcal, "gzcombcal",
                   &gzcombcal, &gzcombcala, &gzcombcald,
                   pw_gzcombcal, pw_gzcombcala, pw_gzcombcald,
                   ia_gzcombcal, ia_gzcombcalwa, ia_gzcombcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcala - pw_gzcombcala - pw_gzcombcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal + tacq_cal/2 + pw_gzprcala);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcal_mem[res_gzprcal];
        s16 gzprcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1291_pg_beta=pg_beta,&_temp1291_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzprcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcalf != 0))
        {
            uramp( (&gzprcal_mem[gzprcal_indx]),
                   (pw_gzprcalf/per_gzprcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcal_indx = ( pw_gzprcalf/ per_gzprcal );
            gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcala/per_gzprcal),
               (short) 0, ia_gzprcalwa , pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcalf)/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcal_mem[gzprcal_indx]),
              (pw_gzprcal/per_gzprcal),
              ia_gzprcalwa, ia_gzprcalwb, pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcal + pw_gzprcalf )/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcald/per_gzprcal),
               ia_gzprcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcal, "gzprcal" );
        createreserve( &gzprcal, (WF_PROCESSOR)wg_gzprcal, res_gzprcal );
        createinstr( &gzprcal,(LONG)(PosTemp-pw_gzprcala - 
                                         pw_gzprcalf),
                     (pw_gzprcalf + pw_gzprcala + 
                      pw_gzprcal + pw_gzprcald), 
                     ia_gzprcal );
        /* Move user pulse into waveform mem */
        gzprcal_mem[res_gzprcal-1] |= WEOS_BIT;  
        movewaveimm(gzprcal_mem, &gzprcal, 
                    (int)0, res_gzprcal, TOHARDWARE);
        if ((wg_gzprcal==TYPRHO1)||(wg_gzprcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcal,0,(LONG)(PosTemp),
                      (pw_gzprcala + pw_gzprcal + pw_gzprcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcal, "gzprcal",
                   &gzprcal, &gzprcala, &gzprcald,
                   pw_gzprcal, pw_gzprcala, pw_gzprcald,
                   ia_gzprcal, ia_gzprcalwa, ia_gzprcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcala - pw_gzprcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal - tacq_cal/2); /* from TE */
         

  trapezoid((WF_PROCESSOR)wg_gxwcal, "gxwcal", &gxwcal, &gxwcala,
                        &gxwcald, pw_gxwcal, pw_gxwcala, pw_gxwcald,
                        ia_gxwcal, 0, 0, 0, 0, PosTemp-pw_gxwcala, TRAP_ALL,
                        &calloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1cal,"echo1cal");
    acqq(&echo1cal, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1cal,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcal,"d3dcal");
    create3dim(&d3dcal,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcal, 0) - (pw_gx1cal + pw_gx1cald));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1cal_mem[res_gx1cal];
        s16 gx1cal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1292_pg_beta=pg_beta,&_temp1292_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gx1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1calf != 0))
        {
            uramp( (&gx1cal_mem[gx1cal_indx]),
                   (pw_gx1calf/per_gx1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1cal_indx = ( pw_gx1calf/ per_gx1cal );
            gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cala/per_gx1cal),
               (short) 0, ia_gx1calwa , pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1calf)/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1cal_mem[gx1cal_indx]),
              (pw_gx1cal/per_gx1cal),
              ia_gx1calwa, ia_gx1calwb, pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1cal + pw_gx1calf )/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cald/per_gx1cal),
               ia_gx1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1cal, "gx1cal" );
        createreserve( &gx1cal, (WF_PROCESSOR)wg_gx1cal, res_gx1cal );
        createinstr( &gx1cal,(LONG)(PosTemp-pw_gx1cala - 
                                         pw_gx1calf),
                     (pw_gx1calf + pw_gx1cala + 
                      pw_gx1cal + pw_gx1cald), 
                     ia_gx1cal );
        /* Move user pulse into waveform mem */
        gx1cal_mem[res_gx1cal-1] |= WEOS_BIT;  
        movewaveimm(gx1cal_mem, &gx1cal, 
                    (int)0, res_gx1cal, TOHARDWARE);
        if ((wg_gx1cal==TYPRHO1)||(wg_gx1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1cal,0,(LONG)(PosTemp),
                      (pw_gx1cala + pw_gx1cal + pw_gx1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1cal, "gx1cal",
                   &gx1cal, &gx1cala, &gx1cald,
                   pw_gx1cal, pw_gx1cala, pw_gx1cald,
                   ia_gx1cal, ia_gx1calwa, ia_gx1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1cala - pw_gx1calf),
                   TRAP_ALL, &calloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1cal,"gzrf1cal",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1cal_mem[res_gy1cal];
        s16 gy1cal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1293_pg_beta=pg_beta,&_temp1293_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1calf != 0))
        {
            uramp( (&gy1cal_mem[gy1cal_indx]),
                   (pw_gy1calf/per_gy1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1cal_indx = ( pw_gy1calf/ per_gy1cal );
            gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cala/per_gy1cal),
               (short) 0, ia_gy1calwa , pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1calf)/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1cal_mem[gy1cal_indx]),
              (pw_gy1cal/per_gy1cal),
              ia_gy1calwa, ia_gy1calwb, pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1cal + pw_gy1calf )/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cald/per_gy1cal),
               ia_gy1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1cal, "gy1cal" );
        createreserve( &gy1cal, (WF_PROCESSOR)wg_gy1cal, res_gy1cal );
        createinstr( &gy1cal,(LONG)(PosTemp+pw_gy1cala-pw_gy1cala - 
                                         pw_gy1calf),
                     (pw_gy1calf + pw_gy1cala + 
                      pw_gy1cal + pw_gy1cald), 
                     ia_gy1cal );
        /* Move user pulse into waveform mem */
        gy1cal_mem[res_gy1cal-1] |= WEOS_BIT;  
        movewaveimm(gy1cal_mem, &gy1cal, 
                    (int)0, res_gy1cal, TOHARDWARE);
        if ((wg_gy1cal==TYPRHO1)||(wg_gy1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1cal,0,(LONG)(PosTemp+pw_gy1cala),
                      (pw_gy1cala + pw_gy1cal + pw_gy1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1cal, "gy1cal",
                   &gy1cal, &gy1cala, &gy1cald,
                   pw_gy1cal, pw_gy1cala, pw_gy1cald,
                   ia_gy1cal, ia_gy1calwa, ia_gy1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1cala - pw_gy1cala - pw_gy1calf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcal,"gxwcal", 0) + tacq_cal);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcal_mem[res_gy1rcal];
        s16 gy1rcal_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1294_pg_beta=pg_beta,&_temp1294_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1rcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcalf != 0))
        {
            uramp( (&gy1rcal_mem[gy1rcal_indx]),
                   (pw_gy1rcalf/per_gy1rcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcal_indx = ( pw_gy1rcalf/ per_gy1rcal );
            gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcala/per_gy1rcal),
               (short) 0, ia_gy1rcalwa , pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcalf)/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcal_mem[gy1rcal_indx]),
              (pw_gy1rcal/per_gy1rcal),
              ia_gy1rcalwa, ia_gy1rcalwb, pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcal + pw_gy1rcalf )/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcald/per_gy1rcal),
               ia_gy1rcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcal, "gy1rcal" );
        createreserve( &gy1rcal, (WF_PROCESSOR)wg_gy1rcal, res_gy1rcal );
        createinstr( &gy1rcal,(LONG)(PosTemp+pw_gy1rcala-pw_gy1rcala - 
                                         pw_gy1rcalf),
                     (pw_gy1rcalf + pw_gy1rcala + 
                      pw_gy1rcal + pw_gy1rcald), 
                     ia_gy1rcal );
        /* Move user pulse into waveform mem */
        gy1rcal_mem[res_gy1rcal-1] |= WEOS_BIT;  
        movewaveimm(gy1rcal_mem, &gy1rcal, 
                    (int)0, res_gy1rcal, TOHARDWARE);
        if ((wg_gy1rcal==TYPRHO1)||(wg_gy1rcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcal,0,(LONG)(PosTemp+pw_gy1rcala),
                      (pw_gy1rcala + pw_gy1rcal + pw_gy1rcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcal, "gy1rcal",
                   &gy1rcal, &gy1rcala, &gy1rcald,
                   pw_gy1rcal, pw_gy1rcala, pw_gy1rcald,
                   ia_gy1rcal, ia_gy1rcalwa, ia_gy1rcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcala - pw_gy1rcala - pw_gy1rcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycal,"attenuator_keycal");
  createatten(&attenuator_keycal, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcal,"seqcal");
    createseq(&seqcal,RUP_GRD(tr_cal), off_seqcal);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcal );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcal = %d\n", idx_seqcal );
#endif
  }

    attenflagon(&seqcal, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscal,"d3dpasscal");
    create3dim(&d3dpasscal,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecal,"pass_pulsecal");
    createpass(&pass_pulsecal,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcalpass,"seqcalpass");
    createseq(&seqcalpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssical), off_seqcalpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcalpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcalpass = %d\n", idx_seqcalpass );
#endif
  }


    return SUCCESS;
}   /* End of ExtCalpulsegen */


/*
 *  AutoCoilpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AutoCoilpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcoilwa  = _ia_gzcombcoilwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzcombcoilwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcoilwb  = _ia_gzcombcoilwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzcombcoilwb) : max_pg_wamp;
    
    ia_gzprcoilwa  = _ia_gzprcoilwa.fixedflag ?  ((void)((int)(PSDRAMPEDTRAP*max_pg_wamp)), ia_gzprcoilwa) : (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcoilwb  = _ia_gzprcoilwb.fixedflag ?  ((void)(max_pg_wamp), ia_gzprcoilwb) : max_pg_wamp;

    /* selective RF1 */
    PosStart = td0coil + pw_gzrf1coila;

         
               
  {
        INT old_res =  res_rf1coil; /* temp holder for old pulse resolution */

    if ( (wg_rf1coil != TYPRHO1)  && (wg_rf1coil != TYPRHO2) &&
         (wg_rf1coil != TYPTHETA) && (wg_rf1coil != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1coil  = _n_rf1coil.fixedflag ?  ((void)(1), n_rf1coil) : n_rf1coil+1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1coil.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1coil,"rf1coil");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1coil].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1coil].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1coil, (WF_PROCESSOR)wg_rf1coil, new_res);

                movestretchedwave( fileloc_rf1coil, old_res,
                                   &rf1coil, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(new_res), res_rf1coil) : new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1coil,(WF_PROCESSOR)wg_rf1coil,
                          old_res,fileloc_rf1coil);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1coil,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1coil,ia_rf1coil);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1coil,off_rf1coil,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1coil);
    

    /*** Reset Resolution ***/
    res_rf1coil  = _res_rf1coil.fixedflag ?  ((void)(old_res), res_rf1coil) : old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1coil, &rf1coil, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1coil, "gzrf1coil", &gzrf1coil, &gzrf1coila,
                        &gzrf1coild, pw_gzrf1coil, pw_gzrf1coila, pw_gzrf1coild,
                        ia_gzrf1coil, 0, 0, 0, 0, pbeg(&rf1coil,"rf1coil",0)-psd_rf_wait-pw_gzrf1coila, TRAP_ALL,
                        &coilloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) + pw_gzrf1coild);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcoil_mem[res_gzcombcoil];
        s16 gzcombcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1295_pg_beta=pg_beta,&_temp1295_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcombcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcoilf != 0))
        {
            uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
                   (pw_gzcombcoilf/per_gzcombcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcoil_indx = ( pw_gzcombcoilf/ per_gzcombcoil );
            gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoila/per_gzcombcoil),
               (short) 0, ia_gzcombcoilwa , pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoilf)/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcoil_mem[gzcombcoil_indx]),
              (pw_gzcombcoil/per_gzcombcoil),
              ia_gzcombcoilwa, ia_gzcombcoilwb, pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoilf )/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoild/per_gzcombcoil),
               ia_gzcombcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcoil, "gzcombcoil" );
        createreserve( &gzcombcoil, (WF_PROCESSOR)wg_gzcombcoil, res_gzcombcoil );
        createinstr( &gzcombcoil,(LONG)(PosTemp+pw_gzcombcoila-pw_gzcombcoila - 
                                         pw_gzcombcoilf),
                     (pw_gzcombcoilf + pw_gzcombcoila + 
                      pw_gzcombcoil + pw_gzcombcoild), 
                     ia_gzcombcoil );
        /* Move user pulse into waveform mem */
        gzcombcoil_mem[res_gzcombcoil-1] |= WEOS_BIT;  
        movewaveimm(gzcombcoil_mem, &gzcombcoil, 
                    (int)0, res_gzcombcoil, TOHARDWARE);
        if ((wg_gzcombcoil==TYPRHO1)||(wg_gzcombcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcoil,0,(LONG)(PosTemp+pw_gzcombcoila),
                      (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcoil, "gzcombcoil",
                   &gzcombcoil, &gzcombcoila, &gzcombcoild,
                   pw_gzcombcoil, pw_gzcombcoila, pw_gzcombcoild,
                   ia_gzcombcoil, ia_gzcombcoilwa, ia_gzcombcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcoila - pw_gzcombcoila - pw_gzcombcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil + tacq_coil/2 + pw_gzprcoila);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcoil_mem[res_gzprcoil];
        s16 gzprcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1296_pg_beta=pg_beta,&_temp1296_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzprcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcoilf != 0))
        {
            uramp( (&gzprcoil_mem[gzprcoil_indx]),
                   (pw_gzprcoilf/per_gzprcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcoil_indx = ( pw_gzprcoilf/ per_gzprcoil );
            gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoila/per_gzprcoil),
               (short) 0, ia_gzprcoilwa , pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoilf)/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcoil_mem[gzprcoil_indx]),
              (pw_gzprcoil/per_gzprcoil),
              ia_gzprcoilwa, ia_gzprcoilwb, pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoil + pw_gzprcoilf )/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoild/per_gzprcoil),
               ia_gzprcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcoil, "gzprcoil" );
        createreserve( &gzprcoil, (WF_PROCESSOR)wg_gzprcoil, res_gzprcoil );
        createinstr( &gzprcoil,(LONG)(PosTemp-pw_gzprcoila - 
                                         pw_gzprcoilf),
                     (pw_gzprcoilf + pw_gzprcoila + 
                      pw_gzprcoil + pw_gzprcoild), 
                     ia_gzprcoil );
        /* Move user pulse into waveform mem */
        gzprcoil_mem[res_gzprcoil-1] |= WEOS_BIT;  
        movewaveimm(gzprcoil_mem, &gzprcoil, 
                    (int)0, res_gzprcoil, TOHARDWARE);
        if ((wg_gzprcoil==TYPRHO1)||(wg_gzprcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcoil,0,(LONG)(PosTemp),
                      (pw_gzprcoila + pw_gzprcoil + pw_gzprcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcoil, "gzprcoil",
                   &gzprcoil, &gzprcoila, &gzprcoild,
                   pw_gzprcoil, pw_gzprcoila, pw_gzprcoild,
                   ia_gzprcoil, ia_gzprcoilwa, ia_gzprcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcoila - pw_gzprcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil - tacq_coil/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwcoil, "gxwcoil", &gxwcoil, &gxwcoila,
                        &gxwcoild, pw_gxwcoil, pw_gxwcoila, pw_gxwcoild,
                        ia_gxwcoil, 0, 0, 0, 0, PosTemp-pw_gxwcoila, TRAP_ALL,
                        &coilloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1coil,"echo1coil");
    acqq(&echo1coil, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1coil,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcoil,"d3dcoil");
    create3dim(&d3dcoil,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcoil, 0) - (pw_gx1coil + pw_gx1coild));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1coil_mem[res_gx1coil];
        s16 gx1coil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1297_pg_beta=pg_beta,&_temp1297_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gx1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1coilf != 0))
        {
            uramp( (&gx1coil_mem[gx1coil_indx]),
                   (pw_gx1coilf/per_gx1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1coil_indx = ( pw_gx1coilf/ per_gx1coil );
            gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coila/per_gx1coil),
               (short) 0, ia_gx1coilwa , pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coilf)/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1coil_mem[gx1coil_indx]),
              (pw_gx1coil/per_gx1coil),
              ia_gx1coilwa, ia_gx1coilwb, pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coil + pw_gx1coilf )/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coild/per_gx1coil),
               ia_gx1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1coil, "gx1coil" );
        createreserve( &gx1coil, (WF_PROCESSOR)wg_gx1coil, res_gx1coil );
        createinstr( &gx1coil,(LONG)(PosTemp-pw_gx1coila - 
                                         pw_gx1coilf),
                     (pw_gx1coilf + pw_gx1coila + 
                      pw_gx1coil + pw_gx1coild), 
                     ia_gx1coil );
        /* Move user pulse into waveform mem */
        gx1coil_mem[res_gx1coil-1] |= WEOS_BIT;  
        movewaveimm(gx1coil_mem, &gx1coil, 
                    (int)0, res_gx1coil, TOHARDWARE);
        if ((wg_gx1coil==TYPRHO1)||(wg_gx1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1coil,0,(LONG)(PosTemp),
                      (pw_gx1coila + pw_gx1coil + pw_gx1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1coil, "gx1coil",
                   &gx1coil, &gx1coila, &gx1coild,
                   pw_gx1coil, pw_gx1coila, pw_gx1coild,
                   ia_gx1coil, ia_gx1coilwa, ia_gx1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1coila - pw_gx1coilf),
                   TRAP_ALL, &coilloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1coil,"gzrf1coil",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1coil_mem[res_gy1coil];
        s16 gy1coil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1298_pg_beta=pg_beta,&_temp1298_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1coilf != 0))
        {
            uramp( (&gy1coil_mem[gy1coil_indx]),
                   (pw_gy1coilf/per_gy1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1coil_indx = ( pw_gy1coilf/ per_gy1coil );
            gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coila/per_gy1coil),
               (short) 0, ia_gy1coilwa , pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coilf)/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1coil_mem[gy1coil_indx]),
              (pw_gy1coil/per_gy1coil),
              ia_gy1coilwa, ia_gy1coilwb, pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coil + pw_gy1coilf )/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coild/per_gy1coil),
               ia_gy1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1coil, "gy1coil" );
        createreserve( &gy1coil, (WF_PROCESSOR)wg_gy1coil, res_gy1coil );
        createinstr( &gy1coil,(LONG)(PosTemp+pw_gy1coila-pw_gy1coila - 
                                         pw_gy1coilf),
                     (pw_gy1coilf + pw_gy1coila + 
                      pw_gy1coil + pw_gy1coild), 
                     ia_gy1coil );
        /* Move user pulse into waveform mem */
        gy1coil_mem[res_gy1coil-1] |= WEOS_BIT;  
        movewaveimm(gy1coil_mem, &gy1coil, 
                    (int)0, res_gy1coil, TOHARDWARE);
        if ((wg_gy1coil==TYPRHO1)||(wg_gy1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1coil,0,(LONG)(PosTemp+pw_gy1coila),
                      (pw_gy1coila + pw_gy1coil + pw_gy1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1coil, "gy1coil",
                   &gy1coil, &gy1coila, &gy1coild,
                   pw_gy1coil, pw_gy1coila, pw_gy1coild,
                   ia_gy1coil, ia_gy1coilwa, ia_gy1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1coila - pw_gy1coila - pw_gy1coilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcoil,"gxwcoil", 0) + tacq_coil);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcoil_mem[res_gy1rcoil];
        s16 gy1rcoil_indx = 0;       /* indx into user memory */

        getbeta(_pg_beta.fixedflag ? (_temp1299_pg_beta=pg_beta,&_temp1299_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gy1rcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcoilf != 0))
        {
            uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
                   (pw_gy1rcoilf/per_gy1rcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcoil_indx = ( pw_gy1rcoilf/ per_gy1rcoil );
            gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoila/per_gy1rcoil),
               (short) 0, ia_gy1rcoilwa , pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoilf)/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcoil_mem[gy1rcoil_indx]),
              (pw_gy1rcoil/per_gy1rcoil),
              ia_gy1rcoilwa, ia_gy1rcoilwb, pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoilf )/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoild/per_gy1rcoil),
               ia_gy1rcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcoil, "gy1rcoil" );
        createreserve( &gy1rcoil, (WF_PROCESSOR)wg_gy1rcoil, res_gy1rcoil );
        createinstr( &gy1rcoil,(LONG)(PosTemp+pw_gy1rcoila-pw_gy1rcoila - 
                                         pw_gy1rcoilf),
                     (pw_gy1rcoilf + pw_gy1rcoila + 
                      pw_gy1rcoil + pw_gy1rcoild), 
                     ia_gy1rcoil );
        /* Move user pulse into waveform mem */
        gy1rcoil_mem[res_gy1rcoil-1] |= WEOS_BIT;  
        movewaveimm(gy1rcoil_mem, &gy1rcoil, 
                    (int)0, res_gy1rcoil, TOHARDWARE);
        if ((wg_gy1rcoil==TYPRHO1)||(wg_gy1rcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcoil,0,(LONG)(PosTemp+pw_gy1rcoila),
                      (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcoil, "gy1rcoil",
                   &gy1rcoil, &gy1rcoila, &gy1rcoild,
                   pw_gy1rcoil, pw_gy1rcoila, pw_gy1rcoild,
                   ia_gy1rcoil, ia_gy1rcoilwa, ia_gy1rcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcoila - pw_gy1rcoila - pw_gy1rcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycoil,"attenuator_keycoil");
  createatten(&attenuator_keycoil, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcoil,"seqcoil");
    createseq(&seqcoil,RUP_GRD(tr_coil), off_seqcoil);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoil );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoil = %d\n", idx_seqcoil );
#endif
  }

    attenflagon(&seqcoil, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscoil,"d3dpasscoil");
    create3dim(&d3dpasscoil,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecoil,"pass_pulsecoil");
    createpass(&pass_pulsecoil,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcoilpass,"seqcoilpass");
    createseq(&seqcoilpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssicoil), off_seqcoilpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoilpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoilpass = %d\n", idx_seqcoilpass );
#endif
  }


    return SUCCESS;
}   /* End of AutoCoilpulsegen */




/* FOR MERGE */
#include "RtpPsd.h"
#include "RtpCommon.h"
#include "smartprepRTP.h"
#include "rtp_feedback_task.h"

int smartprep_detected = 0;
float smartprep_signal = 0.0;

#if defined(MGD_TGT) && defined(PSD_HW)
long roundtrip_time = 0;
long max_roundtrip_time = 0;
long min_roundtrip_time = 9999;
#define SPREP_NUM_TIMING_POINTS 200 
long sprep_roundtrip_timing_array[SPREP_NUM_TIMING_POINTS];
long sprep_roundtrip_index = 0;
#endif

int *mon_receive_freq1;
int *rf1mon_freq, *rf2mon_freq, *rfmontipup_freq;

float datamax[MAX_DATA_POINTS];
long nav_timing[MAX_DATA_POINTS];
float last_buff[1024];
int buffmax,buffmaxloc;
float gycylr0_scale,gzcylr0_scale;
float gycylrtipup0_scale,gzcylrtipup0_scale;


STATUS monitor_PG(void)
{
    INT postemp;

    /* CYL Nav */
    EXTERN_FILENAME rf_ext;
    EXTERN_FILENAME th_ext;
    EXTERN_FILENAME gy_ext;
    EXTERN_FILENAME gz_ext;

    short *temp_wspace_mon;
    short *wspace_mon;
    int temp_res;

    if (navigator_flag && navigatorCYL_flag)
    {
        if (CYLR_CONSTANT_DENSITY == cylr_rf_type)
        {   /* XRM */
            strcpy(rf_ext,"cylrf2400.rho");
            strcpy(th_ext,"cylrf2400.rho");
            strcpy(gy_ext,"cylgy12c2400.grd");
            strcpy(gz_ext,"cylgz12c2400.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR48 == cylr_rf_type)
        {   /* Starter */
            strcpy(rf_ext,"cylrfsr48.rho");
            strcpy(th_ext,"cylrfsr48.rho");
            strcpy(gy_ext,"cylgysr48.grd");
            strcpy(gz_ext,"cylgzsr48.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR75 == cylr_rf_type)
        {   /* TRM-W */
            strcpy(rf_ext,"cylrfsr75.rho");
            strcpy(th_ext,"cylrfsr75.rho");
            strcpy(gy_ext,"cylgysr75.grd");
            strcpy(gz_ext,"cylgzsr75.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR107 == cylr_rf_type)
        {   /* VRMW */
            strcpy(rf_ext,"cylrfsr107.rho");
            strcpy(th_ext,"cylrfsr107.rho");
            strcpy(gy_ext,"cylgysr107.grd");
            strcpy(gz_ext,"cylgzsr107.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR118 == cylr_rf_type)
        {   /* BRM/CRM */
            strcpy(rf_ext,"cylrfsr118.rho");
            strcpy(th_ext,"cylrfsr118.rho");
            strcpy(gy_ext,"cylgysr118.grd");
            strcpy(gz_ext,"cylgzsr118.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR145 == cylr_rf_type) 
        {   /* XRMW, TRM-Z */
            strcpy(rf_ext,"cylrfsr145.rho");
            strcpy(th_ext,"cylrfsr145.rho");
            strcpy(gy_ext,"cylgysr145.grd");
            strcpy(gz_ext,"cylgzsr145.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR190 == cylr_rf_type)
        {   /* XRM */
            strcpy(rf_ext,"cylrfsr190.rho");
            strcpy(th_ext,"cylrfsr190.rho");
            strcpy(gy_ext,"cylgysr190.grd");
            strcpy(gz_ext,"cylgzsr190.grd");
        }
        else
        {
            psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "Invalid cylindrical pulse type",
                    PSD_ARG_STRING, "Monitor_PG()", 0);
            return FAILURE;
        }

        /* 2D Cylindrical RF */
        
  {
    pulsename(&gycylra,"gycylra");
 
        getbeta(_pg_beta.fixedflag ? (_temp1300_pg_beta=pg_beta,&_temp1300_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gycylra, &monloggrd);
 
    if ( (start_gycylra>0.0) || (start_gycylra<0.0) )
      {
        createramp(&gycylra,(WF_PROCESSOR)wg_gycylra,pw_gycylra,
                   ia_stgycylra,ia_endgycylra,
                   (short)(maxGradRes*(pw_gycylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gycylra,(long)(tlead_monitor-pw_gycylra),pw_gycylra,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gycylra,(WF_PROCESSOR)wg_gycylra,pw_gycylra,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gycylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gycylra,(long)(tlead_monitor-pw_gycylra),pw_gycylra,
                    ia_endgycylra);
      }
  }

        
  {
    pulsename(&gzcylra,"gzcylra");
 
        getbeta(_pg_beta.fixedflag ? (_temp1301_pg_beta=pg_beta,&_temp1301_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcylra, &monloggrd);
 
    if ( (start_gzcylra>0.0) || (start_gzcylra<0.0) )
      {
        createramp(&gzcylra,(WF_PROCESSOR)wg_gzcylra,pw_gzcylra,
                   ia_stgzcylra,ia_endgzcylra,
                   (short)(maxGradRes*(pw_gzcylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzcylra,(long)(tlead_monitor-pw_gzcylra),pw_gzcylra,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gzcylra,(WF_PROCESSOR)wg_gzcylra,pw_gzcylra,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gzcylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gzcylra,(long)(tlead_monitor-pw_gzcylra),pw_gzcylra,
                    ia_endgzcylra);
      }
  }


        postemp = tlead_monitor;
        /* RFCYLR */
        temp_wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,rf_ext);
#endif
        /* Stretch rf pw if needed */ 
        temp_res = res_rfcylr;
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(rfpulseInfo[RFCYLR_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcylr,(int)rfpulseInfo[RFCYLR_SLOT].newres,temp_wspace_mon,wspace_mon);
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(rfpulseInfo[RFCYLR_SLOT].newres), res_rfcylr) : rfpulseInfo[RFCYLR_SLOT].newres;
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&rfcylr,"rfcylr");
    createreserve(&rfcylr,(WF_PROCESSOR)wg_rfcylr,
		  res_rfcylr);
  }

        createinstr(&rfcylr, postemp+psd_rf_wait, pw_rfcylr,ia_rfcylr);
        addrfbits(&rfcylr, 0, postemp+psd_rf_wait, pw_rfcylr);

        movewaveimm(wspace_mon, &rfcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* THCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,th_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&thcylr,"thcylr");
    createreserve(&thcylr,(WF_PROCESSOR)wg_thcylr,
		  res_thcylr);
  }

        createinstr(&thcylr, postemp+psd_rf_wait, pw_thcylr,ia_thcylr);

        movewaveimm(wspace_mon, &thcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* GYCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,gy_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&gycylr,"gycylr");
    createreserve(&gycylr,(WF_PROCESSOR)wg_gycylr,
		  res_gycylr);
  }

        createinstr(&gycylr, postemp, pw_gycylr,ia_gycylr);

        movewaveimm(wspace_mon, &gycylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* GZCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,gz_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&gzcylr,"gzcylr");
    createreserve(&gzcylr,(WF_PROCESSOR)wg_gzcylr,
		  res_gzcylr);
  }

        createinstr(&gzcylr, postemp, pw_gzcylr,ia_gzcylr);

        movewaveimm(wspace_mon, &gzcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* Change back incase external grad_file used */
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            res_rfcylr  = _res_rfcylr.fixedflag ?  ((void)(temp_res), res_rfcylr) : temp_res;
        }

        postemp = RUP_GRD(tlead_monitor+t_exa_cylr+act_te_cylr-rda_mon);
    } 
    else 
    {
        
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1mon", 
                                    (WF_PROCESSOR)wg_rf1mon);

    /* Modify resolution if scaling required */
    temp_res_rf1mon  = _temp_res_rf1mon.fixedflag ?  ((void)(res_rf1mon), temp_res_rf1mon) : res_rf1mon;
    if (rfpulseInfo[RF1MON_SLOT].change==PSD_ON)
       res_rf1mon  = _res_rf1mon.fixedflag ?  ((void)(rfpulseInfo[RF1MON_SLOT].newres), res_rf1mon) : rfpulseInfo[RF1MON_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1mona,"gzrf1mona");
    pulsename(&gzrf1mon,"gzrf1mon");
    pulsename(&gzrf1mond,"gzrf1mond");
    pulsename(&rf1mon,"rf1mon");
    
    /*  Now create the slice select trapezoid */
	pg_beta  = _pg_beta.fixedflag ?  ((void)(monloggrd.zbeta), pg_beta) : monloggrd.zbeta;
    createramp(&gzrf1mona,ZGRAD,pw_gzrf1mona,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1mona/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1mona,(LONG)(tlead_monitor-pw_gzrf1mona),
		pw_gzrf1mona,ia_gzrf1mon);
    createconst(&gzrf1mon,ZGRAD,pw_gzrf1mon,MAX_PG_WAMP);
    createinstr( &gzrf1mon,(LONG)(tlead_monitor),
		pw_gzrf1mon,ia_gzrf1mon);
    createramp(&gzrf1mond,ZGRAD,pw_gzrf1mond,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1mond/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1mond,(LONG)(tlead_monitor+pw_gzrf1mon),
		pw_gzrf1mond,ia_gzrf1mon);
    
    /* Now create the rf pulse */
    createsinc(&rf1mon,(WF_PROCESSOR)wg_rf1mon,res_rf1mon,
	       MAX_PG_WAMP,cyc_rf1mon, alpha_rf1mon);
    createinstr( &rf1mon,(LONG)(tlead_monitor) + psd_rf_wait,
		pw_rf1mon,ia_rf1mon);
    linkpulses(4,&rf1mon,&gzrf1mon,&gzrf1mona,
	       &gzrf1mond);
    addrfbits(&rf1mon,off_rf1mon,(LONG)(tlead_monitor) + psd_rf_wait, 
	      pw_rf1mon);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1MON_SLOT].change==PSD_ON)
       res_rf1mon  = _res_rf1mon.fixedflag ?  ((void)(temp_res_rf1mon), res_rf1mon) : temp_res_rf1mon;
  }


        

  trapezoid((WF_PROCESSOR)wg_gyrf1mon, "gyrf1mon", &gyrf1mon, &gyrf1mona,
                        &gyrf1mond, pw_gyrf1mon, pw_gyrf1mona, pw_gyrf1mond,
                        ia_gyrf1mon, 0, 0, 0, 0, tlead_monitor-pw_gyrf1mona, TRAP_ALL,
                        &monloggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mond,"gzrf1mond",0));
        

  trapezoid((WF_PROCESSOR)wg_gz1mon, "gz1mon", &gz1mon, &gz1mona,
                        &gz1mond, pw_gz1mon, pw_gz1mona, pw_gz1mond,
                        ia_gz1mon, 0, 0, 0, 0, postemp+pw_gz1mona-pw_gz1mona, TRAP_ALL,
                        &monloggrd);


        /* SVBranch HCSDM00313823. Do not generate gy1mon when selecting smartprep on SV system.
           On SV system, with 5mm tracker thickness, gy1mond and gyrf2lmona overlapped and triggered a download failure.
           As a quick solution, we removed gy1mon. This has no impact for smartprep, since amplitude of gy1mon is zero
           for smartprep. */
        if( !((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)) || !smartprep_flag)
        {
            

  trapezoid((WF_PROCESSOR)wg_gy1mon, "gy1mon", &gy1mon, &gy1mona,
                        &gy1mond, pw_gy1mon, pw_gy1mona, pw_gy1mond,
                        ia_gy1mon, 0, 0, 0, 0, postemp+pw_gy1mona-pw_gy1mona, TRAP_ALL,
                        &monloggrd);

        }

        postemp = RUP_GRD( (pbeg(&gzrf1mon,"gzrf1mon",0) + pw_gzrf1mon/2)
                   + te_180sp/2 - pw_gyrf2mon/2) ;

             
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mon", 
                                     (WF_PROCESSOR)wg_rf2mon);

    /* Modify resolution if scaling required */
    temp_res_rf2mon  = _temp_res_rf2mon.fixedflag ?  ((void)(res_rf2mon), temp_res_rf2mon) : res_rf2mon;
    if (rfpulseInfo[RF2MON_SLOT].change==PSD_ON)
      res_rf2mon  = _res_rf2mon.fixedflag ?  ((void)(rfpulseInfo[RF2MON_SLOT].newres), res_rf2mon) : rfpulseInfo[RF2MON_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrf2mona,"gyrf2mona");
    pulsename(&gyrf2mon,"gyrf2mon");
    pulsename(&gyrf2mond,"gyrf2mond");
    pulsename(&rf2mon,"rf2mon");

	/*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(monloggrd.ybeta), pg_beta) : monloggrd.ybeta;
  createramp(&gyrf2mona,YGRAD,pw_gyrf2mona,(short)0,MAX_PG_WAMP,
			(short)(maxGradRes*(pw_gyrf2mona/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrf2mona,(LONG)(postemp-pw_gyrf2mona),
      pw_gyrf2mona,ia_gyrf2mon);
  createconst(&gyrf2mon,YGRAD,pw_gyrf2mon,MAX_PG_WAMP);
  createinstr( &gyrf2mon,(LONG)(postemp),
      pw_gyrf2mon,ia_gyrf2mon);
  createramp(&gyrf2mond,YGRAD,pw_gyrf2mond,MAX_PG_WAMP,
			(short)0,(short)(maxGradRes*(pw_gyrf2mond/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrf2mond,(LONG)(postemp+pw_gyrf2mon),
      pw_gyrf2mond,ia_gyrf2mon);

    /* Now create the rf pulse */
    createsinc(&rf2mon,(WF_PROCESSOR)wg_rf2mon,res_rf2mon,
	       MAX_PG_WAMP,cyc_rf2mon, alpha_rf2mon);
    createinstr( &rf2mon,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mon,ia_rf2mon);
    linkpulses(4,&rf2mon,&gyrf2mon,&gyrf2mona,&gyrf2mond);
    addrfbits(&rf2mon,off_rf2mon,(LONG)(postemp) + psd_rf_wait,
	      pw_rf2mon);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2MON_SLOT].change==PSD_ON)
      res_rf2mon  = _res_rf2mon.fixedflag ?  ((void)(temp_res_rf2mon), res_rf2mon) : temp_res_rf2mon;
}


        /* Apply 90 phase shift to 180 pulse */
        setphase((float)(M_PI/-2.0), &rf2mon, 0);
  
        /* crushers */
        postemp = pbeg(&gyrf2mon,"gyrf2mon",0) - pw_gyrf2lmon - pw_gyrf2lmond;
           

  trapezoid((WF_PROCESSOR)wg_gyrf2lmon, "gyrf2lmon", &gyrf2lmon, &gyrf2lmona,
                        &gyrf2lmond, pw_gyrf2lmon, pw_gyrf2lmona, pw_gyrf2lmond,
                        ia_gyrf2lmon, 0, 0, 0, 0, postemp-pw_gyrf2lmona, TRAP_ALL,
                        &monloggrd);

  
             

  trapezoid((WF_PROCESSOR)wg_gyrf2rmon, "gyrf2rmon", &gyrf2rmon, &gyrf2rmona,
                        &gyrf2rmond, pw_gyrf2rmon, pw_gyrf2rmona, pw_gyrf2rmond,
                        ia_gyrf2rmon, 0, 0, 0, 0, pendall(&gyrf2mon,0)-pw_gyrf2rmona, TRAP_ALL,
                        &monloggrd);


        postemp = RUP_GRD(pmid(&gyrf2mon,"gyrf2mon",0)+ (te_180sp/2) - rda_mon);
    }

    

  trapezoid((WF_PROCESSOR)wg_gxwmon, "gxwmon", &gxwmon, &gxwmona,
                        &gxwmond, pw_gxwmon, pw_gxwmona, pw_gxwmond,
                        ia_gxwmon, 0, 0, 0, 0, postemp-pw_gxwmona, TRAP_ALL,
                        &monloggrd);
    
  
    /* read dephaser */
    postemp = RUP_GRD(pbeg(&gxwmon, "gxwmon", 0) - pw_gxwmona - pw_gx1mond - pw_gx1mon);

    

  trapezoid((WF_PROCESSOR)wg_gx1mon, "gx1mon", &gx1mon, &gx1mona,
                        &gx1mond, pw_gx1mon, pw_gx1mona, pw_gx1mond,
                        ia_gx1mon, 0, 0, 0, 0, postemp-pw_gx1mona, TRAP_ALL,
                        &monloggrd);


    if (mon_fcomp)
    {			
        /* 1st echo flow comp pulse */
        postemp = pbegall(&gx1mon,0)-(pw_gxfcmon+pw_gxfcmond);
              

  trapezoid((WF_PROCESSOR)wg_gxfcmon, "gxfcmon", &gxfcmon, &gxfcmona,
                        &gxfcmond, pw_gxfcmon, pw_gxfcmona, pw_gxfcmond,
                        ia_gxfcmon, 0, 0, 0, 0, postemp-pw_gxfcmona, TRAP_ALL,
                        &monloggrd);

    }

    /* MRIge42228  */
    /* FOR MERGE */
    /*
    ACQUIREDATA(echo1mon, pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait,pbeg(&gxwmon,"gxwmon",0)-mon_dabdelay,, 
      filter_echo1mon, TYPRECVALL, DABNORM, );        
    */
     
  {
    pulsename(&echo1mon,"echo1mon");
    acqq(&echo1mon, (long)(pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait),(long)(pbeg(&gxwmon,"gxwmon",0)-mon_dabdelay),
        (long)(DEFAULTPOS),(long)filter_echo1mon,
        (TYPDAB_PACKETS)DABNORM);
  }
        

     
  {
    e1entnsmon_pack[0] = SSPDS+EDC;
    pulsename(&e1entnsmon,"e1entnsmon");
    createbits(&e1entnsmon,TYPSSP,4,e1entnsmon_pack);
    createinstr( &e1entnsmon,(LONG)(pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait),4,0);
  }
 
     
  {
    e1distnsmon_pack[0] = SSPDS+EDC;
    pulsename(&e1distnsmon,"e1distnsmon");
    createbits(&e1distnsmon,TYPSSP,4,e1distnsmon_pack);
    createinstr( &e1distnsmon,(LONG)(pend(&gxwmon,"gxwmon",0)+psd_grd_wait),4,0);
  }


    postemp = pend(&gxwmon,"gxwmon",0)+pw_gzkmona;

         

  trapezoid((WF_PROCESSOR)wg_gzkmon, "gzkmon", &gzkmon, &gzkmona,
                        &gzkmond, pw_gzkmon, pw_gzkmona, pw_gzkmond,
                        ia_gzkmon, 0, 0, 0, 0, postemp-pw_gzkmona, TRAP_ALL,
                        &monloggrd);

    postemp = pendall(&gzkmon,0);

    {
        LONG tseq_mon_duration = RUP_GRD(mon_tr_nav - mon_ssi_time);
        if(smartprep_flag)
        {
            tseq_mon_duration = RUP_GRD(mon_tr - mon_ssi_time);
        }
          
  {
    pulsename(&seqmon,"seqmon");
    createseq(&seqmon,tseq_mon_duration, off_seqmon);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmon );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmon = %d\n", idx_seqmon );
#endif
  }

    }

    if (!smartprep_flag)
    {
            
  {
    pulsename(&seqmonwait,"seqmonwait");
    createseq(&seqmonwait,RUP_GRD(mon_tr_wait-mon_ssi_time), off_seqmonwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmonwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmonwait = %d\n", idx_seqmonwait );
#endif
  }

    }
    attenflagon(&seqmon, 0);

    if (opcgate && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
    {
        if (navigatorCYL_flag)
        {
             /* Nav. IRPREP Tipup */
             
                  
  {
    pulsename(&gycylratipup,"gycylratipup");
 
        getbeta(_pg_beta.fixedflag ? (_temp1302_pg_beta=pg_beta,&_temp1302_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gycylratipup, &monloggrd);
 
    if ( (start_gycylratipup>0.0) || (start_gycylratipup<0.0) )
      {
        createramp(&gycylratipup,(WF_PROCESSOR)wg_gycylratipup,pw_gycylratipup,
                   ia_stgycylratipup,ia_endgycylratipup,
                   (short)(maxGradRes*(pw_gycylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gycylratipup,(long)(tlead_montipup-pw_gycylratipup),pw_gycylratipup,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gycylratipup,(WF_PROCESSOR)wg_gycylratipup,pw_gycylratipup,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gycylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gycylratipup,(long)(tlead_montipup-pw_gycylratipup),pw_gycylratipup,
                    ia_endgycylratipup);
      }
  }

             
                  
  {
    pulsename(&gzcylratipup,"gzcylratipup");
 
        getbeta(_pg_beta.fixedflag ? (_temp1303_pg_beta=pg_beta,&_temp1303_pg_beta) : &pg_beta, (WF_PROCESSOR)wg_gzcylratipup, &monloggrd);
 
    if ( (start_gzcylratipup>0.0) || (start_gzcylratipup<0.0) )
      {
        createramp(&gzcylratipup,(WF_PROCESSOR)wg_gzcylratipup,pw_gzcylratipup,
                   ia_stgzcylratipup,ia_endgzcylratipup,
                   (short)(maxGradRes*(pw_gzcylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzcylratipup,(long)(tlead_montipup-pw_gzcylratipup),pw_gzcylratipup,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gzcylratipup,(WF_PROCESSOR)wg_gzcylratipup,pw_gzcylratipup,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gzcylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gzcylratipup,(long)(tlead_montipup-pw_gzcylratipup),pw_gzcylratipup,
                    ia_endgzcylratipup);
      }
  }

             postemp = tlead_montipup; 
             /* RFCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,rf_ext);
#endif
             /* Stretch rf pw if needed */ 
             temp_res = res_rfcylrtipup;
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(rfpulseInfo[RFCYLRTIPUP_SLOT].newres*sizeof(short));
                 stretchpulse((int)res_rfcylrtipup,(int)rfpulseInfo[RFCYLRTIPUP_SLOT].newres,
                              temp_wspace_mon,wspace_mon);
                 res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(rfpulseInfo[RFCYLRTIPUP_SLOT].newres), res_rfcylrtipup) : rfpulseInfo[RFCYLRTIPUP_SLOT].newres;
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&rfcylrtipup,"rfcylrtipup");
    createreserve(&rfcylrtipup,(WF_PROCESSOR)wg_rfcylrtipup,
		  res_rfcylrtipup);
  }

             createinstr(&rfcylrtipup, postemp+psd_rf_wait, pw_rfcylrtipup,ia_rfcylrtipup);
             addrfbits(&rfcylrtipup, 0, postemp+psd_rf_wait, pw_rfcylrtipup);
             movewaveimm(wspace_mon, &rfcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* THCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,th_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&thcylrtipup,"thcylrtipup");
    createreserve(&thcylrtipup,(WF_PROCESSOR)wg_thcylrtipup,
		  res_thcylrtipup);
  }

             createinstr(&thcylrtipup, postemp+psd_rf_wait, pw_thcylrtipup,ia_thcylrtipup);
             movewaveimm(wspace_mon, &thcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* GYCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,gy_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&gycylrtipup,"gycylrtipup");
    createreserve(&gycylrtipup,(WF_PROCESSOR)wg_gycylrtipup,
		  res_gycylrtipup);
  }

             createinstr(&gycylrtipup, postemp, pw_gycylrtipup,ia_gycylrtipup);
             movewaveimm(wspace_mon, &gycylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* GZCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,gz_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&gzcylrtipup,"gzcylrtipup");
    createreserve(&gzcylrtipup,(WF_PROCESSOR)wg_gzcylrtipup,
		  res_gzcylrtipup);
  }

             createinstr(&gzcylrtipup, postemp, pw_gzcylrtipup,ia_gzcylrtipup);
             movewaveimm(wspace_mon, &gzcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* Change back incase external grad_file used */
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 res_rfcylrtipup  = _res_rfcylrtipup.fixedflag ?  ((void)(temp_res), res_rfcylrtipup) : temp_res;
             }

             postemp = tlead_montipup + pw_gycylrtipup + GRAD_UPDATE_TIME;
        }
        else 
        { 
            postemp = tlead_montipup + pw_gyrfmontipupa; 

                 
                         
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfmontipup", 
                                     (WF_PROCESSOR)wg_rfmontipup);

    /* Modify resolution if scaling required */
    temp_res_rfmontipup  = _temp_res_rfmontipup.fixedflag ?  ((void)(res_rfmontipup), temp_res_rfmontipup) : res_rfmontipup;
    if (rfpulseInfo[RFMONTIPUP_SLOT].change==PSD_ON)
      res_rfmontipup  = _res_rfmontipup.fixedflag ?  ((void)(rfpulseInfo[RFMONTIPUP_SLOT].newres), res_rfmontipup) : rfpulseInfo[RFMONTIPUP_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfmontipupa,"gyrfmontipupa");
    pulsename(&gyrfmontipup,"gyrfmontipup");
    pulsename(&gyrfmontipupd,"gyrfmontipupd");
    pulsename(&rfmontipup,"rfmontipup");

	/*  Now create the slice select trapezoid */
  pg_beta  = _pg_beta.fixedflag ?  ((void)(monloggrd.ybeta), pg_beta) : monloggrd.ybeta;
  createramp(&gyrfmontipupa,YGRAD,pw_gyrfmontipupa,(short)0,MAX_PG_WAMP,
			(short)(maxGradRes*(pw_gyrfmontipupa/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrfmontipupa,(LONG)(postemp-pw_gyrfmontipupa),
      pw_gyrfmontipupa,ia_gyrfmontipup);
  createconst(&gyrfmontipup,YGRAD,pw_gyrfmontipup,MAX_PG_WAMP);
  createinstr( &gyrfmontipup,(LONG)(postemp),
      pw_gyrfmontipup,ia_gyrfmontipup);
  createramp(&gyrfmontipupd,YGRAD,pw_gyrfmontipupd,MAX_PG_WAMP,
			(short)0,(short)(maxGradRes*(pw_gyrfmontipupd/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrfmontipupd,(LONG)(postemp+pw_gyrfmontipup),
      pw_gyrfmontipupd,ia_gyrfmontipup);

    /* Now create the rf pulse */
    createsinc(&rfmontipup,(WF_PROCESSOR)wg_rfmontipup,res_rfmontipup,
	       MAX_PG_WAMP,cyc_rfmontipup, alpha_rfmontipup);
    createinstr( &rfmontipup,(LONG)(postemp) + psd_rf_wait,
		pw_rfmontipup,ia_rfmontipup);
    linkpulses(4,&rfmontipup,&gyrfmontipup,&gyrfmontipupa,&gyrfmontipupd);
    addrfbits(&rfmontipup,off_rfmontipup,(LONG)(postemp) + psd_rf_wait,
	      pw_rfmontipup);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFMONTIPUP_SLOT].change==PSD_ON)
      res_rfmontipup  = _res_rfmontipup.fixedflag ?  ((void)(temp_res_rfmontipup), res_rfmontipup) : temp_res_rfmontipup;
}


            postemp = pend(&gyrfmontipup, "gyrfmontipup", 0);
        }

        /* Gzk Nav Tipup */
             

  trapezoid((WF_PROCESSOR)wg_gzkmontipup, "gzkmontipup", &gzkmontipup, &gzkmontipupa,
                        &gzkmontipupd, pw_gzkmontipup, pw_gzkmontipupa, pw_gzkmontipupd,
                        ia_gzkmontipup, 0, 0, 0, 0, postemp+pw_gzkmontipupa-pw_gzkmontipupa, TRAP_ALL,
                        &monloggrd);


        postemp = nav_tseq_irprep - nav_min_tseq_irprep;
        
  {
    pulsename(&seqmontipup,"seqmontipup");
    createseq(&seqmontipup,RUP_GRD(tmin_montipup+postemp), off_seqmontipup);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmontipup );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmontipup = %d\n", idx_seqmontipup );
#endif
  }

        attenflagon(&seqmontipup, 0);
    } /*end tipup*/
   
    if (navigator_flag && navigatorCYL_flag)
    {   /* Offset phase calculation */
        float xmod,ymod;
        float phiw;
        float arot;
        float brot;

        float ysum,zsum,kfact;
        int iw, iwb;
        float* kynorm=NULL;
        float* kznorm=NULL;
        short* wspace_theta=NULL;
        short* wspace_gy=NULL;
        short* wspace_gz=NULL;
        int act_res_rfcylr;
        int act_res_rfcylrtipup;

        /* convert mm to cm ahead of time */
        arot = cos(cylr_dtheta)/10.0;
        brot = sin(cylr_dtheta)/10.0;

        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            act_res_rfcylr = rfpulseInfo[RFCYLR_SLOT].newres;
        } else {
            act_res_rfcylr = res_rfcylr;
        }

        /* navCYL: prepare fm calculation for pencil offsets */
        ysum = 0;
        zsum = 0;
        kfact = -2.0*PI*GAM*(((float)pw_rfcylr/1000000)/(float)act_res_rfcylr);

        kynorm = (float *)AllocNode(act_res_rfcylr*sizeof(float));
        kznorm = (float *)AllocNode(act_res_rfcylr*sizeof(float));

        wspace_gy = (short *)AllocNode(act_res_rfcylr*sizeof(short));
        wspace_gz = (short *)AllocNode(act_res_rfcylr*sizeof(short));
        movewaveimm(wspace_gy, &gycylr, (int)0, act_res_rfcylr, FROMHARDWARE);
        movewaveimm(wspace_gz, &gzcylr, (int)0, act_res_rfcylr, FROMHARDWARE);

        gycylr0_scale = (float)wspace_gy[0]/(float)max_pg_wamp;
        gzcylr0_scale = (float)wspace_gz[0]/(float)max_pg_wamp;

        for (iw = 0; iw < (act_res_rfcylr); iw++)
        {
            iwb = (act_res_rfcylr - 1) - iw;   /* integrate backwards!! (w/neg kfact) */
            ysum=ysum+(float)(wspace_gy[iwb])*(a_gycylr/max_pg_wamp);
            zsum=zsum+(float)(wspace_gz[iwb])*(a_gzcylr/max_pg_wamp);
            kynorm[iwb] = kfact*ysum;
            kznorm[iwb] = kfact*zsum;
        }

        FreeNode(wspace_gy);
        FreeNode(wspace_gz);

        if (cylr_manoff) /* manual offsets, reset xo and yo */
        {
            xo = (int)cylr_xoff;
            yo = (int)cylr_yoff;
        } else {
            xo = (int)mon_rsp_info[0].rsptloc;
            yo = (int)mon_rsp_info[0].rspphasoff;
        }

        xmod = (arot*xo + brot*yo);
        ymod = (-brot*xo + arot*yo);

        wspace_theta = (short *)AllocNode(act_res_rfcylr*sizeof(short));

        for (iw = 0; iw < act_res_rfcylr; iw++)
        {
            phiw = (kznorm[iw]*xmod + kynorm[iw]*ymod)/PI;
            if(phiw>=0)
            {
                wspace_theta[iw]=(short)((phiw-(int)((phiw+1)/2)*2)*max_pg_wamp);
            } else {
                wspace_theta[iw]=(short)((phiw-(int)((phiw-1)/2)*2)*max_pg_wamp);
            }
            if(wspace_theta[iw]%2 !=0 )
            {
                wspace_theta[iw] += 1;
            }
        }
        wspace_theta[act_res_rfcylr-1]=1;
        movewaveimm(wspace_theta, &thcylr, (int)0, act_res_rfcylr, TOHARDWARE);
        FreeNode(wspace_theta);
        FreeNode(kynorm);
        FreeNode(kznorm);

        if ((opcgate && (nav_irprep_flag || navsat_flag) && slabtracking_flag) && navigatorCYL_flag)
        {
            if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
            {
                act_res_rfcylrtipup = rfpulseInfo[RFCYLRTIPUP_SLOT].newres;
            } else {
                act_res_rfcylrtipup = res_rfcylrtipup;
            }

            /* navCYL: prepare fm calculation for pencil offsets */
            ysum = 0;
            zsum = 0;
            kfact = -2.0*PI*GAM*(((float)pw_rfcylrtipup/1000000)/(float)act_res_rfcylrtipup);

            kynorm = (float *)AllocNode(act_res_rfcylrtipup*sizeof(float));
            kznorm = (float *)AllocNode(act_res_rfcylrtipup*sizeof(float));

            wspace_gy = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));
            wspace_gz = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));
            movewaveimm(wspace_gy, &gycylrtipup, (int)0, act_res_rfcylrtipup, FROMHARDWARE);
            movewaveimm(wspace_gz, &gzcylrtipup, (int)0, act_res_rfcylrtipup, FROMHARDWARE);

            gycylrtipup0_scale = (float)wspace_gy[0]/(float)max_pg_wamp;
            gzcylrtipup0_scale = (float)wspace_gz[0]/(float)max_pg_wamp;

            for (iw = 0; iw < (act_res_rfcylrtipup); iw++)
            {
                iwb = (act_res_rfcylrtipup - 1) - iw;   /* integrate backwards!! (w/neg kfact) */
                ysum=ysum+(float)(wspace_gy[iwb])*(a_gycylrtipup/max_pg_wamp);
                zsum=zsum+(float)(wspace_gz[iwb])*(a_gzcylrtipup/max_pg_wamp);
                kynorm[iwb] = kfact*ysum;
                kznorm[iwb] = kfact*zsum;
            }

            FreeNode(wspace_gy);
            FreeNode(wspace_gz);

            if (cylr_manoff) /* manual offsets, reset xo and yo */
            {
                xo = (int)cylr_xoff;
                yo = (int)cylr_yoff;
            } else {
                xo = (int)mon_rsp_info[0].rsptloc;
                yo = (int)mon_rsp_info[0].rspphasoff;
            }

            xmod = (arot*xo + brot*yo);
            ymod = (-brot*xo + arot*yo);

            wspace_theta = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));

            for (iw = 0; iw < act_res_rfcylrtipup; iw++)
            {
                phiw = (kznorm[iw]*xmod + kynorm[iw]*ymod)/PI;
                if(phiw>=0)
                {
                    wspace_theta[iw]=(short)((phiw-(int)((phiw+1)/2)*2)*max_pg_wamp);
                } else {
                    wspace_theta[iw]=(short)((phiw-(int)((phiw-1)/2)*2)*max_pg_wamp);
                }
                if(wspace_theta[iw]%2 !=0 )
                {
                    wspace_theta[iw] += 1;
                }
            }
            wspace_theta[act_res_rfcylrtipup-1]=1;
            movewaveimm(wspace_theta, &thcylrtipup, (int)0, act_res_rfcylrtipup, TOHARDWARE);
            FreeNode(wspace_theta);
            FreeNode(kynorm);
            FreeNode(kznorm);
        }
    }

    return SUCCESS;
}

STATUS Monitor_pulsegen(void)
{
    if (smartprep_flag || navigator_flag) 
    {
        if (FAILURE == monitor_PG())
        {
            printf("pulsegen(): monitor_PG() returned FAILURE.\n");
            return FAILURE; 
        }

        if (smartprep_flag)
            getperiod((long*)&mon_deadtime, &seqmon, 0);
        else
            getperiod((long*)&mon_deadtime, &seqmonwait, 0);
    }

    /*********************
    Dummy wait sequence 
     *********************/

          
  {
    pulsename(&seqloopdelay,"seqloopdelay");
    createseq(&seqloopdelay,RUP_GRD(IMax(2,1,loopdelay-mon_ssi_time)), off_seqloopdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqloopdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqloopdelay = %d\n", idx_seqloopdelay );
#endif
  }

           
  {
    pulsename(&seqloopdelay2,"seqloopdelay2");
    createseq(&seqloopdelay2,RUP_GRD(IMax(2,1,loopdelay2-mon_ssi_time)), off_seqloopdelay2);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqloopdelay2 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqloopdelay2 = %d\n", idx_seqloopdelay2 );
#endif
  }

      
  {
    pulsename(&seqsmartprepdelay,"seqsmartprepdelay");
    createseq(&seqsmartprepdelay,RUP_GRD(30000), off_seqsmartprepdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsmartprepdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsmartprepdelay = %d\n", idx_seqsmartprepdelay );
#endif
  }


    /* NAV delay after last slice in nav gating */
#ifdef NAV_EFGRE3D
          
  {
    pulsename(&seqnavend,"seqnavend");
    createseq(&seqnavend,RUP_GRD(IMax(2,1,navend_time-mon_ssi_time)), off_seqnavend);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqnavend );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqnavend = %d\n", idx_seqnavend );
#endif
  }

#endif
    /* Dummy sequence played when histogram is being calculated */
          
  {
    pulsename(&seqnavhistdelay,"seqnavhistdelay");
    createseq(&seqnavhistdelay,RUP_GRD(IMax(2,1,hist_wait_time-mon_ssi_time)), off_seqnavhistdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqnavhistdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqnavhistdelay = %d\n", idx_seqnavhistdelay );
#endif
  }


    /* Wait pulse Navigator feedback */
      
  {
    pulsename(&seqrtpnav,"seqrtpnav");
    createseq(&seqrtpnav,rtpresultwait, off_seqrtpnav);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtpnav );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtpnav = %d\n", idx_seqrtpnav );
#endif
  }


    mon_receive_freq1 = (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 
    rf1mon_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int));
    rf2mon_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 
    rfmontipup_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 

    return SUCCESS;
}



/**
 * Initialize Navigator related parameters
 *
 * @return SUCCESS if function completes successfully.
 */
STATUS NavigatorCvevalInit(void)
{
    _navtrig_flag.fixedflag = PSD_FIX_OFF;
    _navgate_flag.fixedflag = PSD_FIX_OFF;

    /* Navigator Enhancements (MRIhc07226) */
    if (PSD_ON == navigator_flag)
    {
        if(PSD_ON == exist(opcgate))
        {
            _nav_alg.fixedflag = PSD_FIX_OFF;
        }

#ifdef NAV_EFGRE3D
        if(PSD_ON == exist(opcgate))
        {
            nav_alg  = _nav_alg.fixedflag ?  ((void)(0), nav_alg) : 0; /* LSQ */
            nav_channel  = _nav_channel.fixedflag ?  ((void)(-2), nav_channel) : -2; /* AGCC - SCM does not have enouge evaluation for 3D Heart navigator */
        } else {
            nav_channel  = _nav_channel.fixedflag ?  ((void)(-3), nav_channel) : -3; /* SCM */
            nav_alg  = _nav_alg.fixedflag ?  ((void)(0), nav_alg) : 0; /* LSQ */
        }
#else
        nav_channel  = _nav_channel.fixedflag ?  ((void)(-3), nav_channel) : -3; /* SCM */
        nav_alg  = _nav_alg.fixedflag ?  ((void)(0), nav_alg) : 0; /* LSQ */
#endif

        if( nav_channel == -3 ) /* All Good Channel Combine + Suboptimal Channel Mask */
        {
            nav_coilsel_index  = _nav_coilsel_index.fixedflag ?  ((void)(2), nav_coilsel_index) : 2;
        } else {
            nav_coilsel_index  = _nav_coilsel_index.fixedflag ?  ((void)(1), nav_coilsel_index) : 1;
        }

        mon_xres   = _mon_xres.fixedflag ?  ((void)(256), mon_xres) : 256;   /* Changed from 128 to 256 for higher resolution */
        mon_fov    = _mon_fov.fixedflag ?  ((void)(100), mon_fov) : 100;
        xres2use   = _xres2use.fixedflag ?  ((void)(DEFAULT_FFT_LENGTH_256), xres2use) : DEFAULT_FFT_LENGTH_256;

#ifdef NAV_EFGRE3D
        if(PSD_ON == ifir_flag)
        {
            navtrig_flag  = _navtrig_flag.fixedflag ?  ((void)(PSD_ON), navtrig_flag) : PSD_ON;
            navgate_flag  = _navgate_flag.fixedflag ?  ((void)(PSD_OFF), navgate_flag) : PSD_OFF;
        } else {
            navtrig_flag  = _navtrig_flag.fixedflag ?  ((void)(PSD_OFF), navtrig_flag) : PSD_OFF;
            navgate_flag  = _navgate_flag.fixedflag ?  ((void)(PSD_ON), navgate_flag) : PSD_ON;
        }
#else
        navtrig_flag  = _navtrig_flag.fixedflag ?  ((void)(PSD_ON), navtrig_flag) : PSD_ON;
        navgate_flag  = _navgate_flag.fixedflag ?  ((void)(PSD_OFF), navgate_flag) : PSD_OFF;
#endif

        if ((PSD_ON == navgate_flag) && (PSD_OFF == slabtracking_flag) && (PSD_OFF == exist(opdisco)))
        {
            nav_dual_mode  = _nav_dual_mode.fixedflag ?  ((void)(PSD_ON), nav_dual_mode) : PSD_ON;
        }
        else
        {
            nav_dual_mode  = _nav_dual_mode.fixedflag ?  ((void)(PSD_OFF), nav_dual_mode) : PSD_OFF; /* DISCO NAV does not use dual mode because of RHDC_RAWDATA mode */
        }

        /* reset trigger status */
        if ((PSD_ON == navgate_flag) && (PSD_OFF == nav_dual_mode))
            nav_active = 1;
        else
            nav_active = 0;

        if (PSD_ON == navigatorCYL_flag)
        {
            monrot_phi  = _monrot_phi.fixedflag ?  ((void)(0.0), monrot_phi) : 0.0;    /* Changed from -45 to 0 for cyl-nav */
        }
        
#ifdef NAV_EFGRE3D
        if (PSD_ON == heart3d_flag)
        {
            nav_angle_adj = _nav_angle_adj.fixedflag ? ((void)(1), nav_angle_adj) : 1;
            if(abs(mon_loc.oprot[1]) > abs(mon_loc.oprot[2]))
            {   /* Sag */
                mon_angle = _mon_angle.fixedflag ? ((void)(-45.0), mon_angle) : -45.0;
                monrot_phi = _monrot_phi.fixedflag ? ((void)(0.0), monrot_phi) : 0.0;
            } 
            else
            {   /* Cor */
                mon_angle = _mon_angle.fixedflag ? ((void)(45.0), mon_angle) : 45.0;
                monrot_phi = _monrot_phi.fixedflag ? ((void)(90.0), monrot_phi) : 90.0;
            }
            corr_mode  = _corr_mode.fixedflag ?  ((void)(2), corr_mode) : 2;
            corr_factor_z  = _corr_factor_z.fixedflag ?  ((void)(0.6), corr_factor_z) : 0.6;
            corr_factor_y  = _corr_factor_y.fixedflag ?  ((void)(0.0), corr_factor_y) : 0.0;
            corr_factor_x  = _corr_factor_x.fixedflag ?  ((void)(0.0), corr_factor_x) : 0.0;
        } else {
            nav_angle_adj = _nav_angle_adj.fixedflag ? ((void)(0), nav_angle_adj) : 0;
            mon_angle = _mon_angle.fixedflag ? ((void)(0.0), mon_angle) : 0.0;
            monrot_phi = _monrot_phi.fixedflag ? ((void)(-45.0), monrot_phi) : -45.0;
            corr_mode  = _corr_mode.fixedflag ?  ((void)(2), corr_mode) : 2;
            corr_factor_z  = _corr_factor_z.fixedflag ?  ((void)(1.0), corr_factor_z) : 1.0;
            corr_factor_y  = _corr_factor_y.fixedflag ?  ((void)(0.0), corr_factor_y) : 0.0;
            corr_factor_x  = _corr_factor_x.fixedflag ?  ((void)(0.0), corr_factor_x) : 0.0;
        }
#else
        nav_angle_adj = _nav_angle_adj.fixedflag ? ((void)(0), nav_angle_adj) : 0;
        mon_angle = _mon_angle.fixedflag ? ((void)(0.0), mon_angle) : 0.0;
        monrot_phi = _monrot_phi.fixedflag ? ((void)(-45.0), monrot_phi) : -45.0;
#endif

        if(PSD_ON == navigatorCYL_flag)
        {
            monrot_phi  = _monrot_phi.fixedflag ?  ((void)(0.0), monrot_phi) : 0.0;
        }

        if (0 == nav_alg) {
            nav_ss  = _nav_ss.fixedflag ?  ((void)(3), nav_ss) : 3; /* LSQ requires nav_ss > 0 */
        } else {
            nav_ss  = _nav_ss.fixedflag ?  ((void)(0), nav_ss) : 0;
        }

        if( (PSD_ON == navtrig_flag) || (PSD_ON == navgate_flag) ) {
            int target_tr;
            int seq_update_time; /* maximum time available for sequence update for navigator gating sequences */

            if(PSD_ON == navtrig_flag) {
                target_tr = navtrig_target_tr;
                seq_update_time = MAX_PGEN_TIME_TRIG;
            } else if(PSD_ON == navgate_flag) {
                target_tr = navgate_target_tr;
                seq_update_time = MAX_PGEN_TIME_GATE;
            }

            mon_tr_nav  = _mon_tr_nav.fixedflag ?  ((void)(min_montr), mon_tr_nav) : min_montr;
            mon_tr_wait  = _mon_tr_wait.fixedflag ?            ((void)(IMax(2,seq_update_time+rtpresultwait+2*mon_ssi_time,target_tr-mon_tr_nav)), mon_tr_wait) : IMax(2,seq_update_time+rtpresultwait+2*mon_ssi_time,target_tr-mon_tr_nav);
            mon_tr  = _mon_tr.fixedflag ?    ((void)(mon_tr_nav+mon_tr_wait), mon_tr) : mon_tr_nav+mon_tr_wait;
        } else {
            mon_tr_wait  = _mon_tr_wait.fixedflag ?    ((void)(rtpresultwait+mon_ssi_time), mon_tr_wait) : rtpresultwait+mon_ssi_time;
        }

        nav_coilsel_tr  = _nav_coilsel_tr.fixedflag ?    ((void)(IMax(2,200000,mon_tr)), nav_coilsel_tr) : IMax(2,200000,mon_tr);

        if(PSD_ON == exist(opnavrrmeas))
        {
            nav_prescan_tr  = _nav_prescan_tr.fixedflag ?  ((void)(200000), nav_prescan_tr) : 200000;
        } else if(PSD_ON == navtrig_flag) {
            nav_prescan_tr  = _nav_prescan_tr.fixedflag ?  ((void)(mon_tr), nav_prescan_tr) : mon_tr;
        }

#ifdef NAV_EFGRE3D
        if(PSD_ON == exist(opcgate))
        {
            if((PSD_OFF == irprep_flag) && (B0_15000 == cffield))
            {
                pinavtypenub = 3;
                navigatorCYL_flag  = _navigatorCYL_flag.fixedflag ?  ((void)(exist(opnavtype)), navigatorCYL_flag) : exist(opnavtype);
            } else {
                pinavtypenub = 0;
                cvoverride(opnavtype, PSD_NAV_TYPE_90_180, PSD_FIX_ON, PSD_EXIST_ON);
                navigatorCYL_flag  = _navigatorCYL_flag.fixedflag ?  ((void)(0), navigatorCYL_flag) : 0;
            }
            pinavsltracknub = 1;
        } else {
            pinavtypenub = 0;
            cvoverride(opnavtype, PSD_NAV_TYPE_CYL, PSD_FIX_ON, PSD_EXIST_ON);
            navigatorCYL_flag  = _navigatorCYL_flag.fixedflag ?  ((void)(1), navigatorCYL_flag) : 1;
            if(PSD_ON == ifir_flag)
            {
                pinavsltracknub = 1;
            } else {
                pinavsltracknub = 0;
                cvoverride(opnavsltrack, PSD_OFF, PSD_FIX_OFF, PSD_EXIST_ON);
            }
        }
#else
        pinavtypenub = 0;
        cvoverride(opnavtype, PSD_NAV_TYPE_CYL, PSD_FIX_ON, PSD_EXIST_ON);
        navigatorCYL_flag  = _navigatorCYL_flag.fixedflag ?  ((void)(1), navigatorCYL_flag) : 1;
        pinavsltracknub = 0;
#endif

#ifdef NAV_EFGRE3D
        max_navgate_tr = exist(opnavmaxinterval) * 1000;

        if((PSD_ON == ssfp_flag) && (PSD_OFF == t2prep_flag) && (PSD_ON == navigatorCYL_flag))
        {
            navsat_flag  = _navsat_flag.fixedflag ?  ((void)(PSD_ON), navsat_flag) : PSD_ON;
        } else {
            navsat_flag  = _navsat_flag.fixedflag ?  ((void)(PSD_OFF), navsat_flag) : PSD_OFF;
        }

        if ((PSD_ON == ifir_flag) && (PSD_ON == exist(opirprep)))
        {
            if (exist(opbspti) > 1200000)
                navtrig_factor  = _navtrig_factor.fixedflag ?  ((void)(0.6), navtrig_factor) : 0.6;
            else
                navtrig_factor  = _navtrig_factor.fixedflag ?  ((void)(exist(opbspti)/(float)2000000), navtrig_factor) : exist(opbspti)/(float)2000000;
        }
#endif

#ifdef NAV_EFGRE3D
        if(PSD_ON == exist(opcgate))
        {
            flip_rfcylr  = _flip_rfcylr.fixedflag ?  ((void)(30.0), flip_rfcylr) : 30.0;
        } else if(PSD_ON == navgate_flag) {
            flip_rfcylr  = _flip_rfcylr.fixedflag ?      ((void)(FMax(2,20.0,exist(opflip)+5.0)), flip_rfcylr) : FMax(2,20.0,exist(opflip)+5.0);
        } else {
            flip_rfcylr  = _flip_rfcylr.fixedflag ?  ((void)(20.0), flip_rfcylr) : 20.0;
        }
#else
        flip_rfcylr  = _flip_rfcylr.fixedflag ?  ((void)(20.0), flip_rfcylr) : 20.0;
#endif

        /* HCSDM00176210 */
        skip_navigator_prescan  = _skip_navigator_prescan.fixedflag ?  ((void)(0), skip_navigator_prescan) : 0;

#ifdef NAV_EFGRE3D
        if( (PSD_ON == exist(oplava)) || (PSD_ON == de3d_flag) )
        {
            pinavsigenhancenub = 1;
        } else {
            pinavsigenhancenub = 0;
        }

        if(PSD_ON == ifir_flag)
        {
            pinavautoaccwinnub = 1;
            pinavrradjust = NAV_RRADJUST_MANUAL;
        } else {
            pinavautoaccwinnub = 0;
            pinavrradjust = 0;
        }
#else
        pinavsigenhancenub = 0;
        pinavautoaccwinnub = 0;
#ifdef NAV_3DFSE
        pinavrradjust = NAV_RRADJUST_MANUAL;
#else
#ifdef NAV_SSFSE
        pinavrradjust = NAV_RRADJUST_MANUAL;
#else
        pinavrradjust = NAV_RRADJUST_THICKNESS
                      + NAV_RRADJUST_SPACING
                      + NAV_RRADJUST_RESPINTERVAL
                      + NAV_RRADJUST_MANUAL;
#endif
#endif
#endif

        if(PSD_ON == navtrig_flag)
        {
            pinavrrmeasnub = 1;
            if( PSD_ON == exist(opnavrrmeas) ) {
                pinavrrmeastimenub = 15;
            } else {
                pinavrrmeastimenub = 0;
            }
            pinavpscpausenub = 0;
            pinavmaxintervalnub = 0;
            pinavautotrigtimenub = 15;
            pirtrigwinnub = 5;
            pirtrepnub = 63;
            pirtratenub = 1;
            cvoverride(oprtcardseq, PSD_CARD_INTER_MIN, PSD_FIX_OFF, PSD_EXIST_ON);
        } else {
            pinavrrmeasnub = 0;
            pinavrrmeastimenub = 0;
            if(PSD_OFF == exist(opcgate)) {
                if(((PSD_ON == exist(oplava)) && (PSD_OFF == exist(opmedal))) || (PSD_ON == exist(opdisco))) {
                    pinavmaxintervalnub = 15;
                } else {
                    pinavmaxintervalnub = 0;
                }
                if (PSD_ON == exist(opdisco))
                {
                    /* NAV DISCO does not use pause after Nav Prescan to avoid workflow confusion */
                    pinavpscpausenub = 0;
                }
                else
                {
                    pinavpscpausenub = 1;
                }
            } else {
                pinavmaxintervalnub = 0;
                pinavpscpausenub = 0;
            }
            pinavautotrigtimenub = 0;
            pirtrigwinnub = 0;
            pirtrepnub = 0;
            pirtratenub = 0;
        }
        pirtseqnub = 0;
        pirtpointnub = 0;
        pinavaccwinnub = 15;
        pinavpsctimenub = 15;

        calc_rate  = _calc_rate.fixedflag ?  ((void)(exist(opnavrrmeas)), calc_rate) : exist(opnavrrmeas);
        slabtracking_flag  = _slabtracking_flag.fixedflag ?  ((void)(exist(opnavsltrack)), slabtracking_flag) : exist(opnavsltrack);
        enhanced_nav_flag  = _enhanced_nav_flag.fixedflag ?  ((void)(exist(opnavsigenhance)), enhanced_nav_flag) : exist(opnavsigenhance);
        nav_pause_after_prescan  = _nav_pause_after_prescan.fixedflag ?  ((void)(exist(opnavpscpause)), nav_pause_after_prescan) : exist(opnavpscpause);
    } else {
        navtrig_flag  = _navtrig_flag.fixedflag ?  ((void)(PSD_OFF), navtrig_flag) : PSD_OFF;
        navgate_flag  = _navgate_flag.fixedflag ?  ((void)(PSD_OFF), navgate_flag) : PSD_OFF;
        pinavaccwinnub = 0;
        pinavautoaccwinnub = 0;
        pinavpsctimenub = 0;
        pinavautotrigtimenub = 0;
        pinavsltracknub = 0;
        pinavrrmeasnub = 0;
        pinavrrmeastimenub = 0;
        pinavmaxintervalnub = 0;
        pinavtypenub = 0;
        pinavpscpausenub = 0;
        pinavsigenhancenub = 0;
        pinavrradjust = 0;

        if(PSD_ON == exist(oprtcgate))
        {
            pirtrigwinnub = 5;
            pirtseqnub = 7;
            pirtrepnub = 63;
            pirtpointnub = 30;
            pirtratenub = 1;
        } else {
            pirtrigwinnub = 0;
            pirtseqnub = 0;
            pirtrepnub = 0;
            pirtpointnub = 0;
            pirtratenub = 0;
        }

        calc_rate  = _calc_rate.fixedflag ?  ((void)(PSD_OFF), calc_rate) : PSD_OFF;
        slabtracking_flag  = _slabtracking_flag.fixedflag ?  ((void)(PSD_OFF), slabtracking_flag) : PSD_OFF;
        enhanced_nav_flag  = _enhanced_nav_flag.fixedflag ?  ((void)(PSD_OFF), enhanced_nav_flag) : PSD_OFF;
        nav_pause_after_prescan  = _nav_pause_after_prescan.fixedflag ?  ((void)(PSD_OFF), nav_pause_after_prescan) : PSD_OFF;
    }

    nav_window  = _nav_window.fixedflag ?  ((void)(exist(opnavaccwin)), nav_window) : exist(opnavaccwin);

    cvmin(opnavaccwin, -FLT_MAX);
    cvmax(opnavaccwin, FLT_MAX);
    avminnavaccwin = 1.0;
    avmaxnavaccwin = 50.0;

    cvmin(opnavpsctime, INT_MIN);
    cvmax(opnavpsctime, INT_MAX);
    avminnavpsctime = 5;
    avmaxnavpsctime = 60;

    cvmin(opnavautotrigtime, INT_MIN);
    cvmax(opnavautotrigtime, INT_MAX);
    avminnavautotrigtime = 5;

#ifdef NAV_EFGRE3D
    if(PSD_ON == ifir_flag)
    {
        cvdef(opnavautotrigtime, 20);
    } else {
        cvdef(opnavautotrigtime, 5);
    }
#else
    cvdef(opnavautotrigtime, 5);
#endif

    avmaxnavautotrigtime = 60;

    if(PSD_ON == navtrig_flag)
    {
        cvmin(opnavrrmeastime, INT_MIN);
        cvmax(opnavrrmeastime, INT_MAX);
        avminnavrrmeastime = 10;
        avmaxnavrrmeastime = 120;
    }
    else if(PSD_ON == navgate_flag)
    {
        cvmin(opnavmaxinterval, INT_MIN);
        cvmax(opnavmaxinterval, INT_MAX);
        avminnavmaxinterval = 100;
        avmaxnavmaxinterval = 1000;
    }

    if(PSD_ON == navtrig_flag)
    {
#ifdef NAV_EFGRE3D
        cvmax( oprtrep, 2 );
#else
        cvmax( oprtrep, 5 );
#endif
    }

    if(PSD_ON == calc_rate) {
        /* scan will stop the sequence by stop looping. 100 was added to keep PSD running until scan stops */
        nav_dda  = _nav_dda.fixedflag ?       ((void)((int)(exist(opnavrrmeastime)*1000000/(float)nav_prescan_tr)+100), nav_dda) : (int)(exist(opnavrrmeastime)*1000000/(float)nav_prescan_tr)+100;
    } else if(PSD_ON == navtrig_flag) {
        nav_dda  = _nav_dda.fixedflag ?       ((void)((int)(exist(opnavpsctime)*1000000/(float)nav_prescan_tr)-nav_ss), nav_dda) : (int)(exist(opnavpsctime)*1000000/(float)nav_prescan_tr)-nav_ss;
#ifdef NAV_EFGRE3D
    } else if((PSD_ON == navgate_flag) && (PSD_ON == exist(opcgate))) {
        nav_dda  = _nav_dda.fixedflag ?       ((void)((int)(exist(opnavpsctime)*exist(ophrate)/60.0)-nav_ss), nav_dda) : (int)(exist(opnavpsctime)*exist(ophrate)/60.0)-nav_ss;
    } else if(PSD_ON == navgate_flag) {
        nav_dda  = _nav_dda.fixedflag ?       ((void)((int)(exist(opnavpsctime)*1000000/(float)act_navgate_tr)-nav_ss), nav_dda) : (int)(exist(opnavpsctime)*1000000/(float)act_navgate_tr)-nav_ss;
#endif
    } else {
        nav_dda  = _nav_dda.fixedflag ?  ((void)(48), nav_dda) : 48;
    }

    if(nav_dda > MAXNAVDDA - nav_ss)
    {
        nav_dda  = _nav_dda.fixedflag ?    ((void)(MAXNAVDDA-nav_ss), nav_dda) : MAXNAVDDA-nav_ss;
    }

#ifdef NAV_EFGRE3D
    if(PSD_ON == navgate_flag)
    {
        if(PSD_ON == exist(opcgate))
        {
            nav_scantime_refresh_pts  = _nav_scantime_refresh_pts.fixedflag ?  ((void)(1), nav_scantime_refresh_pts) : 1;
        }
        else
        {
            nav_scantime_refresh_pts  = _nav_scantime_refresh_pts.fixedflag ?       ((void)((int)((float)nav_scantime_refresh/(float)act_navgate_tr+0.5)-0.5), nav_scantime_refresh_pts) : (int)((float)nav_scantime_refresh/(float)act_navgate_tr+0.5)-0.5;
        }
    }
#endif

    if (PSD_ON == navtrig_flag)
    {
        float avail_image_time_per_min;

        avail_image_time_per_min = 60.0 * (1 - exist(oprtarr) * 0.01);

#ifdef NAV_EFGRE3D
        if(PSD_ON == ifir_flag)
        {
            pinavmaxrr = avail_image_time_per_min/
                         ( ( (float)tmin_total/ 1000000.0)/ (float)exist(oprtrep) );

            pinavrrmeasrtrep = (ceil)( ( (float)exist(opnavrrmeasrr) *
                         (float)tmin_total/ 1000000.0 )/ avail_image_time_per_min );
        }
#else
#ifdef NAV_3DFSE
        pinavmaxrr = avail_image_time_per_min/
                         ( ( (float)tmin_total/ 1000000.0)/ (float)exist(oprtrep) );

        pinavrrmeasrtrep = (ceil)( ( (float)exist(opnavrrmeasrr) *
                         (float)tmin_total/ 1000000.0 )/ avail_image_time_per_min );
#else
#ifdef NAV_SSFSE
        pinavmaxrr = avail_image_time_per_min/
                         ( ( (float)tmin_total/ 1000000.0)/ (float)exist(oprtrep) );

        pinavrrmeasrtrep = (ceil)( ( (float)exist(opnavrrmeasrr) *
                         (float)tmin_total/ 1000000.0 )/ avail_image_time_per_min );
#else
        pinavmaxrr = avail_image_time_per_min/ ( (float)exist(opslquant) *
                         ( ( (float)tmin_total/ 1000000.0)/ (float)exist(oprtrep) ) );

        pinavrrmeasrtrep = (ceil)( ( (float)exist(opnavrrmeasrr) * (float)exist(opslquant) *
                         (float)tmin_total/ 1000000.0 )/ avail_image_time_per_min );

        pinavrrmeasmaxsl = (int)( (float)avail_image_time_per_min/ (float)( exist(opnavrrmeasrr) *
                         ( ( (float)tmin_total/ 1000000.0)/ (float)exist(oprtrep) ) ) );
#endif
#endif
#endif

    }

    _navtrig_flag.fixedflag = PSD_FIX_ON;
    _navgate_flag.fixedflag = PSD_FIX_ON;

    return SUCCESS;
}

/**
 * Calculate navigator direction from tracker rotation matrix
 *
 * @return SUCCESS if function completes successfully.
 */
STATUS NavigatorEval(void)
{
    /* MRIhc12741 This fixes the problem where Nav direction is reversed when tracker is prescribed from the Coronal localizer instead of Saggital*/
    if ((((float)rsprot_monitor[0][6] <= 0) && (1 != opentry)) || /*feet first*/
        (((float)rsprot_monitor[0][6] >= 0) && (1 == opentry))) { /*head first*/
        nav_dir  = _nav_dir.fixedflag ?  ((void)(1), nav_dir) : 1;    /*ascending edge Saggital*/
    } else {
        nav_dir  = _nav_dir.fixedflag ?  ((void)(-1), nav_dir) : -1;   /*descending edge Coronal*/
    }

    return SUCCESS;
}

void getDiffGradAmp(float * difx, float * dify, float * difz, int dshot)
{
    int bindex, dirindex;

    if (opdifnumt2 > 0)
    {
        if (dshot <= 0 )  /* ref and T2 */
        {
            *difx = 0;
            *dify = 0;
            *difz = 0;
        }
        else
        {
            *difx = diff_ampx[(int)((dshot-1)/opdifnumdirs)];
            *dify = diff_ampy[(int)((dshot-1)/opdifnumdirs)];
            *difz = diff_ampz[(int)((dshot-1)/opdifnumdirs)];

            if(opdfaxtetra > PSD_OFF || opdfax3in1 > PSD_OFF || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
            {
                if (obl_3in1_opt) /* Obl 3in1 opt */
                {
                    bindex = (int)((dshot-1)/opdifnumdirs);
                    dirindex = (dshot-1)%opdifnumdirs;

                    *difx = diff_ampx2[bindex][dirindex];
                    *dify = diff_ampy2[bindex][dirindex];
                    *difz = diff_ampz2[bindex][dirindex];

                    if (obl_3in1_opt_debug)
                    {
                        printf(" \n");
                        printf("bindex= %d dirindex= %d\n", bindex, dirindex);
                        printf("MPG amplitude in each axis in G/cm.\n");
                        printf("*difx= %f *dify= %f *difz= %f\n", *difx, *dify, *difz);
                    }
                }
                else if (PSD_OFF == different_mpg_amp_flag)
                {
                    rotateToLogical(difx, dify, difz, (dshot-1)%opdifnumdirs);
                }
            }
            else
            {
                *difx *= D[(dshot-1)%opdifnumdirs][AXIS_X];
                *dify *= D[(dshot-1)%opdifnumdirs][AXIS_Y];
                *difz *= D[(dshot-1)%opdifnumdirs][AXIS_Z];
            }
        }
    }
    else
    {
        if (dshot<0)  /* ref */
        {
            *difx = 0;
            *dify = 0;
            *difz = 0;
        }
        else
        {
            *difx = diff_ampx[(int)(dshot/opdifnumdirs)];
            *dify = diff_ampy[(int)(dshot/opdifnumdirs)];
            *difz = diff_ampz[(int)(dshot/opdifnumdirs)];

            if(opdfaxtetra > PSD_OFF || opdfax3in1 > PSD_OFF || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
            {
                if (obl_3in1_opt) /* Obl 3in1 opt */
                {
                    bindex = (int)(dshot/opdifnumdirs);
                    dirindex = dshot%opdifnumdirs;

                    *difx = diff_ampx2[bindex][dirindex];
                    *dify = diff_ampy2[bindex][dirindex];
                    *difz = diff_ampz2[bindex][dirindex];

                    if (obl_3in1_opt_debug)
                    {
                        printf(" \n");
                        printf("bindex= %d dirindex= %d\n", bindex, dirindex);
                        printf("MPG amplitude in each axis in G/cm.\n");
                        printf("*difx= %f *dify= %f *difz= %f\n", *difx, *dify, *difz);
                    }
                }
                else if (PSD_OFF == different_mpg_amp_flag)
                {
                    rotateToLogical(difx, dify, difz, dshot%opdifnumdirs);
                }
            }
            else
            {
                *difx *= D[dshot%opdifnumdirs][AXIS_X];
                *dify *= D[dshot%opdifnumdirs][AXIS_Y];
                *difz *= D[dshot%opdifnumdirs][AXIS_Z];
            }
        }
    }
}

void loadDiffVecMatrix(void)
{
    /* SWL: set the diffusion lobe amp scale for DWI
     * D[][] are 4by3 matrix. First dimension
     * indicates the axis to play the gradient lobe, the second
     * dimension indicates the TRs to be played. (Index 0 is the
     * T2 scan) */

    if (opdfaxall == PSD_ON)
    {
        if(gradopt_diffall == PSD_OFF)
        {
            D[DIR1][AXIS_X] = 0.0;
            D[DIR1][AXIS_Y] = 0.0;
            D[DIR1][AXIS_Z] = 1.0;

            D[DIR2][AXIS_X] = 1.0;
            D[DIR2][AXIS_Y] = 0.0;
            D[DIR2][AXIS_Z] = 0.0;

            D[DIR3][AXIS_X] = 0.0;
            D[DIR3][AXIS_Y] = 1.0;
            D[DIR3][AXIS_Z] = 0.0;
        }
        else
        {
            D[DIR1][AXIS_X] = 1.0;
            D[DIR1][AXIS_Y] = 1.0;
            D[DIR1][AXIS_Z] = 0.0;

            D[DIR2][AXIS_X] = 1.0/sqrt(2.0);
            D[DIR2][AXIS_Y] = -1.0/sqrt(2.0);
            D[DIR2][AXIS_Z] = 1.0;

            D[DIR3][AXIS_X] = -1.0/sqrt(2.0);
            D[DIR3][AXIS_Y] = 1.0/sqrt(2.0);
            D[DIR3][AXIS_Z] = 1.0;
        }
    }
    else if(opdfaxx > 0)
    {
        D[DIR1][AXIS_X] = 1.0;
        D[DIR1][AXIS_Y] = 0.0;
        D[DIR1][AXIS_Z] = 0.0;
    }
    else if(opdfaxy > 0)
    {
        D[DIR1][AXIS_X] = 0.0;
        D[DIR1][AXIS_Y] = 1.0;
        D[DIR1][AXIS_Z] = 0.0;
    }
    else if(opdfaxz > 0)
    {
        D[DIR1][AXIS_X] = 0.0;
        D[DIR1][AXIS_Y] = 0.0;
        D[DIR1][AXIS_Z] = 1.0;
    }
    else if (opdfax3in1 > PSD_OFF || opdfaxtetra > PSD_OFF)
    {
        D[DIR1][AXIS_X] = 1.0;
        D[DIR1][AXIS_Y] = 1.0;
        D[DIR1][AXIS_Z] = 1.0;

        D[DIR2][AXIS_X] = 1.0;
        D[DIR2][AXIS_Y] = -1.0;
        D[DIR2][AXIS_Z] = -1.0;

        D[DIR3][AXIS_X] = -1.0;
        D[DIR3][AXIS_Y] = -1.0;
        D[DIR3][AXIS_Z] = 1.0;

        D[DIR4][AXIS_X] = -1.0;
        D[DIR4][AXIS_Y] = 1.0;
        D[DIR4][AXIS_Z] = -1.0;
    }
}

STATUS rotateToLogical(float * idifx, float * idify, float * idifz, int dir)
{
    float ax, ay, az;

    ax = (*idifx)*D[dir][AXIS_X];
    ay = (*idify)*D[dir][AXIS_Y];
    az = (*idifz)*D[dir][AXIS_Z];

    *idifx = inversRR[0]*ax+inversRR[1]*ay+inversRR[2]*az;
    *idify = inversRR[3]*ax+inversRR[4]*ay+inversRR[5]*az;
    *idifz = inversRR[6]*ax+inversRR[7]*ay+inversRR[8]*az;

    return SUCCESS;
}

STATUS inversRspRot( float inversRot[9], long  origRot[9])
{
    /* given that the rotation matrix would always be real and
     * orthogonal, then the inverse of the rotation matrix would
     * be the same as its tranpose matrix ZL */
    float a[9];
    int i, j;

    for (i = 0; i<9; i++)
    {
        a[i] = (float)origRot[i]/(float)max_pg_iamp;
    }

    for (i=0; i<3 ; i++)
    {
        for (j=0; j<3; j++)
        {
            inversRot[i*3+j] = a[3*j+i];
        }
    }

    if (debugTensor == PSD_ON)
    {
        printf("orig rot is\n");
        for (i=0; i<3; i++)
        {
            for (j=0; j<3; j++)
            {
                printf( "%f        ",a[i*3+j]);
            }
            printf("\n");
        }
        printf("invers rot is\n");
        for (i=0; i<3; i++)
        {
            for (j=0; j<3; j++)
            {
                printf( "%f        ",inversRot[i*3+j]);
            }
            printf("\n");
        }
        fflush( stdout );
    }
    return SUCCESS;
}

STATUS set_diff_order( void )
{
    /* This function calculates the diffusion gradient cycling orders for each pass and
     * save the scheme into diff_order.txt
     * */
    int npass;
    int nslice;
    int ndirs = 0;
    int LCD;
    int thedir = 0;
    int count = 0;
    int noffset=0;
    int n = 0, nrep = 0;
    int var;
    int kk, ll, mm;
    int maxnex;

#ifndef IPG
    int sum_dir;
    FILE *fp_diff_order = NULL;

#ifdef PSD_HW
    const char *dir_difforder = "/usr/g/service/log";
#else
    const char *dir_difforder = "./";
#endif

    char fname_difforder[255];
    sprintf(fname_difforder, "%s/diff_order.txt", dir_difforder);
#endif

    int pass_offset = (ref_in_scan_flag ? 1:0) + (rpg_in_scan_flag?rpg_in_scan_num:0);

    if (tensor_flag == PSD_OFF)
    {
        if(diff_order_flag == 1)
        {
            ndirs = num_dif;
            nrep = opnumbvals;
        }
        else if (diff_order_flag == 2)
        {
            ndirs = (int)(opdifnext2 * opdifnumt2 + num_dif * total_difnex);
            nrep = 1;
        }
    }
    else
    {
        if(diff_order_flag == 1)
        {
#ifndef IPG
            ndirs = exist(opdifnumdirs);
#else
            ndirs = opdifnumdirs;
#endif
        }
        else if (diff_order_flag == 2)
        {
            ndirs = pass_reps - pass_offset; /* Don't cycle integrated ref nor RPG volume */
        }
        nrep = 1;
    }

    int counter = 0;
    if (diff_order_flag == 2 && tensor_flag == PSD_OFF)
    {
        for(kk=0; kk<opdifnumt2; kk++)
        {
            for (ll=0; ll<opdifnext2; ll++)
            {
                diff_order_pass[counter] = kk+pass_offset;
                diff_order_nex[counter]  = ll;
                diff_order_dif[counter]  = 0;
                counter++;
            }
        }

        for(kk=0; kk<opnumbvals; kk++)
        {
#ifdef IPG
            maxnex = difnextab_rsp[kk];
#else
            maxnex = (int)difnextab[kk];
#endif
            for (ll=0; ll< maxnex; ll++)
            {
                for (mm=0; mm<num_dif; mm++)
                {
                    diff_order_pass[counter] = (int)(opdifnext2 * opdifnumt2 + mm + num_dif * kk + pass_offset);
                    diff_order_nex[counter] = ll;
                    diff_order_dif[counter] = kk;
                    counter++;
                }
            }
        }
    }

    if (ndirs == 0)
    {
        return SKIP;
    }

    /* No change in order */
    for (npass = 0; npass < opdifnumt2 + pass_offset; npass++)
    {
        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            diff_order[npass][nslice] = npass;
        }
    }

    /* Assign diffusion direction */
    if (diff_order_flag == 1)
    {
        noffset = opdifnumt2 + pass_offset;
    }
    else if (diff_order_flag == 2)
    {
        noffset = pass_offset;
    }

    LCD = getLCD(diff_order_nslices, ndirs);

    if(LCD == 0)
    {
        return FAILURE;
    }

    var = 0;

    for (npass = 0; npass < ndirs; npass++)
    {
        if (diff_order_nslices > ndirs)
        {
            var = npass;
        }

        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            if ((diff_order_flag == 1) || (diff_order_flag == 2))
            {
                thedir = thedir%ndirs;
                diff_order[noffset + npass][nslice] = noffset + thedir;
                count++;
                thedir++;
            }
        }

        if ((diff_order_flag == 1) || (diff_order_flag == 2))
        {
            thedir = thedir%ndirs;
            if(count%LCD == 0)
            {
                thedir++;
            }
            thedir = thedir%ndirs;
        }
    }

    /* repeat for multi-b */
    if (nrep > 1)
    {
        for (n = 1; n < nrep; n++)
        {
            for (npass = 0; npass < ndirs; npass++)
            {
                for (nslice = 0; nslice < diff_order_nslices; nslice++)
                {
                    diff_order[noffset + n * ndirs + npass][nslice] = diff_order[noffset + npass + (n-1) * ndirs][nslice] + ndirs;
                }
            }
        }
    }

#ifndef IPG
    /* Debug info in diff_order.txt*/
    if(diff_order_debug)
    {
        if (NULL != (fp_diff_order = fopen(fname_difforder, "w")))
        {
            fprintf(fp_diff_order, "# ndirs, Slices\n");
            fprintf(fp_diff_order, "%d, %d\n", ndirs, diff_order_nslices);
            fprintf(fp_diff_order, "# opdfaxall, opdfax3in1, opdfaxtetra, optensor\n");
            fprintf(fp_diff_order, "%d, %d, %d, %d\n", opdfaxall, opdfax3in1, opdfaxtetra, optensor);

            for (npass = 0; npass < diff_order_size; npass++)
            {
                fprintf(fp_diff_order, "# Pass %d: \n", npass);
                for (nslice = 0; nslice < diff_order_nslices; nslice++)
                {
                    fprintf(fp_diff_order, "%d ", diff_order[npass][nslice]);
                }
                fprintf(fp_diff_order, "\n");

            }

            if (diff_order_flag == 2 && tensor_flag == PSD_OFF)
            {
                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_pass: ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_pass[npass]);
                }

                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_nex:  ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_nex[npass]);
                }

                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_dif:  ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_dif[npass]);
                }
            }
            fclose(fp_diff_order);
        }
    }

    /* verify order */
    if (diff_order_verify == 1)
    {
        int *verify_diff = NULL;
        if((verify_diff = (int *) malloc(sizeof(int) * pass_reps)) == NULL)
        {
            return FAILURE;
        }

        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            memset(verify_diff, 0, sizeof(int) * pass_reps);

            sum_dir = 0;

            for (npass = 0; npass < pass_reps; npass++)
            {
                if(verify_diff[diff_order[npass][nslice]] == 1)
                {
                    return FAILURE;
                }
                else
                {
                    verify_diff[diff_order[npass][nslice]] = 1;
                }

                sum_dir += diff_order[npass][nslice];
            }

            if (sum_dir != pass_reps*(pass_reps - 1)/2)
            {
                return FAILURE;
            }
        }

        free(verify_diff);
    }

#endif
    return SUCCESS;
}

int getLCD(int a, int b)
{
    int x, y, r;

    x = a;
    y = b;
    r = a % b;

    while (r > 0)
    {
        x = y;
        y = r;
        r = x % y;
    }

    return a*b/y;
}

int get_diff_order(int pass, int slice)
{
    return diff_order[pass][slice];
}

/* Include special CV download code */
#include "epi2.cvcopy.cpp"

