/*
 *  epi2.tgt.cpp
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Jul 22 2018
 *  Time : 03:23:38
 */

#include <epic_struct.h>
#if defined(MGD_TGT) && defined(PSD_HW)
#include "valuesMGD.h"
#endif /* MGD_TGT && PSD_HW */
#include "epi2.global.h"
#include <pgen_tmpl.h>
#include <epicfuns.h>
#ifdef PSD_HW
__asm__(".align 8");
#endif

#include "epi2.allcv.h"
#include "epi2.tgtex.h"
#include "epi2.tgtdecl.h"
long _header_source_rev= 1558027195;
int omegathetamod_func(int dur, 
		       int isodelay,
		       short *om_in, 
		       int om_res, 
		       int om_amp_hz, 
		       short *th_in, 
		       int th_res, 
		       short *gz_in, 
		       int gz_res, 
		       float gz_amp_gcm, 
		       float zoffset,
		       short *om_out_iamp, 
		       LONG *om_out_wave, 
		       LONG *th_out_wave)
{
  int res_out;		       /* Resolution of output waveforms */
  float *kz_omth;	       /* Excitation k-space */
  float *freq_in_omth;     /* Floating-point frequency waveform */
  float *phase_in_omth;    /* Floating-point phase waveform */
  int idx;		       /* temp index */
  int gzidx;	       /* temp index */
  int kzidx;	       /* temp index */
  int omidx;	       /* temp index */
  int thidx;	       /* temp index */
  int zm, zmidx;	       /* zoom factor and index */
  float gscale_to_kz;      /* Conversion to cycles/cm */
  float kzint;	       /* Current Kz integral */
  float kzref;	       /* Kz reference value */
  float freq_ideal_max; 
  float *phase_ideal_omth; /* Ideal output phase waveform */
  float *freq_ideal_omth; /* Ideal output frequency waveform */
  float *phase_correct_omth; /* Phase correction to apply after non-ideal frequency */
  short *freq_out_omth;
  short *phase_out_omth;
  float phase_wrap_off;    /* phase unwrapping offset */
  float phase_save;    /* temp variable used during phase unwrapping */
  float phaseref;	       /* Kz reference value */
  float phdiff;	       /* temp value */

  WF_PULSE temp_om_omth = INITPULSE;  /* temp Omega waveform pulse */
  WF_PULSE temp_th_omth = INITPULSE;  /* temp Theta waveform pulse */

  static const CHAR *routine = "omegathetamod";

  /* Calculate resolution of omega-theta waveforms */
  res_out = dur/ RF_UPDATE_TIME;

  kz_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for floating-point frequency / phase inputs */
  freq_in_omth = (float *)AllocNode(res_out * sizeof(float));

  phase_in_omth = (float *)AllocNode(res_out * sizeof(float));
      
  /* Initialize frequency and phase input waveforms to zero */
  for (idx = 0; idx < res_out; idx++) {
    freq_in_omth[idx] = 0.0;
    phase_in_omth[idx] = 0.0;
  }

  /* Allocate memory for ideal phase */
  phase_ideal_omth = (float *)AllocNode(res_out * sizeof(float));

  freq_ideal_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for phase correction to omega quantization */
  phase_correct_omth = (float *)AllocNode(res_out * sizeof(float));

  /* Allocate memory for temporary phase / frequency final results */
  phase_out_omth = (short *)AllocNode(res_out * sizeof(short));
  freq_out_omth = (short *)AllocNode(res_out * sizeof(short));

  /* Calculate interpolation required to apply to gradient */
  zm = res_out/ gz_res;

  /* Calculate excitation k-space at RF_UPDATE_TIME spacing */
  /* NOTE - Excitation k-space is integrated from t to T (end of pulse)!! */
  kzidx = res_out-1;
  kzint = 0.0;
  gscale_to_kz = -GAM * gz_amp_gcm * 1.0e-6 * RF_UPDATE_TIME/ max_pg_wamp;
  for (gzidx = gz_res-1; gzidx >= 0; gzidx--)
    for (zmidx = 0; zmidx <zm; zmidx++) {
      kzint = kzint + gscale_to_kz * gz_in[gzidx];
      kz_omth[kzidx--] = kzint;
    }
      
  /* Remove offset to k-space origin reference -- this will keep excitation profile / phase
     constant independent of the offset applied */
  kzref = kz_omth[((int) (res_out - isodelay/RF_UPDATE_TIME))];
  for (kzidx = 0; kzidx < res_out; kzidx++) 
    kz_omth[kzidx] -= kzref;

  /* Now read in external frequency waveform if it exists */
  if (om_res != 0) { /* Check for non-null input */
    /* Assign freq_omth to input frequency waveform - do NOT interpolate */
    zm = res_out/ om_res;
    if (om_res * zm != res_out) {
        MsgHndlr(routine,
                 MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "OMEGA resolution");
      return FAILURE;
    }

    idx = 0;
    for (omidx = 0; omidx < om_res; omidx++)
      for (zmidx = 0; zmidx <zm; zmidx++) 
	freq_in_omth[idx++] = (om_in[omidx] * om_amp_hz/ max_pg_wamp) * 1.0;
  } /* non-null omega */

  /* Now read in external phase waveform if it exists */
  if (th_res != 0) {	/* Check for non-null string filename */
    /* Assign freq_omth to input frequency waveform - do NOT interpolate */
    zm = res_out/ th_res;
    if (th_res * zm != res_out) {
        MsgHndlr(routine,
                 MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "THETA resolution");
      return FAILURE;
    }

    idx = 0;
    for (thidx = 0; thidx < th_res; thidx++)
      for (zmidx = 0; zmidx <zm; zmidx++) 
	phase_in_omth[idx++] = th_in[thidx] * PI/ max_pg_wamp;
  } /* non-null theta file string */

  /* Reserve waveform memory for omega / theta waveforms */
  *th_out_wave = createwreserve(&temp_th_omth, TYPTHETA, res_out);
  *om_out_wave = createwreserve(&temp_om_omth, TYPOMEGA, res_out);

  /* Calculate ideal phase waveform by first integrating frequency */
  for (idx = 0; idx < res_out; idx++) 
    if (idx == 0)
      phase_ideal_omth[idx] = 2 * PI * freq_in_omth[idx] * RF_UPDATE_TIME * 1e-6;
    else
      phase_ideal_omth[idx] = phase_ideal_omth[idx-1] + 2 * PI * freq_in_omth[idx] * RF_UPDATE_TIME * 1e-6;
  /* Set phase to 0 at reference point in pulse */
  phaseref = phase_ideal_omth[((int) (res_out - isodelay/RF_UPDATE_TIME))];
  for (idx = 0; idx < res_out; idx++) {
    phase_ideal_omth[idx] -= phaseref;
  }

  /* Calculate phase contribution from Z offset and input phase waveform */
  for (idx = 0; idx < res_out; idx++) {
    phase_ideal_omth[idx] = phase_ideal_omth[idx] + phase_in_omth[idx] - omegatheta_pol * 2 * PI * kz_omth[idx] * zoffset;
    phase_ideal_omth[idx] = MODTWOPI(phase_ideal_omth[idx]);
  }
	
  /* Unwrap phase waveform */
  phase_wrap_off = 0.0;
  phase_save = phase_ideal_omth[0];
  for (idx = 1; idx < res_out; idx++) {
    phdiff = phase_ideal_omth[idx] - phase_save;
    phase_save = phase_ideal_omth[idx];
    if (phdiff < -PI)
      phase_wrap_off += 2 * PI;
    if (phdiff > PI) 
      phase_wrap_off -= 2 * PI;
    phase_ideal_omth[idx] += phase_wrap_off;
  }

  /* Calculate ideal frequency waveforms and max frequency */
  freq_ideal_max = 0.0;
  for (idx = 0; idx < res_out-1; idx++) {
    freq_ideal_omth[idx] = (phase_ideal_omth[idx+1]-phase_ideal_omth[idx])/(2*PI*RF_UPDATE_TIME*1e-6);
    freq_ideal_max = FMax(2, freq_ideal_max, FABS(freq_ideal_omth[idx]));
  }
  freq_ideal_omth[res_out-1] = freq_ideal_omth[res_out-2];
  /* We must now quantize the ideal frequency waveform onto a 16-bit
     time-varying waveform and a 16-bit instruciton multiplier. The effective
     frequency that will be encoded by the waveform / instruction
     amplitude product is in the 24 MSBs of the product. e.g. 

     freq = (wamp * iamp / 2^7) * TARDIS_FREQ_RES

     If we scale the max wamp to a full signed 16 bits, then the instruction
     amplitude will be scaled by 2^15

     freq = (max_wamp * iamp / 2^7) * TARDIS_FREQ_RES

     or 

     iamp = freq * 2^7 / (TARDIS_FREQ_RES * 2^15)
     iamp = freq / (TARDIS_FREQ_RES * 2^8)
  */

  for (idx = 0; idx < res_out; idx++) {
    if (freq_ideal_max > 0.0)
      freq_out_omth[idx] = (int)(freq_ideal_omth[idx]/ freq_ideal_max * max_pg_wamp);
    else
      freq_out_omth[idx] = max_pg_wamp;
    freq_out_omth[idx] &= 0xfffe; /* Set LSB to 0 */
  }
  freq_out_omth[res_out-1] |= 1; /* Set LSB to 1 */
	
  /* Move frequency waveform to hardware, save instruction amplitude */
  movewavememimm(&temp_om_omth, TYPOMEGA, freq_out_omth, *om_out_wave, res_out, TOHARDWARE);
  *om_out_iamp = (int) (freq_ideal_max/ (TARDIS_FREQ_RES * 256.0));

  /* Now calculate phase correction to apply to achieve the ideal desired
     phase at each time point. This corrects for quantization errors in the
     frequency waveform. Start with calculating the integral of the frequency
     waveform, then calculate the correction to apply. */
  for (idx = 0; idx < res_out; idx++) 
    if (idx == 0)
      phase_correct_omth[idx] = ((int) ((freq_out_omth[idx] * (*om_out_iamp)) >> 7)) * TARDIS_FREQ_RES * RF_UPDATE_TIME * 1e-6 * 2 * PI;  
    else
      phase_correct_omth[idx] = phase_correct_omth[idx-1] + ((int) ((freq_out_omth[idx] * (*om_out_iamp)) >> 7)) * TARDIS_FREQ_RES * RF_UPDATE_TIME * 1e-6 * 2 * PI;  

  for (idx = 0; idx < res_out; idx++) 
    phase_correct_omth[idx] = phase_ideal_omth[idx] - phase_correct_omth[idx];

  /* Convert phase correction into [-pi, pi] range and convert to digital scale */
  for (idx = 0; idx < res_out; idx++) {
    phase_correct_omth[idx] = MODTWOPI(phase_correct_omth[idx]);
    phase_out_omth[idx] = (short)(phase_correct_omth[idx] * max_pg_wamp/ PI);
    phase_out_omth[idx] &= 0xfffe;
  }
  phase_out_omth[res_out-1] |= 0x0001;

  /* Move phase waveform to hardware */
  movewavememimm(&temp_th_omth, TYPTHETA, phase_out_omth, *th_out_wave, res_out, TOHARDWARE);

  /* Now free up all the memory we reserved */
  FreeNode((ADDRESS) kz_omth);
  FreeNode((ADDRESS) freq_in_omth);
  FreeNode((ADDRESS) phase_in_omth);
  FreeNode((ADDRESS) phase_ideal_omth);
  FreeNode((ADDRESS) freq_ideal_omth);
  FreeNode((ADDRESS) phase_correct_omth);
  FreeNode((ADDRESS) phase_out_omth);
  FreeNode((ADDRESS) freq_out_omth);

  return(SUCCESS);
}

/*********************************************************************
 *                       EPI2.E PULSEGEN SECTION                     *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
/* MRIge55206 - change memory allocation if in SIM for multi-dim array support */
#ifdef SIM
#include <stdlib.h>
#define AllocMem malloc
#else
#define AllocMem AllocNode
#endif

#include <math.h>

long rsprot_orig[DATA_ACQ_MAX][9]; /* rotation matrix for SAT */
extern PSD_EXIT_ARG psdexitarg;
short *acq_ptr;               /* first slice in a pass */
int   *ctlend_tab;            /* table of cardiac deadtimes */
short *slc_in_acq;            /* number of slices in each pass */
/* Frequency/Phase offsets */
int   *rf1_freq;
int   *theta_freq;
int   *rf2_freq;
int   *thetarf2_freq;
int   ***recv_freq;
int   ***recv_phase;
double ***recv_phase_ang_nom;   /* nominal receiver phase angle - XJZ */
double ***recv_phase_angle;
int *rf1_pha;
int *rf2_pha;
int *rf2left_pha;
int *rf2right_pha;
WF_PULSE tmppulse,*tmppulseptr;
WF_INSTR_HDR *tmpinstr;
int **diff_order;
int *diff_order_pass;
int *diff_order_nex;
int *diff_order_dif;

/* update for external gradient waveforms for QTI granty 9/28/2017 */
/* holds QTI waveforms */
WF_PULSE gxdlbuff = INITPULSE;
WF_PULSE gxdrbuff = INITPULSE;
WF_PULSE gydlbuff = INITPULSE;
WF_PULSE gydrbuff = INITPULSE;
WF_PULSE gzdlbuff = INITPULSE;
WF_PULSE gzdrbuff = INITPULSE;

WF_PULSE gxiso1 = INITPULSE;
WF_PULSE gxiso2 = INITPULSE;
WF_PULSE gyiso1 = INITPULSE;
WF_PULSE gyiso2 = INITPULSE;
WF_PULSE gziso1 = INITPULSE;
WF_PULSE gziso2 = INITPULSE;

/* bipolar trapezoidal waveform */
WF_PULSE gbpbuffx = INITPULSE;
WF_PULSE gbpbuffy = INITPULSE;
WF_PULSE gbpbuffz = INITPULSE;
/* Single trapezoidal waveform */
WF_PULSE gtrapbuffx = INITPULSE;
WF_PULSE gtrapbuffy = INITPULSE;
WF_PULSE gtrapbuffz = INITPULSE;

WF_PULSE gxdr = INITPULSE;
WF_PULSE gxdl = INITPULSE;
WF_PULSE gydr = INITPULSE;
WF_PULSE gydl = INITPULSE;
WF_PULSE gzdr = INITPULSE;
WF_PULSE gzdl = INITPULSE;
/* declare delta grad and freq arrays */

/* delta grad and freq arrays */
int ***ia_gx_hoec_comp, ***ia_gy_hoec_comp;  /* final value for gradient amplitude correction */
double ***recv_phase_b0_hoec_comp;  /* final value for frequency correction */

/* Allocate memory for PSD correction in AGP */

int   **rf_phase_spgr;
WF_PULSE **echotrainxtr;
WF_PULSE **echotrainrba;
int *echotrainramp1;
int *echotrainramp2;

/*RTB0 correction*/
WF_PULSE_ADDR rtb0echoxtr;

/* invertGy1 = 1 or -1, for rpg_flag.
   We need this for setting gy1f because this is init in PG by ileaveinit and 
   depends on pepolar. For the RPG volume, gy1 needs to be inverted because
   it is not initialized properly. */
int invertGy1 = 1;

/* The following arrays are indexed by intleave: */
int *gy1f;      /* amplitude of gy1f pulse */
int *gymn;      /* amplitude of y gradient moment nulling pulses */
int *view1st;   /* 1st view to acquire */
int *viewskip;  /* number of views to skip */
int *tf;        /* time factor shift */
int *rfpol;     /* rf polarity */
int *blippol;   /* blip gradient polarity */
int *gradpol;   /* readout gradient polarity */
float *b0ditherval;/* B0 dither value, per slice basis */
float *delayval;   /* delay values, per slice basis */
int *gldelaycval;  /* per slice gldelayc valuse */
float *gldelayfval; /* per slice gldelayf values */
int defaultdelay = 0; /* default delay */
int mintf;         /* most negative tfon value, for echo train positioning */
int sp_satindex, cs_satindex;  /* index for multiple calls to spsat
                                  and chemsat routines */
int rcvrunblankpos;
WF_PULSE gx1a = INITPULSE;
WF_PULSE gx1 = INITPULSE;
WF_PULSE gx1d = INITPULSE;

WF_PULSE rs_omega_attack = INITPULSE;
WF_PULSE rs_omega_decay = INITPULSE;
WF_PULSE omega_flat = INITPULSE;

WF_PULSE rho_killer = INITPULSE;

long scan_deadtime_inv;      /* deadtime in ir prep loop */
long scan_deadlast;          /* deadtime in last seqcore loop in 
                                Interleaved IR EPI*/
long prescan_trigger;        /* save the prescan slice's trigger */
long rsptrigger_temp[1];     /* temp trigger array for pass packets 
                                sequences and other misc */
/* Original scan info */
RSP_INFO orig_rsp_info[DATA_ACQ_MAX];
long origrot[DATA_ACQ_MAX][9];
WF_INSTR_HDR *instrtemp;

char psddbgstr[256] = "";

/* t1flair_stir */

int **real_slice_acq_seq;
int *physical_slice_acq_seq_reg;
int *physical_slice_acq_seq_enh;
int **T1flair_slice_flag;

STATUS
T1flair_sliceordering(void)
{
    if (PSD_ON == t1flair_flag)
    {
        int p, s, s1, n, tmpdummyslices, kk;
        int tmp_real_slice_acq_seq[128];
        FILE *fp = NULL;

        if (PSD_ON == debug_t1flairenh)
        {
#ifdef PSD_HW
            fp = fopen("/usr/g/service/log/t1flairsliceorder.txt", "w+");
#else
            fp = fopen("t1flairsliceorder.txt", "w+");
#endif
        }

        for (p = 0; p < acqs; p++)
        {
            /* read slice information including dummy and edge slices */
            if (t1flair_slice_info_enh[0] == slquant1)
            {
                for (s = 1; s <= slquant1; s++)
                {
                    physical_slice_acq_seq_enh[t1flair_slice_info_enh[s]] = s;
                }
            }
            else /* this should not happen */
            {
                for (s = 0; s < slquant1; s++)
                {
                    physical_slice_acq_seq_enh[s] = s + 1;
                }
            }

            /* read slice information of img slice */
            if (t1flair_slice_info_reg[0] == slquant1-dummyslices - 2*act_edge_slice_enh_flag)
            {
                for (s = 1; s <= slquant1-dummyslices - 2*act_edge_slice_enh_flag; s++)
                {
                    physical_slice_acq_seq_reg[t1flair_slice_info_reg[s]] = s;
                }
            }
            else /* this should not happen */
            {
                for (s = 0; s < slquant1-dummyslices - 2*act_edge_slice_enh_flag; s++)
                {
                    physical_slice_acq_seq_reg[s] = s + 1;
                }
            }

            /* initialization */
            for (s = 0; s < slquant1; s++)
            {
                tmp_real_slice_acq_seq[s] = s;
            }

            /* extra dummy slice due to multiple pass */
            tmpdummyslices = ((slc_in_acq[p] == slc_in_acq[0])? 0:1);

            /* determine dummy slices */
            if (dummyslices >= 0)
            {
                tmpdummyslices += dummyslices;

                kk = 0;
                for (s = 0; s < slquant1; s++)
                {
                    if (physical_slice_acq_seq_enh[s] > (slquant1 - tmpdummyslices))
                    {
                        physical_slice_acq_seq_enh[s] = -1;
                        tmp_real_slice_acq_seq[s] = slc_in_acq[p] + 2* act_edge_slice_enh_flag + kk;
                        kk++;
                        for (s1 = s+1; s1 < slquant1; s1++)
                        {
                            tmp_real_slice_acq_seq[s1] -= 1;
                        }
                    }
                }
            }

            /* adjust slice ordering for multipass scan */
            if (slc_in_acq[p] != slc_in_acq[0])
            {
                int m, tmps;
                for (n = 0; n < slquant1 - dummyslices - 2*act_edge_slice_enh_flag - 1; n++)
                {
                    if (physical_slice_acq_seq_reg[n] == slquant1 - dummyslices - 2*act_edge_slice_enh_flag)
                    {
                        tmps = physical_slice_acq_seq_reg[n];
                        for (m = n; m < slquant1 - dummyslices - 2*act_edge_slice_enh_flag -1; m++)
                        {
                            physical_slice_acq_seq_reg[m] = physical_slice_acq_seq_reg[m+1];
                        }
                        physical_slice_acq_seq_reg[slquant1 - dummyslices - 2*act_edge_slice_enh_flag -1] = tmps;
                        break;
                    }
                }
            }

            /* determine edge slice and set flag */
            for (s = 0; s < slquant1; s++)
            {
                if (-1 == physical_slice_acq_seq_enh[s])
                {
                    T1flair_slice_flag[p][s] = DUMMYSLICE;
                    real_slice_acq_seq[p][s] = tmp_real_slice_acq_seq[s];
                }
                else if (PSD_OFF == act_edge_slice_enh_flag)
                {
                    T1flair_slice_flag[p][s] = IMGSLICE;
                    real_slice_acq_seq[p][s] = tmp_real_slice_acq_seq[s];
                }
                else
                {
                    if (1 == physical_slice_acq_seq_enh[s])
                    {
                        T1flair_slice_flag[p][s] = EDGESLICE;
                        for (n = 0; n < slquant1- tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s] == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                    else if (physical_slice_acq_seq_enh[s] == (slc_in_acq[p]+2*act_edge_slice_enh_flag))
                    {
                        T1flair_slice_flag[p][s] = EDGESLICE;
                        for (n = 0; n < slquant1-tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s]-2 == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                    else
                    {
                        T1flair_slice_flag[p][s] = IMGSLICE;
                        for (n = 0; n < slquant1-tmpdummyslices - 2*act_edge_slice_enh_flag; n++)
                        {
                            if (physical_slice_acq_seq_enh[s] -1 == physical_slice_acq_seq_reg[n])
                            {
                                real_slice_acq_seq[p][s] = n;
                                break;
                            }
                        }
                    }
                }
            }

            if (fp != NULL)
            {
                fprintf(fp, "Pass #%d\nenhreal enhphy  act_real  flag origreal\n",p);
                for (s = 0; s < slquant1; s++)
                {
                    if (s < slquant1 - dummyslices - 2*act_edge_slice_enh_flag)
                    {
                       fprintf(fp,"%2d      %2d     %2d     %2d    %2d \n",
                               tmp_real_slice_acq_seq[s], physical_slice_acq_seq_enh[s],
                               real_slice_acq_seq[p][s], T1flair_slice_flag[p][s],
                               physical_slice_acq_seq_reg[s]);
                    }
                    else
                    {
                       fprintf(fp,"%2d      %2d     %2d     %2d\n",
                               tmp_real_slice_acq_seq[s], physical_slice_acq_seq_enh[s],
                               real_slice_acq_seq[p][s], T1flair_slice_flag[p][s]);
                    }
                }
            }
        }
        if (fp != NULL)
        {
            fclose(fp);
        }
    }
    return SUCCESS;
}



/*RTB0 correction*/
short sspwm_dynr1[4]={SSPDS,SSPOC,SSPD,SSPDS};


/* Frequency offsets */
int *rf0_freq;
int *rf0_pha;


WF_PULSE gyrf1a = INITPULSE;
WF_PULSE gyrf1  = INITPULSE;
WF_PULSE gyrf1d = INITPULSE;
WF_PULSE thrf1  = INITPULSE;
WF_PULSE *thrf1sl;
WF_HW_WAVEFORM_PTR *thrf1slp;

EXTERN_FILENAME rf1_filename;
EXTERN_FILENAME gz_filename;
EXTERN_FILENAME th_filename;
EXTERN_FILENAME gy_filename;

/* SVBranch HCSDM00155611 Use Type I pulse, pos lobes and 
   neg lobes may be different */
WF_PULSE gyrf1pa = INITPULSE;
WF_PULSE gyrf1p  = INITPULSE;
WF_PULSE gyrf1pd = INITPULSE;
WF_PULSE gyrf1na = INITPULSE;
WF_PULSE gyrf1n  = INITPULSE;
WF_PULSE gyrf1nd = INITPULSE;

/* for walk sat */
EXTERN_FILENAME rho_file;
EXTERN_FILENAME pha_file;
WF_PULSE rfwk = INITPULSE;
WF_PULSE thrfwk = INITPULSE;
WF_PULSE gyrfwk = INITPULSE;
WF_PULSE gyrfwka = INITPULSE;
WF_PULSE gyrfwkd = INITPULSE;
WF_PULSE *rfwksl;
WF_PULSE *thrfwksl;
WF_HW_WAVEFORM_PTR *rfwkslp;
WF_HW_WAVEFORM_PTR *thrfwkslp;

/* pointers to temporary waveforms for omega */
short *temp_wave1; short *temp_wave2; short *temp_wavep; short *temp_wavesum;
char pnstr[40];

void integrate2_add_phasewave (short *thwaveout, short *phasewave, short *omegawave1,
                               float ia_omegawave1, short *omegawave2, float ia_omegawave2, int npoints)
{
    /* TARDIS_FREQ_RES : Resiolution of frequency (about .596Hz/Unit)
       PSD_THETAFREQ_SHIFT : 4, Theta frequency path multiplier */
    int count;
    int current_integral = 0;
    float bits_to_hz = TARDIS_FREQ_RES * PSD_THETAFREQ_SHIFT * 64;
    float maxia_to_2pi = 2.0;
    int delta_t = pw_rf1/npoints;
 
    for (count = 0; count < npoints; count++)
    {
        current_integral += (int)(maxia_to_2pi*bits_to_hz*delta_t/1E6*ia_omegawave1*(*omegawave1++));
        current_integral += (int)(maxia_to_2pi*bits_to_hz*delta_t/1E6*ia_omegawave2*(*omegawave2++));
        *thwaveout++ = ((short)((current_integral + (*phasewave++))) & 0xfffe);
    }

    thwaveout--;               /* Back pointer up to last point */
    *thwaveout = *thwaveout+1; /* Set EOS bit */
    thwaveout++;               /* Advance pointer again. */
}

/*** SVBranch HCSDM00155611 Pulsegen for walk sat ***/
STATUS walk_sat_pulsegen(void)
{  

    /* declare the space for rho/pha waves */
    short *temp_waver_orig;
    short *temp_waver;
    short *temp_waver_ha;
    short *temp_wavep_orig;
    short *temp_wavep; 
    short *temp_wavep_ha;
    short *temp_wavep_sum; 
 
    /* update resolution after RF stretch */
    if (rfpulseInfo[RFWK_SLOT].change==PSD_ON)     
    {
        res_rfwk = rfpulseInfo[RFWK_SLOT].newres;
    }
    else
    {
        res_rfwk = res_rfwk_orig;
    }     
     
    /* allocate space for rho/pha waves */
    temp_waver_orig = (short *)AllocNode(res_rfwk_orig*sizeof(short));   
    temp_wavep_orig = (short *)AllocNode(res_rfwk_orig*sizeof(short)); 
    temp_waver      = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_waver_ha   = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_wavep      = (short *)AllocNode(res_rfwk*sizeof(short));
    temp_wavep_ha   = (short *)AllocNode(res_rfwk*sizeof(short)); 
    temp_wavep_sum  = (short *)AllocNode(res_rfwk*sizeof(short));    
  
    /* name the pulses */
    pulsename(&rfwk, "rfwk");
    pulsename(&thrfwk, "thrfwk");  
    pulsename(&gyrfwk, "gyrfwk");
    pulsename(&gyrfwka, "gyrfwka");
    pulsename(&gyrfwkd, "gyrfwkd");      
   
    /* external file names */
    sprintf(rho_file, "satqptbw12.rho");
    sprintf(pha_file, "satqptbw12.the");
   
    /* read in rho & pha wave */
    uextwave(temp_waver_orig, res_rfwk_orig, rho_file);
    uextwave(temp_wavep_orig, res_rfwk_orig, pha_file);                  
    
    /* stretch rf if needed */
    if (rfpulseInfo[RFWK_SLOT].change==PSD_ON) 
    {  
        /* stretch rho */    
        stretchpulse(res_rfwk_orig, 
                     res_rfwk,
                     temp_waver_orig,
                     temp_waver);
        /* stretch pha */
        stretchpulse(res_rfwk_orig, 
                     res_rfwk,
                     temp_wavep_orig,
                     temp_wavep);        
    } 
    else
    {
        temp_waver = temp_waver_orig; 
        temp_wavep = temp_wavep_orig;  
    }           
    
    /* create RHO waveform */
    createreserve(&rfwk, RHO, res_rfwk);
    rfwksl = (WF_PULSE *) AllocNode(sizeof(WF_PULSE));
    rfwkslp = (WF_HW_WAVEFORM_PTR *) AllocNode(sizeof(WF_HW_WAVEFORM_PTR));
    pulsename(&rfwksl[0], "rfwksl0");
    createreserve(&rfwksl[0], RHO, res_rfwk);    
     
    /* create THETA waveform */
    createreserve(&thrfwk, THETA, res_rfwk);
    thrfwksl = (WF_PULSE *) AllocNode(sizeof(WF_PULSE));
    thrfwkslp = (WF_HW_WAVEFORM_PTR *) AllocNode(sizeof(WF_HW_WAVEFORM_PTR));
    pulsename(&thrfwksl[0], "thrfwksl0");
    createreserve(&thrfwksl[0], THETA, res_rfwk); 
  
    /* create Hadamard waveforms */
	altcomplexrfgen((INT)TYPLINEAR, 
                    res_rfwk, 
                    temp_waver, 
                    temp_wavep, 
                    cyc_rfwk,
                    sep_sat_ratio, 
                    1.0, 
                    NULL, 
                    (FLOAT)0, 
                    temp_waver_ha, 
                    temp_wavep_ha,
                    65536/(float)res_rfwk);                
    movewaveimm(temp_waver_ha, &rfwksl[0], 0, res_rfwk, TOHARDWARE); 
    movewaveimm(temp_wavep_ha, &thrfwksl[0], 0, res_rfwk, TOHARDWARE);    
    rfwkslp[0] = rfwksl[0].wave_addr; 
    thrfwkslp[0] = thrfwksl[0].wave_addr;      

    /* set instructions for RHO waves */
    createinstr(&rfwk, pos_rfwk + psd_rf_wait, pw_rfwk, ia_rfwk);   
    setwave(rfwkslp[0], &rfwk, 0);
    addrfbits(&rfwk, off_rfwk, (LONG)pos_rfwk + psd_rf_wait, pw_rfwk);    

    /* set instructions for THETA waves */
    createinstr(&thrfwk, pos_rfwk + psd_rf_wait, pw_rfwk, ia_thrfwk);   
    setwave(thrfwkslp[0], &thrfwk, 0); 
    addrfbits(&thrfwk, off_thrfwk, (LONG)pos_rfwk + psd_rf_wait, pw_rfwk);   
 
    /* slice selective gradients */
    /* ramp up */
    createramp(&gyrfwka,
               YGRAD,
               pw_gyrfwka,
               (short)0,
               MAX_PG_WAMP,
               (short)(maxGradRes*(pw_gyrfwka/GRAD_UPDATE_TIME)), 
               loggrd.ybeta);
    createinstr(&gyrfwka,
                (long)(pos_rfwk-pw_gyrfwka),
                pw_gyrfwka,
                ia_gyrfwk);
    /* plateau */
    createconst(&gyrfwk,
                YGRAD,
                pw_gyrfwk,
                MAX_PG_WAMP);
    createinstr(&gyrfwk,
                (long)(pos_rfwk),
                pw_gyrfwk,
                ia_gyrfwk);
    /* ramp down */
    createramp(&gyrfwkd,
               YGRAD,
               pw_gyrfwkd,
               MAX_PG_WAMP,
               (short)0,
               (short)(maxGradRes*(pw_gyrfwkd/GRAD_UPDATE_TIME)),
               loggrd.ybeta);
    createinstr(&gyrfwkd,
                (long)(pos_rfwk+pw_gyrfwk),
                pw_gyrfwkd,
                ia_gyrfwk);    
 
    /* spoilers */
         

  trapezoid((WF_PROCESSOR)wg_gxwksp, "gxwksp", &gxwksp, &gxwkspa,
                        &gxwkspd, pw_gxwksp, pw_gxwkspa, pw_gxwkspd,
                        ia_gxwksp, 0, 0, 0, 0, pos_sp_wk+pw_gxwkspa-pw_gxwkspa, TRAP_ALL,
                        &loggrd);
   
         

  trapezoid((WF_PROCESSOR)wg_gywksp, "gywksp", &gywksp, &gywkspa,
                        &gywkspd, pw_gywksp, pw_gywkspa, pw_gywkspd,
                        ia_gywksp, 0, 0, 0, 0, pos_sp_wk+pw_gywkspa-pw_gywkspa, TRAP_ALL,
                        &loggrd);

         

  trapezoid((WF_PROCESSOR)wg_gzwksp, "gzwksp", &gzwksp, &gzwkspa,
                        &gzwkspd, pw_gzwksp, pw_gzwkspa, pw_gzwkspd,
                        ia_gzwksp, 0, 0, 0, 0, pos_sp_wk+pw_gzwkspa-pw_gzwkspa, TRAP_ALL,
                        &loggrd);
 
 
    /* link pulses */
    linkpulses(4,
               &rfwk,
               &gyrfwk,
               &gyrfwka,
               &gyrfwkd);  
               
    /* Deallocate space */
    FreeNode(temp_waver_orig);   
    FreeNode(temp_wavep_orig);     
    FreeNode(temp_waver);
    FreeNode(temp_waver_ha);    
    FreeNode(temp_wavep);     
    FreeNode(temp_wavep_ha);             

    return SUCCESS;    
}
/****************************************************/

STATUS rfov_pulsegen(void)
{
    INT i;

    if(res_rf1 <= 0)
    {
        return FAILURE;
    }

    /* Timing of the pulses */
    start_rf1 = pos_start;

    /* SVBranch HCSDM00155611 walk sat pulsegen */
    if (walk_sat_flag)
    {
        if (FAILURE == walk_sat_pulsegen()) return FAILURE;
        start_rf1 = start_rf1 + pw_wksat_tot;
    }    
    
    /* Name the pulses */
    pulsename(&rf1, "rf1");
    pulsename(&thrf1, "thrf1");

    /* External filenames */
    sprintf(rf1_filename, "2drf_%d.rho", rfov_type);
    sprintf(gz_filename, "2drf_%d.gz", rfov_type);
    sprintf(gy_filename, "2drf_%d.gy", rfov_type);
    sprintf(th_filename, "2drf_%d.theta", rfov_type);

    /* Read external rho waveform in */
    createextwave(&rf1, RHO, res_rf1, rf1_filename);

    /* Create instructions for external waveforms */
    createinstr(&rf1, start_rf1 + psd_rf_wait + addrfdel, pw_rf1, ia_rf1);
    addrfbits(&rf1, 0, start_rf1 + psd_rf_wait + addrfdel, pw_rf1);

    /* Allocate space for theta waveforms to be summed */
    temp_wavep = (short *) AllocNode(res_rf1 * sizeof(short));
    temp_wavesum = (short *) AllocNode(res_rf1 * sizeof(short));

    /* Read waveform into local memory */
    /* SVBranch HCSDM00155611 Type I case: no extra phase wave */
    if (type1_flag)
    {
        for (i=0; i<res_rf1; i++)
        {
            temp_wavep[i] = (short)0; 
        }
    }    
    else /* regular case */
    {
        uextwave(temp_wavep, res_rf1, th_filename); 
    }

    /* Allocate space and set-up gradients here since they are used in RF setup */
    temp_wave1 = (short *) AllocNode(res_rf1 * sizeof(short));
    temp_wave2 = (short *) AllocNode(res_rf1 * sizeof(short));
    uextwave(temp_wave1, res_rf1, gy_filename);
    uextwave(temp_wave2, res_rf1, gz_filename);

    /* Create theta waveform for shifting the excitation */
    createreserve(&thrf1, THETA, res_rf1);
    thrf1sl = (WF_PULSE *) AllocNode(opslquant*sizeof(WF_PULSE));
    thrf1slp = (WF_HW_WAVEFORM_PTR *) AllocNode(opslquant*sizeof(WF_HW_WAVEFORM_PTR));

    for (i = 0; i < opslquant; i++)
    {
        /* Integrate and add Gy and Gz, add phase as theta waveforms
           Then move the summed waveform to waveform memory */
        sprintf(pnstr, "thrf1sl%d", i);
        pulsename(&thrf1sl[i], pnstr);
        createreserve(&thrf1sl[i], THETA, res_rf1);
        integrate2_add_phasewave(temp_wavesum, temp_wavep, temp_wave1, y_to_omscale[i]*shift_to_omscale[i],
                                 temp_wave2, z_to_omscale[i]*shift_to_omscale[i], res_rf1);
        movewaveimm(temp_wavesum, &thrf1sl[i], 0, res_rf1, TOHARDWARE);
        thrf1slp[i] = thrf1sl[i].wave_addr;
    }

    createinstr(&thrf1, start_rf1 + psd_rf_wait + addrfdel, pw_rf1, ia_thrf1);
    setwave(thrf1slp[0], &thrf1, 0);

    /* Now let's do the gradients */
    pulsename(&gzrf1, "gzrf1");
    pulsename(&gyrf1a, "gyrf1a");
    pulsename(&gyrf1, "gyrf1");
    pulsename(&gyrf1d, "gyrf1d");
    
    /* SVBranch HCSDM00155611 For Type I pulse */
    /* positive lobes */
    pulsename(&gyrf1pa, "gyrf1pa");
    pulsename(&gyrf1p,  "gyrf1p");
    pulsename(&gyrf1pd, "gyrf1pd");
    /* negative lobes */
    pulsename(&gyrf1na, "gyrf1na");
    pulsename(&gyrf1n,  "gyrf1n");
    pulsename(&gyrf1nd, "gyrf1nd");    
 
#ifdef IPG /* Execute only on IPG - we'll use trapezoids on the Host for pgen_on_host
              accurate with gradient heating calcs. */
    createextwave(&gzrf1, ZGRAD, res_rf1, gz_filename);
    createextwave(&gyrf1, YGRAD, res_rf1, gy_filename);
    createinstr(&gyrf1, start_rf1, pw_rf1, ia_gyrf1);
    createinstr(&gzrf1, start_rf1, pw_rf1, ia_gzrf1);
#else
    {
        if (type1_flag) /* SVBranch HCSDM00155611 For Type I pulse */
        {
            int pulsepos_rf1y = RUP_GRD(start_rf1);
            int pulsepos_rf1z = RUP_GRD(start_rf1 + 
                                        ex_pw_constanty_pos + 
                                        2*ex_pw_rampy_pos);
	                                         
            /************* Fast Grad ************/  			
            for (i = 1; i <= ex_num_gzlobe; i++)
            {            
                /* First, positive lobe */
                trapezoid( YGRAD, 
                           "gyrf1p", 
                           &gyrf1p, 
                           &gyrf1pa, 
                           &gyrf1pd,
                           ex_pw_constanty_pos, 
                           ex_pw_rampy_pos, 
                           ex_pw_rampy_pos,
                           ia_gys_pos, 
                           ia_gys_pos, 
                           ia_gys_pos, 
                           0, 
                           0,
                           pulsepos_rf1y, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1y += ex_pw_rampy_pos + 
                                 ex_pw_constanty_pos + 
                                 ex_pw_rampy_pos;	
                
                /* Next, negative lobe */
                trapezoid( YGRAD, 
                           "gyrf1n", 
                           &gyrf1n, 
                           &gyrf1na, 
                           &gyrf1nd,
                           ex_pw_constanty, 
                           ex_pw_rampy, 
                           ex_pw_rampy,
                           -ia_gyrf1, 
                           -ia_gyrf1, 
                           -ia_gyrf1, 
                           0, 
                           0,
                           pulsepos_rf1y, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1y += ex_pw_rampy + 
                                 ex_pw_constanty + 
                                 ex_pw_rampy;                				
            }
            
            /* The last positive lobe */
            trapezoid( YGRAD, 
                       "gyrf1p", 
                       &gyrf1p, 
                       &gyrf1pa, 
                       &gyrf1pd,
                       ex_pw_constanty_pos, 
                       ex_pw_rampy_pos, 
                       ex_pw_rampy_pos,
                       ia_gys_pos, 
                       ia_gys_pos, 
                       ia_gys_pos, 
                       0, 
                       0,
                       pulsepos_rf1y, 
                       TRAP_ALL, 
                       &loggrd );  
            pulsepos_rf1y += ex_pw_rampy_pos + 
                             ex_pw_constanty_pos + 
                             ex_pw_rampy_pos;                       

            /********** Blip Grad ***********/
            for (i = 1; i <= ex_num_gzlobe; i++)
            {		
                trapezoid( ZGRAD, 
                           "gzrf1", 
                           &gzrf1, 
                           &gzrf1a, 
                           &gzrf1d,
                           ex_pw_constantz, 
                           ex_pw_rampz, 
                           ex_pw_rampz,
                           ia_gzrf1, 
                           ia_gzrf1, 
                           ia_gzrf1, 
                           0, 
                           0,
                           pulsepos_rf1z, 
                           TRAP_ALL, 
                           &loggrd );
                pulsepos_rf1z += ex_pw_rampy_pos + 
                                 ex_pw_constanty_pos + 
                                 ex_pw_rampy_pos + 
                                 ex_pw_rampz + 
                                 ex_pw_constantz + 
                                 ex_pw_rampz; 
            }
        }
        else /* regular case */
        {        
            int polarity = 1;
            int pulsepos_rf1y = RUP_GRD(start_rf1);
            int pulsepos_rf1z = RUP_GRD(start_rf1 + ex_pw_constanty + 2*ex_pw_rampy -
                                        ex_pw_rampz - ex_pw_constantz/2);
            int intertype = (int)((float)ex_num_gylobe/(float)ex_num_gzlobe);
            int deltapos_rf1y = RUP_GRD(ex_pw_constanty + 2 * ex_pw_rampy);
            int deltapos_rf1z = intertype * deltapos_rf1y;

            for (i = 1; i <= ex_num_gylobe; i++)
            {
                trapezoid( YGRAD, "gyrf1", &gyrf1, &gyrf1a, &gyrf1d,
                           ex_pw_constanty, ex_pw_rampy, ex_pw_rampy,
                           (polarity*ia_gyrf1), (polarity*ia_gyrf1), (polarity*ia_gyrf1), 0, 0,
                           pulsepos_rf1y, TRAP_ALL, &loggrd );
                polarity *= -1;
                pulsepos_rf1y += deltapos_rf1y;
            }

            for (i = 1; i <= ex_num_gzlobe; i++)
            {
                trapezoid( ZGRAD, "gzrf1", &gzrf1, &gzrf1a, &gzrf1d,
                           ex_pw_constantz, ex_pw_rampz, ex_pw_rampz,
                           ia_gzrf1, ia_gzrf1, ia_gzrf1, 0, 0,
                           pulsepos_rf1z, TRAP_ALL, &loggrd );
                pulsepos_rf1z += deltapos_rf1z;
            }
        }
    }
#endif

    /* Refocusing y gradient, if needed. Refocusing z is combined with spin-echo crusher. */
    if (fabs(area_gyex1) > 0.0)
    {
        int temp_gy;   
        
        if (type1_flag) /* SVBranch HCSDM00155611 For Type I pulse */
        {
            temp_gy = pw_rf1 + RUP_GRD(start_rf1) + pw_gyex1a;         
        }
        else /* regular case */
        {
            temp_gy = RUP_GRD(pendall(&gyrf1, gyrf1.ninsts-1) + pw_gyex1a);
        }
        
               

  trapezoid((WF_PROCESSOR)wg_gyex1, "gyex1", &gyex1, &gyex1a,
                        &gyex1d, pw_gyex1, pw_gyex1a, pw_gyex1d,
                        ia_gyex1, 0, 0, 0, 0, temp_gy-pw_gyex1a, TRAP_ALL,
                        &loggrd);

    }

    /* Deallocate space */
    FreeNode(temp_wave1);
    FreeNode(temp_wave2);
    FreeNode(temp_wavep);
    FreeNode(temp_wavesum);

    return SUCCESS;
}

/***********************************/

WF_PULSE             index_rf1[10]; /* Multi-band indexed */
WF_HW_WAVEFORM_PTR   ptr_rf1[10];   /* pointer to waveform within Multi-band */

EXTERN_FILENAME ext_grad_filename; /* filename holder for externals - MUX */
EXTERN_FILENAME ext_mux_filename;  /* filename holder for externals - MUX */

short *temp_grad_space;   /* temporary waveform space for multi-band VERSEd gradients  - MUX */
short *temp_mux_space;    /* temporary waveform space for frequency modulation of VERSEd gradient - MUX */
short *this_modulated_rf; /* temporary waveform space for MUX modulated RF */

int grad_wave_ptr;      /* hardware wave pointer - MUX */
float iG_sum, kz;       /* keep track of excitation k-space total area */
float mux_modulation;   /* MUX modulation */
float iG2k;             /* integer gradient value to delta kz */
int   pair, pairs;      /* Pairs of side lobes */
char  instrname[128];   /* name the MUX RF waveforms */
int mux_index  = 0 ;      /* Multiband phase index */


/* Memory for multiplexed RF waveform */
short   srtrf_rf1[32768];



STATUS Multiband_pulsegen_rf1(void)
{
    if(res_rf1 <= 0)
    {
        return FAILURE;
    }

    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1", (WF_PROCESSOR)wg_rf1);

    /* Select proper filename */
    grad_zrf1=  ssgzfile;
    rf_rf1 =  ssrffile;
    theta_rf1 = ssgzfile;

    /* Now create the pulses */
    pulsename(&gzrf1a,"gzrf1a");
    pulsename(&gzrf1,"gzrf1");
    pulsename(&gzrf1d,"gzrf1d");
    pulsename(&rf1,"rf1");
    pulsename(&thetarf1, "thetarf1");

    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.zbeta;

    if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
        /* Use external gradient file for now */
        createextwave( &gzrf1, ZGRAD, res_gzrf1,
                       grad_zrf1 );

        createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                     pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
        /* Create train of trapezoids on the Host side */
        int i;
        int polarity = 1;

        pulsepos = pos_start+pw_gzrf1a;

        for(i = 1; i <= num_rf1lobe; i++) {
            polarity *= -1;

            trapezoid( ZGRAD,"gzrf1", &gzrf1,
                       &gzrf1a, &gzrf1d,
                       pw_constant, pw_ss_rampz, pw_ss_rampz,
                       (polarity*(ia_gzrf1)),
                       (polarity*(ia_gzrf1)),
                       (polarity*(ia_gzrf1)), 0, 0,
                       pulsepos, TRAP_ALL, &loggrd );

            pulsepos += pw_constant + 2 * pw_ss_rampz;
        }
#endif

    } else {

        /* Create simple trapezoid for chem sat + rf */
        createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                    (short)0, max_pg_wamp,
                    (short)(maxGradRes *
                        (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                        pg_beta );

        createinstr( &gzrf1a,
                     (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                     pw_gzrf1a, ia_gzrf1 );

        createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
        createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                     pw_gzrf1, ia_gzrf1 );

        createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                    max_pg_wamp, (short)0,
                    (short)(maxGradRes *
                        (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                        pg_beta );
        createinstr( &gzrf1d,
                     (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                     pw_gzrf1d, ia_gzrf1 );

    }

    /* Now create the rf pulse */
    if ( rftype == PLAY_RFFILE) {
        createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                       rf_rf1);
    } else {

        /* Runtime generated multiplexed RF pulse */

        { /* Copy multiplexed RF waveform to waveform memory */
            int indx,indy;
            for (indx=0; indx < res_rf1; indx++){
                srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1[indx];
            }
            createreserve(&rf1, RHO, res_rf1);
            movewaveimm(srtrf_rf1,&rf1, (int)0, res_rf1, TOHARDWARE);
            setweos(EOS_DEAD, &rf1, res_rf1-1);
            if (mux_slices_rf1 >1){    /* Now prepare for the multiple indices of the multi-band pulse */
                for (indy=0; indy < mux_slices_rf1; indy++){
                    char instrname[256];
                    if (indy==0) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1a[indx];
                    if (indy==1) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1b[indx];
                    if (indy==2) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1c[indx];
                    if (indy==3) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1d[indx];
                    if (indy==4) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1e[indx];
                    if (indy==5) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1f[indx];
                    if (indy==6) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1g[indx];
                    if (indy==7) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1h[indx];
                    if (indy==8) for (indx=0; indx < res_rf1; indx++) srtrf_rf1[indx]=(short)runtime_rf_waveform_rf1i[indx];

                    /* create space for this index of the multiband pulse */
                    sprintf(instrname, "index_rf1_%d",indy);
                    pulsename(&index_rf1[indy],instrname);                     /* Name the pulse */
                    createreserve(&index_rf1[indy],RHO,res_rf1);     /* Reserve the memory */
                    movewaveimm(srtrf_rf1,&index_rf1[indy], (int)0,
                                res_rf1,TOHARDWARE);                    /* Copy the waveform into the memory space */
                    setweos(EOS_DEAD,&index_rf1[indy],res_rf1-1);    /* Make the last word odd */
                    ptr_rf1[indy] = index_rf1[indy].wave_addr;       /* Save the pointer to memory */

                }
            }
        }

    }

    createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                 ss_rf_wait,  pw_rf1,ia_rf1);

    addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
               psd_rf_wait + ss_rf_wait, pw_rf1 );

    /* Now create the theta pulse */
    if ( thetatype == PLAY_THETA) {
        createextwave( &thetarf1, (wg_rf1==TYPRHO1)?TYPOMEGA:TYPTHETA,
                       res_thetarf1, theta_rf1 );

        createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                     ss_rf_wait, pw_thetarf1,
                     ia_thetarf1 );

    }
    if ( gztype == PLAY_GFILE) {
#if defined(IPG_TGT) || defined(MGD_TGT)
        linkpulses( 3,
                    &rf1, &gzrf1, &thetarf1);
#endif
    } else {
        linkpulses( 4,
                    &rf1, &gzrf1,
                    &gzrf1a, &gzrf1d);
    }

    if ( oppseq == PSD_GE && PSD_ON == opepi )
    {
        if (rfpulseInfo[RF1_SLOT].change==PSD_ON)
        {
            /* Stretch RF1 if needed */
            short *wave_space;
            short *orig_wave_space;
            short orig_res = PSD_SE_RF1_PW/2;
            orig_wave_space = (short *)AllocNode(orig_res*sizeof(short));
            movewaveimm(orig_wave_space, &index_rf1[0], (int)0, orig_res, FROMHARDWARE);
            res_rf1 = rfpulseInfo[RF1_SLOT].newres;
            wave_space = (short *)AllocNode(res_rf1*sizeof(short));
            stretchpulse((int)orig_res, (int)res_rf1, orig_wave_space, wave_space);
            FreeNode(orig_wave_space);
            movewaveimm(wave_space, &index_rf1[0], (int)0, res_rf1, TOHARDWARE);
            FreeNode(wave_space);
        }
    }

    return SUCCESS;
}

STATUS Multiband_pulsegen_rf2(int *Rf2Location, short *temp_wave_space)
{
    int i;

    if (mux_flag)
    {
        if(res_rf2 <= 0)
        {
            return FAILURE;
        }

        gscale_rf2 = 1.0;
        if (verse_rf2) {
            sprintf(ext_grad_filename, "verse_sb%d_rf2.grd",mux_slices_rf2);
            sprintf(ext_mux_filename,  "verse_sb%d_rf2.frq",mux_slices_rf2); /* 2us gradient file for modulation calculation */
        }
        if (debug_mux_rf)
        {
            printf("MB: RF2 Pulse: %s\n", ext_mux_filename);
        }

        temp_grad_space = (short *)AllocNode(res_gzrf2*sizeof(short)); /* 4us boundaries */
        uextwave(temp_grad_space, res_gzrf2, ext_grad_filename);

        temp_mux_space = (short *)AllocNode(res_rf2*sizeof(short)); /* 2us boundaries */
        uextwave(temp_mux_space, res_rf2, ext_mux_filename);

#ifdef EPI2_FLAG
        if( PSD_OFF == dualspinecho_flag)
        {
#endif
            if (verse_rf2) {

                if (use_omegatheta) {
                          
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2 = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2 = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2 = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2[slidx]),
                                 &(om_wave_omthrf2[slidx]), &(th_wave_omthrf2[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2), "om_omthrf2");

      createreserve(&(om_omthrf2), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2), (LONG) (Rf2Location[0] + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2[0]);

      pulsename(&(th_omthrf2), "th_omthrf2");

      createreserve(&(th_omthrf2), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2), (LONG) (Rf2Location[0] + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta = loggrd.zbeta;

                    pulsename(&thetarf2a,"thetarf2a");
                    pulsename(&thetarf2, "thetarf2");
                    pulsename(&thetarf2d,"thetarf2d");

                    /* frequency modulation waveform attack ramp */
                    createramp(&thetarf2a,OMEGA,pw_gzrf2a,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2a/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2a,(long)(Rf2Location[0] - pw_gzrf2a + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2a,ia_thetarf2);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2, (long)(Rf2Location[0] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2d,OMEGA,pw_gzrf2d,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_thetarf2d/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2d,(long)(Rf2Location[0] + pw_gzrf2 + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2d,ia_thetarf2);

                    linkpulses(3, &thetarf2a, &thetarf2, &thetarf2d);
                }
            }
#ifdef EPI2_FLAG
        }
        else
        {
            if (verse_rf2) { /* versed gradients need ramps to be created separately */

                if (use_omegatheta) {
                            
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2left = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2left = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2left = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2left[slidx]),
                                 &(om_wave_omthrf2left[slidx]), &(th_wave_omthrf2left[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2left), "om_omthrf2left");

      createreserve(&(om_omthrf2left), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2left), (LONG) (Rf2Location[1]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2left[0]);

      pulsename(&(th_omthrf2left), "th_omthrf2left");

      createreserve(&(th_omthrf2left), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2left), (LONG) (Rf2Location[1]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta = loggrd.zbeta;
                    pulsename(&thetarf2lefta,"thetarf2lefta");
                    pulsename(&thetarf2left, "thetarf2left");
                    pulsename(&thetarf2leftd,"thetarf2leftd");

                    /* frequency modulation waveform */
                    createramp(&thetarf2lefta,OMEGA,pw_gzrf2lefta,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2lefta/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2lefta,(long)(Rf2Location[1] - pw_gzrf2lefta + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2lefta,ia_thetarf2left);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2left, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2left, (long)(Rf2Location[1] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2leftd,OMEGA,pw_gzrf2leftd,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_gzrf2leftd/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2leftd,(long)(Rf2Location[1] + pw_gzrf2left + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2leftd,ia_thetarf2left);

                    linkpulses(3, &thetarf2lefta, &thetarf2left, &thetarf2leftd);
                }

                if (use_omegatheta) {
                            
    /* Code substituted in pulsegen */
    {
      int slidx;
      static const CHAR *routine = "OMEGATHETAMOD";
      short *gz_in;
      /* Allocate memory for waveform and iamp vectors */
      om_iamp_omthrf2right = (short *) AllocNode(opslquant * sizeof(short));

      om_wave_omthrf2right = (LONG *) AllocNode(opslquant * sizeof(LONG));

      th_wave_omthrf2right = (LONG *) AllocNode(opslquant * sizeof(LONG));

      /* Read in gradient file */
      gz_in = (short *) AllocNode (res_gzrf2 * sizeof(short));
      uextwave(gz_in, res_gzrf2, ext_grad_filename);

      for (slidx = 0; slidx < opslquant; slidx++) {
          if (omegathetamod_func(pw_rf2, rf2_isodelay, (short *) NULL, 0, 0, (short *) NULL, 0, gz_in,
                                 res_gzrf2, a_gzrf2, rsp_info[slidx].rsptloc/10.0, &(om_iamp_omthrf2right[slidx]),
                                 &(om_wave_omthrf2right[slidx]), &(th_wave_omthrf2right[slidx])) == FAILURE) {
              MsgHndlr(routine,
                       MSG_FORMAT, SOFTWARE_PBM, EMT_FREE,  "omegathetamod_func");
              return(FAILURE);
          }
      }

      FreeNode((ADDRESS) gz_in);

      /* Build omega and theta instructions */
      pulsename(&(om_omthrf2right), "om_omthrf2right");

      createreserve(&(om_omthrf2right), TYPOMEGA, (int) pw_rf2/RF_UPDATE_TIME);


      createinstr(&(om_omthrf2right), (LONG) (Rf2Location[2]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) om_iamp_omthrf2right[0]);

      pulsename(&(th_omthrf2right), "th_omthrf2right");

      createreserve(&(th_omthrf2right), TYPTHETA, (int) pw_rf2/RF_UPDATE_TIME);

      createinstr(&(th_omthrf2right), (LONG) (Rf2Location[2]+sltune_rf2 + psd_rf_wait), (LONG) pw_rf2, (LONG) max_pg_iamp);
    }

                } else {
                    pg_beta = loggrd.zbeta;

                    pulsename(&thetarf2righta,"thetarf2righta");
                    pulsename(&thetarf2right, "thetarf2right");
                    pulsename(&thetarf2rightd,"thetarf2rightd");

                    /* frequency modulation waveform */
                    createramp(&thetarf2righta,OMEGA,pw_gzrf2righta,(short)0,
                               max_pg_wamp,(short)(maxGradRes*(pw_gzrf2righta/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2righta,(long)(Rf2Location[2] - pw_gzrf2righta + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2righta,ia_thetarf2right);

                    /* Load the gradient file name for frequency modulating the VERSEd gradient */
                    createextwave( &thetarf2right, OMEGA, res_gzrf2, ext_grad_filename );
                    createinstr( &thetarf2right, (long)(Rf2Location[2] + psd_rf_wait + sltune_rf2), pw_gzrf2, ia_thetarf2 );

                    /* frequency modulation waveform decay ramp */
                    createramp(&thetarf2rightd,OMEGA,pw_gzrf2rightd,max_pg_wamp,
                               (short)0,(short)(maxGradRes*(pw_gzrf2rightd/ GRAD_UPDATE_TIME)),pg_beta);
                    createinstr( &thetarf2rightd,(long)(Rf2Location[2] + pw_gzrf2right + psd_rf_wait + sltune_rf2),
                                 pw_gzrf2rightd,ia_thetarf2right);

                    linkpulses(3, &thetarf2righta, &thetarf2right, &thetarf2rightd);
                }
            }
        } /*end dualspinecho_flag*/
#endif

        /* reset the bit */
        rfunblank_bits[0][2] = SSPD + RUBL;
        rfunblank_bits[1][2] = SSPD + RUBL;

        if (verse_rf2) {
            res_rf2_gradient_waveform = res_gzrf2;
              
  {
    pulsename(&rf2_gradient_waveform,"rf2_gradient_waveform");
    createreserve(&rf2_gradient_waveform,(WF_PROCESSOR)wg_rf2_gradient_waveform,
		  res_rf2_gradient_waveform);
  }

            movewaveimm(temp_grad_space, &rf2_gradient_waveform, (int)0, res_gzrf2, TOHARDWARE);
            setweos(EOS_DEAD,&rf2_gradient_waveform,res_gzrf2-1);

            this_modulated_rf = (short *)AllocNode(res_rf2*sizeof(short)); /* to hold current 2us modulated MUX RF */

            iG_sum = 0.0;
            for (i=0; i< res_rf2; i++) {
                iG_sum += (float)temp_mux_space[i]; /* integrate the gradient waveform to find center of excitation k-space */
            }
            iG2k = pw_rf2/res_rf2 * GAM/((float)MAX_PG_WAMP)*a_gzrf2*1e-7; /* conversion from integers to delta k in cycles per mm */
            pairs = mux_slices_rf2/2;
            {
                for (mux_index = 0; mux_index < mux_slices_rf2; mux_index++) {

                    /* create an RF waveform for each phase index of the mux for DFT slice separation */
                    sprintf(instrname, "mux_rf_index_%d", mux_index);
                    pulsename(&index_rf2[mux_index],instrname);
                    createreserve(&index_rf2[mux_index],RHO,res_rf2);

                    kz = -iG_sum/2.0;
                    for (i=0; i < res_rf2; i++) {
                        kz += (float)temp_mux_space[i];
                        mux_modulation = (mux_slices_rf2 & 1); /* 1 if odd number of bands */
                        for (pair = 0; pair < pairs; pair++) {
                            mux_modulation += 2.0*cos(2.0*PI*kz*iG2k * mux_slice_shift_mm_rf1 * (pair + 1 - 0.5*((mux_slices_rf2+1)&1) ) /* frequency */
                                                      + 2.0 * PI * mux_index * (pair + 1 - 0.5*((mux_slices_rf2+1)&1))/mux_slices_rf2); /* phase */
                        } /* pairs of bands */
                        mux_modulation/= mux_slices_rf2;
                        this_modulated_rf[i] = ( (short)floor(temp_wave_space[i]*mux_modulation + 0.5) ) & ~WEOS_BIT;
                    } /* i - points in RF waveform */
                    this_modulated_rf[res_rf2-1] |= WEOS_BIT;
                    movewaveimm(this_modulated_rf, &index_rf2[mux_index], (long)0, (short)res_rf2, TOHARDWARE);
                    ptr_rf2[mux_index] = index_rf2[mux_index].wave_addr;
                } /* mux_index */
            }

            FreeNode(this_modulated_rf);
        }
        FreeNode(temp_mux_space);
        FreeNode(temp_grad_space); 

    } /*end mux_flag*/


    return SUCCESS;
}

#ifdef __STDC__ 
void dummyssi( void )
#else /* !__STDC__ */
    void dummyssi() 
#endif /* __STDC__ */
{
    return;
}

/* Added for Inversion.e */
#ifdef __STDC__
STATUS setupphases ( INT *phase, INT *freq, INT slice, FLOAT rel_phase, INT time_delay, INT sign_flag)
#else /* !__STDC__ */
    STATUS setupphases (phase, freq, slice, rel_phase, time_delay)
    INT *phase;                /* output phase offsets */
    INT *freq;                 /* precomputed frequency offsets */
    INT slice;                 /* slice number */
    FLOAT rel_phase;           /* in cycles */
    INT time_delay;            /* in micro seconds */
#endif /* __STDC__ */
{
    double ftime_delay;           /* floating point time delay in seconds */
    double temp_freq;             /* frequency offset */
    float tmpphase;
    int   intphase;
    int   sign;

    ftime_delay = ((double)time_delay)/((double)(1000000));

    /* Convert tardis int to frequency */
    temp_freq = sign_flag*((double)(freq[slice]))*TARDIS_FREQ_RES;

    /* determine phase change in radians */
    tmpphase = (rel_phase - ( temp_freq * ftime_delay ))*2.0*PI;

    tmpphase/= (float)PI;    /* unwrap this phase bits */
    if (tmpphase < 0) {
        sign = -1;
        tmpphase *= -1;
    }
    else
        sign = 1;

    if ( ((int)floor((double)tmpphase) % 2) == 1) {
        sign *= -1;
        intphase = sign * (long)
            ( (1.0-(tmpphase - (float)floor((double)tmpphase)) ) * ((double)FSI));
    }
    else
        intphase = sign * (long)
            ( (tmpphase - (float)floor((double)tmpphase)) * ((double)FSI));

    phase[slice] = intphase;

    return SUCCESS;
}

void
#ifdef __STDC__ 
ssisat( void )
#else /* !__STDC__ */
    ssisat()
#endif /* __STDC__ */
{
#ifdef IPG
    int next_slice;

    next_slice = sp_sat_index;
    sp_update_rot_matrix( &rsprot_orig[next_slice][0], sat_rot_matrices,
                          sat_rot_ex_num, sat_rot_df_num );
#endif /* IPG */
    return;
}

/***************************** setreadpolarity *************************/
#ifdef __STDC__ 
STATUS setreadpolarity( void )
#else /* !__STDC__ */
    STATUS setreadpolarity()
#endif /* __STDC__ */
{
    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    }

    tia_gx1 = gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw = polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk = polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */

    setiamp(tia_gx1, &gx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &gx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &gx1d, 0);        /* x dephaser decay  */

    if(iref_etl > 0)
    {
        tia_gxiref1 = polarity*gradpol[ileave]*ia_gxiref1; /* temporary interref x dephaser amp */ 
        tia_gxirefr = (iref_etl%2 ? 1 : -1)*polarity*gradpol[ileave]*ia_gxirefr; /* temporary interref x rephaser amp */
        setiampt(tia_gxiref1, &gxiref1, 0);  /* interref x dephaser */
        setiampt(tia_gxirefr, &gxirefr, 0);  /* interref x rephaser */
    }

    if(iref_etl > 0)
    {
        setiamp(tia_gxw, &gxw, 0); /* gx_dwi cross term correction */
    }
    else
    {
        setiamp(tia_gxw-ia_gx_dwi, &gxw, 0); /* gx_dwi cross term correction */
    }

    /* Ramps are handled with opposite sign because of the way they
       are defined in the EP_TRAIN macro.  Please refer to epic.h
       for more details. */

    for (echo=1; echo < tot_etl; echo++) {
        if(echo < iref_etl)
        {
            if ((echo % 2) == 1) {  /* Even echo within interleave */
                setiamp(-tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(-tia_gxw, &gxwd, echo-1);
                setiamp(-tia_gxw, &gxw, echo);    /* const   */
            } else {                    /* Odd echo within interleave */
                setiamp(tia_gxw, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(tia_gxw, &gxwd, echo-1);
                setiamp(tia_gxw, &gxw, echo);     /* flattop   */
            }
        }
        else
        {
            if ((echo % 2) == 1) {  /* Even echo within interleave */ 
                setiamp(-tia_gxw-ia_gx_dwi, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(-tia_gxw-ia_gx_dwi, &gxwd, echo-1);
                setiamp(-tia_gxw-ia_gx_dwi, &gxw, echo);    /* const   */
            } else {                    /* Odd echo within interleave */
                setiamp(tia_gxw-ia_gx_dwi, &gxwa, echo-1); /* waveforms go neg to pos in ep_train */
                setiamp(tia_gxw-ia_gx_dwi, &gxwd, echo-1);
                setiamp(tia_gxw-ia_gx_dwi, &gxw, echo);     /* flattop   */
            }
        }
    }

    if ((tot_etl % 2) == 1) {
        setiamp(-tia_gxw-ia_gx_dwi,&gxwde, 0);  /* decay,end */
        if (eosxkiller == 1) {
            setiamp(-tia_gxk,&gxka, 0);   /* killer attack */
            setiamp(-tia_gxk,&gxk, 0);    /* killer flattop */
            setiamp(-tia_gxk,&gxkd, 0);   /* killer decay  */
        }
    } else {
        setiamp(tia_gxw-ia_gx_dwi,&gxwde, 0);   /* decay,end */
        if (eosxkiller == 1) {
            setiamp(tia_gxk,&gxka, 0);    /* killer attack */
            setiamp(tia_gxk,&gxk, 0);     /* killer flattop */
            setiamp(tia_gxk,&gxkd, 0);    /* killer decay  */
        }
    }

    return SUCCESS;
} /* end setreadpolarity */

#ifdef __STDC__ 
STATUS pulsegen( void )
#else /* !__STDC__ */
    STATUS pulsegen() 
#endif /* __STDC__ */ 
{
    EXTERN_FILENAME ext_filename; /* filename holder for externals */
    int Rf2Location[NECHO_MAX]; /* time locations of Rf2 */
    short slmod_acqs;           /* slices%acqs */
    int tempx, tempy, tempz, temps, tempiref = 0;
    int temp1, temp2 = 0;
    int echoloop;
    int psd_icnt,psd_jcnt;
    int psd_seqtime;      /* sequence time */
    short *wave_space;
    short *temp_wave_space = NULL; /* temporary waveform space for rf scaling */
    short temp_res;         /* temporary resolution */
    int wave_ptr;           /* hardware wave pointer */
    float temp_gmnamp;  /* temporary amplitudes for y gmn calc */
    float tempa, tempb;
    LONG pulsePos;
    int lpfval = -1;
    float betax;
    EXTERN_FILENAME test_wave_file; /* granty edit for qti */

    tot_etl = etl + iref_etl; /* internref */

    /* Added for Inversion.e InversionPG1 */
    int i;

    /* Set HPC timer set to 10 seconds (5 sec. per count) */
    setwatchdogrsp(watchdogcount); /* First give pulsegen a little extra time */
#ifdef MGD_TGT		/* if this is MGD */
    SetHWMem();		/* reset MGD instruction and waveform mem */
#endif	
 
    /*MRIhc18005*/
    sspinit(psd_board_type);

    /* Initialize TGlimit */
    TGlimit = MAX_SYS_TG;

#ifdef IPG 
    /*
     * Execute this code only on the Tgt side
     */
#ifdef SIM
    /* 7/17/96 RJL: Initialization for Simulators. Only required for simulation builds.
       This is not compiled in during HW builds. This is taken care of in Makefile */
    simulationInit( rsprot[0] );
    /* rsprot code */
    {
        int j;

        for (i=0; i<opslquant*opphases; i++) {
            for (j=0; j<9; j++) {
                rsprot_unscaled[i][j] = rsprot[i][j];
            }
        }
    }

#endif /* SIM */
#endif /* IPG */

    { /* Start of code inlined from vmx.e VMXpg */
        if( system_type == 1 )
        {
            rfupa = cv_rfupa;
        }
    } /* End of code inlined from vmx.e VMXpg */


    debugstate = debugipg;

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    acq_ptr = (short *)AllocNode((act_acqs*pass_reps + 2)*sizeof(short));
    ctlend_tab = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
    slc_in_acq = (short *)AllocNode((act_acqs*pass_reps + 2)*sizeof(short));
    rf1_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    theta_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_freq = (int *)AllocNode((opslquant + 2)*sizeof(int));
    thetarf2_freq = (int *)AllocNode((mux_slquant + 2)*sizeof(int));
    rf1_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2left_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));
    rf2right_pha = (int *)AllocNode((opslquant + 2)*sizeof(int));

    recv_freq = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_freq[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_freq[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
        }
    }

    recv_phase = (int ***)AllocMem(opslquant*sizeof(int **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_phase[psd_icnt] = (int **)AllocMem(intleaves*sizeof(int *));
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_phase[psd_icnt][psd_jcnt] = (int *)AllocMem(tot_etl*sizeof(int));
        }
    }

    recv_phase_angle = (double ***)AllocMem(opslquant*sizeof(double **));
    recv_phase_ang_nom = (double ***)AllocMem(opslquant*sizeof(double **));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
        recv_phase_angle[psd_icnt] = (double **)AllocMem(intleaves* sizeof(double *));
        recv_phase_ang_nom[psd_icnt] = (double **)AllocMem(intleaves*sizeof(double *)); 
        for (psd_jcnt = 0; psd_jcnt < intleaves; psd_jcnt++)
        {
            recv_phase_angle[psd_icnt][psd_jcnt] = (double *)AllocMem(tot_etl*sizeof(double));
            recv_phase_ang_nom[psd_icnt][psd_jcnt] = (double *)AllocMem(tot_etl*sizeof(double));
        }
    }

    rf_phase_spgr = (int **)AllocMem(opslquant*sizeof(int *));
    for (psd_icnt = 0; psd_icnt < opslquant; psd_icnt++) {
	rf_phase_spgr[psd_icnt] = (int *)AllocMem(intleaves*sizeof(int));
    }

{   int pp;

    ia_gx_hoec_comp = (int ***)AllocMem(intleaves*sizeof(int **));
    ia_gy_hoec_comp = (int ***)AllocMem(intleaves*sizeof(int **));
    recv_phase_b0_hoec_comp = (double ***)AllocMem(intleaves*sizeof(double **));

    for (pp=0; pp<intleaves; pp++)
    {

        ia_gx_hoec_comp[pp] = (int **)AllocMem(opslquant*sizeof(int *));
        for (i=0; i<opslquant; i++)
        {
            ia_gx_hoec_comp[pp][i] = (int *)AllocMem(tot_etl*sizeof(int));
        }
        ia_gy_hoec_comp[pp] = (int **)AllocMem(opslquant*sizeof(int *));
        for (i=0; i<opslquant; i++)
        {
            ia_gy_hoec_comp[pp][i] = (int *)AllocMem(tot_etl*sizeof(int));
        }
        recv_phase_b0_hoec_comp[pp] = (double **)AllocMem(opslquant*sizeof(double *));
        for (i=0; i<opslquant; i++)
        {
             recv_phase_b0_hoec_comp[pp][i] = (double *)AllocMem(tot_etl*sizeof(double));
        }
    }
}

/* functions that set blip amplitude and receiver phase */

    echotrainxtr = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainrba = (WF_PULSE **)AllocNode(tot_etl*sizeof(WF_PULSE *));
    echotrainramp1 = (int *)AllocNode(tot_etl*sizeof(int));
    echotrainramp2 = (int *)AllocNode(tot_etl*sizeof(int));

    gy1f = (int *)AllocNode((intleaves+1)*sizeof(int));
    gymn = (int *)AllocNode((intleaves+1)*sizeof(int));
    view1st = (int *)AllocNode((intleaves+1)*sizeof(int));
    viewskip = (int *)AllocNode((intleaves+1)*sizeof(int));
    tf = (int *)AllocNode((intleaves+1)*sizeof(int));
    rfpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    gradpol = (int *)AllocNode((intleaves+1)*sizeof(int));
    blippol = (int *)AllocNode((intleaves+1)*sizeof(int));
    b0ditherval = (float *)AllocNode((opslquant+1)*sizeof(float));
    delayval = (float *)AllocNode((opslquant+1)*sizeof(float));
    gldelaycval = (int *)AllocNode((opslquant+1)*sizeof(int));
    gldelayfval = (float *)AllocNode((opslquant+1)*sizeof(float));

    /* t1flair_stir */
    if (t1flair_flag == PSD_ON)
    {
        physical_slice_acq_seq_reg = (int *)AllocNode((slquant1 + 2)*sizeof(int));
        physical_slice_acq_seq_enh = (int *)AllocNode((slquant1 + 2)*sizeof(int));
        real_slice_acq_seq = (int **)AllocNode((acqs + 2)*sizeof(int*));

        T1flair_slice_flag = (int **)AllocNode((acqs + 2)*sizeof(int*));
        for (i = 0; i < acqs + 2; i++)
        {
            real_slice_acq_seq[i] = (int *)AllocNode((slquant1 + 1)*sizeof(int));
            T1flair_slice_flag[i] = (int *)AllocNode((slquant1 + 1)*sizeof(int));
        }
    }

    if (opdiffuse == PSD_ON && diff_order_flag)
    {
        if (flair_flag == PSD_OFF)
        {
            diff_order_nslices = (mux_flag?mux_slquant:slquant1) * acqs;
        }
        else
        {
            diff_order_nslices = false_slquant1 * false_acqs * acqs;
        }

        if ((diff_order_flag == 1) || (diff_order_flag == 2 && tensor_flag == PSD_ON))
        {
            diff_order_size = pass_reps;
        }
        else if (diff_order_flag == 2)
        {
            diff_order_size = (int)(opdifnext2 * opdifnumt2 + num_dif * total_difnex + (ref_in_scan_flag ? 1:0) + (rpg_in_scan_flag?rpg_in_scan_num:0));
            diff_order_pass = (int *)AllocNode(diff_order_size*sizeof(int));
            diff_order_nex = (int *)AllocNode(diff_order_size*sizeof(int));
            diff_order_dif = (int *)AllocNode(diff_order_size*sizeof(int));
        }

        /* diff_order[pass][slice] */
        diff_order = (int **)AllocNode(diff_order_size*sizeof(int *));

        for (psd_icnt = 0; psd_icnt < diff_order_size; psd_icnt++)
        {
            diff_order[psd_icnt] = (int *)AllocNode(diff_order_nslices*sizeof(int));
        }

        if ( FAILURE == set_diff_order() )
        {
            return FAILURE;
        }
    }

#ifdef ERMES_DEBUG
    debugileave = 1;
#else
    debugileave = 0;
#endif
  
    switch (ky_dir) {
    case PSD_TOP_DOWN:
	readpolar = 1;
	break;
    case PSD_BOTTOM_UP:
    case PSD_CENTER_OUT:
    default:
	if (etl % 2 == 1)  /* odd */
            readpolar = 1;
	else               /* even */
            readpolar = -1;  
	break;
    }

    /* BJM: MRIge60610 - added num_overscan */ 
    /* MRIge89403: added one more argument for EPI internal ref
       scan but set to 0 */
    if (FAILURE == ileaveinit( fullk_nframes, ky_dir,
                               intleaves, ep_alt, readpolar, blippolar, debugileave, ia_rf1,
                               ia_gyb, pepolar, etl, seq_data, delt, tfon, fract_ky,
                               ky_offset, num_overscan, endview_iamp, esp, tsp, rhfrsize,
                               a_gxw, rhrcxres, slquant1, lpfval, iref_etl, gy1f, view1st,
                               viewskip, tf, rfpol, gradpol, blippol, &mintf ))
    {
        return FAILURE;
    }

    for (ileave = 0; ileave < intleaves; ileave++){
        if (ygmn_type == CALC_GMN1) {
            tempa = a_gy1a * (float)gy1f[ileave]/(float)endview_iamp;
            tempb = a_gy1b * (float)gy1f[ileave]/(float)endview_iamp;
	  
            amppwygmn(gyb_tot_0thmoment, gyb_tot_1stmoment, pw_gy1a, pw_gy1,
                      pw_gy1d, tempa, tempb, loggrd.ty_xyz, (float)loggrd.yrt*loggrd.scale_3axis_risetime,
                      1, &pw_gymn1a, &pw_gymn1, &pw_gymn1d, &temp_gmnamp);
	  
            gymn[ileave] = (int)((float)ia_gymn1 * a_gymn1/ temp_gmnamp);
          
            if (debugileave == 1)
                printf("gymn[%d] = %d, temp_gmnamp = %f\n",
                       ileave,gymn[ileave],temp_gmnamp);
        } else
            gymn[ileave] = 0;
    }


#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    rdx = dx;
    rdy = dy;
    rdz = dz;

    dlyx = gldelayx;
    dlyy = gldelayy;
    dlyz = gldelayz;

    b0Dither_ifile(b0ditherval, ditheron, rdx, rdy, rdz, a_gxw, esp, opslquant,
                   debugdither, rsprot_unscaled, ccinx, cciny, ccinz, esp_in, 
                   fesp_in, &g0, &num_elements, &file_exist);

    calcdelay(delayval, delayon, dlyx, dlyy, dlyz,
              &defaultdelay, opslquant, opgradmode,debugdelay, rsprot_unscaled);

    for (slice = 0; slice < opslquant; slice++)
        delayval[slice] += dacq_adjust;

    if (oppseq == PSD_SPGR)
	spgr_flag = 1;
    else
	spgr_flag = 0;

    for (slice = 0; slice < opslquant; slice++) {
        for (ileave = 0; ileave < intleaves; ileave++)
            rf_phase_spgr[slice][ileave] = 0;  /* call spgr function in future */
    }
#endif /* IPG */

    /*RTB0 correction*/
    if(rtb0_flag)
    {
        
  {
    pulsename(&dynr1,"dynr1");
    createbits(&dynr1,TYPSSP,sizeof(sspwm_dynr1)/2,sspwm_dynr1);
    createinstr( &dynr1,(long)(tlead-pw_dynr1-GRAD_UPDATE_TIME),
		pw_dynr1,ia_dynr1);
  }

    }

       
  {
    pulsename(&x_td0,"x_td0");
    createconst(&x_td0,(WF_PROCESSOR)wg_x_td0,pw_x_td0,(short)0); 
    createinstr( &x_td0,(long)(tlead),pw_x_td0,0);
  }

       
  {
    pulsename(&y_td0,"y_td0");
    createconst(&y_td0,(WF_PROCESSOR)wg_y_td0,pw_y_td0,(short)0); 
    createinstr( &y_td0,(long)(tlead),pw_y_td0,0);
  }

       
  {
    pulsename(&z_td0,"z_td0");
    createconst(&z_td0,(WF_PROCESSOR)wg_z_td0,pw_z_td0,(short)0); 
    createinstr( &z_td0,(long)(tlead),pw_z_td0,0);
  }

       
  {
    pulsename(&rho_td0,"rho_td0");
    createconst(&rho_td0,(WF_PROCESSOR)wg_rho_td0,pw_rho_td0,(short)0); 
    createinstr( &rho_td0,(long)(tlead),pw_rho_td0,0);
  }

       
  {
    pulsename(&theta_td0,"theta_td0");
    createconst(&theta_td0,(WF_PROCESSOR)wg_theta_td0,pw_theta_td0,(short)0); 
    createinstr( &theta_td0,(long)(tlead),pw_theta_td0,0);
  }
 /* YMSmr07445 */
       
  {
    pulsename(&omega_td0,"omega_td0");
    createconst(&omega_td0,(WF_PROCESSOR)wg_omega_td0,pw_omega_td0,(short)0); 
    createinstr( &omega_td0,(long)(tlead),pw_omega_td0,0);
  }

       
  {
    pulsename(&ssp_td0,"ssp_td0");
    createconst(&ssp_td0,(WF_PROCESSOR)wg_ssp_td0,pw_ssp_td0,(short)0); 
    createinstr( &ssp_td0,(long)(tlead),pw_ssp_td0,0);
  }

  
#ifdef IPG
    for (slice = 0; slice < opslquant; slice++) 
    {
        if (delayval[slice] < 0.0)
	    gldelaycval[slice] = (int)(delayval[slice] - 0.5);
        else
	    gldelaycval[slice] = (int)(delayval[slice] + 0.5);
    }
#endif /* IPG */  

    /* Spatial Sat *******************************************************/
    sp_satindex = 0;
    SpSatPG(vrgsat,sp_satstart, &sp_satindex, sp_satcard_loc);
  
    /* Chem Sat **********************************************************/
    cs_satindex = 0;
    if (cs_sat)
	ChemSatPG(cs_satstart, &cs_satindex);

    if (rfov_flag)
    {
        if(FAILURE == rfov_pulsegen())
        {
            return FAILURE;
        }
    }
    else if (mux_flag)
    {
        if(FAILURE == Multiband_pulsegen_rf1())
        {
            return FAILURE;
        }
    }
    else
    {
        /* spsp 90 RF slice select pulse *******************************************/
        if(rftype && (!ss_rf1))
        {
            temp_wave_space = (short *)AllocNode(res_rf1*sizeof(short));
            uextwave(temp_wave_space, res_rf1, ssrffile);
        }

        temp_res = res_rf1;
        if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* set to new resolution */
            res_rf1 = rfpulseInfo[RF1_SLOT].newres;

        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
           unblank the receiver - see EpicConf.c for defaults. Will unblank
           the receiver later - MRIge28778 */ /*CLARIFY*/

        rfunblank_bits[0][2] = SSPD;
        rfunblank_bits[1][2] = SSPD;
           
                             
                              
                              
  {
      /* Check for RF waveform generator */
      RFEnvelopeWaveformGeneratorCheck("rf1", 
                                       (WF_PROCESSOR)wg_rf1);

      /* Select proper filename */
      grad_zrf1=  ssgzfile;
      rf_rf1 =  ssrffile;
      theta_rf1 = ssgzfile;

      /* Now create the pulses */
      pulsename(&gzrf1a,"gzrf1a");
      pulsename(&gzrf1,"gzrf1");
      pulsename(&gzrf1d,"gzrf1d");
      pulsename(&rf1,"rf1");
      pulsename(&thetarf1, "thetarf1");

      /*  Now create the slice select trapezoid */
      pg_beta = loggrd.zbeta;

      if ( gztype == PLAY_GFILE) {

#if defined(IPG_TGT) || defined(MGD_TGT)
          /* Use external gradient file for now */
          createextwave( &gzrf1, ZGRAD, res_gzrf1,
                         grad_zrf1 );

          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

#elif defined(HOST_TGT)
          /* Create train of trapezoids on the Host side */
          int i;
          int polarity = 1;
       
          pulsepos = pos_start+pw_gzrf1a; 
       
          for(i = 1; i <= num_rf1lobe; i++) {
              polarity *= -1;

              trapezoid( ZGRAD,"gzrf1", &gzrf1, 
                         &gzrf1a, &gzrf1d,
                         pw_constant, pw_ss_rampz, pw_ss_rampz, 
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)),
                         (polarity*(ia_gzrf1)), 0, 0, 
                         pulsepos, TRAP_ALL, &loggrd );

              pulsepos += pw_constant + 2 * pw_ss_rampz;
          }
#endif

      } else {

          /* Create simple trapezoid for chem sat + rf */
          createramp( &gzrf1a,ZGRAD,pw_gzrf1a,
                      (short)0, max_pg_wamp,
                      (short)(maxGradRes *
                              (pw_gzrf1a/ GRAD_UPDATE_TIME)),
                      pg_beta );

          createinstr( &gzrf1a,
                       (long)(pos_start+pw_gzrf1a - pw_gzrf1a),
                       pw_gzrf1a, ia_gzrf1 );

          createconst( &gzrf1, ZGRAD, pw_rf1, max_pg_wamp );
          createinstr( &gzrf1, (long)pos_start+pw_gzrf1a,
                       pw_gzrf1, ia_gzrf1 );

          createramp( &gzrf1d, ZGRAD, pw_gzrf1d,
                      max_pg_wamp, (short)0,
                      (short)(maxGradRes *
                              (pw_gzrf1d/ GRAD_UPDATE_TIME)),
                      pg_beta );
          createinstr( &gzrf1d,
                       (long)(pos_start+pw_gzrf1a + pw_gzrf1),
                       pw_gzrf1d, ia_gzrf1 );

      }

      /* Now create the rf pulse */
      if ( (rftype&&ss_rf1) == PLAY_RFFILE) {
          createextwave( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                         rf_rf1);
      } else {
          createsinc( &rf1, (WF_PROCESSOR)wg_rf1, res_rf1,
                      max_pg_wamp,cyc_rf1, alpha_rf1 );
      }

      createinstr( &rf1,(long)pos_start+pw_gzrf1a + psd_rf_wait +
                   ss_rf_wait,  pw_rf1,ia_rf1);

      addrfbits( &rf1, off_rf1, (long)pos_start+pw_gzrf1a +
                 psd_rf_wait + ss_rf_wait, pw_rf1 );

      /* Now create the theta pulse */
      if ( thetatype == PLAY_THETA) {
          createextwave( &thetarf1, (wg_rf1==TYPRHO1)?TYPOMEGA:TYPTHETA,
                         res_thetarf1, theta_rf1 );

          createinstr( &thetarf1, (long)pos_start+pw_gzrf1a + psd_rf_wait +
                       ss_rf_wait, pw_thetarf1,
                       ia_thetarf1 );

          addrfbits( &thetarf1, off_thetarf1,
                     (long)pos_start+pw_gzrf1a + psd_rf_wait + ss_rf_wait,
                     pw_thetarf1 );
      }
      if ( gztype == PLAY_GFILE) {
          #if defined(IPG_TGT) || defined(MGD_TGT)
          linkpulses( 3,
                      &rf1, &gzrf1, &thetarf1);
          #endif
      } else {
          linkpulses( 4,
                      &rf1, &gzrf1,
                      &gzrf1a, &gzrf1d);
      }
  }


        /* reset the bit */
        rfunblank_bits[0][2] = SSPD + RUBL;
        rfunblank_bits[1][2] = SSPD + RUBL;

        if(rftype && (!ss_rf1))
        {
             /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_SLOT].change==PSD_ON) 
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_SLOT].newres,temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } 
            else
            {
                wave_space = temp_wave_space;
            }

            /* move immediately into permanent memory */
            movewaveimm(wave_space, &rf1, (int)0, res_rf1, TOHARDWARE);
            FreeNode(wave_space);
        }

        if (rfpulseInfo[RF1_SLOT].change == PSD_ON)  /* change back for ext. file */
            res_rf1 = temp_res;
    }

    /* 180 RF refocusing pulse ********************************************/
    if (oppseq == PSD_SE) {
        Rf2Location[0] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso  + opte/2
                                       - pw_rf2/2) - psd_rf_wait);  /* Find start loc of 180s */
 
        /* DTI */
        if (PSD_ON == dualspinecho_flag)
        {
            /* BJM: place the 180's at t & 3t with echo center at 4t... */
            /*      Note: this increases the TE slightly since minTE = 4* azminb  */
            Rf2Location[1] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte/4 - pw_rf2/2) - psd_rf_wait);
            Rf2Location[2] = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + 3*opte/4 - pw_rf2/2) - psd_rf_wait);
        }

        /* MRIge58235: moved uextwave to here so the file read from disk is always read with orig. res_rf2 */
        if (PSD_OFF == mux_flag)
        {
            strcpy(ext_filename, "rfse1b4.rho");
        }
        else
        {
            sprintf(ext_filename, "verse_sb%d_rf2.rho",mux_slices_rf2);
        }

        /* Create some RHO waveform space, read in the
       se1b4 spin echo 180 to local memory, and then move
       the local memory to the reserved RHO memory.
        */
        temp_wave_space = (short *)AllocNode(res_rf2*sizeof(short));
        uextwave(temp_wave_space, res_rf2, ext_filename);

        /* MRIge58235: save orig. res_rf2 for scaling */
        short orig_res;

        orig_res = res_rf2;
        if (rfpulseInfo[RF2_SLOT].change==PSD_ON)
            res_rf2 = rfpulseInfo[RF2_SLOT].newres;     /* Set to new resolution */

        /* set rfunblank_bits[2] so that addrfbits in sliceselz does not
               unblank the receiver - see EpicConf.c for defaults. Will unblank
               the receiver later - MRIge28778 */
        rfunblank_bits[0][2] = SSPD;
        rfunblank_bits[1][2] = SSPD;

        /*  180 slice sel pulse  */
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2", 
                                     (WF_PROCESSOR)wg_rf2);

    /* First create the pulses */
    pulsename(&gzrf2a,"gzrf2a");
    pulsename(&gzrf2,"gzrf2");
    pulsename(&gzrf2d,"gzrf2d");
    pulsename(&rf2,"rf2");
    
    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.zbeta;
    createramp(&gzrf2a,ZGRAD,pw_gzrf2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2a,(long)(Rf2Location[0]-pw_gzrf2a),
                pw_gzrf2a,ia_gzrf2);
    createconst(&gzrf2,ZGRAD,pw_gzrf2,MAX_PG_WAMP);
    createinstr( &gzrf2,(long)(Rf2Location[0]),
                pw_gzrf2,ia_gzrf2);
    createramp(&gzrf2d,ZGRAD,pw_gzrf2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2d,(long)(Rf2Location[0]+pw_gzrf2),
                pw_gzrf2d,ia_gzrf2);
    
    /* Now create the rf pulse */
    createsinc(&rf2,(WF_PROCESSOR)wg_rf2,res_rf2,
	       MAX_PG_WAMP,cyc_rf2, alpha_rf2);
    createinstr( &rf2,(long)(Rf2Location[0]) + psd_rf_wait,
		pw_rf2,ia_rf2);
    linkpulses(4,&rf2,&gzrf2,&gzrf2a,
	       &gzrf2d);
    addrfbits(&rf2,off_rf2,(long)(Rf2Location[0]) + psd_rf_wait, 
	      pw_rf2);
  }


        } else {
            /* If pw_rf2 is scaled...DTI BJM (dsp) */
            if (PSD_ON == dualspinecho_flag)
            {
                res_rf2left = res_rf2;
                res_rf2right = res_rf2left;
            }

              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2left", 
                                     (WF_PROCESSOR)wg_rf2left);

    /* First create the pulses */
    pulsename(&gzrf2lefta,"gzrf2lefta");
    pulsename(&gzrf2left,"gzrf2left");
    pulsename(&gzrf2leftd,"gzrf2leftd");
    pulsename(&rf2left,"rf2left");
    
    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.zbeta;
    createramp(&gzrf2lefta,ZGRAD,pw_gzrf2lefta,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2lefta/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2lefta,(long)(Rf2Location[1]-pw_gzrf2lefta),
                pw_gzrf2lefta,ia_gzrf2left);
    createconst(&gzrf2left,ZGRAD,pw_gzrf2left,MAX_PG_WAMP);
    createinstr( &gzrf2left,(long)(Rf2Location[1]),
                pw_gzrf2left,ia_gzrf2left);
    createramp(&gzrf2leftd,ZGRAD,pw_gzrf2leftd,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2leftd/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2leftd,(long)(Rf2Location[1]+pw_gzrf2left),
                pw_gzrf2leftd,ia_gzrf2left);
    
    /* Now create the rf pulse */
    createsinc(&rf2left,(WF_PROCESSOR)wg_rf2left,res_rf2left,
	       MAX_PG_WAMP,cyc_rf2left, alpha_rf2left);
    createinstr( &rf2left,(long)(Rf2Location[1]) + psd_rf_wait,
		pw_rf2left,ia_rf2left);
    linkpulses(4,&rf2left,&gzrf2left,&gzrf2lefta,
	       &gzrf2leftd);
    addrfbits(&rf2left,off_rf2left,(long)(Rf2Location[1]) + psd_rf_wait, 
	      pw_rf2left);
  }



              
                          
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2right", 
                                     (WF_PROCESSOR)wg_rf2right);

    /* First create the pulses */
    pulsename(&gzrf2righta,"gzrf2righta");
    pulsename(&gzrf2right,"gzrf2right");
    pulsename(&gzrf2rightd,"gzrf2rightd");
    pulsename(&rf2right,"rf2right");
    
    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.zbeta;
    createramp(&gzrf2righta,ZGRAD,pw_gzrf2righta,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2righta/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2righta,(long)(Rf2Location[2]-pw_gzrf2righta),
                pw_gzrf2righta,ia_gzrf2right);
    createconst(&gzrf2right,ZGRAD,pw_gzrf2right,MAX_PG_WAMP);
    createinstr( &gzrf2right,(long)(Rf2Location[2]),
                pw_gzrf2right,ia_gzrf2right);
    createramp(&gzrf2rightd,ZGRAD,pw_gzrf2rightd,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrf2rightd/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrf2rightd,(long)(Rf2Location[2]+pw_gzrf2right),
                pw_gzrf2rightd,ia_gzrf2right);
    
    /* Now create the rf pulse */
    createsinc(&rf2right,(WF_PROCESSOR)wg_rf2right,res_rf2right,
	       MAX_PG_WAMP,cyc_rf2right, alpha_rf2right);
    createinstr( &rf2right,(long)(Rf2Location[2]) + psd_rf_wait,
		pw_rf2right,ia_rf2right);
    linkpulses(4,&rf2right,&gzrf2right,&gzrf2righta,
	       &gzrf2rightd);
    addrfbits(&rf2right,off_rf2right,(long)(Rf2Location[2]) + psd_rf_wait, 
	      pw_rf2right);
  }

        }

        if(mux_flag)
        {
            if(FAILURE == Multiband_pulsegen_rf2(Rf2Location, temp_wave_space))
            {
                return FAILURE;
            }
            FreeNode(temp_wave_space);
        }
        else
        {
            /* reset the bit */
            rfunblank_bits[0][2] = SSPD + RUBL;
            rfunblank_bits[1][2] = SSPD + RUBL;

            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF2_SLOT].change==PSD_ON) {
                wave_space = (short *)AllocNode(rfpulseInfo[RF2_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)orig_res, (int)rfpulseInfo[RF2_SLOT].newres,
                             temp_wave_space,wave_space);
                FreeNode(temp_wave_space);
            } else
                wave_space = temp_wave_space;

            /* Assign temporary board memory and move immediately into permanent
               memory */
            res_rf2se1b4 = res_rf2;
              
  {
    pulsename(&rf2se1b4,"rf2se1b4");
    createreserve(&rf2se1b4,(WF_PROCESSOR)wg_rf2se1b4,
		  res_rf2se1b4);
  }

            movewaveimm(wave_space, &rf2se1b4, (int)0, res_rf2, TOHARDWARE);
            FreeNode(wave_space);
        }

        /* MRIge58235: reset res_rf2 after scaling */
        res_rf2 = orig_res;

        /* DTI BJM (dsp) */
        if (PSD_ON == dualspinecho_flag)
        {
            res_rf2left = res_rf2;
            res_rf2right = res_rf2left;
        }

        if (innerVol == PSD_ON)
        {
                 

  trapezoid((WF_PROCESSOR)wg_gyrf2iv, "gyrf2iv", &gyrf2iv, &gyrf2iva,
                        &gyrf2ivd, pw_gyrf2iv, pw_gyrf2iva, pw_gyrf2ivd,
                        ia_gyrf2iv, 0, 0, 0, 0, Rf2Location[0]-pw_gyrf2iva, TRAP_ALL,
                        &loggrd);

            ia_gzrf2 = 0;
        }

        /* DTI BJM (dsp) */
        if (PSD_OFF == dualspinecho_flag)
        {
            setphase((float)(PI/-2.0), &rf2, 0);       /* Apply 90 phase shift to  180 */
        } else {
            setphase((float)(PI/-2.0), &rf2right, 0);  /* Apply 90 phase shift to  180 */
            setphase((float)(PI/-2.0), &rf2left, 0);   /* Apply 90 phase shift to  180 */
        }

        attenflagon(&rf1, 0);                 /* Assert ESSP flag on rf1 pulse */

        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            attenflagon(&rf2, 0);                 /* Assert ESSP flag on 1st rf2 */
        } else {
            attenflagon(&rf2right, 0);            /* Assert ESSP flag on rigth rf2 */
        }

        /* Z crushers (echo 1) ***********************************************/
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
             
                         
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2l1, "gzrf2l1", &gzrf2l1, &gzrf2l1a,
                        &gzrf2l1d, pw_gzrf2l1, pw_gzrf2l1a, pw_gzrf2l1d,
                        ia_gzrf2l1, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_gzrf2l1+pw_gzrf2l1d)-pw_gzrf2l1a, TRAP_ALL,
                        &loggrd);


                 

  trapezoid((WF_PROCESSOR)wg_gzrf2r1, "gzrf2r1", &gzrf2r1, &gzrf2r1a,
                        &gzrf2r1d, pw_gzrf2r1, pw_gzrf2r1a, pw_gzrf2r1d,
                        ia_gzrf2r1, 0, 0, 0, 0, pend(&gzrf2,"gzrf2d",0)-pw_gzrf2r1a, TRAP_ALL,
                        &loggrd);

            if( PSD_ON == xygradCrusherFlag ) {
                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradCrusherL, "xgradCrusherL", &xgradCrusherL, &xgradCrusherLa,
                        &xgradCrusherLd, pw_xgradCrusherL, pw_xgradCrusherLa, pw_xgradCrusherLd,
                        ia_xgradCrusherL, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_xgradCrusherL+pw_xgradCrusherLd)-pw_xgradCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradCrusherR, "xgradCrusherR", &xgradCrusherR, &xgradCrusherRa,
                        &xgradCrusherRd, pw_xgradCrusherR, pw_xgradCrusherRa, pw_xgradCrusherRd,
                        ia_xgradCrusherR, 0, 0, 0, 0, pend(&gzrf2,"gzrf2",0)+pw_xgradCrusherRa-pw_xgradCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradCrusherL, "ygradCrusherL", &ygradCrusherL, &ygradCrusherLa,
                        &ygradCrusherLd, pw_ygradCrusherL, pw_ygradCrusherLa, pw_ygradCrusherLd,
                        ia_ygradCrusherL, 0, 0, 0, 0, pbeg(&gzrf2,"gzrf2",0)-(pw_ygradCrusherL+pw_ygradCrusherLd)-pw_ygradCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradCrusherR, "ygradCrusherR", &ygradCrusherR, &ygradCrusherRa,
                        &ygradCrusherRd, pw_ygradCrusherR, pw_ygradCrusherRa, pw_ygradCrusherRd,
                        ia_ygradCrusherR, 0, 0, 0, 0, pend(&gzrf2,"gzrf2",0)+pw_ygradCrusherRa-pw_ygradCrusherRa, TRAP_ALL,
                        &loggrd);

            }
        } else {
             
                         
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2leftl1, "gzrf2leftl1", &gzrf2leftl1, &gzrf2leftl1a,
                        &gzrf2leftl1d, pw_gzrf2leftl1, pw_gzrf2leftl1a, pw_gzrf2leftl1d,
                        ia_gzrf2leftl1, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_gzrf2leftl1+pw_gzrf2leftl1d)-pw_gzrf2leftl1a, TRAP_ALL,
                        &loggrd);


              
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2leftr1, "gzrf2leftr1", &gzrf2leftr1, &gzrf2leftr1a,
                        &gzrf2leftr1d, pw_gzrf2leftr1, pw_gzrf2leftr1a, pw_gzrf2leftr1d,
                        ia_gzrf2leftr1, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2leftd",0)-pw_gzrf2leftr1a, TRAP_ALL,
                        &loggrd);


             
                        
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2rightl1, "gzrf2rightl1", &gzrf2rightl1, &gzrf2rightl1a,
                        &gzrf2rightl1d, pw_gzrf2rightl1, pw_gzrf2rightl1a, pw_gzrf2rightl1d,
                        ia_gzrf2rightl1, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_gzrf2rightl1+pw_gzrf2rightl1d)-pw_gzrf2rightl1a, TRAP_ALL,
                        &loggrd);


              
                         

  trapezoid((WF_PROCESSOR)wg_gzrf2rightr1, "gzrf2rightr1", &gzrf2rightr1, &gzrf2rightr1a,
                        &gzrf2rightr1d, pw_gzrf2rightr1, pw_gzrf2rightr1a, pw_gzrf2rightr1d,
                        ia_gzrf2rightr1, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2rightd",0)-pw_gzrf2rightr1a, TRAP_ALL,
                        &loggrd);


            /* MRIhc05227 */
            /* Create Crushers on Left and Right 180s for X & Y axes */ 
            if( PSD_ON == xygradRightCrusherFlag ) { 
                  
                            
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradRightCrusherL, "xgradRightCrusherL", &xgradRightCrusherL, &xgradRightCrusherLa,
                        &xgradRightCrusherLd, pw_xgradRightCrusherL, pw_xgradRightCrusherLa, pw_xgradRightCrusherLd,
                        ia_xgradRightCrusherL, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_xgradRightCrusherL+pw_xgradRightCrusherLd)-pw_xgradRightCrusherLa, TRAP_ALL,
                        &loggrd);


                  
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradRightCrusherR, "xgradRightCrusherR", &xgradRightCrusherR, &xgradRightCrusherRa,
                        &xgradRightCrusherRd, pw_xgradRightCrusherR, pw_xgradRightCrusherRa, pw_xgradRightCrusherRd,
                        ia_xgradRightCrusherR, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2right",0)+pw_xgradRightCrusherRa-pw_xgradRightCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradRightCrusherL, "ygradRightCrusherL", &ygradRightCrusherL, &ygradRightCrusherLa,
                        &ygradRightCrusherLd, pw_ygradRightCrusherL, pw_ygradRightCrusherLa, pw_ygradRightCrusherLd,
                        ia_ygradRightCrusherL, 0, 0, 0, 0, pbeg(&gzrf2right,"gzrf2right",0)-(pw_ygradRightCrusherL+pw_ygradRightCrusherLd)-pw_ygradRightCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradRightCrusherR, "ygradRightCrusherR", &ygradRightCrusherR, &ygradRightCrusherRa,
                        &ygradRightCrusherRd, pw_ygradRightCrusherR, pw_ygradRightCrusherRa, pw_ygradRightCrusherRd,
                        ia_ygradRightCrusherR, 0, 0, 0, 0, pend(&gzrf2right,"gzrf2right",0)+pw_ygradRightCrusherRa-pw_ygradRightCrusherRa, TRAP_ALL,
                        &loggrd);

            }
            if( PSD_ON == xygradLeftCrusherFlag ) {
                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_xgradLeftCrusherL, "xgradLeftCrusherL", &xgradLeftCrusherL, &xgradLeftCrusherLa,
                        &xgradLeftCrusherLd, pw_xgradLeftCrusherL, pw_xgradLeftCrusherLa, pw_xgradLeftCrusherLd,
                        ia_xgradLeftCrusherL, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_xgradLeftCrusherL+pw_xgradLeftCrusherLd)-pw_xgradLeftCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_xgradLeftCrusherR, "xgradLeftCrusherR", &xgradLeftCrusherR, &xgradLeftCrusherRa,
                        &xgradLeftCrusherRd, pw_xgradLeftCrusherR, pw_xgradLeftCrusherRa, pw_xgradLeftCrusherRd,
                        ia_xgradLeftCrusherR, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2left",0)+pw_xgradLeftCrusherRa-pw_xgradLeftCrusherRa, TRAP_ALL,
                        &loggrd);


                 
                           
                          
                          

  trapezoid((WF_PROCESSOR)wg_ygradLeftCrusherL, "ygradLeftCrusherL", &ygradLeftCrusherL, &ygradLeftCrusherLa,
                        &ygradLeftCrusherLd, pw_ygradLeftCrusherL, pw_ygradLeftCrusherLa, pw_ygradLeftCrusherLd,
                        ia_ygradLeftCrusherL, 0, 0, 0, 0, pbeg(&gzrf2left,"gzrf2left",0)-(pw_ygradLeftCrusherL+pw_ygradLeftCrusherLd)-pw_ygradLeftCrusherLa, TRAP_ALL,
                        &loggrd);


                 
                           
                          

  trapezoid((WF_PROCESSOR)wg_ygradLeftCrusherR, "ygradLeftCrusherR", &ygradLeftCrusherR, &ygradLeftCrusherRa,
                        &ygradLeftCrusherRd, pw_ygradLeftCrusherR, pw_ygradLeftCrusherRa, pw_ygradLeftCrusherRd,
                        ia_ygradLeftCrusherR, 0, 0, 0, 0, pend(&gzrf2left,"gzrf2left",0)+pw_ygradLeftCrusherRa-pw_ygradLeftCrusherRa, TRAP_ALL,
                        &loggrd);

            }
        }   
    } /* end PSD_SE check */

    /***********************************************************************/
    /* X EPI readout train                                                 */
    /***********************************************************************/
  
    /* For now assume a simple retiling. */
    if (fract_ky == PSD_FRACT_KY) {
	echoOffset  = num_overscan/intleaves;
    } else {
	if (ky_dir == PSD_TOP_DOWN || ky_dir == PSD_BOTTOM_UP)
            echoOffset  = fullk_nframes/intleaves/2;
	else
            echoOffset  = 0;
    }
  
    if (rampsamp == PSD_ON) {  /* Ramp sampling on CERD, HOUP */
        if ( mux_flag == PSD_ON && use_slice_fov_shift_blips == PSD_ON ) {
            dacq_offset = pkt_delay + pw_gxwad - (int)IMax(2, (int)(fbhw*((float)pw_gyb/2.0 + (float)pw_gybd) + 0.5),
                                                 (int)(fbhw*((float)pw_gzb/2.0 + (float)pw_gzbd) + 0.5));
        } else {
            dacq_offset = pkt_delay + pw_gxwad - (int)(fbhw*((float)pw_gyb/2.0 +
                                                             (float)pw_gybd) + 0.5);
        }
    } else {
        dacq_offset = pkt_delay;
    }

    /* MRIge58023 & 58033 need to RUP_GRD entire expression */
    if (intleaves == fullk_nframes)
    {
        tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte -
                              pw_gxw/2 - pw_gxwl - ky_offset*esp/intleaves));
    }
    else
    {
        tempx = RUP_GRD((int)(pend(&rf1,"rf1",0) - rfExIso + opte -
                              echoOffset * esp - ky_offset*esp/intleaves));
    }

    tempy = tempx + gydelay;
    tempz = tempx;
    tempx += gxdelay;
  
    if(iref_etl > 0)
    {
        if(rtb0_flag && dpc_flag)
        {   
            tempiref = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+
                       rtb0_acq_delay+esp+pw_gxiref1_tot;
        }
        else
        {
            tempiref = pendall(&rf1, 0) + IMax(3, pw_gz1_tot, rfupd+4  +pw_gxiref1_tot, pw_gyex1_tot);
        }
        tempiref = RUP_GRD(tempiref);
    }

    /* MRIge89403: added one more argument for EPI internal ref
     * but set it to 0 */
    /* EP_TRAIN */
    /* internref: use tot_etl instead of etl; added iref_etl */
      
             
             
             
             
             
                 
               
             
             
             
             
             
             
                     
    {
      int psd_gxwcnt;
      int psd_pulsepos;
      int psd_eparity;
      long psd_epxtroff;
      long psd_epdaboff;
      float psd_etbetax;
      float psd_etbetay;
      float psd_etbetaz;
      char psd_epstring[EPSTRING_LENGTH];

      if( (iref_etl > 0) && ((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS) != DEFAULTPOS) )
      {
          psd_pulsepos = RUP_GRD((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS));
      }
      else
      {
      psd_pulsepos = RUP_GRD((LONG)tempx+pw_gxwad);
      }
      if( (iref_etl == 0) || ((iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS) != DEFAULTPOS) ){
          pw_iref_gxwait = 0;
      }
      /* allocate on 1st pass only  */
      if ( 0 == 0 ) {
          echotrain = (WF_PULSE *)AllocNode((tot_etl + 3) * sizeof(WF_PULSE));
      }

      pulsename(&gxcla, "gxcla");
      pulsename(&gxcl, "gxcl");
      pulsename(&gxcld, "gxcld");
 
      pulsename(&gxwa, "gxwa");
      pulsename(&gxw, "gxw");
      pulsename(&gxwd, "gxwd");
      pulsename(&gxwde, "gxwde");
 
      pulsename(&gxgap, "gxgap");
 
      pulsename(&gyba, "gyba");
      pulsename(&gyb, "gyb");
      pulsename(&gybd, "gybd");
 
      if (1)
      {
          pulsename(&gzba, "gzba");
          pulsename(&gzb, "gzb");
          pulsename(&gzbd, "gzbd");
      }
 
      pulsename(&gxcra, "gxcra");
      pulsename(&gxcr, "gxcr");
      pulsename(&gxcrd, "gxcrd");
 
      getbeta(&psd_etbetax, XGRAD, &epiloggrd);
      getbeta(&psd_etbetay, YGRAD, &epiloggrd);
      if (1)
      {
          getbeta(&psd_etbetaz, ZGRAD, &epiloggrd);
      }
 
      if (pw_gxcla >= GRAD_UPDATE_TIME) 
      {
          createramp(&gxcla, XGRAD, pw_gxcla, (short)0, (short)ia_gxcl, 
                      (short)(maxGradRes*(pw_gxcla/GRAD_UPDATE_TIME)), psd_etbetax);
          createinstr(&gxcla, (long)psd_pulsepos, pw_gxcla, max_pg_iamp);
          psd_pulsepos += pw_gxcla;
      }
    
      if (pw_gxcl >= GRAD_UPDATE_TIME) 
      {
          createconst(&gxcl, XGRAD, pw_gxcl, max_pg_wamp);
          createinstr(&gxcl, (long)psd_pulsepos, pw_gxcl, ia_gxcl);
          psd_pulsepos += pw_gxcl;
      }
    
      if (pw_gxcld >= GRAD_UPDATE_TIME) 
      {
          createramp(&gxcld, XGRAD, pw_gxcld, (short)ia_gxcl, (short)ia_gxw, 
                     (short)(maxGradRes*(pw_gxcld/GRAD_UPDATE_TIME)), psd_etbetax);
          createinstr(&gxcld, (long)psd_pulsepos, pw_gxcld, max_pg_iamp);
          psd_pulsepos += pw_gxcld;
      }
    
      createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
      createinstr(&gxw, (long)psd_pulsepos, pw_gxwl+pw_gxw+pw_gxwr, ia_gxw);
      psd_pulsepos += pw_gxwl;
    
      sprintf(psd_epstring, "echo%04d", 0);
      pulsename(&(echotrain[0]), psd_epstring);
    
      if (dab_offset == 0)
          psd_epdaboff = 0;
      else
          psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
     
      if (xtr_offset == 0)
          psd_epxtroff = 0;
      else
          psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
    
      epiacqq(&(echotrain[0]),
          (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
          psd_epdaboff, psd_epxtroff,
          (long)scanslot,
          (TYPDAB_PACKETS)DABNORM,
          (long)fast_rec,
          (long)hsdab>0?0:1);
    
      psd_pulsepos += pw_gxw + pw_gxwr;
    
      psd_eparity = 1;
      for (psd_gxwcnt = 2; psd_gxwcnt <= tot_etl; psd_gxwcnt++) 
      {
          psd_eparity *= -1;
          if( psd_gxwcnt - 1 > iref_etl )
          {
              createramp(&gyba, YGRAD, pw_gyba, 0, max_pg_wamp,
                         (short)((maxGradRes*pw_gyba)/GRAD_UPDATE_TIME), psd_etbetay);
              createinstr(&gyba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                         (pw_gyba + pw_gyb/2)), pw_gyba, ia_gyb);

      if (pw_gyb >= GRAD_UPDATE_TIME) {
        createconst(&gyb, YGRAD, pw_gyb, max_pg_wamp);
        createinstr(&gyb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                        pw_gyb/2), pw_gyb, ia_gyb);
      }

      createramp(&gybd, YGRAD, pw_gybd, max_pg_wamp, 0,
             (short)((maxGradRes*pw_gybd)/GRAD_UPDATE_TIME), psd_etbetay);
      createinstr(&gybd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                       pw_gyb/2), pw_gybd, ia_gyb);

      linkpulses(3,&gyb,&gyba,&gybd);

      /* Make Z blip */
      if (1)
      {
          if ((pw_gzba + pw_gzb + pw_gzbd) > 0) {
              createramp(&gzba, ZGRAD, pw_gzba, 0, max_pg_wamp,
                         (short)((maxGradRes*pw_gzba)/GRAD_UPDATE_TIME), psd_etbetaz);
              createinstr(&gzba, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                               (pw_gzba + pw_gzb/2)), pw_gzba, ia_gzb);

              if (pw_gzb >= GRAD_UPDATE_TIME) {
                  createconst(&gzb, ZGRAD, pw_gzb, max_pg_wamp);
                  createinstr(&gzb, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 -
                                                  pw_gzb/2), pw_gzb, ia_gzb);
              }

              createramp(&gzbd, ZGRAD, pw_gzbd, max_pg_wamp, 0,
                         (short)((maxGradRes*pw_gzbd)/GRAD_UPDATE_TIME), psd_etbetaz);
              createinstr(&gzbd, (long)RUP_GRD(psd_pulsepos + pw_gxwad + pw_gxgap/2 +
                                               pw_gzb/2), pw_gzbd, ia_gzb);

              linkpulses(3,&gzb,&gzba,&gzbd);
          }
      }
    }

    createramp(&gxwd, XGRAD, pw_gxwad, -max_pg_wamp, 0,
           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME),
           psd_etbetax);
    createinstr(&gxwd, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
    psd_pulsepos += pw_gxwad;


    if( (iref_etl > 0) && (psd_gxwcnt == iref_etl+1) && (DEFAULTPOS != (iref_etl>0?tempiref+pw_gxwad:DEFAULTPOS)) ){
        psd_pulsepos = (LONG)tempx+pw_gxwad - pw_gxwad;
    }
    else if( pw_gxgap == 0 ){
      if( (pw_iref_gxwait != 0) && (psd_gxwcnt == iref_etl) ){
        createconst(&gxgap, XGRAD, pw_iref_gxwait, 0);
        createinstr(&gxgap, (long)psd_pulsepos, pw_iref_gxwait, 0);
        psd_pulsepos += pw_iref_gxwait;
      }
    }else{
      int gapgap;
      if( (pw_iref_gxwait == 0) || (psd_gxwcnt != iref_etl) ){
        gapgap = pw_gxgap;
      }else{
        gapgap = pw_gxgap+pw_iref_gxwait;
      }
      createconst(&gxgap, XGRAD, gapgap, 0);
      createinstr(&gxgap, (long)psd_pulsepos, gapgap, 0);
      psd_pulsepos += gapgap;
    }

    createramp(&gxwa, XGRAD, pw_gxwad, 0, max_pg_wamp,
           (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
    createinstr(&gxwa, (long)psd_pulsepos, pw_gxwad, psd_eparity* ia_gxw);
    psd_pulsepos += pw_gxwad;

    createconst(&gxw, XGRAD, pw_gxwl+pw_gxw+pw_gxwr, max_pg_wamp);
    createinstr(&gxw, (long)psd_pulsepos,
            pw_gxwl+pw_gxw+pw_gxwr, psd_eparity*ia_gxw);
    psd_pulsepos += pw_gxwl;
        
    sprintf(psd_epstring, "echo%04d", psd_gxwcnt-1 + 0);
    pulsename(&(echotrain[psd_gxwcnt-1+0]), psd_epstring);
        
    if (dab_offset == 0)
      psd_epdaboff = 0;
    else
      psd_epdaboff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + dab_offset);
        
    if (xtr_offset == 0)
      psd_epxtroff = 0;
    else
      psd_epxtroff = (long)(psd_pulsepos + psd_grd_wait-dacq_offset + xtr_offset);
            
    epiacqq(&(echotrain[psd_gxwcnt-1+0]),
        (long)(psd_pulsepos + psd_grd_wait-dacq_offset),
        psd_epdaboff, psd_epxtroff,
        (long)scanslot,
        (TYPDAB_PACKETS)DABNORM,
        (long)fast_rec,
        (long)hsdab>0?0:1);
        
    psd_pulsepos += pw_gxw + pw_gxwr;
      }
      if ((tot_etl % 2) == 1) {    /* views per shot is odd */
    if (pw_gxcra >= GRAD_UPDATE_TIME) {
      createramp(&gxcra, XGRAD, pw_gxcra, (short)ia_gxw,
             (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                             GRAD_UPDATE_TIME)), psd_etbetax);
      createinstr(&gxcra, (long)(psd_pulsepos), pw_gxcra, max_pg_iamp);
      psd_pulsepos += pw_gxcra;
    }
      } else { /* views per shot is even */
    /* single transition ramp into crusher */
    if ((ia_gxw == ia_gxcr) && (pw_gxwad == pw_gxcra)) {
      createramp(&gxwd, XGRAD, 2*pw_gxwad, -max_pg_wamp, max_pg_wamp,
             (short)(maxGradRes*(2*pw_gxwad)/GRAD_UPDATE_TIME),
             psd_etbetax);
      createinstr(&gxwd, (long)psd_pulsepos, 2*pw_gxwad, ia_gxw);
      psd_pulsepos += 2*pw_gxwad;
    } else {    /* two separate ramps, decay ramp needs new waveform */
      createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
             (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), psd_etbetax);
      createinstr(&gxwde, (long)psd_pulsepos, pw_gxwad, ia_gxw);
      psd_pulsepos += pw_gxwad;

      if (pw_gxcra >= GRAD_UPDATE_TIME) {
        createramp(&gxcra, XGRAD, pw_gxcra, (short)0,
               (short)ia_gxcr, (short)(maxGradRes*(pw_gxcra/
                               GRAD_UPDATE_TIME)),psd_etbetax);
        createinstr(&gxcra, (long)(psd_pulsepos),pw_gxcra, max_pg_iamp);
        psd_pulsepos += pw_gxcra;
      }
    }
      }
      if (pw_gxcr >= GRAD_UPDATE_TIME) {
    createconst(&gxcr, XGRAD, pw_gxcr, max_pg_wamp);
    createinstr(&gxcr, (long)psd_pulsepos,pw_gxcr, ia_gxcr);
    psd_pulsepos += pw_gxcr;
      }

      if (pw_gxcrd >= GRAD_UPDATE_TIME) {
    createramp(&gxcrd, XGRAD, pw_gxcrd, (short)ia_gxcr,
           (short)0, (short)(maxGradRes*(pw_gxcrd/
                         GRAD_UPDATE_TIME)), psd_etbetax);
    createinstr(&gxcrd, (long)psd_pulsepos,pw_gxcrd, max_pg_iamp);
    psd_pulsepos += pw_gxcrd;
      }
    }


    /* unblank receiver rcvr_ub_off us prior to first xtr/dab/rba packet */
    /*  rec_unblank_pack[2] = SSPD+RUBL;*/
    getssppulse(&(echotrainxtr[0]), &(echotrain[0]), "xtr", 0);
    rcvrunblankpos = echotrainxtr[0]->inst_hdr_tail->start;
    rcvrunblankpos += rcvr_ub_off;
     
  {
    rec_unblank_pack[0] = SSPDS+RDC;
    rec_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank_pack[2] = SSPD+RUBL;
    rec_unblank_pack[3] = SSPDS;

    pulsename(&rec_unblank,"rec_unblank");
    createbits(&rec_unblank,TYPSSP,4,rec_unblank_pack);
    createinstr( &rec_unblank,(long)(rcvrunblankpos),4,ia_rec_unblank);
  }

    if(iref_etl>0)
    {
        getssppulse(&(echotrainxtr[iref_etl]), &(echotrain[iref_etl]), "xtr", 0);
        rcvrunblankpos = echotrainxtr[iref_etl]->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank3_pack[0] = SSPDS+RDC;
    rec_unblank3_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank3_pack[2] = SSPD+RUBL;
    rec_unblank3_pack[3] = SSPDS;

    pulsename(&rec_unblank3,"rec_unblank3");
    createbits(&rec_unblank3,TYPSSP,4,rec_unblank3_pack);
    createinstr( &rec_unblank3,(long)(rcvrunblankpos),4,ia_rec_unblank3);
  }

    }

    if (tot_etl % 2 == 1) {
        getbeta(&betax, XGRAD, &epiloggrd);
        pulsePos = pend(&gxw, "gxw", tot_etl-1);
        createramp(&gxwde, XGRAD, pw_gxwad, -max_pg_wamp, 0,
                   (short)(maxGradRes*(pw_gxwad)/GRAD_UPDATE_TIME), betax);
        createinstr(&gxwde, (LONG)pulsePos, pw_gxwad, -ia_gxw-ia_gx_dwi);
        pulsePos += pw_gxwad;
    }

    /***********************************************************************/
    /* X dephaser                                                          */
    /***********************************************************************/
  
    if (gx1pos == PSD_POST_180)
        temp1 = RUP_GRD((int)(pbeg(&gxw,"gxw",iref_etl) - (pw_gxwad + pw_gx1a +
            pw_gx1 + pw_gx1d)));
    else
        temp1 = RUP_GRD((int)(pend(&gzrf1,"gzrf1",0) + pw_gx1a + pw_wgx + rfupd));

    pg_beta = loggrd.xbeta;

    pulsename(&gx1a,"gx1a");
    createramp(&gx1a,XGRAD,pw_gx1a,(short)0,
               max_pg_wamp,(short)(maxGradRes*(pw_gx1a/
                                               GRAD_UPDATE_TIME)),
               pg_beta);
    createinstr(&gx1a, (LONG)temp1, pw_gx1a, ia_gx1);

    if (pw_gx1 >= GRAD_UPDATE_TIME) {
        pulsename(&gx1,"gx1");
        createconst(&gx1,XGRAD,pw_gx1,max_pg_wamp);
        createinstr( &gx1,(LONG)(LONG)temp1+pw_gx1a,
                     pw_gx1,ia_gx1);
    }

    pulsename(&gx1d, "gx1d");
    if (single_ramp_gx1d == PSD_ON) {   /* Single ramp for gx1 decay into gxw
                                           attack */
        createramp(&gx1d, XGRAD, pw_gxwad, max_pg_wamp, -max_pg_wamp,
                   (short)(maxGradRes*(2*pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        createinstr(&gx1d, (LONG)(temp1+pw_gx1a+pw_gx1), 2*pw_gxwad, ia_gx1);
    } else {                     /* decay ramp for gx1 */
        createramp(&gx1d,XGRAD,pw_gx1d,max_pg_wamp,
                   (short)0,(short)(maxGradRes*(pw_gx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gx1d,(LONG)((LONG)temp1+pw_gx1a+pw_gx1),
                     pw_gx1d,ia_gx1);

        pulsename(&gxwa, "gxwa");  /* attack ramp for epi train */
        createramp(&gxwa, XGRAD, pw_gxwad, (short)0, max_pg_wamp,
                   (short)(maxGradRes*(pw_gxwad/GRAD_UPDATE_TIME)), pg_beta);
        if(iref_etl > 0)
        {
            tempx = tempiref;
        }
        if ( tot_etl%2 == 0 )
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, -ia_gxw-ia_gx_dwi);
        else
            createinstr(&gxwa, (LONG)tempx, pw_gxwad, ia_gxw-ia_gx_dwi);
    }

    /*RTB0 correction*/
    if(rtb0_flag)
    {
        temp2 = pendall(&rf1, 0) + IMax(2, pw_gz1_tot, rfupd + 4   + rtb0_minintervalb4acq)+rtb0_acq_delay;
            
  {
    pulsename(&rtb0echo,"rtb0echo");
    acqq(&rtb0echo, (long)(temp2),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rtb0echo,
        (TYPDAB_PACKETS)DABNORM);
  }

        attenflagon( &(rtb0echo), 0 );

        getssppulse(&(rtb0echoxtr), &(rtb0echo), "xtr", 0);
        rcvrunblankpos = rtb0echoxtr->inst_hdr_tail->start;
        rcvrunblankpos += rcvr_ub_off;
         
  {
    rec_unblank2_pack[0] = SSPDS+RDC;
    rec_unblank2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rec_unblank2_pack[2] = SSPD+RUBL;
    rec_unblank2_pack[3] = SSPDS;

    pulsename(&rec_unblank2,"rec_unblank2");
    createbits(&rec_unblank2,TYPSSP,4,rec_unblank2_pack);
    createinstr( &rec_unblank2,(long)(rcvrunblankpos),4,ia_rec_unblank2);
  }


        temp2 += esp;
    }

    /* Hyperscan and diff DAB packet */
    if (hsdab > 0) {
        if (rtb0_flag == PSD_OFF)
        {
            temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        }

        if(hsdab == 1)
	         
{
    pulsename(&hyperdab,"hyperdab");

        createhsdab(&hyperdab, (long)(temp2));
  }

        else
             
{
    pulsename(&diffdab,"diffdab");

    creatediffdab(&diffdab, (long)(temp2));
}

    }  

    if(iref_etl > 0)
    {
             

  trapezoid((WF_PROCESSOR)wg_gxiref1, "gxiref1", &gxiref1, &gxiref1a,
                        &gxiref1d, pw_gxiref1, pw_gxiref1a, pw_gxiref1d,
                        ia_gxiref1, 0, 0, 0, 0, tempiref-pw_gxiref1_tot+pw_gxiref1a-pw_gxiref1a, TRAP_ALL,
                        &loggrd);
    
             

  trapezoid((WF_PROCESSOR)wg_gxirefr, "gxirefr", &gxirefr, &gxirefra,
                        &gxirefrd, pw_gxirefr, pw_gxirefra, pw_gxirefrd,
                        ia_gxirefr, 0, 0, 0, 0, tempiref+pw_gxiref_tot+pw_gxirefra-pw_gxirefra, TRAP_ALL,
                        &loggrd);

    }

    /* Set readout polarity to gradpol[ileave] value */
    ileave = 0;
    setreadpolarity();

    /* If we don't reset frequency and phase on each view, then it is best
       to use a single packet at the beginning of the frame - one that doesn't
       shift with interleave.  This is because we want the constant part of Ahn
       correction to see continuous phase evolution across the views. */
 
    if (oppseq == PSD_SE) {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            temp2 = pendall(&rf2, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        } else {
            temp2 = pendall(&rf2right, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
        }
    } else {
        temp2 = pendall(&rf1, 0) + rfupd + 4  ;  /* 4us for unblank receiver */
    }

    /* Y prephaser ************************************************************/
    if (gy1pos == PSD_POST_180) {
	temp1 = pbeg(&gxw, "gxw", iref_etl) - pw_gxwad - pw_gy1_tot;
	temp1 = RDN_GRD(temp1);
    } else {
	temp1 = RDN_GRD(pend(&rf1,"rf1",0) + rfupd);
    }

        
    trapezoid((WF_PROCESSOR)wg_gy1,"gy1",
              &gy1,&gy1a,&gy1d,
              pw_gy1,pw_gy1a,pw_gy1d,
              ia_gy1,ia_gy1wa,ia_gy1wb,
              0,0,temp1,TRAP_ALL_SLOPED,
                          &loggrd);


    if (ygmn_type == CALC_GMN1) {
        temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2 - pw_gymn2d;
             

  trapezoid((WF_PROCESSOR)wg_gymn2, "gymn2", &gymn2, &gymn2a,
                        &gymn2d, pw_gymn2, pw_gymn2a, pw_gymn2d,
                        ia_gymn2, 0, 0, 0, 0, temp1-pw_gymn2a, TRAP_ALL,
                        &loggrd);

        temp1 = pbeg(&gy1a, "gy1a", 0) - pw_gymn2_tot - pw_gymn1 - pw_gymn1d;
             

  trapezoid((WF_PROCESSOR)wg_gymn1, "gymn1", &gymn1, &gymn1a,
                        &gymn1d, pw_gymn1, pw_gymn1a, pw_gymn1d,
                        ia_gymn1, 0, 0, 0, 0, temp1-pw_gymn1a, TRAP_ALL,
                        &loggrd);

    }

    /* Z prephaser ************************************************************/
    if (oppseq != PSD_SE || zgmn_type == CALC_GMN1 || rtb0_flag || dpc_flag || ((oppseq == PSD_SE) && mux_flag && (use_slice_fov_shift_blips) && (mux_slices_rf1>1)) ) {
        if(ss_rf1 == PSD_ON)
        {
#if defined(IPG_TGT) || defined(MGD_TGT)
            temp1 = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gz1a);
#elif defined(HOST_TGT)
            temp1 = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gz1a);
#endif
        }
        else
        {
            temp1 = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gz1a);
        }
	      

  trapezoid((WF_PROCESSOR)wg_gz1, "gz1", &gz1, &gz1a,
                        &gz1d, pw_gz1, pw_gz1a, pw_gz1d,
                        ia_gz1, 0, 0, 0, 0, temp1-pw_gz1a, TRAP_ALL,
                        &loggrd);

	if (zgmn_type == CALC_GMN1) {
            temp1 += (pw_gz1 + pw_gz1d + pw_gzmna);
                  

  trapezoid((WF_PROCESSOR)wg_gzmn, "gzmn", &gzmn, &gzmna,
                        &gzmnd, pw_gzmn, pw_gzmna, pw_gzmnd,
                        ia_gzmn, 0, 0, 0, 0, temp1-pw_gzmna, TRAP_ALL,
                        &loggrd);
 
	}
    }

    /* Added for Inversion.e */
      
  {
    pulsename(&rf2se1,"rf2se1");
    createreserve(&rf2se1,(WF_PROCESSOR)wg_rf2se1,
		  res_rf2se1);
  }


    /* X diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {


        if (PSD_OFF == dualspinecho_flag)
        {

	    res_gxdl = res_gd1;
	    pw_gxdl = pw_gd1;

            if(xygradCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&xgradCrusherL,"xgradCrusherLa",0)) - pw_gxdl - pw_gxdld - pw_wgxdl);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gxdl - pw_gxdld - pw_wgxdl);
            }
	


    	    pulsename(&gxdl,"gxdl");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_x1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_x1.bin",(int)opuser12);
#endif 
	    printf("pg 16497 ia_gxdl = %d\n", ia_gxdl);
	    printf("max_bval = %f\n", max_bval);
	    printf("ide_max_bval = %f\n", ide_max_bval);
            fflush( stdout );
	    
	    if(waveform_type == 3){ /* used to change which pulsed gets used to calculate the b-mat in dti predownload */
            	createextwave(&gxdl,(WF_PROCESSOR)XGRAD,
                           res_gxdl,test_wave_file);
	    	createinstr( &gxdl,(long)tempx,
                           pw_gxdl,ia_gxdl);
	     }



    	    pulsename(&gxiso1,"gxiso1");
            createextwave(&gxiso1,(WF_PROCESSOR)wg_gxdl,
                           res_gxdl,test_wave_file);


    	    pulsename(&gxdlbuff,"gxdlbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif 
            createextwave(&gxdlbuff,(WF_PROCESSOR)wg_gxdl,
                           res_gxdl,test_wave_file);

	    if(waveform_type != 3){ /* used to change which pulsed gets used to calculate the b-mat in dti predownload */
            	createextwave(&gxdl,(WF_PROCESSOR)XGRAD,
                           res_gxdl,test_wave_file);
	    	createinstr( &gxdl,(long)tempx,
                           pw_gxdl,ia_gxdl);
	     }

#if defined(HOST_TGT)
            setiampiter(xamp_iters, cur_num_iters, &gxdl, 0, 1);
#endif

	    res_gxdr = res_gd2;
	    pw_gxdr = pw_gd2;

            if(xygradCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&xgradCrusherR,"xgradCrusherRd",0)) + pw_gxdra + pw_wgxdr);
            } else {
                tempx = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gxdra + pw_wgxdr);
            }


    	    pulsename(&gxdr,"gxdr");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_x2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_x2.bin",(int)opuser12);
#endif 

	    if(waveform_type == 3){
            	createextwave(&gxdr,(WF_PROCESSOR)XGRAD,
                           res_gxdr,test_wave_file);
            	createinstr( &gxdr,(long)tempx,
                           pw_gxdr,ia_gxdr);
	    }

    	    pulsename(&gxiso2,"gxiso2");
            createextwave(&gxiso2,(WF_PROCESSOR)wg_gxdr,
                           res_gxdr,test_wave_file);

    	    pulsename(&gxdlbuff,"gxdrbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif
 
            createextwave(&gxdrbuff,(WF_PROCESSOR)wg_gxdr,
                           res_gxdr,test_wave_file);

	    if(waveform_type != 3){
            	createextwave(&gxdr,(WF_PROCESSOR)XGRAD,
                           res_gxdr,test_wave_file);
            	createinstr( &gxdr,(long)tempx,
                           pw_gxdr,ia_gxdr);
	    }

#if defined(HOST_TGT)
            setiampiter(xamp_iters, cur_num_iters, &gxdr, 0, 1);
#endif


        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gxdl1 - pw_gxdl1d - pw_wgxdl1);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                                pw_gxdl1 - pw_gxdl1d - pw_wgxdl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempx = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gxdl1a +pw_wgxdl1);
#elif defined(HOST_TGT)
        tempx = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
#endif
    }
    else if (rfov_flag)
    {
        tempx = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
    }
    else
    {
        tempx = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gxdl1a + pw_wgxdl1);
    }
}

                 

  trapezoid((WF_PROCESSOR)wg_gxdl1, "gxdl1", &gxdl1, &gxdl1a,
                        &gxdl1d, pw_gxdl1, pw_gxdl1a, pw_gxdl1d,
                        ia_gxdl1, 0, 0, 0, 0, tempx-pw_gxdl1a, TRAP_ALL,
                        &loggrd);

         
#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gxdr1a + pw_wgxdr1);
            } else {
                tempx = RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                                pw_gxdr1a + pw_wgxdr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdr1, "gxdr1", &gxdr1, &gxdr1a,
                        &gxdr1d, pw_gxdr1, pw_gxdr1a, pw_gxdr1d,
                        ia_gxdr1, 0, 0, 0, 0, tempx-pw_gxdr1a, TRAP_ALL,
                        &loggrd);

         
#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) { 
                tempx = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gxdl2 - pw_gxdl2d - pw_wgxdl2);
            } else {
                tempx = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gxdl2 - pw_gxdl2d - pw_wgxdl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdl2, "gxdl2", &gxdl2, &gxdl2a,
                        &gxdl2d, pw_gxdl2, pw_gxdl2a, pw_gxdl2d,
                        ia_gxdl2, 0, 0, 0, 0, tempx-pw_gxdl2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempx = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gxdr2a + pw_wgxdr2);
            } else {
                tempx = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gxdr2a + pw_wgxdr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gxdr2, "gxdr2", &gxdr2, &gxdr2a,
                        &gxdr2d, pw_gxdr2, pw_gxdr2a, pw_gxdr2d,
                        ia_gxdr2, 0, 0, 0, 0, tempx-pw_gxdr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(xamp_iters, cur_num_iters, &gxdr2, 0, -1);
#endif

        }
    }

    /* X killer pulse *********************************************************/
    if (eosxkiller == PSD_ON) {
	tempx = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gxka);
	     

  trapezoid((WF_PROCESSOR)wg_gxk, "gxk", &gxk, &gxka,
                        &gxkd, pw_gxk, pw_gxka, pw_gxkd,
                        ia_gxk, 0, 0, 0, 0, tempx-pw_gxka, TRAP_ALL,
                        &loggrd);

    }
  
    /* Y diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {

	    res_gydl = res_gd1;
	    pw_gydl = pw_gd1;

            if(xygradCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&ygradCrusherL,"ygradCrusherLa",0)) - pw_gydl - pw_gydld - pw_wgydl);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gydl - pw_gydld - pw_wgydl);
            }

    	    pulsename(&gydl,"gydl");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_y1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_y1.bin",(int)opuser12);
#endif
	    if(waveform_type == 3){
            	createextwave(&gydl,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);
            	createinstr( &gydl,(long)tempy,
                           pw_gydl,ia_gydl);
	    }

    	    pulsename(&gyiso1,"gyiso1");
            createextwave(&gyiso1,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);

    	    pulsename(&gydlbuff,"gydlbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif
            createextwave(&gydlbuff,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);

	    if(waveform_type != 3){
            	createextwave(&gydl,(WF_PROCESSOR)wg_gydl,
                           res_gydl,test_wave_file);
            	createinstr( &gydl,(long)tempy,
                           pw_gydl,ia_gydl);
	    }

#if defined(HOST_TGT)
            setiampiter(yamp_iters, cur_num_iters, &gydl, 0, 1);
#endif

	    res_gydr = res_gd2;
	    pw_gydr = pw_gd2;

            if(xygradCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&ygradCrusherR,"ygradCrusherRd",0)) + pw_gydra + pw_wgydr);
            } else {
                tempy = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gydra + pw_wgydr);
            }

/* granty edit custom pulse */



    	    pulsename(&gydr,"gydr");
#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_y2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_y2.bin",(int)opuser12);
#endif

	    if( waveform_type == 3){
            	createextwave(&gydr,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);
            	createinstr( &gydr,(long)tempy,
                           pw_gydr,ia_gydr);
	    }

    	    pulsename(&gyiso2,"gyiso2");
            createextwave(&gyiso2,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);

    	    pulsename(&gydrbuff,"gydrbuff");
#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif 
            createextwave(&gydrbuff,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);

	    if( waveform_type != 3){
            	createextwave(&gydr,(WF_PROCESSOR)wg_gydr,
                           res_gydr,test_wave_file);
            	createinstr( &gydr,(long)tempy,
                           pw_gydr,ia_gydr);
	    }

#if defined(HOST_TGT)
            setiampiter(yamp_iters, cur_num_iters, &gydr, 0, 1);
#endif

        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gydl1 - pw_gydl1d - pw_wgydl1);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                                pw_gydl1 - pw_gydl1d - pw_wgydl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempy = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gydl1a + pw_wgydl1);
#elif defined(HOST_TGT)
        tempy = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gydl1a + pw_wgydl1);
#endif
    }
    else if (rfov_flag)
    {
        tempy = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gydl1a + pw_wgydl1);
    }    
    else
    {
        tempy = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gydl1a +pw_wgydl1);
    }
}

                 

  trapezoid((WF_PROCESSOR)wg_gydl1, "gydl1", &gydl1, &gydl1a,
                        &gydl1d, pw_gydl1, pw_gydl1a, pw_gydl1d,
                        ia_gydl1, 0, 0, 0, 0, tempy-pw_gydl1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gydr1a + pw_wgydr1);
            } else {
                tempy = RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                                pw_gydr1a + pw_wgydr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydr1, "gydr1", &gydr1, &gydr1a,
                        &gydr1d, pw_gydr1, pw_gydr1a, pw_gydr1d,
                        ia_gydr1, 0, 0, 0, 0, tempy-pw_gydr1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gydl2 - pw_gydl2d - pw_wgydl2);
            } else {
                tempy = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gydl2 - pw_gydl2d - pw_wgydl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydl2, "gydl2", &gydl2, &gydl2a,
                        &gydl2d, pw_gydl2, pw_gydl2a, pw_gydl2d,
                        ia_gydl2, 0, 0, 0, 0, tempy-pw_gydl2a, TRAP_ALL,
                        &loggrd);

       
#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempy = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gydr2a + pw_wgydr2);
            } else {
                tempy = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gydr2a + pw_wgydr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gydr2, "gydr2", &gydr2, &gydr2a,
                        &gydr2d, pw_gydr2, pw_gydr2a, pw_gydr2d,
                        ia_gydr2, 0, 0, 0, 0, tempy-pw_gydr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(yamp_iters, cur_num_iters, &gydr2, 0, -1);
#endif
        }
    }

    /* Y killer pulse *****************************************************/
    if (eosykiller == PSD_ON) {
	tempy = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gyka);
	     

  trapezoid((WF_PROCESSOR)wg_gyk, "gyk", &gyk, &gyka,
                        &gykd, pw_gyk, pw_gyka, pw_gykd,
                        ia_gyk, 0, 0, 0, 0, tempy-pw_gyka, TRAP_ALL,
                        &loggrd);

    }
  
    /* Z diffusion pulses *****************************************************/
    /* DTI */
    if ((oppseq == PSD_SE && opdiffuse == PSD_ON) || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
	    res_gzdl = res_gd1;
	    pw_gzdl = pw_gd1;

            if(xygradCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2l1,"gzrf2l1a",0),pbeg(&xgradCrusherL,"xgradCrusherLa",0)) - pw_gzdl - pw_gzdld - pw_wgzdl);
            } else {
                tempz = RUP_GRD(pbeg(&gzrf2l1,"gzrf2l1a",0) - pw_gzdl - pw_gzdld - pw_wgzdl);
            }

/* granty edit custom pulse */

    	    pulsename(&gzdl,"gzdl");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_z1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_z1.bin",(int)opuser12);
#endif 

	    if( waveform_type == 3){
            	createextwave(&gzdl,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

            	createinstr( &gzdl,(long)tempz,
                           pw_gzdl,ia_gzdl);
	    }

    	    pulsename(&gziso1,"gziso1");
            createextwave(&gziso1,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

    	    pulsename(&gzdlbuff,"gzdlbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_1.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_1.bin",(int)opuser12);
#endif 

            createextwave(&gzdlbuff,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

	    if( waveform_type != 3){
            	createextwave(&gzdl,(WF_PROCESSOR)wg_gzdl,
                           res_gzdl,test_wave_file);

            	createinstr( &gzdl,(long)tempz,
                           pw_gzdl,ia_gzdl);
	    }

#if defined(HOST_TGT)
            setiampiter(zamp_iters, cur_num_iters, &gzdl, 0, 1);
#endif
	    res_gzdr = res_gd2;
	    pw_gzdr = pw_gd2;

            if(xygradCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2r1,"gzrf2r1d",0),pend(&xgradCrusherR,"xgradCrusherRd",0)) + pw_gzdra + pw_wgzdr);
            } else {
                tempz = RUP_GRD(pend(&gzrf2r1,"gzrf2r1d",0) + pw_gzdra + pw_wgzdr);
            }

    	    pulsename(&gzdr,"gzdr");

#ifndef PSD_HW
	    sprintf(test_wave_file,"ide%d_z2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/ide%d_z2.bin",(int)opuser12);
#endif 

	    if( waveform_type == 3){
	            createextwave(&gzdr,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);
	            createinstr( &gzdr,(long)tempz,
                           pw_gzdr,ia_gzdr);
	    }

    	    pulsename(&gziso2,"gziso2");
            createextwave(&gziso2,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);

    	    pulsename(&gzdrbuff,"gzdrbuff");

#ifndef PSD_HW
	    sprintf(test_wave_file,"sde%d_2.bin",(int)opuser12);
#else
	    sprintf(test_wave_file,"/usr/g/research/grant/cdiff/WAVES/sde%d_2.bin",(int)opuser12);
#endif 
            createextwave(&gzdrbuff,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);

	    if( waveform_type != 3){
	            createextwave(&gzdr,(WF_PROCESSOR)wg_gzdr,
                           res_gzdr,test_wave_file);
	            createinstr( &gzdr,(long)tempz,
                           pw_gzdr,ia_gzdr);
	    }

#if defined(HOST_TGT)
            setiampiter(zamp_iters, cur_num_iters, &gzdl, 0, 1);
#endif


        } else {
            /*MRIhc05259*/
            if(xygradLeftCrusherFlag == PSD_ON) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2leftl1,"gzrf2leftl1a",0),
                                pbeg(&xgradLeftCrusherL,"xgradLeftCrusherLa",0))
                                - pw_gzdl1 - pw_gzdl1d - pw_wgzdl1);
            }
            else {
                tempz=RUP_GRD(pbeg(&gzrf2leftl1,"gzrf2leftl1a",0) -
                              pw_gzdl1 - pw_gzdl1d - pw_wgzdl1);
            }
/* SVBranch:HCSDM00259119  -  dse enh */        
if(dse_enh_flag)
{
    if(ss_rf1 == PSD_ON)
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        tempz = RDN_GRD(pend(&gzrf1, "gzrf1", gzrf1.ninsts-1) + pw_gzdl1a +pw_wgzdl1);
#elif defined(HOST_TGT)
        tempz = RDN_GRD(pend(&gzrf1d, "gzrf1d", gzrf1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
#endif
    }
    else if (rfov_flag)
    {
        tempz = RDN_GRD(pendall(&gyex1, gyex1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
    }    
    else
    {
        tempz = RDN_GRD(pendall(&gzrf1, gzrf1.ninsts-1) + pw_gzdl1a + pw_wgzdl1);
    }
}
                 

  trapezoid((WF_PROCESSOR)wg_gzdl1, "gzdl1", &gzdl1, &gzdl1a,
                        &gzdl1d, pw_gzdl1, pw_gzdl1a, pw_gzdl1d,
                        ia_gzdl1, 0, 0, 0, 0, tempz-pw_gzdl1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdl1, 0, 1);
#endif

            if(xygradLeftCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2leftr1,"gzrf2leftr1d",0),
                                pend(&xgradLeftCrusherR,"xgradLeftCrusherRd",0))
                                + pw_gzdr1a + pw_wgzdr1);
            }
            else {
                tempz=RUP_GRD(pend(&gzrf2leftr1,"gzrf2leftr1d",0) +
                              pw_gzdr1a + pw_wgzdr1);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdr1, "gzdr1", &gzdr1, &gzdr1a,
                        &gzdr1d, pw_gzdr1, pw_gzdr1a, pw_gzdr1d,
                        ia_gzdr1, 0, 0, 0, 0, tempz-pw_gzdr1a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdr1, 0, -1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMin(2,pbeg(&gzrf2rightl1,"gzrf2rightl1a",0),
                            pbeg(&xgradRightCrusherL,"xgradRightCrusherLa",0))
                            - pw_gzdl2 - pw_gzdl2d - pw_wgzdl2);
            } else {
                tempz = RUP_GRD(pbeg(&gzrf2rightl1,"gzrf2rightl1a",0) 
                                - pw_gzdl2 - pw_gzdl2d - pw_wgzdl2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdl2, "gzdl2", &gzdl2, &gzdl2a,
                        &gzdl2d, pw_gzdl2, pw_gzdl2a, pw_gzdl2d,
                        ia_gzdl2, 0, 0, 0, 0, tempz-pw_gzdl2a, TRAP_ALL,
                        &loggrd);

       
#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdl2, 0, 1);
#endif

            if(xygradRightCrusherFlag == PSD_ON ) {
                tempz = RUP_GRD(IMax(2,pend(&gzrf2rightr1,"gzrf2rightr1d",0),
                            pend(&xgradRightCrusherR,"xgradRightCrusherRd",0))
                            + pw_gzdr2a + pw_wgzdr2);
            } else {
                tempz = RUP_GRD(pend(&gzrf2rightr1,"gzrf2rightr1d",0) 
                                + pw_gzdr2a + pw_wgzdr2);
            }
                 

  trapezoid((WF_PROCESSOR)wg_gzdr2, "gzdr2", &gzdr2, &gzdr2a,
                        &gzdr2d, pw_gzdr2, pw_gzdr2a, pw_gzdr2d,
                        ia_gzdr2, 0, 0, 0, 0, tempz-pw_gzdr2a, TRAP_ALL,
                        &loggrd);


#if defined(HOST_TGT)
            setiamptiter(zamp_iters, cur_num_iters, &gzdr2, 0, -1);
#endif
        }

    }


    /* Z killer pulse *****************************************************/
    if (eoszkiller == PSD_ON) {
        tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
             

  trapezoid((WF_PROCESSOR)wg_gzk, "gzk", &gzk, &gzka,
                        &gzkd, pw_gzk, pw_gzka, pw_gzkd,
                        ia_gzk, 0, 0, 0, 0, tempz-pw_gzka, TRAP_ALL,
                        &loggrd);

    }

    /* RHO killer? pulse ***********************************************/
    /* This pulse is specific to MGD.  It forces the RHO sequencer to  */
    /* EOS after all other RF sequencers (omega & theta) as a temp fix */
    /* for a seqeuncer issue.                                          */
    if (eosrhokiller == PSD_ON) {
        int pw_rho_killer = 2;
        int ia_rho_killer = 0;

        tempz = RUP_GRD(pend(&gxwde,"gxwde",0) + gkdelay + pw_gzka);
        pulsename(&rho_killer,"rho_killer");
        createconst(&rho_killer,RHO,pw_rho_killer,MAX_PG_WAMP);
        createinstr( &rho_killer,(long)(tempz),
                     pw_rho_killer,ia_rho_killer);
    }

    /* Major "Wait" Pulses ************************************************/
    /* DTI */
    if (opdiffuse == PSD_ON || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
            tempx = pendall(&gxdr,0);
            tempy = pendall(&gydr,0);
        } else {
            tempx = pendall(&gxdr2,0);
            tempy = pendall(&gydr2,0);
        }	
    } else {
        if (gy1pos == PSD_POST_180)
            tempy = pbeg(&gy1a, "gy1a", 0) - pw_wgy;
        else
            tempy = pbeg(&gyba, "gyba", 0) - pw_wgy;

        if (ygmn_type == CALC_GMN1)
            tempy = pbeg(&gymn1a, "gymn1a", 0) - pw_wgy;

        if (gx1pos == PSD_POST_180)
            tempx = pbeg(&gx1a, "gx1a", 0) - pw_wgx;
        else
            tempx = pbeg(&gxwa, "gxwa", 0) - pw_wgx;
    }

    /* TFON sliding data acq. window wait intervals */
        
  {
    pulsename(&wgx,"wgx");
    createconst(&wgx,(WF_PROCESSOR)wg_wgx,pw_wgx,(short)0); 
    createinstr( &wgx,(long)(tempx),pw_wgx,0);
  }

        
  {
    pulsename(&wgy,"wgy");
    createconst(&wgy,(WF_PROCESSOR)wg_wgy,pw_wgy,(short)0); 
    createinstr( &wgy,(long)(tempy),pw_wgy,0);
  }


    if (oppseq == PSD_SE) {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            tempz = pendall(&gzrf2r1, 0);
        } else {
            tempz = pendall(&gzrf2rightr1, 0);
        }	
    } else {
        if (zgmn_type == CALC_GMN1)
            tempz = pendall(&gzmnd, 0);
        else
            tempz = pendall(&gz1d, 0);
    }

    /* DTI */
    if (opdiffuse == PSD_ON || tensor_flag == PSD_ON) {
        if (PSD_OFF == dualspinecho_flag)
        {
            tempz = pendall(&gzdr,0);
        }
        else {
            tempz = pendall(&gzdr2,0);
        }
    }

       
  {
    pulsename(&wgz,"wgz");
    createconst(&wgz,(WF_PROCESSOR)wg_wgz,pw_wgz,(short)0); 
    createinstr( &wgz,(long)(tempz),pw_wgz,0);
  }


    if (oppseq == PSD_SE)
    {
        if (PSD_OFF == dualspinecho_flag)
        {
            temps = pendall(&rf2, 0) + rfupd + 4  ;
        }
        else
        {
            temps = pendall(&rf2right, 0) + rfupd + 4  ;
        }
    }
    else
    {
        if (hsdab == 2)
            temps = pendall(&rf1, 0) + rfupd + 4   + (int)DIFFDAB_length;
        else
        temps = pendall(&rf1, 0) + rfupd + 4   + (int)HSDAB_length;
    }

    if (mux_flag && verse_rf2)
    {
        temps = temps + 40  ;
    }

       
  {
    pulsename(&wssp,"wssp");
    createconst(&wssp,(WF_PROCESSOR)wg_wssp,pw_wssp,(short)0); 
    createinstr( &wssp,(long)(temps),pw_wssp,0);
  }

    pw_sspdelay = defaultdelay + 1  ;
         
  {
    pulsename(&sspdelay,"sspdelay");
    createconst(&sspdelay,(WF_PROCESSOR)wg_sspdelay,pw_sspdelay,(short)0); 
    createinstr( &sspdelay,(long)(temps+pw_wssp),pw_sspdelay,0);
  }

    pw_omegadelay = RUP_RF(defaultdelay+2  );
        
  {
    pulsename(&omegadelay,"omegadelay");
    createconst(&omegadelay,(WF_PROCESSOR)wg_omegadelay,pw_omegadelay,(short)0); 
    createinstr( &omegadelay,(long)(RUP_GRD(temps)),pw_omegadelay,0);
  }

       
  {
    pulsename(&womega,"womega");
    createconst(&womega,(WF_PROCESSOR)wg_womega,pw_womega,(short)0); 
    createinstr( &womega,(long)(RUP_GRD(temps)+pw_omegadelay),pw_womega,0);
  }
 /* ufi2_ypd */

    /* pulse names for Omega Freq Mod pulses */ 
    pulsename(&rs_omega_attack, "rs_omega_attack");
    pulsename(&rs_omega_decay, "rs_omega_decay");
    pulsename(&omega_flat, "omega_flat");
  
    /* These thress pulses are for receive */
    setrxflag(&rs_omega_attack, 1);
    setrxflag(&rs_omega_decay, 1);
    setrxflag(&omega_flat, 1);
  
    /* internref: use tot_etl instead of etl */
    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);
      
        {   /* local scope */
          
            int time_offset = 0;
            pulsepos = pendallssp(echotrainrba[echoloop], 0); 
            time_offset = pw_gxwad - dacq_offset;  
          
            /* TURN TNS ON at the first etl and OFF at the last etl so that */
            /* the xtr and TNS do not overlap. */
            if ( echoloop == 0) 
  {
    e1entns_pack[0] = SSPDS+EDC;
    pulsename(&e1entns,"e1entns");
    createbits(&e1entns,TYPSSP,4,e1entns_pack);
    createinstr( &e1entns,(LONG)(pulsepos),4,0);
  }

            if ( echoloop == tot_etl-1)   
  {
    e1distns_pack[0] = SSPDS+EDC;
    pulsename(&e1distns,"e1distns");
    createbits(&e1distns,TYPSSP,4,e1distns_pack);
    createinstr( &e1distns,(LONG)(pulsepos+(int)(tsp*(float)rhfrsize)),4,0);
  }

          
            if (vrgfsamp) {
                trapezoid( OMEGA,"omega", &omega_flat, 
                           &rs_omega_attack, &rs_omega_decay,
                           pw_gxwl+pw_gxw+pw_gxwr,  pw_gxwad, pw_gxwad, 
                           ia_omega,ia_omega,ia_omega, 0, 0, 
                           RUP_RF(pulsepos-time_offset+rba_act_start), TRAP_ALL, &loggrd);    
            } else {
              
                /* BJM: to offset frequency, play constant on omega */
                createconst(&omega_flat, OMEGA, pw_gxwl+pw_gxw+pw_gxwr, 
                            max_pg_wamp);
                createinstr(&omega_flat, RUP_RF(pulsepos+rba_act_start),
                            pw_gxwl+pw_gxw+pw_gxwr, ia_omega);            
            }
          
        }
    }
  
    /* 4us for the e1distns pack */
    temps = pendallssp(&echotrain[tot_etl-1], 0) + (int)(tsp*(float)rhfrsize)+ 4; 

     
  {
  pulsename(&atten,"atten");
  createatten(&atten, (long)(temps));
}


    /* spring for sspdelay */
         
  {
    pulsename(&sspshift,"sspshift");
    createconst(&sspshift,(WF_PROCESSOR)wg_sspshift,pw_sspshift,(short)0); 
    createinstr( &sspshift,(long)(temps+7  ),pw_sspshift,0);
  }


    temps = pendallssp(&sspshift, 0);

    for (i=0; i<num_passdelay; i++) { 
           
  {
    pulsename(&ssp_pass_delay,"ssp_pass_delay");
    createconst(&ssp_pass_delay,(WF_PROCESSOR)wg_ssp_pass_delay,pw_ssp_pass_delay,(short)0); 
    createinstr( &ssp_pass_delay,(long)(temps),pw_ssp_pass_delay,0);
  }

        temps = pendallssp(&ssp_pass_delay, i);
    }

     
  {
    pulsename(&pass_pulse,"pass_pulse");
    createpass(&pass_pulse,(long)(temps));
  }


    /* Actual deadtimes for cardiac scans will be rewritten later */
    if((opcgate==PSD_ON) || (oprtcgate==PSD_ON))
    {
        psd_seqtime = RUP_GRD(tmin);
    }
    else if(navtrig_flag == PSD_ON)
    {
        psd_seqtime = RUP_GRD(nav_image_interval - time_ssi);
    }
    else
    {
        psd_seqtime = RUP_GRD(avail_se_time/(mux_flag?mux_slquant:false_slquant1) - time_ssi);

        if (t1flair_flag == PSD_ON)
        {
            psd_seqtime = RUP_GRD(act_tr/false_slquant1 - time_ssi);
        }
    }

    /*  Code to estimate the phase error accumulation for the 90-180-180
        SE sequence so as to maintain the CPMG condotion...this code based
        off the correction in fse-xl.e and fixes the slice-to-slice signal 
        variation issue with dualspinecho ALP */
    getssppulse(&tmppulseptr, &rf1,"frq", 0); /* Get beginning of rf1 */
    tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
    sync1_pos = (tmpinstr->start);
    rf1_pos = pbeg(&rf1,"rf1",0);
    sync_to_rf1 = rf1_pos - ( sync1_pos + frq2sync_dly ); 
    t_rf1_phase = sync_to_rf1 + hrf1a;

    if (PSD_OFF == dualspinecho_flag)
    {
        getssppulse(&tmppulseptr, &rf2,"frq", 0); /* Get beginning of rf2 */
        tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
        sync2_pos = (tmpinstr->start);
        rf2_pos = pbeg(&rf2,"rf2",0);
        sync_to_rf2 = rf2_pos - ( sync2_pos + frq2sync_dly ); 
        t_rf2_phase = sync_to_rf2 + pw_rf2/2;
    }
    else {
        getssppulse(&tmppulseptr, &rf2left,"frq", 0); /* Get beginning of rf2 */
        tmpinstr = (WF_INSTR_HDR *)GetPulseInstrNode(tmppulseptr,0);
        sync2_pos = (tmpinstr->start);
        rf2_pos = pbeg(&rf2left,"rf2left",0);
        sync_to_rf2 = rf2_pos - ( sync2_pos + frq2sync_dly ); 
        t_rf2_phase = sync_to_rf2 + pw_rf2left/2;
    }

    if(!irprep_flag) 
    {
        
  {
    pulsename(&seqcore,"seqcore");
    createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcore = %d\n", idx_seqcore );
#endif
  }


        getperiod((long*)&scan_deadtime, &seqcore, 0);
        scan_deadlast = deadlast;
    }

    if(ir_on)
    {
    { /* Start of code inlined from Inversion_new.e InversionPG */
        if (ir_on == PSD_ON)
        {

            for (ir_index=0;ir_index<irslquant;ir_index = ir_index + 1) {

	        /*MRIhc26154 Support Routine Failure PopUp.*/
                 
                                 
                                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0", 
                                     (WF_PROCESSOR)wg_rf0);

    /* First create the pulses */
    pulsename(&gzrf0a,"gzrf0a");
    pulsename(&gzrf0,"gzrf0");
    pulsename(&gzrf0d,"gzrf0d");
    pulsename(&rf0,"rf0");

    /*  Now create the slice select trapezoid */
	pg_beta = loggrd.zbeta;
    createramp(&gzrf0a,ZGRAD,pw_gzrf0a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0a,(LONG)(ir_start+ir_index*psd_seqtime-pw_gzrf0a),
		pw_gzrf0a,ia_gzrf0);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0,ZGRAD,rfpulseInfo[RF0_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0.type = TYPEXTERNAL;
	    createinstr(&gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
			pw_gzrf0,ia_gzrf0);

                movestretchedwave( grad_zrf0, res_gzrf0,
                                   &gzrf0, 0, rfpulseInfo[RF0_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0,ZGRAD, 
			  res_gzrf0, grad_zrf0);
	    createinstr(&gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
			pw_gzrf0,ia_gzrf0);
	  }
      }
    else
      {
	createconst(&gzrf0,ZGRAD, pw_rf0,MAX_PG_WAMP);
	createinstr( &gzrf0,(LONG)(ir_start+ir_index*psd_seqtime),
		    pw_gzrf0,ia_gzrf0);
      }
    /* Decay ramp */
    createramp(&gzrf0d,ZGRAD,pw_gzrf0d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0d/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0d,(LONG)(ir_start+ir_index*psd_seqtime+pw_gzrf0),
		pw_gzrf0d,ia_gzrf0);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_SLOT].change==PSD_ON)
      {
	cyc_rf0 = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0,(WF_PROCESSOR)wg_rf0,rfpulseInfo[RF0_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0,alpha_rf0);
	createinstr(&rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		    pw_rf0,ia_rf0);
	linkpulses(4,&rf0,&gzrf0,&gzrf0a,
		   &gzrf0d);
	addrfbits(&rf0,off_rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		  pw_rf0);

            movestretchedwave( rf_rf0, res_rf0,
                               &rf0, 0, rfpulseInfo[RF0_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0,(WF_PROCESSOR)wg_rf0,
		      res_rf0,rf_rf0);
	createinstr(&rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		    pw_rf0,ia_rf0);
	linkpulses(4,&rf0,&gzrf0,&gzrf0a,
		   &gzrf0d);
	addrfbits(&rf0,off_rf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
		  pw_rf0);
      }
}


                
                        
  {
        INT old_res =  res_omegarf0; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0 != TYPRHO1)  && (wg_omegarf0 != TYPRHO2) &&
         (wg_omegarf0 != TYPTHETA) && (wg_omegarf0 != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0 += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0,"omegarf0");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0, (WF_PROCESSOR)wg_omegarf0, new_res);

                movestretchedwave( fileloc_omegarf0, old_res,
                                   &omegarf0, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0 = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0,(WF_PROCESSOR)wg_omegarf0,
                          old_res,fileloc_omegarf0);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait, 
                 pw_omegarf0,ia_omegarf0);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0,off_omegarf0,(LONG)(ir_start+ir_index*psd_seqtime) + psd_rf_wait,
              pw_omegarf0);
    

    /*** Reset Resolution ***/
    res_omegarf0 = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


                    

  trapezoid((WF_PROCESSOR)wg_gyk0, "gyk0", &gyk0, &gyk0a,
                        &gyk0d, pw_gyk0, pw_gyk0a, pw_gyk0d,
                        ia_gyk0, 0, 0, 0, 0, RUP_GRD(pend(&rf0,"rf0",ir_index)+pw_gyk0a)+((rfupd>>2)<<2)-pw_gyk0a, TRAP_ALL,
                        &loggrd);

            }
 
        }
    } /* End of code inlined from Inversion_new.e InversionPG */
        if(irprep_flag)
        {
            pulsename(&seqcore,"seqcore");
            createseq(&seqcore,psd_seqtime, off_seqcore);
#if defined(HOST_TGT)
            /* Update sequence counter and get current sequence entry index */
            updateIndex( &idx_seqcore );
            printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                        "idx_seqcore = %d\n", idx_seqcore );
#endif
            getperiod((long*)&scan_deadtime, &seqcore, 0);
            scan_deadlast = deadlast;
        }
        else
        {
              
  {
    pulsename(&seqinv,"seqinv");
    createseq(&seqinv,invseqtime, off_seqinv);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqinv );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqinv = %d\n", idx_seqinv );
#endif
  }

            buildinstr();
            getperiod(&scan_deadtime_inv, &seqinv, 0);
            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqinv, 0);
        }
    }

    /* PS **************************************************************/
/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                          PSpulsegen                               *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
PSpulsegen();
FTGpulsegen();
XTGpulsegen();
ASpulsegen();
RSpulsegen();
DTGpulsegen();
AutoCoilpulsegen();
ExtCalpulsegen();

  
    if (SatRelaxers) /* Create Null sequence for Relaxers */
        SpSatCatRelaxPG(time_ssi);

    /* Baseline Acquisition *********************************************/
     
  {
    bline_unblank_pack[0] = SSPDS+RDC;
    bline_unblank_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    bline_unblank_pack[2] = SSPD+RUBL;
    bline_unblank_pack[3] = SSPDS;

    pulsename(&bline_unblank,"bline_unblank");
    createbits(&bline_unblank,TYPSSP,4,bline_unblank_pack);
    createinstr( &bline_unblank,(long)((LONG)(3000)),4,ia_bline_unblank);
  }

    
                     
                    
                        
                    
                    
                    
  {
    pulsename(&blineacq1,"blineacq1");
 
    epiacqq(&blineacq1, (long)((LONG)(5000)),(long)((LONG)0),
             (long)((LONG)0), (long)(filter_blineacq1),
             (TYPDAB_PACKETS)((TYPDAB_PACKETS)DABNORM), (long)((LONG)fast_rec),
                         (long)((LONG)(hsdab>0?0:1)));
  }

				 


    if (hsdab == 1)
         
{
    pulsename(&hyperdabbl,"hyperdabbl");

        createhsdab(&hyperdabbl, (long)(1000));
  }

    else if (hsdab == 2)
         
{
    pulsename(&diffdabbl,"diffdabbl");

    creatediffdab(&diffdabbl, (long)(1000));
}

  
      
  {
    pulsename(&seqblineacq,"seqblineacq");
    createseq(&seqblineacq,bl_acq_tr2, off_seqblineacq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqblineacq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqblineacq = %d\n", idx_seqblineacq );
#endif
  }


/*RTB0 correction*/
    /*MF B0 correction*/
    if ( rtb0_flag == PSD_ON )
    {
          
  {
    pulsename(&seqrtb0dummy,"seqrtb0dummy");
    createseq(&seqrtb0dummy,rtb0dummy_time, off_seqrtb0dummy);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtb0dummy );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtb0dummy = %d\n", idx_seqrtb0dummy );
#endif
  }
 /*dummy time for rtpinit()*/
          
  {
    pulsename(&seqrtb0fitwait,"seqrtb0fitwait");
    createseq(&seqrtb0fitwait,rtb0fittingwaittime, off_seqrtb0fitwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtb0fitwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtb0fitwait = %d\n", idx_seqrtb0fitwait );
#endif
  }
 /*dummy time for polynomial slice-by-slice CF fitting*/
          
  {
    pulsename(&seqrtprtb0,"seqrtprtb0");
    createseq(&seqrtprtb0,rtb0resultwaittime, off_seqrtprtb0);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtprtb0 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtprtb0 = %d\n", idx_seqrtprtb0 );
#endif
  }
 /*1ms wait time cycle for rtp result return*/
    }


#ifdef IPG
    if (FAILURE == Monitor_pulsegen())
    {
        return FAILURE;
    }
#endif

#ifdef NOT_MGD

    /* Move the instruction memory around a bit */
    /* There are essentially two memory banks: (1) XGRAD, YGRAD, ZGRAD, and SSP
       and      (2) RHO1, RHO2, THETA, OMEGA, AUX
       (Originally there were 4096 instructions assigned to each of x, z and ssp,
       and 4032 instructions to y.) */

    ipg_alloc_instr[0] = 4608;  /* XGRAD */
    ipg_alloc_instr[1] = 4544;  /* YGRAD */
    ipg_alloc_instr[2] = 2560;  /* ZGRAD */
    ipg_alloc_instr[3] = 4096;  /* RHO1  */
    ipg_alloc_instr[4] = 4096;  /* RHO2  */
    ipg_alloc_instr[5] = 4096;  /* THETA */
    ipg_alloc_instr[6] = 4096;  /* OMEGA */
    ipg_alloc_instr[7] = 4608;  /* SSP   */
    ipg_alloc_instr[8]  = 64;   /* AUX   */

#endif

    buildinstr();              /* load the sequencer memory */

    if (SatRelaxers) /* Use X and Z Grad offsets from off seqcore */
        SpSatCatRelaxOffsets(off_seqcore);

    { /* Start of code inlined from Inversion_new.e InversionPG */
        if( ir_sys_type == 1 )
        {
            rfupa = ir_rfupa; /* vmx 3/13/95 YI */
        }

        if( ir_on == PSD_ON )
        {
            int newres;

            newres = res_rf0;
            if(PSD_ON == rfpulseInfo[RF0_SLOT].change) {
                newres = rfpulseInfo[RF0_SLOT].newres;
            }

            setperiod((int)pw_rf0/newres, &rf0, 0);

            rf0_freq = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));
            rf0_pha = (int *)AllocNode((opphases*opslquant + 2)*sizeof(int));

            setupslices(rf0_freq, rsp_info, opslquant, a_gzrf0,
                        (float)1, rhfreqscale*opfov, TYPTRANSMIT);

            for (i=0; i<opslquant; i++)
                setupphases(rf0_pha, rf0_freq, i, rf0_phase, 0, freqSign);
        }
    } /* End of code inlined from Inversion_new.e InversionPG */

/* irprep_support */


    /*  ***********************************************************
        Initialization
        ********************************************************** */

    if (oppseq == PSD_SE) {   /* point to proper waveform */

        if (mux_flag && verse_rf2) {
            getwave(&wave_ptr, &index_rf2[0]);                /* VERSEd envelope */
            getwave(&grad_wave_ptr, &rf2_gradient_waveform);  /* VERSEd gradient waveform */
        } else {
            getwave(&wave_ptr, &rf2se1b4);          /* use this for non-VERSEd RF pulses */
        }
        /* DTI */
        if( opdualspinecho == PSD_OFF) {
            setwave(wave_ptr,   &rf2, 0);
            if (mux_flag && verse_rf2) {
                setwave(grad_wave_ptr, &gzrf2, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2, 0);
            }
        } else {
            setwave(wave_ptr,   &rf2left, 0);
            setwave(wave_ptr,   &rf2right, 0);
            if (mux_flag && verse_rf2) {
                setwave(grad_wave_ptr, &gzrf2left, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2left, 0);
                setwave(grad_wave_ptr, &gzrf2right, 0);
                setperiod(GRAD_UPDATE_TIME, &gzrf2right, 0);
            }
        }
    }

    rspdex = dex;
    rspech = 0;
    rspchp = CHOP_ALL;
    rsp_preview = 0;
  
#ifdef IPG
    /*
     * Execute this code only on the Tgt side
     */
    if (rfov_flag)
    {
        /* Slice shift controlled though theta */
        for (temps = 0; temps < opslquant; ++temps)
        {
            rf1_freq[temps] = 0;
        }

        /* TG limit calc based on Tx freq offset */
        calcTGLimitAtOffset((int)rfov_max_freq_shift, &TGlimit, psddebugcode2);
    }
    else if (mux_flag)
    {
        setupslices(rf1_freq, rsp_info, mux_slquant, a_gzrf1,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
        setupslices(theta_freq, rsp_info, mux_slquant, a_gzrf1/omega_scale,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);

    }
    else
    {
        /* Find frequency offsets */
        setupslices(rf1_freq, rsp_info, opslquant, a_gzrf1,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
        setupslices(theta_freq, rsp_info, opslquant, a_gzrf1/omega_scale,
                    (float)1, (opfov*freq_scale), TYPTRANSMIT);
    }

    if (oppseq == PSD_SE)
    {
        if (mux_flag)
        {
            setupslices(rf2_freq, rsp_info, mux_slquant, a_gzrf2,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
            setupslices(thetarf2_freq, rsp_info, mux_slquant, a_gzrf2/omega_scale,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);

        }
        else
        {
            setupslices(rf2_freq, rsp_info, opslquant, a_gzrf2,
                        (float)1, (opfov*freq_scale), TYPTRANSMIT);
        }
    }

    /* BJM: dualspinecho */
    for (i=0; i<opslquant; i++) {
        if (ss_rf1 == PSD_ON) {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, 0, freqSign);
        } else {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, t_rf1_phase, freqSign);
        }

        if(PSD_OFF == dualspinecho_flag)
        {
            setupphases(rf2_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2);
        }
        else
        {
            setupphases(rf2left_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2left);
            setupphases(rf2right_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2right);
        }
    }
  
    settriggerarray((short)(opslquant*opphases),rsptrigger);
  
    if (FAILURE == Monitor_Download())
    {
        return FAILURE;
    }

    /* Inform the Tgt of the rotation matrix array to be used.
       For everything but CFH and CFL the sat pulses are played
       out so load the sat rotation matrix. Otherwise
       the original slice rotation matrix is used. */
    SpSat_set_sat1_matrix(rsprot_orig, rsprot, opslquant*opphases,
                          sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num,
                          sp_satcard_loc, 0);

    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray((short)(opslquant*opphases),rsprot[0]);

    /* update RSP maxTG with min TGlimit value */
    maxTGAtOffset = updateTGLimitAtOffset(TGlimit, sat_TGlimit);

#endif /* IPG */
    sl_rcvcf = (int)((float)cfreceiveroffsetfreq/ TARDIS_FREQ_RES);

    /* Set up SlcInAcq and AcqPtr tables for multipass scans and
     * multi-repetition scans, including cardiac gating, interleaved,
     * and sequential multi-rep modes.
     * SlcInAcq array gives number of slices per array.
     * AcqPtr array gives index to the first slice in the 
     * multislice tables for each pass. */
  
    /* cardiac gated multi-slice, multi-phase, multi-rep */
    if (opcgate==PSD_ON) 
    {
        rspcardiacinit((short)ophrep, (short)piclckcnt);
        sliceindex = acqs - 1; /* with cardiac gating, acqs is the no. of slices */
        for (pass = 0; pass < acqs; pass++) 
	{
            slc_in_acq[pass] = slquant1*opphases;
            if (pass == 0)
                acq_ptr[pass] = 0;
            else 
	    {
                acq_ptr[pass] = sliceindex;
                sliceindex = sliceindex - 1;
	    }
  	} /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) 
	{
            for (pass = 0; pass < acqs; pass++) 
	    {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
	    }
	}
    }
    /* RTG */
    else if ((oprtcgate == PSD_ON) || (navtrig_flag == PSD_ON))
    {
        rspcardiacinit((short)oprtrep, (short)piclckcnt);

        slmod_acqs = (opslquant * reps) % act_acqs;

        for (pass = 0; pass < act_acqs; pass++)
        {
            slc_in_acq[pass] = (opslquant * reps)/ act_acqs;
            acq_ptr[pass] = 0;

            if (slmod_acqs > pass)
            {
                slc_in_acq[pass] = slc_in_acq[pass] + 1;
            }

            acq_ptr[pass] = (int)(opslquant/ act_acqs) * pass;

            if (slmod_acqs <= pass)
            {
                acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
            }
            else
            {
                acq_ptr[pass] = acq_ptr[pass] + pass;
            }
        }

        /* repeat the table for multi-reps */
        for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) {
            for (pass = 0; pass < acqs; pass++) {
                slc_in_acq[pass + pass_rep*acqs] = slc_in_acq[pass];
                acq_ptr[pass + pass_rep*acqs] = acq_ptr[pass];
            }
        }
    }
    else 
    {
        if ( mph_flag==PSD_OFF ) 
	{  /* single-rep interleaved multi-slice */
            slmod_acqs = (opslquant*reps)%act_acqs;
            for (pass = 0; pass < act_acqs; pass++) 
	    {
                slc_in_acq[pass] = (opslquant*reps)/act_acqs;
                if (slmod_acqs > pass)
                    slc_in_acq[pass] = slc_in_acq[pass] + 1;
                acq_ptr[pass] = (int)(opslquant/act_acqs) *pass;
                if (slmod_acqs <= pass)
                    acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                else
                    acq_ptr[pass] = acq_ptr[pass] + pass;
	    }
	}
        if ( (mph_flag==PSD_ON) && (acqmode==1)) 
	{  /* mph, sequential */
            for (pass=0; pass<act_acqs; pass++) 
	    {  /* for sequential, acqs=opslquant */
                slc_in_acq[pass] = reps;
                acq_ptr[pass] = pass;
	    }
	}
        if ( (mph_flag==PSD_ON) && (acqmode==0) ) 
	{  /* mph, interleaved, single pass */
            for (pass = 0; pass < act_acqs; pass++) 
	    {
                slc_in_acq[pass] = slquant1;
                acq_ptr[pass] = 0;
                slmod_acqs = (opslquant*reps)%act_acqs;
                for (pass = 0; pass < act_acqs; pass++) 
		{
                    slc_in_acq[pass] = (opslquant*reps)/act_acqs;
                    if (slmod_acqs > pass)
                        slc_in_acq[pass] = slc_in_acq[pass] + 1;
                    acq_ptr[pass] = (int)(opslquant/act_acqs) *pass;
                    if (slmod_acqs <= pass)
                        acq_ptr[pass] = acq_ptr[pass] + slmod_acqs;
                    else
                        acq_ptr[pass] = acq_ptr[pass] + pass;
		}
	    }
            for (pass_rep = 1; pass_rep < pass_reps; pass_rep++) 
	    { /* repeat the table for multi-reps */
                for (pass = 0; pass < act_acqs; pass++) 
		{
                    slc_in_acq[pass + pass_rep*act_acqs] = slc_in_acq[pass];
                    acq_ptr[pass + pass_rep*act_acqs] = acq_ptr[pass];
		}
	    }
	}
    }
    
    /* t1flair_stir */
    if (t1flair_flag == PSD_ON)
    {
        if (FAILURE == T1flair_sliceordering())
        {
            return FAILURE;
        }
    }
  
    /* Save the trigger for the prescan slice. */
    prescan_trigger = rsptrigger[acq_ptr[pre_pass] + pre_slice];

    rsptrigger_temp[0] = TRIG_INTERN;
    
    /* Save copy of scan_info table */ 
    for(temp1=0; temp1<opslquant; temp1++) {
        orig_rsp_info[temp1].rsptloc = rsp_info[temp1].rsptloc;
        orig_rsp_info[temp1].rsprloc = rsp_info[temp1].rsprloc;
        orig_rsp_info[temp1].rspphasoff = rsp_info[temp1].rspphasoff;
        for (temp2=0; temp2<9; temp2++)
            origrot[temp1][temp2] = rsprot[temp1][temp2];
    }

    for (echoloop = 0; echoloop < tot_etl; echoloop++ ) {
        getssppulse(&(echotrainxtr[echoloop]), &(echotrain[echoloop]), "xtr", 0);
        getssppulse(&(echotrainrba[echoloop]), &(echotrain[echoloop]), "rba", 0);
    }

    hsdabmask = PSD_LOAD_HSDAB_ALL;
    diffdabmask = PSD_LOAD_DIFFDAB_ALL;
    dabmask = PSD_LOAD_DAB_ALL;
    scaleomega = 0;

    return SUCCESS;

} /* end pulsegen */


#include <stdlib.h>

STATUS
ChemSatPG( INT chemsat_start,
           INT *cssat_index )
{
    CHAR rhoFile[256], phaFile[256];
    SHORT *rhoPulse, *phaPulse;
    SHORT *tempPulse;
    SHORT temp_res;
    /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
    INT gxkcs_start, gykcs_start, gzkcs_start;


    if(csat_sys_type == 1) rfupa = csat_rfupa; /* vmx 3/13/95 YI */
  
    /* Check to see if pw scaled during predownload. If TRUE then set resolution to
    ** scaled resolution.
    */
    temp_res = res_rfcssat;
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON)
        res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
    /*  Create skeleton chemsat pulse. */
      
  {
    pulsename(&rfcssat,"rfcssat");
    createreserve(&rfcssat,(WF_PROCESSOR)wg_rfcssat,
		  res_rfcssat);
  }


    addrfbits(&rfcssat, off_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat);

    createinstr(&rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_rfcssat);

    /* Reset resolution to old resolution in case of external rf pulse */
    if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
        res_rfcssat = temp_res;
    }

    switch (ChemSatPulse) {
   
    case SINC_PULSE:
    default:
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
        }
        rhoPulse = (short *)AllocNode(res_rfcssat*sizeof(short));
        usinc(rhoPulse, res_rfcssat, (short)max_pg_wamp, cyc_rfcssat, alpha_rfcssat);
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    case DB_CS_PULSE:

        strcpy(rhoFile, "multiband_cs_rf.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        if(PSD_ON == DBgrad_flag)
        {
                  

  trapezoid((WF_PROCESSOR)wg_dbgxrfcssat, "dbgxrfcssat", &dbgxrfcssat, &dbgxrfcssata,
                        &dbgxrfcssatd, pw_dbgxrfcssat, pw_dbgxrfcssata, pw_dbgxrfcssatd,
                        ia_dbgxrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgxrfcssata, TRAP_ALL,
                        &loggrd);

                  

  trapezoid((WF_PROCESSOR)wg_dbgyrfcssat, "dbgyrfcssat", &dbgyrfcssat, &dbgyrfcssata,
                        &dbgyrfcssatd, pw_dbgyrfcssat, pw_dbgyrfcssata, pw_dbgyrfcssatd,
                        ia_dbgyrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgyrfcssata, TRAP_ALL,
                        &loggrd);

                  

  trapezoid((WF_PROCESSOR)wg_dbgzrfcssat, "dbgzrfcssat", &dbgzrfcssat, &dbgzrfcssata,
                        &dbgzrfcssatd, pw_dbgzrfcssat, pw_dbgzrfcssata, pw_dbgzrfcssatd,
                        ia_dbgzrfcssat, 0, 0, 0, 0, chemsat_start-pw_dbgzrfcssata, TRAP_ALL,
                        &loggrd);

        } 
        break;


    case CSM_PULSE:

        strcpy(rhoFile, "rfcsm.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
	        
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMIN8_PULSE:

        strcpy(rhoFile, "rfcsmin8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;
      
    case CSMAX8_PULSE:

        strcpy(rhoFile, "rfcsmax8.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);

        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else { 
            rhoPulse = tempPulse;
        }

        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        break;

    case CS3T_PULSE:				/*YH*/

        strcpy(rhoFile, "rfcs3t.rho");
        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);
        break;

    case CS_HS:	
    case CS_HS_20MS:
    case CS_HSLS:
        if (ChemSatPulse == CS_HS_20MS)
        {
            strcpy(rhoFile, "hs.rho");
            strcpy(phaFile, "hs.pha");
        }
        else if (ChemSatPulse == CS_HS)
        {
            strcpy(rhoFile, "hs_40ms.rho");
            strcpy(phaFile, "hs_40ms.pha");
        }
        else if (CS_HSLS == ChemSatPulse)
        {
            strcpy(rhoFile, "hs40ls.rho" );
            strcpy(phaFile, "hs40ls.pha");
        }

        tempPulse =(short *)AllocNode(res_rfcssat*sizeof(short));
        uextwave(tempPulse, res_rfcssat, rhoFile);
        if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
            rhoPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcssat,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,rhoPulse);
            res_rfcssat = rfpulseInfo[RFCSSAT_SLOT].newres;
            FreeNode(tempPulse);
        } else {
            rhoPulse = tempPulse;
        }
        movewaveimm(rhoPulse, &rfcssat, 0, res_rfcssat, TOHARDWARE);
        FreeNode(rhoPulse);

        /* THETA pulse */
        {
              
  {
    pulsename(&omega_hs_rfcssat,"omega_hs_rfcssat");
    createreserve(&omega_hs_rfcssat,(WF_PROCESSOR)wg_omega_hs_rfcssat,
		  res_omega_hs_rfcssat);
  }


            addrfbits(&omega_hs_rfcssat, 0, chemsat_start+psd_rf_wait, pw_rfcssat);

            createinstr(&omega_hs_rfcssat, chemsat_start+psd_rf_wait, pw_rfcssat, ia_omega_hs_rfcssat);

            tempPulse =(short *)AllocNode(temp_res*sizeof(short));
            uextwave(tempPulse, temp_res, phaFile);
            if (rfpulseInfo[RFCSSAT_SLOT].change==PSD_ON) {
                phaPulse = (short *)AllocNode(rfpulseInfo[RFCSSAT_SLOT].newres*sizeof(short));
                stretchpulse((int)temp_res,(int)rfpulseInfo[RFCSSAT_SLOT].newres,tempPulse,phaPulse);
                FreeNode(tempPulse);
            } else {
                phaPulse = tempPulse;
            }
            movewaveimm(phaPulse, &omega_hs_rfcssat, 0, res_rfcssat, TOHARDWARE);
            FreeNode(phaPulse);
        }
        break;
    }
   
    if (selectiveChemsat) 
    { 
             

  trapezoid((WF_PROCESSOR)wg_gzrfcs, "gzrfcs", &gzrfcs, &gzrfcsa,
                        &gzrfcsd, pw_gzrfcs, pw_gzrfcsa, pw_gzrfcsd,
                        ia_gzrfcs, 0, 0, 0, 0, chemsat_start-pw_gzrfcsa, TRAP_ALL,
                        &loggrd);
	
    }

    /* SVBranch HCSDM00260981: Implement Multi_band Fat Sat */
    /* Initialize X, Y, Z axis crusher start position */
    gykcs_start = 0;
    gxkcs_start = 0;
    gzkcs_start = 0;

    /*  Y board crusher for Chem Sat pulse  */
    /* MRIge62364 : karun Rounded up the postion for the pulses */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gykcs_start = RUP_GRD(pendall(&dbgyrfcssat,*cssat_index)  +  pw_gykcsa);
    }
    else
    {
        gykcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) +  pw_gykcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gykcs, "gykcs", &gykcs, &gykcsa,
                        &gykcsd, pw_gykcs, pw_gykcsa, pw_gykcsd,
                        ia_gykcs, 0, 0, 0, 0, gykcs_start-pw_gykcsa, TRAP_ALL,
                        &loggrd);


#ifdef CSXKILLER
    /*  X board crusher for Chem Sat pulse  */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gxkcs_start = RUP_GRD(pendall(&dbgxrfcssat,*cssat_index) + pw_gxkcs);
    }
    else
    {
        gxkcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) +  pw_gxkcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gxkcs, "gxkcs", &gxkcs, &gxkcsa,
                        &gxkcsd, pw_gxkcs, pw_gxkcsa, pw_gxkcsd,
                        ia_gxkcs, 0, 0, 0, 0, gxkcs_start-pw_gxkcsa, TRAP_ALL,
                        &loggrd);

#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
    if(duo_cs_flag)
    {
#endif   
    /*  Z board crusher for Chem Sat pulse  */
    /* SVBranch HCSDM00260891 Multi-Band Fat Sat*/
    if(PSD_ON == DBgrad_flag)
    {
        gzkcs_start = RUP_GRD(pendall(&dbgzrfcssat,*cssat_index) + pw_gzkcsa);
    }
    else
    {
        gzkcs_start = RUP_GRD(pendall(&rfcssat,*cssat_index) + pw_gzrfcsd + pw_gzkcsa - psd_rf_wait);
    }
          

  trapezoid((WF_PROCESSOR)wg_gzkcs, "gzkcs", &gzkcs, &gzkcsa,
                        &gzkcsd, pw_gzkcs, pw_gzkcsa, pw_gzkcsd,
                        ia_gzkcs, 0, 0, 0, 0, gzkcs_start-pw_gzkcsa, TRAP_ALL,
                        &loggrd);

#ifdef DCS_ZKILLER_ENH
    }
#endif
#endif

    if(psd_chemsat_seq_flag)
    {
        if ((*cssat_index == 0) || cs_dda_per_trig_flag)
        {
              
  {
    pulsename(&seqcssat,"seqcssat");
    createseq(&seqcssat,RUP_GRD(cs_sattime/n_cspulses+cs_satstart), off_seqcssat);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcssat );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcssat = %d\n", idx_seqcssat );
#endif
  }

            /* Assert the ESSP flag on the sync packet byte seq length */
            attenflagon(&seqcssat, 0);
        }
    }
	
    /* Initialize for RSP */
    cstun = 0;
    amp_gykcs = ia_gykcs;
#ifdef CSXKILLER
    amp_gxkcs = ia_gxkcs;
#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
    if(duo_cs_flag)
    {
        amp_gzkcs = ia_gzkcs;
    }
#else
    amp_gzkcs = ia_gzkcs;
#endif
#endif
    csa = a_rfcssat * 1000;
    csf = off_rfcssat;
    *cssat_index += 1;

    /* Set the maximum of the csa corresponds to 360 degree */      
    max_csa = csa * CS_MAXFLIP/ flip_sat;  
	
    return SUCCESS;
} 
    
    
#include <float.h>
STATUS
SpSatPG( INT sat_type,
         INT start_time,
         INT *sat_index,
         INT cardiacsat_pos )
{
    SHORT *kernel_tab_rho = NULL; 
    SHORT *hadamard_tab_rho = NULL;
    SHORT *temp_wave_rho = NULL;
    SHORT *wave_space_rho = NULL;
    SHORT *kernel_tab_theta = NULL;
    SHORT *hadamard_tab_theta = NULL;
    SHORT *temp_wave_theta = NULL;
    EXTERN_FILENAME rho_file;
    EXTERN_FILENAME theta_file;  

    INT    skip_next_sat;
    long    ctrl_word;

    INT    sp_sattemp;
    FLOAT  separation; /* slice separation of hadamards in slice thickness */
    INT    sp_pos_killer;
    FLOAT  freqstep;
    INT  temp_sat_index;
  
    int rot_update_time;

    int ending;

    if(spsat_sys_type == 1) rfupa = spsat_rfupa; /* vmx 3/13/95 YI */

    sp_first_scan = 1;  /* First scan since download. This flag is used
                           to determine when rotation matrices need to
                           be copied over. This needs to be set even if
                           sat is off. */

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return(SUCCESS);

    /* Change resolutions since SpSatPG can be called multiple times. i.e. sat1, sat2, sat3 
       conditions*/
    switch (sat_type)
    {
    case SINC_SAT:
	{
            res_rfse1 = RES_NVRGSAT;
            res_rfse2 = RES_NVRGSAT;
            res_rfse3 = RES_NVRGSAT;
            res_rfse4 = RES_NVRGSAT;
            res_rfse5 = RES_NVRGSAT;
            res_rfse6 = RES_NVRGSAT;
            res_rfsx1 = RES_NVRGSAT;
            res_rfsx2 = RES_NVRGSAT;
            res_rfsy1 = RES_NVRGSAT;
            res_rfsy2 = RES_NVRGSAT;
            res_rfsz1 = RES_NVRGSAT;
            res_rfsz2 = RES_NVRGSAT;
	    /* YMSmr09579 04-Oct-2006 HK */
            if (pw_rfse1==4800 ) res_rfse1 = RES_SLRSAT;
            if (pw_rfse2==4800 ) res_rfse2 = RES_SLRSAT;
            if (pw_rfse3==4800 ) res_rfse3 = RES_SLRSAT;
            if (pw_rfse4==4800 ) res_rfse4 = RES_SLRSAT;
            if (pw_rfse5==4800 ) res_rfse5 = RES_SLRSAT;
            if (pw_rfse6==4800 ) res_rfse6 = RES_SLRSAT;
            if (pw_rfsx1==4800 ) res_rfsx1 = RES_SLRSAT;
            if (pw_rfsx2==4800 ) res_rfsx2 = RES_SLRSAT;
            if (pw_rfsy1==4800 ) res_rfsy1 = RES_SLRSAT;
            if (pw_rfsy2==4800 ) res_rfsy2 = RES_SLRSAT;
            if (pw_rfsz1==4800 ) res_rfsz1 = RES_SLRSAT;
            if (pw_rfsz2==4800 ) res_rfsz2 = RES_SLRSAT;
            break;
	}
    case SLR_SAT:
	{
            res_rfse1 = RES_SLRSAT;
            res_rfse2 = RES_SLRSAT;
            res_rfse3 = RES_SLRSAT;
            res_rfse4 = RES_SLRSAT;
            res_rfse5 = RES_SLRSAT;
            res_rfse6 = RES_SLRSAT;
            res_rfsx1 = RES_SLRSAT;
            res_rfsx2 = RES_SLRSAT;
            res_rfsy1 = RES_SLRSAT;
            res_rfsy2 = RES_SLRSAT;
            res_rfsz1 = RES_SLRSAT;
            res_rfsz2 = RES_SLRSAT;
            break;
	}
    case SLR_CSAT:
        {
            res_rfse1 = RES_SLRCSAT;
            res_rfse2 = RES_SLRCSAT;
            res_rfse3 = RES_SLRCSAT;
            res_rfse4 = RES_SLRCSAT;
            res_rfse5 = RES_SLRCSAT;
            res_rfse6 = RES_SLRCSAT;
            res_rfsx1 = RES_SLRCSAT;
            res_rfsx2 = RES_SLRCSAT;
            res_rfsy1 = RES_SLRCSAT;
            res_rfsy2 = RES_SLRCSAT;
            res_rfsz1 = RES_SLRCSAT;
            res_rfsz2 = RES_SLRCSAT;
            break;
        }
    default:
	break;
    }

    sp_sattemp = start_time;

    /* In cardiac scan, there may not be enough time at the beginning
       of the scan for the sat pulses. In this case, the sats are moved
       to the end of the sequence. (i.e. cardiacsat_pos != 0 ) For this
       case an isi interrupt is added before the sats the prepare the
       first rotation matrix.

       If the sats are played at the beginning of a sequence, the first
       rotation matrix is loaded by the psd. 

       Note that the sat index is 0. Since only one sat sequence will
       use this extra SSP packet, the index is 0 not sat_index. */

    /* ************************************************************ *
     * MRIge50713 - change the index to sat_index instead of using  *
     * index 0 always.                                              *
     *                                                              *
     * This is necessary because in the new FSE phase correction,   *
     * two copies of SpSat instructions are generated. The first    *
     * is for fse pulse sequence (seqcore), the 2nd copy is for fse *
     * phase correction pulse sequence (seqfseps). If the index     *
     * remains always 0, the seqfseps will overwrite the seqcore.   *
     * ************************************************************ */
 
    if (cardiacsat_pos != 0)
    {

    	/*
          MRIge51141 - Use sat_index only for FAST sequences.
	*/

        if ( opfast==PSD_ON )	{
            temp_sat_index = *sat_index ;
	} else 	{
            temp_sat_index = 0;
	}

           
  {
    pulsename(&isi_cardiacsat,"isi_cardiacsat");
    createconst(&isi_cardiacsat,(WF_PROCESSOR)wg_isi_cardiacsat,pw_isi_cardiacsat,(short)0); 
    createinstr( &isi_cardiacsat,(long)(sp_sattemp),pw_isi_cardiacsat,0);
  }

        getctrl(&ctrl_word, &isi_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_isisat;

           
  {
    pulsename(&rot_update_cardiacsat,"rot_update_cardiacsat");
    createconst(&rot_update_cardiacsat,(WF_PROCESSOR)wg_rot_update_cardiacsat,pw_rot_update_cardiacsat,(short)0); 
    createinstr( &rot_update_cardiacsat,(long)(sp_sattemp),pw_rot_update_cardiacsat,0);
  }

        getctrl(&ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_cardiacsat, temp_sat_index);
        sp_sattemp =  sp_sattemp + pw_rotupdate;

    }
 
    /****************************************************************

            EXPLICIT SAT GRADIENTS

       1. Slice selection gradient
       2. Killer on y gradient
       3. If there are 2 sat bands that are parallel but do not have
          the same thickness, create a separate slice select & killer
          for the second band.
    ******************************************************************/

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse1", 
                                     (WF_PROCESSOR)wg_rfse1);

    /* Modify resolution if scaling required */
    temp_res_rfse1 = res_rfse1;
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse1a,"gzrfse1a");
    pulsename(&gzrfse1,"gzrfse1");
    pulsename(&gzrfse1d,"gzrfse1d");
    pulsename(&rfse1,"rfse1");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse1a,ZGRAD,pw_gzrfse1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse1a,(LONG)(sp_sattemp+pw_gzrfse1a-pw_gzrfse1a),
                pw_gzrfse1a,ia_gzrfse1);
    createconst(&gzrfse1,ZGRAD,pw_gzrfse1,MAX_PG_WAMP);
    createinstr( &gzrfse1,(LONG)(sp_sattemp+pw_gzrfse1a),
                pw_gzrfse1,ia_gzrfse1);
    createramp(&gzrfse1d,ZGRAD,pw_gzrfse1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse1d,(LONG)(sp_sattemp+pw_gzrfse1a+pw_gzrfse1),
                pw_gzrfse1d,ia_gzrfse1);

    /* Now create the rf pulse */
    createsinc(&rfse1,(WF_PROCESSOR)wg_rfse1,res_rfse1,
               MAX_PG_WAMP,cyc_rfse1, alpha_rfse1);

    createinstr( &rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
                pw_rfse1,ia_rfse1);
    linkpulses(4,&rfse1,&gzrfse1,&gzrfse1a,
               &gzrfse1d);
    addrfbits(&rfse1,off_rfse1,(LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait,
              pw_rfse1);



    pulsename(&rfse1Theta, "rfse1Theta");
    createreserve(&rfse1Theta, THETA, res_rfse1);
    addrfbits(&rfse1Theta, off_rfse1, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait , pw_rfse1);
    createinstr(&rfse1Theta, (LONG)(sp_sattemp+pw_gzrfse1a) + psd_rf_wait, pw_rfse1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
       res_rfse1 = temp_res_rfse1;
  }


        sp_sattemp = pend(&gzrfse1d, "gzrfse1d", *sat_index);

        ending = pendallssp(&rfse1, *sat_index);
 
           
  {
    pulsename(&isi_sate1,"isi_sate1");
    createconst(&isi_sate1,(WF_PROCESSOR)wg_isi_sate1,pw_isi_sate1,(short)0); 
    createinstr( &isi_sate1,(long)(ending),pw_isi_sate1,0);
  }

        getctrl(&ctrl_word, &isi_sate1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_sate1, *sat_index);

        rot_update_time = RUP_GRD(IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
           
  {
    pulsename(&rot_update_e1,"rot_update_e1");
    createconst(&rot_update_e1,(WF_PROCESSOR)wg_rot_update_e1,pw_rot_update_e1,(short)0); 
    createinstr( &rot_update_e1,(long)(rot_update_time),pw_rot_update_e1,0);
  }

        getctrl(&ctrl_word, &rot_update_e1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e1, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse1a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse1, "gykse1", &gykse1, &gykse1a,
                        &gykse1d, pw_gykse1, pw_gykse1a, pw_gykse1d,
                        ia_gykse1, 0, 0, 0, 0, sp_pos_killer-pw_gykse1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse1d, "gykse1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse1, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse1, "gxkse1", &gxkse1, &gxkse1a,
                        &gxkse1d, pw_gxkse1, pw_gxkse1a, pw_gxkse1d,
                        ia_gxkse1, 0, 0, 0, 0, sp_pos_killer-pw_gxkse1a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse1d, "gxkse1d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse1d, "gxkse1d", *sat_index);
        }
	  
             
  {
    pulsename(&isi_satek1,"isi_satek1");
    createconst(&isi_satek1,(WF_PROCESSOR)wg_isi_satek1,pw_isi_satek1,(short)0); 
    createinstr( &isi_satek1,(long)(sp_sattemp-isi_satdelay),pw_isi_satek1,0);
  }

        getctrl(&ctrl_word, &isi_satek1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT ;
        setctrl(ctrl_word, &isi_satek1, *sat_index);
	  
               
  {
    pulsename(&rot_update_ek1,"rot_update_ek1");
    createconst(&rot_update_ek1,(WF_PROCESSOR)wg_rot_update_ek1,pw_rot_update_ek1,(short)0); 
    createinstr( &rot_update_ek1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek1,0);
  }

        getctrl(&ctrl_word, &rot_update_ek1, *sat_index);
        ctrl_word = ctrl_word |PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek1, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse2", 
                                     (WF_PROCESSOR)wg_rfse2);

    /* Modify resolution if scaling required */
    temp_res_rfse2 = res_rfse2;
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2 = rfpulseInfo[RFSE2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse2a,"gzrfse2a");
    pulsename(&gzrfse2,"gzrfse2");
    pulsename(&gzrfse2d,"gzrfse2d");
    pulsename(&rfse2,"rfse2");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse2a,ZGRAD,pw_gzrfse2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse2a,(LONG)(sp_sattemp+pw_gzrfse2a-pw_gzrfse2a),
                pw_gzrfse2a,ia_gzrfse2);
    createconst(&gzrfse2,ZGRAD,pw_gzrfse2,MAX_PG_WAMP);
    createinstr( &gzrfse2,(LONG)(sp_sattemp+pw_gzrfse2a),
                pw_gzrfse2,ia_gzrfse2);
    createramp(&gzrfse2d,ZGRAD,pw_gzrfse2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse2d,(LONG)(sp_sattemp+pw_gzrfse2a+pw_gzrfse2),
                pw_gzrfse2d,ia_gzrfse2);

    /* Now create the rf pulse */
    createsinc(&rfse2,(WF_PROCESSOR)wg_rfse2,res_rfse2,
               MAX_PG_WAMP,cyc_rfse2, alpha_rfse2);

    createinstr( &rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
                pw_rfse2,ia_rfse2);
    linkpulses(4,&rfse2,&gzrfse2,&gzrfse2a,
               &gzrfse2d);
    addrfbits(&rfse2,off_rfse2,(LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait,
              pw_rfse2);



    pulsename(&rfse2Theta, "rfse2Theta");
    createreserve(&rfse2Theta, THETA, res_rfse2);
    addrfbits(&rfse2Theta, off_rfse2, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait , pw_rfse2);
    createinstr(&rfse2Theta, (LONG)(sp_sattemp+pw_gzrfse2a) + psd_rf_wait, pw_rfse2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
       res_rfse2 = temp_res_rfse2;
  }

        sp_sattemp = pend(&gzrfse2d, "gzrfse2d" , *sat_index);

        ending = pendallssp(&rfse2, *sat_index);

           
  {
    pulsename(&isi_sate2,"isi_sate2");
    createconst(&isi_sate2,(WF_PROCESSOR)wg_isi_sate2,pw_isi_sate2,(short)0); 
    createinstr( &isi_sate2,(long)(ending),pw_isi_sate2,0);
  }

        getctrl(&ctrl_word, &isi_sate2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate2, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e2,"rot_update_e2");
    createconst(&rot_update_e2,(WF_PROCESSOR)wg_rot_update_e2,pw_rot_update_e2,(short)0); 
    createinstr( &rot_update_e2,(long)(rot_update_time),pw_rot_update_e2,0);
  }

        getctrl(&ctrl_word, &rot_update_e2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e2, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse2a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse2, "gykse2", &gykse2, &gykse2a,
                        &gykse2d, pw_gykse2, pw_gykse2a, pw_gykse2d,
                        ia_gykse2, 0, 0, 0, 0, sp_pos_killer-pw_gykse2a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse2d, "gykse2d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse2, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse2, "gxkse2", &gxkse2, &gxkse2a,
                        &gxkse2d, pw_gxkse2, pw_gxkse2a, pw_gxkse2d,
                        ia_gxkse2, 0, 0, 0, 0, sp_pos_killer-pw_gxkse2a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse2d, "gxkse2d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse2d, "gxkse2d", *sat_index);
        }

             
  {
    pulsename(&isi_satek2,"isi_satek2");
    createconst(&isi_satek2,(WF_PROCESSOR)wg_isi_satek2,pw_isi_satek2,(short)0); 
    createinstr( &isi_satek2,(long)(sp_sattemp-isi_satdelay),pw_isi_satek2,0);
  }

        getctrl(&ctrl_word, &isi_satek2, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek2, *sat_index);

               
  {
    pulsename(&rot_update_ek2,"rot_update_ek2");
    createconst(&rot_update_ek2,(WF_PROCESSOR)wg_rot_update_ek2,pw_rot_update_ek2,(short)0); 
    createinstr( &rot_update_ek2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek2,0);
  }

        getctrl(&ctrl_word, &rot_update_ek2, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_ek2, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse3", 
                                     (WF_PROCESSOR)wg_rfse3);

    /* Modify resolution if scaling required */
    temp_res_rfse3 = res_rfse3;
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse3a,"gzrfse3a");
    pulsename(&gzrfse3,"gzrfse3");
    pulsename(&gzrfse3d,"gzrfse3d");
    pulsename(&rfse3,"rfse3");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse3a,ZGRAD,pw_gzrfse3a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse3a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse3a,(LONG)(sp_sattemp+pw_gzrfse3a-pw_gzrfse3a),
                pw_gzrfse3a,ia_gzrfse3);
    createconst(&gzrfse3,ZGRAD,pw_gzrfse3,MAX_PG_WAMP);
    createinstr( &gzrfse3,(LONG)(sp_sattemp+pw_gzrfse3a),
                pw_gzrfse3,ia_gzrfse3);
    createramp(&gzrfse3d,ZGRAD,pw_gzrfse3d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse3d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse3d,(LONG)(sp_sattemp+pw_gzrfse3a+pw_gzrfse3),
                pw_gzrfse3d,ia_gzrfse3);

    /* Now create the rf pulse */
    createsinc(&rfse3,(WF_PROCESSOR)wg_rfse3,res_rfse3,
               MAX_PG_WAMP,cyc_rfse3, alpha_rfse3);

    createinstr( &rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
                pw_rfse3,ia_rfse3);
    linkpulses(4,&rfse3,&gzrfse3,&gzrfse3a,
               &gzrfse3d);
    addrfbits(&rfse3,off_rfse3,(LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait,
              pw_rfse3);



    pulsename(&rfse3Theta, "rfse3Theta");
    createreserve(&rfse3Theta, THETA, res_rfse3);
    addrfbits(&rfse3Theta, off_rfse3, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait , pw_rfse3);
    createinstr(&rfse3Theta, (LONG)(sp_sattemp+pw_gzrfse3a) + psd_rf_wait, pw_rfse3, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
       res_rfse3 = temp_res_rfse3;
  }


        sp_sattemp = pend(&gzrfse3d, "gzrfse3d" , *sat_index);

        ending = pendallssp(&rfse3, *sat_index);

           
  {
    pulsename(&isi_sate3,"isi_sate3");
    createconst(&isi_sate3,(WF_PROCESSOR)wg_isi_sate3,pw_isi_sate3,(short)0); 
    createinstr( &isi_sate3,(long)(ending),pw_isi_sate3,0);
  }

        getctrl(&ctrl_word, &isi_sate3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate3, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e3,"rot_update_e3");
    createconst(&rot_update_e3,(WF_PROCESSOR)wg_rot_update_e3,pw_rot_update_e3,(short)0); 
    createinstr( &rot_update_e3,(long)(rot_update_time),pw_rot_update_e3,0);
  }

        getctrl(&ctrl_word, &rot_update_e3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e3, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse3a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse3, "gykse3", &gykse3, &gykse3a,
                        &gykse3d, pw_gykse3, pw_gykse3a, pw_gykse3d,
                        ia_gykse3, 0, 0, 0, 0, sp_pos_killer-pw_gykse3a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse3d, "gykse3d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse3, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse3, "gxkse3", &gxkse3, &gxkse3a,
                        &gxkse3d, pw_gxkse3, pw_gxkse3a, pw_gxkse3d,
                        ia_gxkse3, 0, 0, 0, 0, sp_pos_killer-pw_gxkse3a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse3d, "gxkse3d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse3d, "gxkse3d", *sat_index);
        }

              
  {
    pulsename(&isi_satek3,"isi_satek3");
    createconst(&isi_satek3,(WF_PROCESSOR)wg_isi_satek3,pw_isi_satek3,(short)0); 
    createinstr( &isi_satek3,(long)(sp_sattemp-isi_satdelay),pw_isi_satek3,0);
  }

        getctrl(&ctrl_word, &isi_satek3, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek3, *sat_index);

                
  {
    pulsename(&rot_update_ek3,"rot_update_ek3");
    createconst(&rot_update_ek3,(WF_PROCESSOR)wg_rot_update_ek3,pw_rot_update_ek3,(short)0); 
    createinstr( &rot_update_ek3,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek3,0);
  }

        getctrl(&ctrl_word, &rot_update_ek3, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek3, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;

        if ((opexsatparal &  PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse4", 
                                     (WF_PROCESSOR)wg_rfse4);

    /* Modify resolution if scaling required */
    temp_res_rfse4 = res_rfse4;
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4 = rfpulseInfo[RFSE4_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse4a,"gzrfse4a");
    pulsename(&gzrfse4,"gzrfse4");
    pulsename(&gzrfse4d,"gzrfse4d");
    pulsename(&rfse4,"rfse4");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse4a,ZGRAD,pw_gzrfse4a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse4a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse4a,(LONG)(sp_sattemp+pw_gzrfse4a-pw_gzrfse4a),
                pw_gzrfse4a,ia_gzrfse4);
    createconst(&gzrfse4,ZGRAD,pw_gzrfse4,MAX_PG_WAMP);
    createinstr( &gzrfse4,(LONG)(sp_sattemp+pw_gzrfse4a),
                pw_gzrfse4,ia_gzrfse4);
    createramp(&gzrfse4d,ZGRAD,pw_gzrfse4d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse4d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse4d,(LONG)(sp_sattemp+pw_gzrfse4a+pw_gzrfse4),
                pw_gzrfse4d,ia_gzrfse4);

    /* Now create the rf pulse */
    createsinc(&rfse4,(WF_PROCESSOR)wg_rfse4,res_rfse4,
               MAX_PG_WAMP,cyc_rfse4, alpha_rfse4);

    createinstr( &rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
                pw_rfse4,ia_rfse4);
    linkpulses(4,&rfse4,&gzrfse4,&gzrfse4a,
               &gzrfse4d);
    addrfbits(&rfse4,off_rfse4,(LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait,
              pw_rfse4);



    pulsename(&rfse4Theta, "rfse4Theta");
    createreserve(&rfse4Theta, THETA, res_rfse4);
    addrfbits(&rfse4Theta, off_rfse4, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait , pw_rfse4);
    createinstr(&rfse4Theta, (LONG)(sp_sattemp+pw_gzrfse4a) + psd_rf_wait, pw_rfse4, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
       res_rfse4 = temp_res_rfse4;
  }


        sp_sattemp = pend(&gzrfse4d, "gzrfse4d" , *sat_index);

        ending = pendallssp(&rfse4, *sat_index);
           
  {
    pulsename(&isi_sate4,"isi_sate4");
    createconst(&isi_sate4,(WF_PROCESSOR)wg_isi_sate4,pw_isi_sate4,(short)0); 
    createinstr( &isi_sate4,(long)(ending),pw_isi_sate4,0);
  }

        getctrl(&ctrl_word, &isi_sate4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate4, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e4,"rot_update_e4");
    createconst(&rot_update_e4,(WF_PROCESSOR)wg_rot_update_e4,pw_rot_update_e4,(short)0); 
    createinstr( &rot_update_e4,(long)(rot_update_time),pw_rot_update_e4,0);
  }

        getctrl(&ctrl_word, &rot_update_e4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e4, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse4a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse4, "gykse4", &gykse4, &gykse4a,
                        &gykse4d, pw_gykse4, pw_gykse4a, pw_gykse4d,
                        ia_gykse4, 0, 0, 0, 0, sp_pos_killer-pw_gykse4a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse4d, "gykse4d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse4, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse4, "gxkse4", &gxkse4, &gxkse4a,
                        &gxkse4d, pw_gxkse4, pw_gxkse4a, pw_gxkse4d,
                        ia_gxkse4, 0, 0, 0, 0, sp_pos_killer-pw_gxkse4a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse4d, "gxkse4d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse4d, "gxkse4d", *sat_index);
        }

              
  {
    pulsename(&isi_satek4,"isi_satek4");
    createconst(&isi_satek4,(WF_PROCESSOR)wg_isi_satek4,pw_isi_satek4,(short)0); 
    createinstr( &isi_satek4,(long)(sp_sattemp-isi_satdelay),pw_isi_satek4,0);
  }

        getctrl(&ctrl_word, &isi_satek4, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek4, *sat_index);

                
  {
    pulsename(&rot_update_ek4,"rot_update_ek4");
    createconst(&rot_update_ek4,(WF_PROCESSOR)wg_rot_update_ek4,pw_rot_update_ek4,(short)0); 
    createinstr( &rot_update_ek4,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek4,0);
  }

        getctrl(&ctrl_word, &rot_update_ek4, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek4, *sat_index);

        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat + pw_rotupdate + isi_extra;
    } 

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse5", 
                                     (WF_PROCESSOR)wg_rfse5);

    /* Modify resolution if scaling required */
    temp_res_rfse5 = res_rfse5;
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse5a,"gzrfse5a");
    pulsename(&gzrfse5,"gzrfse5");
    pulsename(&gzrfse5d,"gzrfse5d");
    pulsename(&rfse5,"rfse5");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse5a,ZGRAD,pw_gzrfse5a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse5a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse5a,(LONG)(sp_sattemp+pw_gzrfse5a-pw_gzrfse5a),
                pw_gzrfse5a,ia_gzrfse5);
    createconst(&gzrfse5,ZGRAD,pw_gzrfse5,MAX_PG_WAMP);
    createinstr( &gzrfse5,(LONG)(sp_sattemp+pw_gzrfse5a),
                pw_gzrfse5,ia_gzrfse5);
    createramp(&gzrfse5d,ZGRAD,pw_gzrfse5d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse5d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse5d,(LONG)(sp_sattemp+pw_gzrfse5a+pw_gzrfse5),
                pw_gzrfse5d,ia_gzrfse5);

    /* Now create the rf pulse */
    createsinc(&rfse5,(WF_PROCESSOR)wg_rfse5,res_rfse5,
               MAX_PG_WAMP,cyc_rfse5, alpha_rfse5);

    createinstr( &rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
                pw_rfse5,ia_rfse5);
    linkpulses(4,&rfse5,&gzrfse5,&gzrfse5a,
               &gzrfse5d);
    addrfbits(&rfse5,off_rfse5,(LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait,
              pw_rfse5);



    pulsename(&rfse5Theta, "rfse5Theta");
    createreserve(&rfse5Theta, THETA, res_rfse5);
    addrfbits(&rfse5Theta, off_rfse5, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait , pw_rfse5);
    createinstr(&rfse5Theta, (LONG)(sp_sattemp+pw_gzrfse5a) + psd_rf_wait, pw_rfse5, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
       res_rfse5 = temp_res_rfse5;
  }


        sp_sattemp = pend(&gzrfse5d, "gzrfse5d" , *sat_index);

        ending = pendallssp(&rfse5, *sat_index);
           
  {
    pulsename(&isi_sate5,"isi_sate5");
    createconst(&isi_sate5,(WF_PROCESSOR)wg_isi_sate5,pw_isi_sate5,(short)0); 
    createinstr( &isi_sate5,(long)(ending),pw_isi_sate5,0);
  }

        getctrl(&ctrl_word, &isi_sate5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate5, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e5,"rot_update_e5");
    createconst(&rot_update_e5,(WF_PROCESSOR)wg_rot_update_e5,pw_rot_update_e5,(short)0); 
    createinstr( &rot_update_e5,(long)(rot_update_time),pw_rot_update_e5,0);
  }

        getctrl(&ctrl_word, &rot_update_e5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT;
        setctrl(ctrl_word, &rot_update_e5, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse5a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse5, "gykse5", &gykse5, &gykse5a,
                        &gykse5d, pw_gykse5, pw_gykse5a, pw_gykse5d,
                        ia_gykse5, 0, 0, 0, 0, sp_pos_killer-pw_gykse5a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse5d, "gykse5d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse5, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse5, "gxkse5", &gxkse5, &gxkse5a,
                        &gxkse5d, pw_gxkse5, pw_gxkse5a, pw_gxkse5d,
                        ia_gxkse5, 0, 0, 0, 0, sp_pos_killer-pw_gxkse5a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse5d, "gxkse5d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse5d, "gxkse5d", *sat_index);
        }

              
  {
    pulsename(&isi_satek5,"isi_satek5");
    createconst(&isi_satek5,(WF_PROCESSOR)wg_isi_satek5,pw_isi_satek5,(short)0); 
    createinstr( &isi_satek5,(long)(sp_sattemp-isi_satdelay),pw_isi_satek5,0);
  }

        getctrl(&ctrl_word, &isi_satek5, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek5, *sat_index);

                
  {
    pulsename(&rot_update_ek5,"rot_update_ek5");
    createconst(&rot_update_ek5,(WF_PROCESSOR)wg_rot_update_ek5,pw_rot_update_ek5,(short)0); 
    createinstr( &rot_update_ek5,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek5,0);
  }

        getctrl(&ctrl_word, &rot_update_ek5, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek5, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;

        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }

    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
            
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfse6", 
                                     (WF_PROCESSOR)wg_rfse6);

    /* Modify resolution if scaling required */
    temp_res_rfse6 = res_rfse6;
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6 = rfpulseInfo[RFSE6_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfse6a,"gzrfse6a");
    pulsename(&gzrfse6,"gzrfse6");
    pulsename(&gzrfse6d,"gzrfse6d");
    pulsename(&rfse6,"rfse6");

    /*  Now create the slice select trapezoid */
        pg_beta = satloggrd.zbeta;
    createramp(&gzrfse6a,ZGRAD,pw_gzrfse6a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfse6a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfse6a,(LONG)(sp_sattemp+pw_gzrfse6a-pw_gzrfse6a),
                pw_gzrfse6a,ia_gzrfse6);
    createconst(&gzrfse6,ZGRAD,pw_gzrfse6,MAX_PG_WAMP);
    createinstr( &gzrfse6,(LONG)(sp_sattemp+pw_gzrfse6a),
                pw_gzrfse6,ia_gzrfse6);
    createramp(&gzrfse6d,ZGRAD,pw_gzrfse6d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfse6d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfse6d,(LONG)(sp_sattemp+pw_gzrfse6a+pw_gzrfse6),
                pw_gzrfse6d,ia_gzrfse6);

    /* Now create the rf pulse */
    createsinc(&rfse6,(WF_PROCESSOR)wg_rfse6,res_rfse6,
               MAX_PG_WAMP,cyc_rfse6, alpha_rfse6);

    createinstr( &rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
                pw_rfse6,ia_rfse6);
    linkpulses(4,&rfse6,&gzrfse6,&gzrfse6a,
               &gzrfse6d);
    addrfbits(&rfse6,off_rfse6,(LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait,
              pw_rfse6);



    pulsename(&rfse6Theta, "rfse6Theta");
    createreserve(&rfse6Theta, THETA, res_rfse6);
    addrfbits(&rfse6Theta, off_rfse6, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait , pw_rfse6);
    createinstr(&rfse6Theta, (LONG)(sp_sattemp+pw_gzrfse6a) + psd_rf_wait, pw_rfse6, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
       res_rfse6 = temp_res_rfse6;
  }


        sp_sattemp = pend(&gzrfse6d, "gzrfse6d" , *sat_index);

        ending = pendallssp(&rfse6, *sat_index);
           
  {
    pulsename(&isi_sate6,"isi_sate6");
    createconst(&isi_sate6,(WF_PROCESSOR)wg_isi_sate6,pw_isi_sate6,(short)0); 
    createinstr( &isi_sate6,(long)(ending),pw_isi_sate6,0);
  }

        getctrl(&ctrl_word, &isi_sate6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_sate6, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_e6,"rot_update_e6");
    createconst(&rot_update_e6,(WF_PROCESSOR)wg_rot_update_e6,pw_rot_update_e6,(short)0); 
    createinstr( &rot_update_e6,(long)(rot_update_time),pw_rot_update_e6,0);
  }

        getctrl(&ctrl_word, &rot_update_e6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_e6, *sat_index);
        sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = sp_sattemp + pw_gykse6a + isi_extra;
            

  trapezoid((WF_PROCESSOR)wg_gykse6, "gykse6", &gykse6, &gykse6a,
                        &gykse6d, pw_gykse6, pw_gykse6a, pw_gykse6d,
                        ia_gykse6, 0, 0, 0, 0, sp_pos_killer-pw_gykse6a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gykse6d, "gykse6d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxkse6, 0.0, 2))
        {
                

  trapezoid((WF_PROCESSOR)wg_gxkse6, "gxkse6", &gxkse6, &gxkse6a,
                        &gxkse6d, pw_gxkse6, pw_gxkse6a, pw_gxkse6d,
                        ia_gxkse6, 0, 0, 0, 0, sp_pos_killer-pw_gxkse6a, TRAP_ALL,
                        &loggrd);

            if  (pend(&gxkse6d, "gxkse6d", *sat_index)>sp_sattemp)
		sp_sattemp = pend(&gxkse6d, "gxkse6d", *sat_index);
        }

              
  {
    pulsename(&isi_satek6,"isi_satek6");
    createconst(&isi_satek6,(WF_PROCESSOR)wg_isi_satek6,pw_isi_satek6,(short)0); 
    createinstr( &isi_satek6,(long)(sp_sattemp-isi_satdelay),pw_isi_satek6,0);
  }

        getctrl(&ctrl_word, &isi_satek6, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satek6, *sat_index);

                
  {
    pulsename(&rot_update_ek6,"rot_update_ek6");
    createconst(&rot_update_ek6,(WF_PROCESSOR)wg_rot_update_ek6,pw_rot_update_ek6,(short)0); 
    createinstr( &rot_update_ek6,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_ek6,0);
  }

        getctrl(&ctrl_word, &rot_update_ek6, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_ek6, *sat_index);
          
        /* RJL 08/24/95. More dynamic calculation of timing */
        sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
    } 

    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */

    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT. The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/
    
    switch (sat_type)
    {
    case SINC_SAT:
	
	/* Handle rf scaling */
	if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
	if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
	if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
	
	if ((opexsatparal & PSD_1_PARALLEL) != 0)
        {
	    separation = 2 * satspace1/exsatthick1;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse1, max_pg_wamp, separation,
		      cyc_rfse1, alpha_rfse1);
	    movewaveimm(wave_space_rho, &rfse1, (INT)0, res_rfse1, 
			TOHARDWARE);
        }
	
	if ((opexsatparal & PSD_2_PARALLEL) != 0)
        {
	    separation = 2 * satspace3/exsatthick3;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse3*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse3, max_pg_wamp, separation,
		      cyc_rfse3, alpha_rfse3);
	    movewaveimm(wave_space_rho, &rfse3, (INT)0, res_rfse3, 
			TOHARDWARE);

        }
	
	if ((opexsatparal & PSD_3_PARALLEL) != 0)
        {
	    separation = 2 * satspace5/exsatthick5;
	    wave_space_rho = (SHORT *) AllocNode(res_rfse5*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfse5, max_pg_wamp, separation,
		      cyc_rfse5, alpha_rfse5);
	    movewaveimm(wave_space_rho, &rfse5, (INT)0, res_rfse5, 
			TOHARDWARE);

        }
	
	FreeNode(wave_space_rho);
	break;
	
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type) 
        {
        case SLR_SAT:        	
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;
        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;
        default:
             break;
        }
	
	skip_next_sat = 0;
	if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse1,(int)rfpulseInfo[RFSE1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse1 = rfpulseInfo[RFSE1_SLOT].newres;
            }
	    else
            {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse1*sizeof(SHORT));
                }

            }

	    /* Check if hadamard or pulse ON */
	    if ((opexsatparal & PSD_1_PARALLEL) != 0)
	      {
		separation = satspace1/2.0/exsatthick1;
		freqstep = 65536.0/(float)res_rfse1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, kernel_tab_theta, cyc_rfse1,
			 separation, gscale_rfse1, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse1Theta, (INT)0, res_rfse1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse1, kernel_tab_rho, cyc_rfse1,
                         separation, gscale_rfse1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse1, (INT)0, res_rfse1,
                            TOHARDWARE);
             
		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse1, (INT) 0, res_rfse1,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse1Theta, (INT) 0, res_rfse1,
                            TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSE1_SLOT].change==PSD_ON)
            {
	      FreeNode(kernel_tab_rho);
              if (sat_pulse_type == COMPLEX_RF)
              {
                 FreeNode(kernel_tab_theta);
              }
            }
	  }
	

	if (((opexsatmask & PSD_EXPLICIT_2) != 0) && 
	    (skip_next_sat == 0))
	  {
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_rho,kernel_tab_rho);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE2_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse2,(int)rfpulseInfo[RFSE2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse2 = rfpulseInfo[RFSE2_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse2, (INT)0, res_rfse2,
			TOHARDWARE);

            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse2Theta, (INT) 0, res_rfse2,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
	  }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE3_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse3,(int)rfpulseInfo[RFSE3_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse3 = rfpulseInfo[RFSE3_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse3*sizeof(SHORT));
                }
	      }
	    if ((opexsatparal & PSD_2_PARALLEL) != 0)
	      {
		separation = satspace3/2.0/exsatthick3;
		freqstep = 65536.0/(float) res_rfse3;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, kernel_tab_theta, cyc_rfse3,
			 separation, gscale_rfse3, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta,freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse3Theta, (INT)0, res_rfse3,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse3, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfse3, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

                movewaveimm(hadamard_tab_rho, &rfse3, (INT)0, res_rfse3,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse3, (INT) 0, res_rfse3,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse3Theta, (INT) 0, res_rfse3,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE3_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_4) != 0) && 
	    (skip_next_sat == 0))
        {
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE4_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse4,(int)rfpulseInfo[RFSE4_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfse4 = rfpulseInfo[RFSE4_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho; 
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse4, (INT)0, res_rfse4,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse4Theta, (INT)0, res_rfse4,
                           TOHARDWARE);
            }

	    /* Free Memory */
	    if (rfpulseInfo[RFSE4_SLOT].change==PSD_ON) 
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	skip_next_sat = 0;
	
	if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE5_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse5,(int)rfpulseInfo[RFSE5_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse5 = rfpulseInfo[RFSE5_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfse5*sizeof(SHORT));
                }
	      }
	    
	    if ((opexsatparal & PSD_3_PARALLEL) != 0)
	      {
		separation = satspace5/2.0/exsatthick5;
		freqstep = 65536.0/(float) res_rfse5;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, kernel_tab_theta, cyc_rfse5,
			 separation, gscale_rfse5, NULL, (FLOAT)0, 
			 hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfse5Theta, (INT)0, res_rfse5,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfse5, kernel_tab_rho, cyc_rfse5,
                         separation, gscale_rfse5, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }
                movewaveimm(hadamard_tab_rho, &rfse5, (INT)0, res_rfse5,
                            TOHARDWARE);

		skip_next_sat = 1;
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfse5, (INT) 0, res_rfse5,
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfse5Theta, (INT) 0, res_rfse5,
                               TOHARDWARE);
                }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSE5_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (((opexsatmask & PSD_EXPLICIT_6) != 0) && 
	    (skip_next_sat == 0))
        {
	    /* Check pulse scaling */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
	      {		      
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSE6_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfse6,(int)rfpulseInfo[RFSE6_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }

		res_rfse6 = rfpulseInfo[RFSE6_SLOT].newres;
	      }
	    else
              {
	        kernel_tab_rho = temp_wave_rho;
                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                }
              }

	    movewaveimm(kernel_tab_rho, &rfse6, (INT)0, res_rfse6,
			TOHARDWARE); 
            if (sat_pulse_type == COMPLEX_RF)
            {
               movewaveimm(kernel_tab_theta, &rfse6Theta, (INT)0, res_rfse6,
                           TOHARDWARE);
            }
	    /* Free Memory */
	    if (rfpulseInfo[RFSE6_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
	    } 
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    /****************************************************************
      DEFAULT SAT GRADEINTS
      
      1. Slice selection gradient
      2. Killer on y gradient
      3. If there are 2 sat bands that are parallel but do not have
      the same thickness, create a separate slice select & killer
      for the second band.
      
    ******************************************************************/
    
    if (opsatx != PSD_OFF)    /* X board */
    {
        if (opsatx == PSD_SATNEG)
            satthickdfx = satthickx1;
        else if (opsatx == PSD_SATPOS)
            satthickdfx = satthickx2;
        else
            satthickdfx = satthickx1;
	
           
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx1", 
                                     (WF_PROCESSOR)wg_rfsx1);

    /* Modify resolution if scaling required */
    temp_res_rfsx1 = res_rfsx1;
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx1a,"gxrfsx1a");
    pulsename(&gxrfsx1,"gxrfsx1");
    pulsename(&gxrfsx1d,"gxrfsx1d");
    pulsename(&rfsx1,"rfsx1");

    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.xbeta;
    createramp(&gxrfsx1a,XGRAD,pw_gxrfsx1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx1a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx1a,(LONG)(sp_sattemp+pw_gxrfsx1a-pw_gxrfsx1a),
                pw_gxrfsx1a,ia_gxrfsx1);
    createconst(&gxrfsx1,XGRAD,pw_gxrfsx1,MAX_PG_WAMP);
    createinstr( &gxrfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a),
                pw_gxrfsx1,ia_gxrfsx1);
    createramp(&gxrfsx1d,XGRAD,pw_gxrfsx1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx1d,(LONG)(sp_sattemp+pw_gxrfsx1a+pw_gxrfsx1),
                pw_gxrfsx1d,ia_gxrfsx1);

    /* Now create the rf pulse */
    createsinc(&rfsx1,(WF_PROCESSOR)wg_rfsx1,res_rfsx1,
               MAX_PG_WAMP,cyc_rfsx1, alpha_rfsx1);
    createinstr( &rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
                pw_rfsx1,ia_rfsx1);
    linkpulses(4,&rfsx1,&gxrfsx1,&gxrfsx1a,
               &gxrfsx1d);
    addrfbits(&rfsx1,off_rfsx1,(LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait,
              pw_rfsx1);


    pulsename(&rfsx1Theta, "rfsx1Theta");
    createreserve(&rfsx1Theta, THETA, res_rfsx1);
    addrfbits(&rfsx1Theta, off_rfsx1, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait , pw_rfsx1);
    createinstr(&rfsx1Theta, (LONG)(sp_sattemp+pw_gxrfsx1a) + psd_rf_wait, pw_rfsx1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
       res_rfsx1 = temp_res_rfsx1;
}

	
        sp_sattemp = pend(&gxrfsx1d, "gxrfsx1d", *sat_index);
	
        ending = pendallssp(&rfsx1, *sat_index);
           
  {
    pulsename(&isi_satx1,"isi_satx1");
    createconst(&isi_satx1,(WF_PROCESSOR)wg_isi_satx1,pw_isi_satx1,(short)0); 
    createinstr( &isi_satx1,(long)(ending),pw_isi_satx1,0);
  }

        getctrl(&ctrl_word, &isi_satx1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satx1, *sat_index);
	rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_x1,"rot_update_x1");
    createconst(&rot_update_x1,(WF_PROCESSOR)wg_rot_update_x1,pw_rot_update_x1,(short)0); 
    createinstr( &rot_update_x1,(long)(rot_update_time),pw_rot_update_x1,0);
  }

        getctrl(&ctrl_word, &rot_update_x1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_x1, *sat_index);
	sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksx1, "gyksx1", &gyksx1, &gyksx1a,
                        &gyksx1d, pw_gyksx1, pw_gyksx1a, pw_gyksx1d,
                        ia_gyksx1, 0, 0, 0, 0, sp_pos_killer-pw_gyksx1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksx1d, "gyksx1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxksx1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksx1, "gxksx1", &gxksx1, &gxksx1a,
                        &gxksx1d, pw_gxksx1, pw_gxksx1a, pw_gxksx1d,
                        ia_gxksx1, 0, 0, 0, 0, sp_pos_killer-pw_gxksx1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksx1d, "gxksx1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksx1d, "gxksx1d", *sat_index);
        }

              
  {
    pulsename(&isi_satxk1,"isi_satxk1");
    createconst(&isi_satxk1,(WF_PROCESSOR)wg_isi_satxk1,pw_isi_satxk1,(short)0); 
    createinstr( &isi_satxk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk1,0);
  }

        getctrl(&ctrl_word, &isi_satxk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satxk1, *sat_index);

                
  {
    pulsename(&rot_update_xk1,"rot_update_xk1");
    createconst(&rot_update_xk1,(WF_PROCESSOR)wg_rot_update_xk1,pw_rot_update_xk1,(short)0); 
    createinstr( &rot_update_xk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk1,0);
  }

        getctrl(&ctrl_word, &rot_update_xk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_xk1, *sat_index);
       
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsatx == PSD_SATPARA)
        {
                
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsx2", 
                                     (WF_PROCESSOR)wg_rfsx2);

    /* Modify resolution if scaling required */
    temp_res_rfsx2 = res_rfsx2;
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2 = rfpulseInfo[RFSX2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gxrfsx2a,"gxrfsx2a");
    pulsename(&gxrfsx2,"gxrfsx2");
    pulsename(&gxrfsx2d,"gxrfsx2d");
    pulsename(&rfsx2,"rfsx2");

    /*  Now create the slice select trapezoid */
    pg_beta = loggrd.xbeta;
    createramp(&gxrfsx2a,XGRAD,pw_gxrfsx2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gxrfsx2a/
                                               GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gxrfsx2a,(LONG)(sp_sattemp+pw_gxrfsx2a-pw_gxrfsx2a),
                pw_gxrfsx2a,ia_gxrfsx2);
    createconst(&gxrfsx2,XGRAD,pw_gxrfsx2,MAX_PG_WAMP);
    createinstr( &gxrfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a),
                pw_gxrfsx2,ia_gxrfsx2);
    createramp(&gxrfsx2d,XGRAD,pw_gxrfsx2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gxrfsx2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gxrfsx2d,(LONG)(sp_sattemp+pw_gxrfsx2a+pw_gxrfsx2),
                pw_gxrfsx2d,ia_gxrfsx2);

    /* Now create the rf pulse */
    createsinc(&rfsx2,(WF_PROCESSOR)wg_rfsx2,res_rfsx2,
               MAX_PG_WAMP,cyc_rfsx2, alpha_rfsx2);
    createinstr( &rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
                pw_rfsx2,ia_rfsx2);
    linkpulses(4,&rfsx2,&gxrfsx2,&gxrfsx2a,
               &gxrfsx2d);
    addrfbits(&rfsx2,off_rfsx2,(LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait,
              pw_rfsx2);


    pulsename(&rfsx2Theta, "rfsx2Theta");
    createreserve(&rfsx2Theta, THETA, res_rfsx2);
    addrfbits(&rfsx2Theta, off_rfsx2, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait , pw_rfsx2);
    createinstr(&rfsx2Theta, (LONG)(sp_sattemp+pw_gxrfsx2a) + psd_rf_wait, pw_rfsx2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
       res_rfsx2 = temp_res_rfsx2;
}


	    sp_sattemp = pend(&gxrfsx2d, "gxrfsx2d", *sat_index) ;
	    
	    ending = pendallssp(&rfsx2, *sat_index);
	       
  {
    pulsename(&isi_satx2,"isi_satx2");
    createconst(&isi_satx2,(WF_PROCESSOR)wg_isi_satx2,pw_isi_satx2,(short)0); 
    createinstr( &isi_satx2,(long)(ending),pw_isi_satx2,0);
  }

	    getctrl(&ctrl_word, &isi_satx2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satx2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_x2,"rot_update_x2");
    createconst(&rot_update_x2,(WF_PROCESSOR)wg_rot_update_x2,pw_rot_update_x2,(short)0); 
    createinstr( &rot_update_x2,(long)(rot_update_time),pw_rot_update_x2,0);
  }

	    getctrl(&ctrl_word, &rot_update_x2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_x2, *sat_index);
	    sp_sattemp = RUP_GRD(rot_update_time + pw_rotupdate);	    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksx2a + isi_extra);
	         

  trapezoid((WF_PROCESSOR)wg_gyksx2, "gyksx2", &gyksx2, &gyksx2a,
                        &gyksx2d, pw_gyksx2, pw_gyksx2a, pw_gyksx2d,
                        ia_gyksx2, 0, 0, 0, 0, sp_pos_killer-pw_gyksx2a, TRAP_ALL,
                        &loggrd);

	    sp_sattemp = pend(&gyksx2d, "gyksx2d",*sat_index) ;
	    
            if (!floatsAlmostEqualEpsilons(area_gxksx2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksx2, "gxksx2", &gxksx2, &gxksx2a,
                        &gxksx2d, pw_gxksx2, pw_gxksx2a, pw_gxksx2d,
                        ia_gxksx2, 0, 0, 0, 0, sp_pos_killer-pw_gxksx2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksx2d, "gxksx2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksx2d, "gxksx2d", *sat_index);
            }
	    
	         
  {
    pulsename(&isi_satxk2,"isi_satxk2");
    createconst(&isi_satxk2,(WF_PROCESSOR)wg_isi_satxk2,pw_isi_satxk2,(short)0); 
    createinstr( &isi_satxk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satxk2,0);
  }

	    getctrl(&ctrl_word, &isi_satxk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satxk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_xk2,"rot_update_xk2");
    createconst(&rot_update_xk2,(WF_PROCESSOR)wg_rot_update_xk2,pw_rot_update_xk2,(short)0); 
    createinstr( &rot_update_xk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_xk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_xk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_xk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra);
        }
    }

    if (opsaty != PSD_OFF)   /* Y Board */
    {
        if (opsaty == PSD_SATNEG)
            satthickdfy = satthicky1;
        else if (opsaty == PSD_SATPOS)
            satthickdfy = satthicky2;
        else
            satthickdfy = satthicky1;

             
                     
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy1", 
                                     (WF_PROCESSOR)wg_rfsy1);

    /* Modify resolution if scaling required */
    temp_res_rfsy1 = res_rfsy1;
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy1a,"gyrfsy1a");
    pulsename(&gyrfsy1,"gyrfsy1");
    pulsename(&gyrfsy1d,"gyrfsy1d");
    pulsename(&rfsy1,"rfsy1");

        /*  Now create the slice select trapezoid */
  pg_beta = loggrd.ybeta;
  createramp(&gyrfsy1a,YGRAD,pw_gyrfsy1a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy1a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy1a,(LONG)(sp_sattemp+pw_gyrfsy1a-pw_gyrfsy1a),
      pw_gyrfsy1a,ia_gyrfsy1);
  createconst(&gyrfsy1,YGRAD,pw_gyrfsy1,MAX_PG_WAMP);
  createinstr( &gyrfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a),
      pw_gyrfsy1,ia_gyrfsy1);
  createramp(&gyrfsy1d,YGRAD,pw_gyrfsy1d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy1d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy1d,(LONG)(sp_sattemp+pw_gyrfsy1a+pw_gyrfsy1),
      pw_gyrfsy1d,ia_gyrfsy1);

    /* Now create the rf pulse */
    createsinc(&rfsy1,(WF_PROCESSOR)wg_rfsy1,res_rfsy1,
               MAX_PG_WAMP,cyc_rfsy1, alpha_rfsy1);
    createinstr( &rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
                pw_rfsy1,ia_rfsy1);
    linkpulses(4,&rfsy1,&gyrfsy1,&gyrfsy1a,&gyrfsy1d);
    addrfbits(&rfsy1,off_rfsy1,(LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait,
              pw_rfsy1);

    pulsename(&rfsy1Theta, "rfsy1Theta");
    createreserve(&rfsy1Theta, THETA, res_rfsy1);
    addrfbits(&rfsy1Theta, off_rfsy1, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait , pw_rfsy1);
    createinstr(&rfsy1Theta, (LONG)(sp_sattemp+pw_gyrfsy1a) + psd_rf_wait, pw_rfsy1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
      res_rfsy1 = temp_res_rfsy1;
}


        sp_sattemp = pend(&gyrfsy1d, "gyrfsy1d" , *sat_index);

        ending = pendallssp(&rfsy1, *sat_index);
           
  {
    pulsename(&isi_saty1,"isi_saty1");
    createconst(&isi_saty1,(WF_PROCESSOR)wg_isi_saty1,pw_isi_saty1,(short)0); 
    createinstr( &isi_saty1,(long)(ending),pw_isi_saty1,0);
  }

        getctrl(&ctrl_word, &isi_saty1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_saty1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));

           
  {
    pulsename(&rot_update_y1,"rot_update_y1");
    createconst(&rot_update_y1,(WF_PROCESSOR)wg_rot_update_y1,pw_rot_update_y1,(short)0); 
    createinstr( &rot_update_y1,(long)(rot_update_time),pw_rot_update_y1,0);
  }

        getctrl(&ctrl_word, &rot_update_y1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_y1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;

        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy1a + isi_extra);
              

  trapezoid((WF_PROCESSOR)wg_gyksy1, "gyksy1", &gyksy1, &gyksy1a,
                        &gyksy1d, pw_gyksy1, pw_gyksy1a, pw_gyksy1d,
                        ia_gyksy1, 0, 0, 0, 0, sp_pos_killer-pw_gyksy1a, TRAP_ALL,
                        &loggrd);
 
        sp_sattemp = pend(&gyksy1d, "gyksy1d", *sat_index);

        if (!floatsAlmostEqualEpsilons(area_gxksy1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksy1, "gxksy1", &gxksy1, &gxksy1a,
                        &gxksy1d, pw_gxksy1, pw_gxksy1a, pw_gxksy1d,
                        ia_gxksy1, 0, 0, 0, 0, sp_pos_killer-pw_gxksy1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksy1d, "gxksy1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksy1d, "gxksy1d", *sat_index);
        }

              
  {
    pulsename(&isi_satyk1,"isi_satyk1");
    createconst(&isi_satyk1,(WF_PROCESSOR)wg_isi_satyk1,pw_isi_satyk1,(short)0); 
    createinstr( &isi_satyk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk1,0);
  }

        getctrl(&ctrl_word, &isi_satyk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satyk1, *sat_index);

                
  {
    pulsename(&rot_update_yk1,"rot_update_yk1");
    createconst(&rot_update_yk1,(WF_PROCESSOR)wg_rot_update_yk1,pw_rot_update_yk1,(short)0); 
    createinstr( &rot_update_yk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk1,0);
  }

        getctrl(&ctrl_word, &rot_update_yk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_yk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);

        if (opsaty == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsy2", 
                                     (WF_PROCESSOR)wg_rfsy2);

    /* Modify resolution if scaling required */
    temp_res_rfsy2 = res_rfsy2;
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2 = rfpulseInfo[RFSY2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfsy2a,"gyrfsy2a");
    pulsename(&gyrfsy2,"gyrfsy2");
    pulsename(&gyrfsy2d,"gyrfsy2d");
    pulsename(&rfsy2,"rfsy2");

        /*  Now create the slice select trapezoid */
  pg_beta = loggrd.ybeta;
  createramp(&gyrfsy2a,YGRAD,pw_gyrfsy2a,(short)0,MAX_PG_WAMP,
                        (short)(maxGradRes*(pw_gyrfsy2a/GRAD_UPDATE_TIME))

                        ,pg_beta);
  createinstr( &gyrfsy2a,(LONG)(sp_sattemp+pw_gyrfsy2a-pw_gyrfsy2a),
      pw_gyrfsy2a,ia_gyrfsy2);
  createconst(&gyrfsy2,YGRAD,pw_gyrfsy2,MAX_PG_WAMP);
  createinstr( &gyrfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a),
      pw_gyrfsy2,ia_gyrfsy2);
  createramp(&gyrfsy2d,YGRAD,pw_gyrfsy2d,MAX_PG_WAMP,
                        (short)0,(short)(maxGradRes*(pw_gyrfsy2d/GRAD_UPDATE_TIME))
                        ,pg_beta);
  createinstr( &gyrfsy2d,(LONG)(sp_sattemp+pw_gyrfsy2a+pw_gyrfsy2),
      pw_gyrfsy2d,ia_gyrfsy2);

    /* Now create the rf pulse */
    createsinc(&rfsy2,(WF_PROCESSOR)wg_rfsy2,res_rfsy2,
               MAX_PG_WAMP,cyc_rfsy2, alpha_rfsy2);
    createinstr( &rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
                pw_rfsy2,ia_rfsy2);
    linkpulses(4,&rfsy2,&gyrfsy2,&gyrfsy2a,&gyrfsy2d);
    addrfbits(&rfsy2,off_rfsy2,(LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait,
              pw_rfsy2);

    pulsename(&rfsy2Theta, "rfsy2Theta");
    createreserve(&rfsy2Theta, THETA, res_rfsy2);
    addrfbits(&rfsy2Theta, off_rfsy2, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait , pw_rfsy2);
    createinstr(&rfsy2Theta, (LONG)(sp_sattemp+pw_gyrfsy2a) + psd_rf_wait, pw_rfsy2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
      res_rfsy2 = temp_res_rfsy2;
}


	    sp_sattemp = pend(&gyrfsy2d, "gyrfsy2d", *sat_index);
	    ending = pendallssp(&rfsy2, *sat_index);
	       
  {
    pulsename(&isi_saty2,"isi_saty2");
    createconst(&isi_saty2,(WF_PROCESSOR)wg_isi_saty2,pw_isi_saty2,(short)0); 
    createinstr( &isi_saty2,(long)(ending),pw_isi_saty2,0);
  }

	    getctrl(&ctrl_word, &isi_saty2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_saty2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_y2,"rot_update_y2");
    createconst(&rot_update_y2,(WF_PROCESSOR)wg_rot_update_y2,pw_rot_update_y2,(short)0); 
    createinstr( &rot_update_y2,(long)(rot_update_time),pw_rot_update_y2,0);
  }

	    getctrl(&ctrl_word, &rot_update_y2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_y2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;    

	    sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksy2a + isi_extra);
	           

  trapezoid((WF_PROCESSOR)wg_gyksy2, "gyksy2", &gyksy2, &gyksy2a,
                        &gyksy2d, pw_gyksy2, pw_gyksy2a, pw_gyksy2d,
                        ia_gyksy2, 0, 0, 0, 0, sp_pos_killer-pw_gyksy2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksy2d, "gyksy2d", *sat_index);
	    
            if (!floatsAlmostEqualEpsilons(area_gxksy2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksy2, "gxksy2", &gxksy2, &gxksy2a,
                        &gxksy2d, pw_gxksy2, pw_gxksy2a, pw_gxksy2d,
                        ia_gxksy2, 0, 0, 0, 0, sp_pos_killer-pw_gxksy2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksy2d, "gxksy2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksy2d, "gxksy2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satyk2,"isi_satyk2");
    createconst(&isi_satyk2,(WF_PROCESSOR)wg_isi_satyk2,pw_isi_satyk2,(short)0); 
    createinstr( &isi_satyk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satyk2,0);
  }

	    getctrl(&ctrl_word, &isi_satyk2, *sat_index);
	    ctrl_word =  ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satyk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_yk2,"rot_update_yk2");
    createconst(&rot_update_yk2,(WF_PROCESSOR)wg_rot_update_yk2,pw_rot_update_yk2,(short)0); 
    createinstr( &rot_update_yk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_yk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_yk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_yk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = RUP_GRD(sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra);
        }
    }

    if (opsatz != PSD_OFF)  /* Z Board */
    {
	if (opsatz == PSD_SATNEG)
            satthickdfz = satthickz1;
        else if (opsatz == PSD_SATPOS)
            satthickdfz = satthickz2;
        else
            satthickdfz = satthickz1;
	
             
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz1", 
                                     (WF_PROCESSOR)wg_rfsz1);

    /* Modify resolution if scaling required */
    temp_res_rfsz1 = res_rfsz1;
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz1a,"gzrfsz1a");
    pulsename(&gzrfsz1,"gzrfsz1");
    pulsename(&gzrfsz1d,"gzrfsz1d");
    pulsename(&rfsz1,"rfsz1");

    /*  Now create the slice select trapezoid */
        pg_beta = loggrd.zbeta;
    createramp(&gzrfsz1a,ZGRAD,pw_gzrfsz1a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz1a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz1a,(LONG)(sp_sattemp+pw_gzrfsz1a-pw_gzrfsz1a),
                pw_gzrfsz1a,ia_gzrfsz1);
    createconst(&gzrfsz1,ZGRAD,pw_gzrfsz1,MAX_PG_WAMP);
    createinstr( &gzrfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a),
                pw_gzrfsz1,ia_gzrfsz1);
    createramp(&gzrfsz1d,ZGRAD,pw_gzrfsz1d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz1d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz1d,(LONG)(sp_sattemp+pw_gzrfsz1a+pw_gzrfsz1),
                pw_gzrfsz1d,ia_gzrfsz1);

    /* Now create the rf pulse */
    createsinc(&rfsz1,(WF_PROCESSOR)wg_rfsz1,res_rfsz1,
               MAX_PG_WAMP,cyc_rfsz1, alpha_rfsz1);

    createinstr( &rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
                pw_rfsz1,ia_rfsz1);
    linkpulses(4,&rfsz1,&gzrfsz1,&gzrfsz1a,
               &gzrfsz1d);
    addrfbits(&rfsz1,off_rfsz1,(LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait,
              pw_rfsz1);



    pulsename(&rfsz1Theta, "rfsz1Theta");
    createreserve(&rfsz1Theta, THETA, res_rfsz1);
    addrfbits(&rfsz1Theta, off_rfsz1, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait , pw_rfsz1);
    createinstr(&rfsz1Theta, (LONG)(sp_sattemp+pw_gzrfsz1a) + psd_rf_wait, pw_rfsz1, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
       res_rfsz1 = temp_res_rfsz1;
  }


        sp_sattemp = pend(&gzrfsz1d, "gzrfsz1d", *sat_index);
	
        ending = pendallssp(&rfsz1, *sat_index);
           
  {
    pulsename(&isi_satz1,"isi_satz1");
    createconst(&isi_satz1,(WF_PROCESSOR)wg_isi_satz1,pw_isi_satz1,(short)0); 
    createinstr( &isi_satz1,(long)(ending),pw_isi_satz1,0);
  }

        getctrl(&ctrl_word, &isi_satz1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satz1, *sat_index);
        rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	
           
  {
    pulsename(&rot_update_z1,"rot_update_z1");
    createconst(&rot_update_z1,(WF_PROCESSOR)wg_rot_update_z1,pw_rot_update_z1,(short)0); 
    createinstr( &rot_update_z1,(long)(rot_update_time),pw_rot_update_z1,0);
  }

        getctrl(&ctrl_word, &rot_update_z1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_z1, *sat_index);
	sp_sattemp = rot_update_time + pw_rotupdate;
	
        sp_pos_killer = RUP_GRD(sp_sattemp + pw_gyksz1a + isi_extra);
             

  trapezoid((WF_PROCESSOR)wg_gyksz1, "gyksz1", &gyksz1, &gyksz1a,
                        &gyksz1d, pw_gyksz1, pw_gyksz1a, pw_gyksz1d,
                        ia_gyksz1, 0, 0, 0, 0, sp_pos_killer-pw_gyksz1a, TRAP_ALL,
                        &loggrd);

        sp_sattemp = pend(&gyksz1d, "gyksz1d", *sat_index);
	
        if (!floatsAlmostEqualEpsilons(area_gxksz1, 0.0, 2))
        {
	        

  trapezoid((WF_PROCESSOR)wg_gxksz1, "gxksz1", &gxksz1, &gxksz1a,
                        &gxksz1d, pw_gxksz1, pw_gxksz1a, pw_gxksz1d,
                        ia_gxksz1, 0, 0, 0, 0, sp_pos_killer-pw_gxksz1a, TRAP_ALL,
                        &loggrd);

	    if  (pend(&gxksz1d, "gxksz1d", *sat_index)>sp_sattemp)
                sp_sattemp = pend(&gxksz1d, "gxksz1d", *sat_index);
        }

              
  {
    pulsename(&isi_satzk1,"isi_satzk1");
    createconst(&isi_satzk1,(WF_PROCESSOR)wg_isi_satzk1,pw_isi_satzk1,(short)0); 
    createinstr( &isi_satzk1,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk1,0);
  }

        getctrl(&ctrl_word, &isi_satzk1, *sat_index);
        ctrl_word = ctrl_word | PSD_ISI0_BIT;
        setctrl(ctrl_word, &isi_satzk1, *sat_index);
	
                
  {
    pulsename(&rot_update_zk1,"rot_update_zk1");
    createconst(&rot_update_zk1,(WF_PROCESSOR)wg_rot_update_zk1,pw_rot_update_zk1,(short)0); 
    createinstr( &rot_update_zk1,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk1,0);
  }

        getctrl(&ctrl_word, &rot_update_zk1, *sat_index);
        ctrl_word = ctrl_word | PSD_MTX_UPDT ;
        setctrl(ctrl_word, &rot_update_zk1, *sat_index);
        
	/* RJL 08/24/95. More dynamic calculation of timing */
	sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+pw_rotupdate + isi_extra;
	
        if (opsatz == PSD_SATPARA)
        {
                
                        
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfsz2", 
                                     (WF_PROCESSOR)wg_rfsz2);

    /* Modify resolution if scaling required */
    temp_res_rfsz2 = res_rfsz2;
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2 = rfpulseInfo[RFSZ2_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrfsz2a,"gzrfsz2a");
    pulsename(&gzrfsz2,"gzrfsz2");
    pulsename(&gzrfsz2d,"gzrfsz2d");
    pulsename(&rfsz2,"rfsz2");

    /*  Now create the slice select trapezoid */
        pg_beta = loggrd.zbeta;
    createramp(&gzrfsz2a,ZGRAD,pw_gzrfsz2a,(short)0,
               MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrfsz2a/
                   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrfsz2a,(LONG)(sp_sattemp+pw_gzrfsz2a-pw_gzrfsz2a),
                pw_gzrfsz2a,ia_gzrfsz2);
    createconst(&gzrfsz2,ZGRAD,pw_gzrfsz2,MAX_PG_WAMP);
    createinstr( &gzrfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a),
                pw_gzrfsz2,ia_gzrfsz2);
    createramp(&gzrfsz2d,ZGRAD,pw_gzrfsz2d,MAX_PG_WAMP,
               (short)0,(short)(maxGradRes*(pw_gzrfsz2d/GRAD_UPDATE_TIME)),
                   pg_beta);
    createinstr( &gzrfsz2d,(LONG)(sp_sattemp+pw_gzrfsz2a+pw_gzrfsz2),
                pw_gzrfsz2d,ia_gzrfsz2);

    /* Now create the rf pulse */
    createsinc(&rfsz2,(WF_PROCESSOR)wg_rfsz2,res_rfsz2,
               MAX_PG_WAMP,cyc_rfsz2, alpha_rfsz2);

    createinstr( &rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
                pw_rfsz2,ia_rfsz2);
    linkpulses(4,&rfsz2,&gzrfsz2,&gzrfsz2a,
               &gzrfsz2d);
    addrfbits(&rfsz2,off_rfsz2,(LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait,
              pw_rfsz2);



    pulsename(&rfsz2Theta, "rfsz2Theta");
    createreserve(&rfsz2Theta, THETA, res_rfsz2);
    addrfbits(&rfsz2Theta, off_rfsz2, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait , pw_rfsz2);
    createinstr(&rfsz2Theta, (LONG)(sp_sattemp+pw_gzrfsz2a) + psd_rf_wait, pw_rfsz2, 32766);

    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
       res_rfsz2 = temp_res_rfsz2;
  }


	    sp_sattemp = pend(&gzrfsz2d, "gzrfsz2d", *sat_index);
	    
	    ending = pendallssp(&rfsz2, *sat_index);
	       
  {
    pulsename(&isi_satz2,"isi_satz2");
    createconst(&isi_satz2,(WF_PROCESSOR)wg_isi_satz2,pw_isi_satz2,(short)0); 
    createinstr( &isi_satz2,(long)(ending),pw_isi_satz2,0);
  }

	    getctrl(&ctrl_word, &isi_satz2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satz2, *sat_index);
            rot_update_time =RUP_GRD( IMax(2,sp_sattemp+rot_delay,ending+pw_isisat));
	    
	       
  {
    pulsename(&rot_update_z2,"rot_update_z2");
    createconst(&rot_update_z2,(WF_PROCESSOR)wg_rot_update_z2,pw_rot_update_z2,(short)0); 
    createinstr( &rot_update_z2,(long)(rot_update_time),pw_rot_update_z2,0);
  }

	    getctrl(&ctrl_word, &rot_update_z2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_z2, *sat_index);
	    sp_sattemp = rot_update_time + pw_rotupdate;	    

	    sp_pos_killer = sp_sattemp + pw_gyksz2a + isi_extra;
	          

  trapezoid((WF_PROCESSOR)wg_gyksz2, "gyksz2", &gyksz2, &gyksz2a,
                        &gyksz2d, pw_gyksz2, pw_gyksz2a, pw_gyksz2d,
                        ia_gyksz2, 0, 0, 0, 0, sp_pos_killer-pw_gyksz2a, TRAP_ALL,
                        &loggrd);
 
	    sp_sattemp = pend(&gyksz2d, "gyksz2d", *sat_index);
	    
            if (!floatsAlmostEqualEpsilons(area_gxksz2, 0.0, 2))
            {
		    

  trapezoid((WF_PROCESSOR)wg_gxksz2, "gxksz2", &gxksz2, &gxksz2a,
                        &gxksz2d, pw_gxksz2, pw_gxksz2a, pw_gxksz2d,
                        ia_gxksz2, 0, 0, 0, 0, sp_pos_killer-pw_gxksz2a, TRAP_ALL,
                        &loggrd);

		if  (pend(&gxksz2d, "gxksz2d", *sat_index)>sp_sattemp)
                    sp_sattemp = pend(&gxksz2d, "gxksz2d", *sat_index);
            }
	    
	          
  {
    pulsename(&isi_satzk2,"isi_satzk2");
    createconst(&isi_satzk2,(WF_PROCESSOR)wg_isi_satzk2,pw_isi_satzk2,(short)0); 
    createinstr( &isi_satzk2,(long)(sp_sattemp-isi_satdelay),pw_isi_satzk2,0);
  }

	    getctrl(&ctrl_word, &isi_satzk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_ISI0_BIT;
	    setctrl(ctrl_word, &isi_satzk2, *sat_index);
	    
	            
  {
    pulsename(&rot_update_zk2,"rot_update_zk2");
    createconst(&rot_update_zk2,(WF_PROCESSOR)wg_rot_update_zk2,pw_rot_update_zk2,(short)0); 
    createinstr( &rot_update_zk2,(long)(sp_sattemp-isi_satdelay+pw_isisat),pw_rot_update_zk2,0);
  }

	    getctrl(&ctrl_word, &rot_update_zk2, *sat_index);
	    ctrl_word = ctrl_word | PSD_MTX_UPDT ;
	    setctrl(ctrl_word, &rot_update_zk2, *sat_index);
	    
	    /* RJL 08/24/95. More dynamic calculation of timing */
	    sp_sattemp = sp_sattemp - isi_satdelay  + pw_isisat+ pw_rotupdate + isi_extra;
        }
    }
    
    /* Slice select macro creates a since RF pulse. 
       A psd can use either sinc or SLR RF pulses. Parallel sat bands
       with the same thickness use a hadamard RF pulse. This one
       pulse replaces the 2 separate RF pulses. If the RF
       pulse is sinc, a hadamard sinc pulse is used. Likewise 
       if the SLR RF pulse is used, a hadamard SLR pulse is used. */
    
    /******************************************************************************
     ** This section has undergone significant restructuring to accomode rfpulse
     ** scaling following system safety requirements. The overall function is
     ** still similar. In the first case (SINC_SAT), the resolutions are changed
     ** if pulse scaling was performed. Interpolation is not required since the
     ** pulse is generated internally. For (SLR_SAT), the pulse is read into a work
     ** buffer (temp_wave), and copied over to the kernel file either in original
     ** size or increased size if scaling required. All scaling is performed before
     ** hadamard sat's are created. It is assumed that not all sat regions will have
     ** similar pulse resolutions, and scaling may or may not be required for each
     ** rfpulse SAT.  The final rfpulse is then immediate moved (movewaveimm) onto
     ** the RHO board, and allocated memory freed.
     ******************************************************************************/

    switch (sat_type) 
    {
        /* If hadamard, create and load in hadamard */
    case SINC_SAT:
	
	/* Change resolutions if rfpulse scaled */
	if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
            res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
	if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
            res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
	if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
            res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;

	if (opsatx == PSD_SATHAD) 
	  {
	    separation = 2*satspacex1/satthickx1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsx1, max_pg_wamp, separation,
		      cyc_rfsx1, alpha_rfsx1);
	    movewaveimm(wave_space_rho, &rfsx1, (INT)0, res_rfsx1, TOHARDWARE);
	  }
	
	if (opsaty == PSD_SATHAD) 
	  {
	    separation = 2*satspacey1/satthicky1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsy1, max_pg_wamp, separation,
		      cyc_rfsy1, alpha_rfsy1);
	    movewaveimm(wave_space_rho, &rfsy1, (INT)0, res_rfsy1, TOHARDWARE);
	  }
	
	if (opsatz == PSD_SATHAD) 
	  {
	    separation = 2*satspacez1/satthickz1;
	    wave_space_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
	    uhadamard(wave_space_rho, res_rfsz1, max_pg_wamp, separation,
		      cyc_rfsz1, alpha_rfsz1);
	    movewaveimm(wave_space_rho, &rfsz1, (INT)0, res_rfsz1, TOHARDWARE);
	  }
	
	FreeNode(wave_space_rho);
	break;
	
	/* Include SLR RF files  */
    case SLR_SAT:
    case SLR_CSAT:

        switch (sat_type)
        {
        case SLR_SAT:
	     strcpy(rho_file, "rfdblsatl0.rho");
	     temp_wave_rho = (SHORT *)AllocNode(RES_SLRSAT*sizeof(SHORT));
	     uextwave(temp_wave_rho, RES_SLRSAT, rho_file);
             break;

        case SLR_CSAT:
             strcpy(rho_file, "satqptbw12.rho");
             temp_wave_rho = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
             uextwave(temp_wave_rho, RES_SLRCSAT, rho_file);

             if (sat_pulse_type == COMPLEX_RF)
             {
                strcpy(theta_file, "satqptbw12.the");
                temp_wave_theta = (SHORT *)AllocNode(RES_SLRCSAT*sizeof(SHORT));
                uextwave(temp_wave_theta, RES_SLRCSAT, theta_file);
             }
             break;

        default:
             break;
        }
	
	if (opsatx != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsx1,(int)rfpulseInfo[RFSX1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsx1 = rfpulseInfo[RFSX1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsx1*sizeof(SHORT));
                }
	      }

	    if (opsatx == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacex1/2.0/satthickx1;
		freqstep = 65536.0/(float) res_rfsx1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, kernel_tab_theta, cyc_rfsx1,
			 separation, gscale_rfsx1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                  
                   movewaveimm(hadamard_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                         TOHARDWARE);

                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsx1, kernel_tab_rho, cyc_rfse3,
                         separation, gscale_rfsx1, NULL, (FLOAT)0,
                         hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
				TOHARDWARE); 

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
	      }
	    else
	      { 
		movewaveimm(kernel_tab_rho, &rfsx1, (INT)0, res_rfsx1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsx1Theta, (INT)0, res_rfsx1,
                               TOHARDWARE);
                }

		if (rfpulseInfo[RFSX1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho); 
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }            
		/* Check for parallel sat region */
		if (opsatx == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSX2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsx2,(int)rfpulseInfo[RFSX2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }

			res_rfsx2 = rfpulseInfo[RFSX2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsx2, (INT)0, res_rfsx2,
				TOHARDWARE); 
                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsx2Theta, (INT)0, res_rfsx2,
                                   TOHARDWARE);
                    }
		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }

	    if (rfpulseInfo[RFSX2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsaty != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsy1,(int)rfpulseInfo[RFSY1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsy1 = rfpulseInfo[RFSY1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsy1*sizeof(SHORT));
                }
	      }

	    if (opsaty == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacey1/2.0/satthicky1;
		freqstep = 65536.0/(float) res_rfsy1;

                if (sat_pulse_type == COMPLEX_RF)
                {
    		   altcomplexrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, kernel_tab_theta, cyc_rfsy1,
			 separation, gscale_rfsy1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);

                   movewaveimm(hadamard_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsy1, kernel_tab_rho, cyc_rfsy1,
                         separation, gscale_rfsy1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }
		movewaveimm(hadamard_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE); 

		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsy1, (INT)0, res_rfsy1, 
			    TOHARDWARE);
                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsy1Theta, (INT)0, res_rfsy1,
                               TOHARDWARE);
                }
		if (rfpulseInfo[RFSY1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);  
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta); 
                   }
                }
		if (opsaty == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSY2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsy2,(int)rfpulseInfo[RFSY2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        }
			res_rfsy2 = rfpulseInfo[RFSY2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho;  
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta; 
                        }
                      }
		  movewaveimm(kernel_tab_rho, &rfsy2, (INT)0, res_rfsy2, 
			      TOHARDWARE);
                  if (sat_pulse_type == COMPLEX_RF)
                  {
                     movewaveimm(kernel_tab_theta, &rfsy2Theta, (INT)0, res_rfsy2,
                                 TOHARDWARE);
                  }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSY2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }
	
	if (opsatz != PSD_SATOFF) 
        {
	    /* Check to see if pulse needs to be scaled */
	    if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
	      {
		kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		hadamard_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
		stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   hadamard_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ1_SLOT].newres*sizeof(SHORT));
                   stretchpulse((int)res_rfsz1,(int)rfpulseInfo[RFSZ1_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                }
		res_rfsz1 = rfpulseInfo[RFSZ1_SLOT].newres;
	      }
	    else
	      {
		kernel_tab_rho = temp_wave_rho;
		hadamard_tab_rho = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));

                if (sat_pulse_type == COMPLEX_RF)
                {
                   kernel_tab_theta = temp_wave_theta;
                   hadamard_tab_theta = (SHORT *)AllocNode(res_rfsz1*sizeof(SHORT));
                }
	      }

	    if (opsatz == PSD_SATHAD)
	      { /* Hadamard sat */
		separation = satspacez1/2.0/satthickz1;
		freqstep = 65536.0/(float) res_rfsz1;

                if (sat_pulse_type == COMPLEX_RF)
                {
		   altcomplexrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, kernel_tab_theta, cyc_rfsz1,
			 separation, gscale_rfsz1, NULL,
			 (FLOAT)0, hadamard_tab_rho, hadamard_tab_theta, freqstep);
                   movewaveimm(hadamard_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                            TOHARDWARE);
                }
                else
                {
                   altrfgen((INT)TYPLINEAR, res_rfsz1, kernel_tab_rho, cyc_rfsz1,
                         separation, gscale_rfsz1, NULL,
                         (FLOAT)0, hadamard_tab_rho, freqstep);
                }

		movewaveimm(hadamard_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
	      }
	    else
	      {
		movewaveimm(kernel_tab_rho, &rfsz1, (INT)0, res_rfsz1, 
			    TOHARDWARE);

                if (sat_pulse_type == COMPLEX_RF)
                {
                   movewaveimm(kernel_tab_theta, &rfsz1Theta, (INT)0, res_rfsz1,
                              TOHARDWARE);
                }
		if (rfpulseInfo[RFSZ1_SLOT].change==PSD_ON)
                {
		   FreeNode(kernel_tab_rho);   
                   if (sat_pulse_type == COMPLEX_RF)
                   {
                      FreeNode(kernel_tab_theta);
                   }
                }
		if (opsatz == PSD_SATPARA)
		  {
		    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
		      {
			kernel_tab_rho = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
			stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_rho,kernel_tab_rho);

                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = (SHORT *)AllocNode(rfpulseInfo[RFSZ2_SLOT].newres*sizeof(SHORT));
                           stretchpulse((int)res_rfsz2,(int)rfpulseInfo[RFSZ2_SLOT].newres,temp_wave_theta,kernel_tab_theta);
                        } 

			res_rfsz2 = rfpulseInfo[RFSZ2_SLOT].newres;
		      }
		    else
                      {
		        kernel_tab_rho = temp_wave_rho; 
                        if (sat_pulse_type == COMPLEX_RF)
                        {
                           kernel_tab_theta = temp_wave_theta;
                        }
                      }

		    movewaveimm(kernel_tab_rho, &rfsz2, (INT)0, res_rfsz2, 
				TOHARDWARE); 

                    if (sat_pulse_type == COMPLEX_RF)
                    {
                       movewaveimm(kernel_tab_theta, &rfsz2Theta, (INT)0, res_rfsz2,
                                   TOHARDWARE);
                    }

		  }
	      }
	    /* Free Memory */
	    FreeNode(hadamard_tab_rho);
            if (sat_pulse_type == COMPLEX_RF)
            {
               FreeNode(hadamard_tab_theta);
            }
	    if (rfpulseInfo[RFSZ2_SLOT].change==PSD_ON)
            {
	       FreeNode(kernel_tab_rho);
               if (sat_pulse_type == COMPLEX_RF)
               {
                  FreeNode(kernel_tab_theta);
               }
            }
        }

	FreeNode(temp_wave_rho);
        if (sat_pulse_type == COMPLEX_RF)
        {
           FreeNode(temp_wave_theta);
        }
	break;
	
    default:
	break;
    }
    
    *sat_index += 1;
    
    return SUCCESS;
}

STATUS
SpSatPG_fgre( INT sat_type,
              INT start_time,
              INT *sat_index,
              INT cardiacsat_pos,
              INT seq_time )
{
    SpSatPG(sat_type, start_time, sat_index, cardiacsat_pos);
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return (SUCCESS);
    else
    {
          
  {
    pulsename(&seqsat_fgre,"seqsat_fgre");
    createseq(&seqsat_fgre,seq_time, off_seqsat_fgre);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsat_fgre );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsat_fgre = %d\n", idx_seqsat_fgre );
#endif
  }

        return (SUCCESS);
    }
}

/* Create a null sequence */
STATUS
SpSatCatRelaxPG( INT ssi_time )
{
    INT seq_time;
  
       
  {
    pulsename(&y_ccs_null,"y_ccs_null");
    createconst(&y_ccs_null,(WF_PROCESSOR)wg_y_ccs_null,pw_y_ccs_null,(short)0); 
    createinstr( &y_ccs_null,(long)(RUP_GRD(8  )),pw_y_ccs_null,0);
  }

  
    seq_time = RUP_GRD(ccs_relaxseqtime - ssi_time);
    
  {
    pulsename(&cat_seq,"cat_seq");
    createseq(&cat_seq,seq_time, off_cat_seq);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_cat_seq );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_cat_seq = %d\n", idx_cat_seq );
#endif
  }

  
    return SUCCESS;
}

STATUS
SpSatCatRelaxOffsets( SEQUENCE_ENTRIES sequence_offsets )
{
    off_cat_seq[(int)TYPXGRAD]= sequence_offsets[(int)TYPXGRAD];
    off_cat_seq[(int)TYPZGRAD]= sequence_offsets[(int)TYPZGRAD];
  
    return SUCCESS;
}

/*********************************************************************
 *                      PRESCAN.E PG SECTION                         *
 *                             PSipg                                 *
 *                                                                   *
 * Write here the functional code that loads hardware sequencer      *
 * memory with data that will allow it to play out the sequence.     *
 * These functions call pulse generation macros previously defined   *
 * with @pulsedef, and must return SUCCESS or FAILURE.               *
 *********************************************************************/
int rs_echo2toNdab[16], dtg_echo2toNdab[16];
int rs_echo2toNrba[16], dtg_echo2toNrba[16];
WF_PULSE *rs_echo2toN;
WF_PULSE *dtg_echo2toN;

short dyntg_txatten_bits[EATTEN_SSP_LENGTH_MAX];

/*
 *  PS1pulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
PS1pulsegen( INT posstart )
{
    INT postemp;
    INT ta_180, tb_180, te_180;
    INT temp_max_pw, temp_max_ypw, temp_max_zpw;

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/
         
  {
    pulsename(&rf1mps1,"rf1mps1");
    createsinc(&rf1mps1,(WF_PROCESSOR)wg_rf1mps1,res_rf1mps1,
               MAX_PG_WAMP,cyc_rf1mps1,alpha_rf1mps1);
    if ((wg_rf1mps1==TYPRHO1)||(wg_rf1mps1==TYPRHO2) ||
        (wg_rf1mps1==TYPTHETA)||(wg_rf1mps1==TYPOMEGA))
      {
        createinstr( &rf1mps1,(long)(posstart) + psd_rf_wait,
                    pw_rf1mps1,ia_rf1mps1);
        addrfbits(&rf1mps1,off_rf1mps1,(long)(posstart) + psd_rf_wait,
                  pw_rf1mps1);
      }
    else
      {
        createinstr( &rf1mps1,(long)(posstart),
                    pw_rf1mps1,ia_rf1mps1);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1mps1, "gyrf1mps1", &gyrf1mps1, &gyrf1mps1a,
                        &gyrf1mps1d, pw_gyrf1mps1, pw_gyrf1mps1a, pw_gyrf1mps1d,
                        ia_gyrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gyrf1mps1a, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */

        /* Refocus on slice gradient */
        postemp = RUP_GRD(pend(&gyrf1mps1d,"gyrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gy1mps1, "gy1mps1", &gy1mps1, &gy1mps1a,
                        &gy1mps1d, pw_gy1mps1, pw_gy1mps1a, pw_gy1mps1d,
                        ia_gy1mps1, 0, 0, 0, 0, postemp+pw_gy1mps1a-pw_gy1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gyrf1mps1, "gyrf1mps1", 0)+rfupd+pw_gx1mps1a);

    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1mps1, "gzrf1mps1", &gzrf1mps1, &gzrf1mps1a,
                        &gzrf1mps1d, pw_gzrf1mps1, pw_gzrf1mps1a, pw_gzrf1mps1d,
                        ia_gzrf1mps1, 0, 0, 0, 0, pbegall(&rf1mps1,0)-psd_rf_wait-pw_gzrf1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mps1d,"gzrf1mps1d",0));
             

  trapezoid((WF_PROCESSOR)wg_gz1mps1, "gz1mps1", &gz1mps1, &gz1mps1a,
                        &gz1mps1d, pw_gz1mps1, pw_gz1mps1a, pw_gz1mps1d,
                        ia_gz1mps1, 0, 0, 0, 0, postemp+pw_gz1mps1a-pw_gz1mps1a, TRAP_ALL,
                        &ps1loggrd);


        /* read dephaser */
        postemp = RUP_GRD(pend(&gzrf1mps1, "gzrf1mps1", 0)+rfupd+pw_gx1mps1a);
    }
         

  trapezoid((WF_PROCESSOR)wg_gx1mps1, "gx1mps1", &gx1mps1, &gx1mps1a,
                        &gx1mps1d, pw_gx1mps1, pw_gx1mps1a, pw_gx1mps1d,
                        ia_gx1mps1, 0, 0, 0, 0, postemp-pw_gx1mps1a, TRAP_ALL,
                        &ps1loggrd);


    /****** figure out minimum te from z grad, compare needed 
      time before and after 180 *********/
    if(PSD_ON == local_tg)
    {
        temp_max_ypw = pw_gyrf1mps1d + pw_gy1mps1a + pw_gy1mps1 + pw_gy1mps1d;
        temp_max_zpw = pw_gzrf2lmps1a+pw_gzrf2lmps1+pw_gzrf2lmps1d;
    }
    else
    {
        temp_max_ypw = 0;
        temp_max_zpw = pw_gzrf1mps1d + pw_gz1mps1a + pw_gz1mps1 + pw_gz1mps1d+
            pw_gzrf2lmps1a + pw_gzrf2lmps1 + pw_gzrf2lmps1d;
    }

    temp_max_pw = IMax(3, rfupd+pw_gx1mps1a+pw_gx1mps1+pw_gx1mps1d, temp_max_ypw, temp_max_zpw); 

    tb_180  =  PSoff90 + pw_rf1mps1/2 + temp_max_pw + pw_rf2mps1/2;

    ta_180  = pw_rf2mps1/2 + pw_gzrf2rmps1a + pw_gzrf2rmps1 + pw_gzrf2rmps1d
        + pw_gxwmps1/2 - psd_rf_wait + psd_grd_wait + DABSETUP;

    te_180 = RUP_GRD(2*(IMax(3, ta_180, tb_180, min180te/2)));

    postemp = RUP_GRD( (posstart + pw_rf1mps1/2 - PSoff90)
                       + (te_180/2) - pw_rf2mps1/2 );

         
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mps1", 
                                    (WF_PROCESSOR)wg_rf2mps1);

    /* Modify resolution if scaling required */
    temp_res_rf2mps1 = res_rf2mps1;
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = rfpulseInfo[RF2_APS1_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2mps1a,"gzrf2mps1a");
    pulsename(&gzrf2mps1,"gzrf2mps1");
    pulsename(&gzrf2mps1d,"gzrf2mps1d");
    pulsename(&rf2mps1,"rf2mps1");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2mps1a,ZGRAD,pw_gzrf2mps1a,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2mps1a/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2mps1a,(LONG)(postemp-pw_gzrf2mps1a),
		pw_gzrf2mps1a,ia_gzrf2mps1);
    createconst(&gzrf2mps1,ZGRAD,pw_gzrf2mps1,MAX_PG_WAMP);
    createinstr( &gzrf2mps1,(LONG)(postemp),
		pw_gzrf2mps1,ia_gzrf2mps1);
    createramp(&gzrf2mps1d,ZGRAD,pw_gzrf2mps1d,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2mps1d/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2mps1d,(LONG)(postemp+pw_gzrf2mps1),
		pw_gzrf2mps1d,ia_gzrf2mps1);
    
    /* Now create the rf pulse */
    createsinc(&rf2mps1,(WF_PROCESSOR)wg_rf2mps1,res_rf2mps1,
	       MAX_PG_WAMP,cyc_rf2mps1, alpha_rf2mps1);
    createinstr( &rf2mps1,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mps1,ia_rf2mps1);
    linkpulses(4,&rf2mps1,&gzrf2mps1,&gzrf2mps1a,
	       &gzrf2mps1d);
    addrfbits(&rf2mps1,off_rf2mps1,(LONG)(postemp) + psd_rf_wait, 
	      pw_rf2mps1);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_APS1_SLOT].change==PSD_ON)
       res_rf2mps1 = temp_res_rf2mps1;
  }


    /* crushers */
    postemp = pbeg(&gzrf2mps1,"gzrf2mps1",0) - pw_gzrf2lmps1 - pw_gzrf2lmps1d;
          

  trapezoid((WF_PROCESSOR)wg_gzrf2lmps1, "gzrf2lmps1", &gzrf2lmps1, &gzrf2lmps1a,
                        &gzrf2lmps1d, pw_gzrf2lmps1, pw_gzrf2lmps1a, pw_gzrf2lmps1d,
                        ia_gzrf2lmps1, 0, 0, 0, 0, postemp-pw_gzrf2lmps1a, TRAP_ALL,
                        &ps1loggrd);

  
           

  trapezoid((WF_PROCESSOR)wg_gzrf2rmps1, "gzrf2rmps1", &gzrf2rmps1, &gzrf2rmps1a,
                        &gzrf2rmps1d, pw_gzrf2rmps1, pw_gzrf2rmps1a, pw_gzrf2rmps1d,
                        ia_gzrf2rmps1, 0, 0, 0, 0, pendall(&gzrf2mps1,0)-pw_gzrf2rmps1a, TRAP_ALL,
                        &ps1loggrd);

  
    postemp = RUP_GRD(pmid(&gzrf2mps1,"gzrf2mps1",0)+ (te_180/2) - pw_gxwmps1/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwmps1, "gxwmps1", &gxwmps1, &gxwmps1a,
                        &gxwmps1d, pw_gxwmps1, pw_gxwmps1a, pw_gxwmps1d,
                        ia_gxwmps1, 0, 0, 0, 0, postemp-pw_gxwmps1a, TRAP_ALL,
                        &ps1loggrd);
    

        
  {
    pulsename(&echo1mps1,"echo1mps1");
    acqq(&echo1mps1, (long)(pbeg(&gxwmps1,"gxwmps1",0)+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1mps1,
        (TYPDAB_PACKETS)DABNORM);
  }


      
  {
  pulsename(&attenuator_keymps1,"attenuator_keymps1");
  createatten(&attenuator_keymps1, (long)(pend(&gxwmps1,"gxwmps1",0)));
}


      
  {
    pulsename(&seqmps1,"seqmps1");
    createseq(&seqmps1,ps1_tr, off_seqmps1);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmps1 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmps1 = %d\n", idx_seqmps1 );
#endif
  }


    return SUCCESS;
}

/*
 *  CFLpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFLpulsegen( INT posstart )
{
    INT postemp;
    INT tsamp_delay_cfl;

    tsamp_delay_cfl = RUP_GRD(1000);

    /*  90 slice sel pulse  */
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfl", 
                                    (WF_PROCESSOR)wg_rf1cfl);

    /* Modify resolution if scaling required */
    temp_res_rf1cfl = res_rf1cfl;
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = rfpulseInfo[RF1_CFL_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfla,"gzrf1cfla");
    pulsename(&gzrf1cfl,"gzrf1cfl");
    pulsename(&gzrf1cfld,"gzrf1cfld");
    pulsename(&rf1cfl,"rf1cfl");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cflloggrd.zbeta;
    createramp(&gzrf1cfla,ZGRAD,pw_gzrf1cfla,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfla/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfla,(LONG)(posstart-pw_gzrf1cfla),
		pw_gzrf1cfla,ia_gzrf1cfl);
    createconst(&gzrf1cfl,ZGRAD,pw_gzrf1cfl,MAX_PG_WAMP);
    createinstr( &gzrf1cfl,(LONG)(posstart),
		pw_gzrf1cfl,ia_gzrf1cfl);
    createramp(&gzrf1cfld,ZGRAD,pw_gzrf1cfld,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfld/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfld,(LONG)(posstart+pw_gzrf1cfl),
		pw_gzrf1cfld,ia_gzrf1cfl);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfl,(WF_PROCESSOR)wg_rf1cfl,res_rf1cfl,
	       MAX_PG_WAMP,cyc_rf1cfl, alpha_rf1cfl);
    createinstr( &rf1cfl,(LONG)(posstart) + psd_rf_wait,
		pw_rf1cfl,ia_rf1cfl);
    linkpulses(4,&rf1cfl,&gzrf1cfl,&gzrf1cfla,
	       &gzrf1cfld);
    addrfbits(&rf1cfl,off_rf1cfl,(LONG)(posstart) + psd_rf_wait, 
	      pw_rf1cfl);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFL_SLOT].change==PSD_ON)
       res_rf1cfl = temp_res_rf1cfl;
  }

  
    /* Refocusing Pulse */
        
                    

  trapezoid((WF_PROCESSOR)wg_gz1cfl, "gz1cfl", &gz1cfl, &gz1cfla,
                        &gz1cfld, pw_gz1cfl, pw_gz1cfla, pw_gz1cfld,
                        ia_gz1cfl, 0, 0, 0, 0, pbeg(&gzrf1cfl,"gzrf1cfl",0)+pw_gzrf1cfl+pw_gzrf1cfld+pw_gz1cfla-pw_gz1cfla, TRAP_ALL,
                        &cflloggrd);

  
    /* Data Acquisiton with 2K filter */
         
  {
    pulsename(&cfl_fid,"cfl_fid");
    acqq(&cfl_fid, (long)(pendall(&gz1cfl,0)+tsamp_delay_cfl),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfl_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* Assert the ESSP flag on the rf1cfl pulse */
    attenflagon(&rf1cfl, 0);

    postemp = RUP_GRD(pendall(&gz1cfl,0) + tsamp_delay_cfl + cfl_tdaq + pw_gykcfla);

     
  {
  pulsename(&cfl_attenkey,"cfl_attenkey");
  createatten(&cfl_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfl, "gykcfl", &gykcfl, &gykcfla,
                        &gykcfld, pw_gykcfl, pw_gykcfla, pw_gykcfld,
                        ia_gykcfl, 0, 0, 0, 0, postemp-pw_gykcfla, TRAP_ALL,
                        &cflloggrd);

  
      
  {
    pulsename(&seqcfl,"seqcfl");
    createseq(&seqcfl,cfl_tr, off_seqcfl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfl = %d\n", idx_seqcfl );
#endif
  }


    return SUCCESS;
}

/*
 *  RCVNpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
RCVNpulsegen( INT posstart )
{
    INT postemp, postemp2;
    INT tsamp_delay_rcvn;
    INT unblank_delay_rcvn;

    /* MRIhc47602/MRIhc47515/GEHmr03545 */
    if ( (rcvn_flag == 1) || (rcvn_flag == 3) )
    {
               

  trapezoid((WF_PROCESSOR)wg_gxkrcvn, "gxkrcvn", &gxkrcvn, &gxkrcvna,
                        &gxkrcvnd, pw_gxkrcvn, pw_gxkrcvna, pw_gxkrcvnd,
                        ia_gxkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gxkrcvna)-pw_gxkrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gykrcvn, "gykrcvn", &gykrcvn, &gykrcvna,
                        &gykrcvnd, pw_gykrcvn, pw_gykrcvna, pw_gykrcvnd,
                        ia_gykrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gykrcvna)-pw_gykrcvna, TRAP_ALL,
                        &rcvnloggrd);

               

  trapezoid((WF_PROCESSOR)wg_gzkrcvn, "gzkrcvn", &gzkrcvn, &gzkrcvna,
                        &gzkrcvnd, pw_gzkrcvn, pw_gzkrcvna, pw_gzkrcvnd,
                        ia_gzkrcvn, 0, 0, 0, 0, RUP_GRD(posstart+pw_gzkrcvna)-pw_gzkrcvna, TRAP_ALL,
                        &rcvnloggrd);


        if(3 == rcvn_flag)   /* Additional gradient waveform for Grad prognostic */
        {
            long ctrl_word;

               
  {
    pulsename(&grd_trig,"grd_trig");
    createconst(&grd_trig,(WF_PROCESSOR)wg_grd_trig,pw_grd_trig,(short)0); 
    createinstr( &grd_trig,(long)(posstart),pw_grd_trig,0);
  }

            getctrl(&ctrl_word, &grd_trig, 0);
            ctrl_word = ctrl_word | PSD_GRADR_SYNC;
            setctrl(ctrl_word, &grd_trig, 0);
            posstart = RUP_GRD(pendallssp(&grd_trig, 0)); 

            postemp = RUP_GRD(pend(&gxkrcvnd,"gxkrcvnd",0) + pw_gxk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gxk2rcvn, "gxk2rcvn", &gxk2rcvn, &gxk2rcvna,
                        &gxk2rcvnd, pw_gxk2rcvn, pw_gxk2rcvna, pw_gxk2rcvnd,
                        ia_gxk2rcvn, 0, 0, 0, 0, postemp-pw_gxk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gykrcvnd,"gykrcvnd",0) + pw_gyk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gyk2rcvn, "gyk2rcvn", &gyk2rcvn, &gyk2rcvna,
                        &gyk2rcvnd, pw_gyk2rcvn, pw_gyk2rcvna, pw_gyk2rcvnd,
                        ia_gyk2rcvn, 0, 0, 0, 0, postemp-pw_gyk2rcvna, TRAP_ALL,
                        &rcvnloggrd);


            postemp = RUP_GRD(pend(&gzkrcvnd,"gzkrcvnd",0) + pw_gzk2rcvna);
                 

  trapezoid((WF_PROCESSOR)wg_gzk2rcvn, "gzk2rcvn", &gzk2rcvn, &gzk2rcvna,
                        &gzk2rcvnd, pw_gzk2rcvn, pw_gzk2rcvna, pw_gzk2rcvnd,
                        ia_gzk2rcvn, 0, 0, 0, 0, postemp-pw_gzk2rcvna, TRAP_ALL,
                        &rcvnloggrd);

        }
    }
    else if ( rcvn_flag == 2 ) /* extra delay before rcvn */
    {
        
  {
    pulsename(&rcvn_wait,"rcvn_wait");
    createconst(&rcvn_wait,(WF_PROCESSOR)wg_rcvn_wait,pw_rcvn_wait,(short)0); 
    createinstr( &rcvn_wait,(long)(RUP_GRD(posstart)),pw_rcvn_wait,0);
  }

    }
      
  {
    pulsename(&pre_rcvn,"pre_rcvn");
    createseq(&pre_rcvn,RUP_GRD(pre_rcvn_tr+posstart), off_pre_rcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_pre_rcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_pre_rcvn = %d\n", idx_pre_rcvn );
#endif
  }


    unblank_delay_rcvn = RUP_GRD(1000);
    tsamp_delay_rcvn = RUP_GRD(2000);

    /* RCVRUNBLANK & RCVRBLANK mechanism is normally taken care 
       of by the RF pulse itself. However RCVN entry point does
       not have any RF pulse so we wrap data acqusition window. */

    /* Unblank receiver before Data Acquisition window */
    
  {
    rcvrbl_pack[0] = SSPDS+RDC;
    rcvrbl_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl_pack[2] = SSPD+RUBL;
    rcvrbl_pack[3] = SSPDS;

    pulsename(&rcvrbl,"rcvrbl");
    createbits(&rcvrbl,TYPSSP,4,rcvrbl_pack);
    createinstr( &rcvrbl,(long)(unblank_delay_rcvn),4,ia_rcvrbl);
  }

  
    /* Data Acquisiton with 2K filter */
       
  {
    pulsename(&rcvn_fid,"rcvn_fid");
    acqq(&rcvn_fid, (long)(tsamp_delay_rcvn),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_rcvn_fid,
        (TYPDAB_PACKETS)DABNORM);
  }


    postemp  = RUP_GRD(tsamp_delay_rcvn + rcvn_tdaq);
    postemp2 = RUP_GRD(unblank_delay_rcvn + postemp);

     
  {
  pulsename(&rcvn_attenkey,"rcvn_attenkey");
  createatten(&rcvn_attenkey, (long)(postemp));
}


    /* Blank receiver after Data Acquisition is completed */
    
  {
    rcvrbl2_pack[0] = SSPDS+RDC;
    rcvrbl2_pack[1] = SSPOC+RFUBL+RSEL_ALL;
    rcvrbl2_pack[2] = SSPD+RBL;
    rcvrbl2_pack[3] = SSPDS;

    pulsename(&rcvrbl2,"rcvrbl2");
    createbits(&rcvrbl2,TYPSSP,4,rcvrbl2_pack);
    createinstr( &rcvrbl2,(long)(postemp2),4,ia_rcvrbl2);
  }

  
      
  {
    pulsename(&seqrcvn,"seqrcvn");
    createseq(&seqrcvn,rcvn_tr, off_seqrcvn);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrcvn );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrcvn = %d\n", idx_seqrcvn );
#endif
  }


    return SUCCESS;
}

/*
 *  CFHpulsegen
 *  
 *  Type: Private Function
 *  
 *  Description:
 *  
 */
STATUS
CFHpulsegen( INT posstart )
{
    INT postemp;
    INT cfh_te;   /* Run at operator TE unless below min cfh te.
                     Then run at min cfh te */
    INT cfh_te2;   /* vmx 05/02/95 YO */
    INT cfh_acq_window_pos;   /* vmx 05/02/94 YO */
    INT tsamp_delay_cfh;
    INT start_time = 0;
    INT start_time_CS = 0;
    INT start_time_MT = 0;
    INT pos_rf2;
    INT newcfh_tr;

    /* variables for presscfh */
    INT pos_rf3 = 0;
    INT pos_rf4 = 0;

    tsamp_delay_cfh = RUP_GRD(1000);

    start_time = posstart;
    start_time_MT = posstart;
    start_time_CS = posstart;

    /* Check for CFH Inversion inclusion */
    if (PSD_ON == PSir)
    {
        /* adiabatic pulse */
           
                       
                        
                          
                       
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf0cfh", 
                                     (WF_PROCESSOR)wg_rf0cfh);

    /* First create the pulses */
    pulsename(&gzrf0cfha,"gzrf0cfha");
    pulsename(&gzrf0cfh,"gzrf0cfh");
    pulsename(&gzrf0cfhd,"gzrf0cfhd");
    pulsename(&rf0cfh,"rf0cfh");

    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf0cfha,ZGRAD,pw_gzrf0cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf0cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfha,(LONG)(posstart-pw_gzrf0cfha),
		pw_gzrf0cfha,ia_gzrf0cfh);
    if ( 0 == PLAY_GFILE)
      {
	/*********************************************************************** 
	 ** Now create the waveform & perform required system safety checks
	 ** create a temporary buffer to modify gradient data using createreserve. Here
	 ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the waveform and
	 ** copy stretched data into permanent waveform memory. It is important to
	 ** to have temp buffer have new resolution size waveform memory.
	 ************************************************************************/
	if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
	  {
	    createreserve(&gzrf0cfh,ZGRAD,rfpulseInfo[RF0_CFH_SLOT].newres/2);
	    /********************************************************************* 
	     * Change pulse type to external createreserve zero fills resolution
	     * number of points in waveform memory for use.
	     ********************************************************************/
	    gzrf0cfh.type = TYPEXTERNAL;
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);

                movestretchedwave( grad_zrf0cfh, res_gzrf0cfh,
                                   &gzrf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres/2 );
	  }
	else
	  {
	    createextwave(&gzrf0cfh,ZGRAD, 
			  res_gzrf0cfh, grad_zrf0cfh);
	    createinstr(&gzrf0cfh,(LONG)(posstart),
			pw_gzrf0cfh,ia_gzrf0cfh);
	  }
      }
    else
      {
	createconst(&gzrf0cfh,ZGRAD, pw_rf0cfh,MAX_PG_WAMP);
	createinstr( &gzrf0cfh,(LONG)(posstart),
		    pw_gzrf0cfh,ia_gzrf0cfh);
      }
    /* Decay ramp */
    createramp(&gzrf0cfhd,ZGRAD,pw_gzrf0cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf0cfhd/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf0cfhd,(LONG)(posstart+pw_gzrf0cfh),
		pw_gzrf0cfhd,ia_gzrf0cfh);
    
    /*********************************************************************** 
    ** Now create the rf pulse & perform required system safety checks
    ** create a temporary buffer to modify rfpulse data using createsinc. Here
    ** the values of cyc_rf and alpha_rf are irrelevant. Stretch the pulse and
    ** copy stretched data into permanent waveform memory. It is important to
    ** to have temp buffer have new resolution size waveform memory.
    ************************************************************************/
    if (rfpulseInfo[RF0_CFH_SLOT].change==PSD_ON)
      {
	cyc_rf0cfh = 1.0; /* Make sure we have a value for createsinc */
	createsinc(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,rfpulseInfo[RF0_CFH_SLOT].newres,
		   MAX_PG_WAMP,cyc_rf0cfh,alpha_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);

            movestretchedwave( rf_rf0cfh, res_rf0cfh,
                               &rf0cfh, 0, rfpulseInfo[RF0_CFH_SLOT].newres );
      }
    else
      {
	/* No rf scaling required. Use createextwave to read pulse 
	 * and move to HW 
	 */
	createextwave(&rf0cfh,(WF_PROCESSOR)wg_rf0cfh,
		      res_rf0cfh,rf_rf0cfh);
	createinstr(&rf0cfh,(LONG)(posstart) + psd_rf_wait,
		    pw_rf0cfh,ia_rf0cfh);
	linkpulses(4,&rf0cfh,&gzrf0cfh,&gzrf0cfha,
		   &gzrf0cfhd);
	addrfbits(&rf0cfh,off_rf0cfh,(LONG)(posstart) + psd_rf_wait,
		  pw_rf0cfh);
      }
}


           
                   
  {
        INT old_res =  res_omegarf0cfh; /* temp holder for old pulse resolution */

    if ( (wg_omegarf0cfh != TYPRHO1)  && (wg_omegarf0cfh != TYPRHO2) &&
         (wg_omegarf0cfh != TYPTHETA) && (wg_omegarf0cfh != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_omegarf0cfh += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( omegarf0cfh.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&omegarf0cfh,"omegarf0cfh");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_omegarf0cfh].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_omegarf0cfh].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&omegarf0cfh, (WF_PROCESSOR)wg_omegarf0cfh, new_res);

                movestretchedwave( fileloc_omegarf0cfh, old_res,
                                   &omegarf0cfh, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_omegarf0cfh = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&omegarf0cfh,(WF_PROCESSOR)wg_omegarf0cfh,
                          old_res,fileloc_omegarf0cfh);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &omegarf0cfh,(LONG)(posstart) + psd_rf_wait, 
                 pw_omegarf0cfh,ia_omegarf0cfh);
    

    /*** Add RF Bits ***/
    addrfbits(&omegarf0cfh,off_omegarf0cfh,(LONG)(posstart) + psd_rf_wait,
              pw_omegarf0cfh);
    

    /*** Reset Resolution ***/
    res_omegarf0cfh = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


           
                     

  trapezoid((WF_PROCESSOR)wg_gyrf0kcfh, "gyrf0kcfh", &gyrf0kcfh, &gyrf0kcfha,
                        &gyrf0kcfhd, pw_gyrf0kcfh, pw_gyrf0kcfha, pw_gyrf0kcfhd,
                        ia_gyrf0kcfh, 0, 0, 0, 0, pend(&gzrf0cfh,"gzrf0cfh",0)+pw_gyrf0kcfha-pw_gyrf0kcfha, TRAP_ALL,
                        &cfhloggrd);

    
        /* Setting up WAIT duration */
        /* 1ms is added at the end so that ssp sequencer has no overlap 
           as 'frq', and RF amp unblank pulses are played. */
        dur_invse = RUP_GRD(cfh_ti - pw_rf0cfh/2 - pw_gyrf0kcfha - pw_gyrf0kcfh 
                            - pw_gyrf0kcfhd  - pw_gzrf1cfha - pw_rf1cfh/2 - 1000);
#ifdef PSD_CFH_CHEMSAT
        if ((cs_sat == PSD_ON) && PScs_sat)
        {
            /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
            dur_invse -= RUP_GRD(cs_sattime - specir_delay);
#else
            dur_invse -= RUP_GRD(cs_sattime);
#endif
        }
#endif
        dur_invse = RUP_GRD(dur_invse);

        
  {
    pulsename(&zticfh,"zticfh");
    createconst(&zticfh,(WF_PROCESSOR)wg_zticfh,pw_zticfh,(short)0); 
    createinstr( &zticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_zticfh,0);
  }

        
  {
    pulsename(&rticfh,"rticfh");
    createconst(&rticfh,(WF_PROCESSOR)wg_rticfh,pw_rticfh,(short)0); 
    createinstr( &rticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_rticfh,0);
  }

        
  {
    pulsename(&xticfh,"xticfh");
    createconst(&xticfh,(WF_PROCESSOR)wg_xticfh,pw_xticfh,(short)0); 
    createinstr( &xticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_xticfh,0);
  }

        
  {
    pulsename(&yticfh,"yticfh");
    createconst(&yticfh,(WF_PROCESSOR)wg_yticfh,pw_yticfh,(short)0); 
    createinstr( &yticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_yticfh,0);
  }

        
  {
    pulsename(&sticfh,"sticfh");
    createconst(&sticfh,(WF_PROCESSOR)wg_sticfh,pw_sticfh,(short)0); 
    createinstr( &sticfh,(long)(pend(&gyrf0kcfhd,"gyrf0kcfhd",0)),pw_sticfh,0);
  }

    
        setperiod(dur_invse,&zticfh,0);
        setperiod(dur_invse,&rticfh,0);
        setperiod(dur_invse,&xticfh,0);
        setperiod(dur_invse,&yticfh,0);
        setperiod(dur_invse,&sticfh,0);
    
        /* Change start time for the 90 180 sequence; pw_gzrf1cfha added to 
           offset start_time calc in rf1cfh call */
        start_time    = pmid(&gzrf0cfh,"gzrf0cfh",0) + cfh_ti - pw_rf1cfh/2;
        start_time_MT = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;
        start_time_CS = pend(&gyrf0kcfhd,"gyrf0kcfhd",0) + dur_invse + 300  ;

        amp_gyrf0kcfh = ia_gyrf0kcfh;
    }
    /* End of IR sequence check */
  
  

#ifdef PSD_CFH_CHEMSAT
    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        ChemSatPG(start_time_CS, &cscfh_satindex);
        cscfh_satindex -= 1;
    }
    if( (PSir != PSD_ON) && ( ((oppseq!=PSD_IR)
                               || (ssfse_ir_on == PSD_OFF)) && PScs_sat ) )
    {
        /* MRIge30640 - already caught in SLICESELZ2 call below! */
        /* GEHmr03577 : Subtract specir_delay in case of SPECIAL. */
#ifdef PSD_CFH_CHEMSAT_SPECIAL
        start_time += (cs_sattime - specir_delay);
#else
        start_time += cs_sattime;
#endif
    }
#endif
  
    /*  90 slice sel pulse  */
       
                 
                        
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1cfh", 
                                    (WF_PROCESSOR)wg_rf1cfh);

    /* Modify resolution if scaling required */
    temp_res_rf1cfh = res_rf1cfh;
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = rfpulseInfo[RF1_CFH_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1cfha,"gzrf1cfha");
    pulsename(&gzrf1cfh,"gzrf1cfh");
    pulsename(&gzrf1cfhd,"gzrf1cfhd");
    pulsename(&rf1cfh,"rf1cfh");
    
    /*  Now create the slice select trapezoid */
	pg_beta = cfhloggrd.zbeta;
    createramp(&gzrf1cfha,ZGRAD,pw_gzrf1cfha,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1cfha/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1cfha,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)-pw_gzrf1cfha),
		pw_gzrf1cfha,ia_gzrf1cfh);
    createconst(&gzrf1cfh,ZGRAD,pw_gzrf1cfh,MAX_PG_WAMP);
    createinstr( &gzrf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)),
		pw_gzrf1cfh,ia_gzrf1cfh);
    createramp(&gzrf1cfhd,ZGRAD,pw_gzrf1cfhd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1cfhd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1cfhd,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)+pw_gzrf1cfh),
		pw_gzrf1cfhd,ia_gzrf1cfh);
    
    /* Now create the rf pulse */
    createsinc(&rf1cfh,(WF_PROCESSOR)wg_rf1cfh,res_rf1cfh,
	       MAX_PG_WAMP,cyc_rf1cfh, alpha_rf1cfh);
    createinstr( &rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait,
		pw_rf1cfh,ia_rf1cfh);
    linkpulses(4,&rf1cfh,&gzrf1cfh,&gzrf1cfha,
	       &gzrf1cfhd);
    addrfbits(&rf1cfh,off_rf1cfh,(LONG)(RUP_GRD(start_time+pw_gzrf1cfha)) + psd_rf_wait, 
	      pw_rf1cfh);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_CFH_SLOT].change==PSD_ON)
       res_rf1cfh = temp_res_rf1cfh;
  }


    if(PSfield_strength <= B0_5000)
    {

        cfh_te = (int)(0.5 * pw_rf1cfh + PSoff90 + pw_rf2cfh
                       + IMax(2, min_ssp,
                              (pw_gzrf1cfhd + pw_gzrf2lcfha
                               + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                       + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd
                       + (cfh_tdaq  * cfh_ec_position));

        cfh_te2 = (int)((IMax(2, min_ssp,
                         (pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd
                          + pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd))
                    + pw_rf2cfh)/ 2
                   + (cfh_tdaq * cfh_ec_position));
        cfh_te2 *= 2;

        cfh_te = IMax(3, cfh_te, cfh_te2, min180te);

        pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
    }
    else
    {
        if( presscfh_ctrl == PRESSCFH_NONE )
        {
            cfh_te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90
                            + IMax(2, min_ssp,
                                   (pw_gzrf1cfhd + pw_gzrf2lcfha
                                    + pw_gzrf2lcfh + pw_gzrf2lcfhd)));
            if (opspf == 0)
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }
            else
            {
                cfh_te = 2*IMax(3, cfh_te, pw_gyrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);
            }

            /* MRIge90312 - use 50ms TE for cfh */
            cfh_te = IMax(3, cfh_te, min180te, eff_cfh_te);

            pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                    + 0.5 * cfh_te - 0.5 * pw_rf2cfh));
        }
        else
        {
            int temp_time = 0;

            cfh_te = IMax(2, presscfh_minte, eff_cfh_te);
            if( cfh_steam_flag != PSD_ON )
            {
                int echo1te = 0;

                echo1te =  (int)(0.5 * (pw_rf1cfh + pw_rf2cfh) + PSoff90 +
                                 IMax(2, min_ssp, (pw_gzrf1cfhd + pw_gzrf2lcfha + pw_gzrf2lcfh + pw_gzrf2lcfhd))
                                 + presscfh_wait_rf12);

                echo1te = 2*IMax(3, echo1te, pw_gxrf2cfhd, pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd);

                echo1te = IMax(2, echo1te, min180te);
                pos_rf2 = RDN_GRD((int)(pmid(&gzrf1cfh,"gzrf1cfh", 0) - PSoff90 
                                        + 0.5 * echo1te - 0.5 * pw_rf2cfh));

                if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
                {
                    temp_time = IMax(2, pw_gyrf3cfha, pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                    cfh_te = IMax(2, 2*temp_time + echo1te + pw_rf3cfh, cfh_te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*cfh_te - 0.5*pw_rf3cfh));
                }
                else
                {
                    int echo2te = 0;    /* interval from echo1 center to echo2 center, not from RF1 to echo2 center */
                    int echo3te = 0;    /* interval from echo2 center to echo3 center, not from RF1 to echo3 center */

                    /* Calculate the position of RF3 */
                    echo2te = (int)(0.5 * pw_rf3cfh
                                    + IMax(3, min_ssp, pw_gyrf3cfha, (pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd))
                                    + presscfh_wait_rf23);
                    echo2te = 2*echo2te;
                    echo2te = IMax(2, echo2te, min180te);

                    pos_rf3 = RDN_GRD((int)(pos_rf2 + 0.5*pw_gxrf2cfh + 0.5*echo1te + 0.5*echo2te - 0.5*pw_rf3cfh));

                    /* Calculate the position of RF4 */
                    echo3te = (int)(0.5 * pw_rf4cfh + pw_gzrf4cfha + pw_isislice + pw_rotslice + isi_sliceextra
                                    + min_ssp + pw_gzrf4lcfha + pw_gzrf4lcfh + pw_gzrf4lcfhd
                                    + presscfh_wait_rf34);

                    echo3te = 2*echo3te;
                    echo3te = IMax(2, echo3te, min180te);

                    cfh_te = IMax(2, echo1te + echo2te + echo3te, cfh_te);
                    pos_rf4 = RDN_GRD((int)(pos_rf3 + 0.5*pw_rf3cfh + 0.5*(cfh_te-echo1te) - 0.5*pw_rf4cfh));
                }
            }
            else
            {
                int mix_time = 0;

                temp_time = IMax(2, 2*min_ssp,  pw_gzrf2rcfha + pw_gzrf2rcfh + pw_gzrf2rcfhd 
                                 + steam_pg_gap + pw_gzrf3lcfha + pw_gzrf3lcfh + pw_gzrf3lcfhd);
                mix_time = RUP_GRD(0.5 * (pw_gxrf2cfh + pw_gyrf3cfh) + temp_time);

                pos_rf2 = RUP_GRD( pmid(&gzrf1cfh,"gzrf1cfh",0) + 0.5*cfh_te - 0.5*pw_gxrf2cfh );
                pos_rf3 = RUP_GRD( pos_rf2 + 0.5*pw_gxrf2cfh + mix_time - 0.5*pw_gyrf3cfh );
            }
        }
    }

    if (rfpulseInfo[RF2_CFH_SLOT].change==PSD_ON)
    {
        res_rf2cfh = rfpulseInfo[RF2_CFH_SLOT].newres;
    }

         
  {
    pulsename(&rf2cfh,"rf2cfh");
    createsinc(&rf2cfh,(WF_PROCESSOR)wg_rf2cfh,res_rf2cfh,
               MAX_PG_WAMP,cyc_rf2cfh,alpha_rf2cfh);
    if ((wg_rf2cfh==TYPRHO1)||(wg_rf2cfh==TYPRHO2) ||
        (wg_rf2cfh==TYPTHETA)||(wg_rf2cfh==TYPOMEGA))
      {
        createinstr( &rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                    pw_rf2cfh,ia_rf2cfh);
        addrfbits(&rf2cfh,off_rf2cfh,(long)(pos_rf2) + psd_rf_wait,
                  pw_rf2cfh);
      }
    else
      {
        createinstr( &rf2cfh,(long)(pos_rf2),
                    pw_rf2cfh,ia_rf2cfh);
      }
  }

    if( presscfh_ctrl != PRESSCFH_NONE )  /* for presscfh_ctrl */
    {
               
  {
    pulsename(&rf3cfh,"rf3cfh");
    createsinc(&rf3cfh,(WF_PROCESSOR)wg_rf3cfh,res_rf3cfh,
               MAX_PG_WAMP,cyc_rf3cfh,alpha_rf3cfh);
    if ((wg_rf3cfh==TYPRHO1)||(wg_rf3cfh==TYPRHO2) ||
        (wg_rf3cfh==TYPTHETA)||(wg_rf3cfh==TYPOMEGA))
      {
        createinstr( &rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                    pw_rf3cfh,ia_rf3cfh);
        addrfbits(&rf3cfh,off_rf3cfh,(long)(pos_rf3) + psd_rf_wait,
                  pw_rf3cfh);
      }
    else
      {
        createinstr( &rf3cfh,(long)(pos_rf3),
                    pw_rf3cfh,ia_rf3cfh);
      }
  }
  
        if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
                 
  {
    pulsename(&rf4cfh,"rf4cfh");
    createsinc(&rf4cfh,(WF_PROCESSOR)wg_rf4cfh,res_rf4cfh,
               MAX_PG_WAMP,cyc_rf4cfh,alpha_rf4cfh);
    if ((wg_rf4cfh==TYPRHO1)||(wg_rf4cfh==TYPRHO2) ||
        (wg_rf4cfh==TYPTHETA)||(wg_rf4cfh==TYPOMEGA))
      {
        createinstr( &rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                    pw_rf4cfh,ia_rf4cfh);
        addrfbits(&rf4cfh,off_rf4cfh,(long)(pos_rf4) + psd_rf_wait,
                  pw_rf4cfh);
      }
    else
      {
        createinstr( &rf4cfh,(long)(pos_rf4),
                    pw_rf4cfh,ia_rf4cfh);
      }
  }

        }
    } 

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TE = %d\n", cfh_te);
	printf("CFH : Mid Position of rf2cfh = %d\n", (int)(pos_rf2+pw_rf2cfh/2));
    }

    /* FOV selective gradients */
    if (opspf == 0 || presscfh_ctrl != PRESSCFH_NONE)
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gxrf2cfh, "gxrf2cfh", &gxrf2cfh, &gxrf2cfha,
                        &gxrf2cfhd, pw_gxrf2cfh, pw_gxrf2cfha, pw_gxrf2cfhd,
                        ia_gxrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gxrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    else
    {
             
                    

  trapezoid((WF_PROCESSOR)wg_gyrf2cfh, "gyrf2cfh", &gyrf2cfh, &gyrf2cfha,
                        &gyrf2cfhd, pw_gyrf2cfh, pw_gyrf2cfha, pw_gyrf2cfhd,
                        ia_gyrf2cfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-psd_rf_wait-pw_gyrf2cfha, TRAP_ALL,
                        &cfhloggrd);

    }
    
    /* Z crushers */
        
                      

  trapezoid((WF_PROCESSOR)wg_gzrf2lcfh, "gzrf2lcfh", &gzrf2lcfh, &gzrf2lcfha,
                        &gzrf2lcfhd, pw_gzrf2lcfh, pw_gzrf2lcfha, pw_gzrf2lcfhd,
                        ia_gzrf2lcfh, 0, 0, 0, 0, pbegall(&rf2cfh,0)-(pw_gzrf2lcfh+pw_gzrf2lcfhd)-psd_rf_wait-pw_gzrf2lcfha, TRAP_ALL,
                        &cfhloggrd);

         
                  

  trapezoid((WF_PROCESSOR)wg_gzrf2rcfh, "gzrf2rcfh", &gzrf2rcfh, &gzrf2rcfha,
                        &gzrf2rcfhd, pw_gzrf2rcfh, pw_gzrf2rcfha, pw_gzrf2rcfhd,
                        ia_gzrf2rcfh, 0, 0, 0, 0, pendall(&rf2cfh,0)+pw_gzrf2rcfha-psd_rf_wait-pw_gzrf2rcfha, TRAP_ALL,
                        &cfhloggrd);


   if( presscfh_ctrl != PRESSCFH_NONE )
   {
             
                        

  trapezoid((WF_PROCESSOR)wg_gyrf3cfh, "gyrf3cfh", &gyrf3cfh, &gyrf3cfha,
                        &gyrf3cfhd, pw_gyrf3cfh, pw_gyrf3cfha, pw_gyrf3cfhd,
                        ia_gyrf3cfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-psd_rf_wait-pw_gyrf3cfha, TRAP_ALL,
                        &cfhloggrd);


        /* Z crushers */
            
                          

  trapezoid((WF_PROCESSOR)wg_gzrf3lcfh, "gzrf3lcfh", &gzrf3lcfh, &gzrf3lcfha,
                        &gzrf3lcfhd, pw_gzrf3lcfh, pw_gzrf3lcfha, pw_gzrf3lcfhd,
                        ia_gzrf3lcfh, 0, 0, 0, 0, pbegall(&rf3cfh,0)-(pw_gzrf3lcfh+pw_gzrf3lcfhd)-psd_rf_wait-pw_gzrf3lcfha, TRAP_ALL,
                        &cfhloggrd);

             
                      

  trapezoid((WF_PROCESSOR)wg_gzrf3rcfh, "gzrf3rcfh", &gzrf3rcfh, &gzrf3rcfha,
                        &gzrf3rcfhd, pw_gzrf3rcfh, pw_gzrf3rcfha, pw_gzrf3rcfhd,
                        ia_gzrf3rcfh, 0, 0, 0, 0, pendall(&rf3cfh,0)+pw_gzrf3rcfha-psd_rf_wait-pw_gzrf3rcfha, TRAP_ALL,
                        &cfhloggrd);


        /* steam_flag */
        if( cfh_steam_flag == PSD_ON ){
            INT pos_g1cfh = 0;
            pos_g1cfh = RUP_GRD( pbeg(&gzrf2lcfh, "gzrf2lcfh", 0) - pw_gzrf2lcfha 
                                 - pw_gy1cfh - pw_gy1cfhd );
                 

  trapezoid((WF_PROCESSOR)wg_gy1cfh, "gy1cfh", &gy1cfh, &gy1cfha,
                        &gy1cfhd, pw_gy1cfh, pw_gy1cfha, pw_gy1cfhd,
                        ia_gy1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gy1cfha, TRAP_ALL,
                        &cfhloggrd);

            pos_g1cfh = RUP_GRD( pend(&gzrf3rcfh, "gzrf3rcfh", 0) + pw_gzrf3rcfhd + pw_gx1cfha );
                 

  trapezoid((WF_PROCESSOR)wg_gx1cfh, "gx1cfh", &gx1cfh, &gx1cfha,
                        &gx1cfhd, pw_gx1cfh, pw_gx1cfha, pw_gx1cfhd,
                        ia_gx1cfh, 0, 0, 0, 0, pos_g1cfh-pw_gx1cfha, TRAP_ALL,
                        &cfhloggrd);

        }
        else if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
        {
            INT pos_isislice1 = 0;
            INT pos_isislice2 = 0;
            long ctrl_word;

                
                            

  trapezoid((WF_PROCESSOR)wg_gzrf4cfh, "gzrf4cfh", &gzrf4cfh, &gzrf4cfha,
                        &gzrf4cfhd, pw_gzrf4cfh, pw_gzrf4cfha, pw_gzrf4cfhd,
                        ia_gzrf4cfh, 0, 0, 0, 0, pbegall(&rf4cfh,0)-psd_rf_wait-pw_gzrf4cfha, TRAP_ALL,
                        &loggrd);


            pos_isislice1 = pbegallssp(&rf4cfh, 0) - pw_gzrf4cfha - pw_isislice - pw_rotslice - isi_sliceextra;
               
  {
    pulsename(&isi_slice1,"isi_slice1");
    createconst(&isi_slice1,(WF_PROCESSOR)wg_isi_slice1,pw_isi_slice1,(short)0); 
    createinstr( &isi_slice1,(long)(pos_isislice1),pw_isi_slice1,0);
  }

            getctrl(&ctrl_word, &isi_slice1, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice1, 0);

               
  {
    pulsename(&rot_slice1,"rot_slice1");
    createconst(&rot_slice1,(WF_PROCESSOR)wg_rot_slice1,pw_rot_slice1,(short)0); 
    createinstr( &rot_slice1,(long)(pos_isislice1+pw_isislice),pw_rot_slice1,0);
  }

            getctrl(&ctrl_word, &rot_slice1, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice1, 0);

            pos_isislice2 = pendallssp(&rf4cfh, 0) + pw_gzrf4cfhd;
               
  {
    pulsename(&isi_slice2,"isi_slice2");
    createconst(&isi_slice2,(WF_PROCESSOR)wg_isi_slice2,pw_isi_slice2,(short)0); 
    createinstr( &isi_slice2,(long)(pos_isislice2),pw_isi_slice2,0);
  }

            getctrl(&ctrl_word, &isi_slice2, 0);
            ctrl_word = ctrl_word | PSD_ISI_CFH ;
            setctrl(ctrl_word, &isi_slice2, 0);

               
  {
    pulsename(&rot_slice2,"rot_slice2");
    createconst(&rot_slice2,(WF_PROCESSOR)wg_rot_slice2,pw_rot_slice2,(short)0); 
    createinstr( &rot_slice2,(long)(pos_isislice2+pw_isislice),pw_rot_slice2,0);
  }

            getctrl(&ctrl_word, &rot_slice2, 0);
            ctrl_word = ctrl_word | PSD_MTX_UPDT;
            setctrl(ctrl_word, &rot_slice2, 0);
            
            /* Z crushers */
                    
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4lcfh, "gzrf4lcfh", &gzrf4lcfh, &gzrf4lcfha,
                        &gzrf4lcfhd, pw_gzrf4lcfh, pw_gzrf4lcfha, pw_gzrf4lcfhd,
                        ia_gzrf4lcfh, 0, 0, 0, 0, RDN_GRD(pos_isislice1-(pw_gzrf4lcfh+pw_gzrf4lcfhd)-psd_rf_wait)-pw_gzrf4lcfha, TRAP_ALL,
                        &cfhloggrd);

                        
                        

  trapezoid((WF_PROCESSOR)wg_gzrf4rcfh, "gzrf4rcfh", &gzrf4rcfh, &gzrf4rcfha,
                        &gzrf4rcfhd, pw_gzrf4rcfh, pw_gzrf4rcfha, pw_gzrf4rcfhd,
                        ia_gzrf4rcfh, 0, 0, 0, 0, RUP_GRD(pos_isislice2+pw_isislice+pw_rotslice+isi_sliceextra+pw_gzrf4rcfha-psd_rf_wait)-pw_gzrf4rcfha, TRAP_ALL,
                        &cfhloggrd);


        }
    }

    /* Data Acquisiton with .5K/.25k filter */
    if(PSfield_strength <= B0_5000)	/* vmx 05/02/94 */
    {
	cfh_acq_window_pos = RUP_GRD( (int)(pmid(&gzrf1cfh,"gzrf1cfh", 0)
                                            + cfh_te - (cfh_tdaq * cfh_ec_position)));
    }
    else
    {
       if( presscfh_ctrl == PRESSCFH_NONE )
       {
	    cfh_acq_window_pos = RUP_GRD(pendall(&gzrf2rcfh,0) + tsamp_delay_cfh);
       }
       else
       {
           if( cfh_steam_flag != PSD_ON )
           {
               if( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE )
               {
	        cfh_acq_window_pos = RUP_GRD(pendall(&gzrf3rcfh,0) + tsamp_delay_cfh);
               }
               else
               {
                   cfh_acq_window_pos = RUP_GRD(pendall(&gzrf4rcfh,0) + tsamp_delay_cfh);
               }
           }
           else
           {
                cfh_acq_window_pos = RUP_GRD(pendall(&gx1cfh,0) + tsamp_delay_cfh);
            }
        }
    }

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : Start of data window = %d\n", cfh_acq_window_pos);
    }

          
  {
    pulsename(&cfh_fid,"cfh_fid");
    acqq(&cfh_fid, (long)(cfh_acq_window_pos),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_cfh_fid,
        (TYPDAB_PACKETS)DABNORM);
  }

    /* vmx 05/02/05 YO */
    /* Assert the ESSP flag on the rf1cfh  and rf2cfh pulse */
    attenflagon(&rf1cfh, 0);  
    attenflagon(&rf2cfh, 0);
    if(presscfh_ctrl != PRESSCFH_NONE)
   {
        attenflagon(&rf3cfh, 0); /* for presscfh */
       if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
       {
           attenflagon(&rf4cfh, 0);
       }
   }

    postemp = RUP_GRD(cfh_acq_window_pos + cfh_tdaq + pw_gykcfha);
     
  {
  pulsename(&cfh_attenkey,"cfh_attenkey");
  createatten(&cfh_attenkey, (long)(postemp));
}

         

  trapezoid((WF_PROCESSOR)wg_gykcfh, "gykcfh", &gykcfh, &gykcfha,
                        &gykcfhd, pw_gykcfh, pw_gykcfha, pw_gykcfhd,
                        ia_gykcfh, 0, 0, 0, 0, postemp-pw_gykcfha, TRAP_ALL,
                        &cfhloggrd);


    /*  If the TE is so long that the readout and killer are pushed out beyond
        the default cfh_tr, cfh_tr must be increased.  Setting cfh_tr to the
        end of the killer + 10ms (time_ssi should never be more than 10ms) 
        should do the trick.   */

    newcfh_tr = RUP_GRD( (((pendall(&gykcfh,0)+10000)>cfh_tr) ? (pendall(&gykcfh,0)+10000) : cfh_tr) );

    if(PSdebugstate)	/* vmx 05/02/95 YO */
    {
	printf("CFH : TR = %d\n", newcfh_tr);
    }

      
  {
    pulsename(&seqcfh,"seqcfh");
    createseq(&seqcfh,newcfh_tr, off_seqcfh);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfh );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfh = %d\n", idx_seqcfh );
#endif
  }


      
  {
    pulsename(&seqcfhwait,"seqcfhwait");
    createseq(&seqcfhwait,wait_time_before_cfh, off_seqcfhwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcfhwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcfhwait = %d\n", idx_seqcfhwait );
#endif
  }


    return SUCCESS;
}


/*
 *  CoilSwitchPG
 *  
 *  Type: Private Function
 *  
 *  Description: Creates a ssp sequence which can set RF HUB index on
 *  RFHUBSEL. The sequence length needs to change depending upon
 *  setrcvportimm flag. If setrcvportimm needs to be called we need to
 *  provide additional time before starting to acquire as there is time
 *  delay in setting HW. So we add a wait pulse whos pulsewidth will be
 *  decided based on setrcvportimm flag. We also need a 'delay' sequence
 *  as explained in MRIhc14300.
 *  
 */
STATUS
CoilSwitchPG( void )
{
    INT PosContRFHubSel;

    /* SSP Packet for setting the hub index corresponding to the desired
     * coil configuration */
    short dcontrfhubsel[4] = {
        SSPDS,
        SSPOC | RFHUBSEL,
        SSPD,
        SSPDS
    };

    /* SSP Packet for changing receiver input */
    short dcontrfsel[4] = {     
        SSPDS,
        SSPOC | RRFSEL,
        SSPD | RFAUX,
        SSPDS
    };

    PosContRFHubSel = 15   + delay_rfhubsel;

    /* SSP sequence for changing RF Hub index for coil switch */
        
  {
    pulsename(&contrfhubsel,"contrfhubsel");
    createbits(&contrfhubsel,TYPSSP,sizeof(dcontrfhubsel)/2,dcontrfhubsel);
    createinstr( &contrfhubsel,(long)(PosContRFHubSel),
		pw_contrfhubsel,ia_contrfhubsel);
  }


    /* SSP Sequence for changing receiver input */
         
  {
    pulsename(&contrfsel,"contrfsel");
    createbits(&contrfsel,TYPSSP,sizeof(dcontrfsel)/2,dcontrfsel);
    createinstr( &contrfsel,(long)(pendallssp(&contrfhubsel,0)),
		pw_contrfsel,ia_contrfsel);
  }


    /* Insert a wait pulse to allow us to change the actual TR when
       a setrcvportimm() call is necessary */
        
  {
    pulsename(&csw_wait,"csw_wait");
    createconst(&csw_wait,(WF_PROCESSOR)wg_csw_wait,pw_csw_wait,(short)0); 
    createinstr( &csw_wait,(long)(pendallssp(&contrfsel,0)),pw_csw_wait,0);
  }


    csw_tr = 15   + delay_rfhubsel + pw_contrfhubsel + pw_contrfsel
        + SSP_UPDATE_TIME + csw_time_ssi;

    if( csw_tr < 1000 ) {
        /* Switch time needs to be long enough for RF Hub to switch the coils.
           This is much less than 1ms. */
        csw_tr = RUP_GRD(1000);
    }
        
  {
    pulsename(&seqcsw,"seqcsw");
    createseq(&seqcsw,RUP_GRD(csw_tr-csw_time_ssi), off_seqcsw);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcsw );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcsw = %d\n", idx_seqcsw );
#endif
  }


    /* MRIhc14300: Short wait pulse before setrcvportimm to avoid race
       condition with SCP */
      
  {
    pulsename(&seqcswWaitBefore,"seqcswWaitBefore");
    createseq(&seqcswWaitBefore,RUP_GRD(csw_wait_before), off_seqcswWaitBefore);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcswWaitBefore );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcswWaitBefore = %d\n", idx_seqcswWaitBefore );
#endif
  }


    return SUCCESS;
}

/*
 *  PSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSpulsegen( void )
{
    INT posstart;

    /* MRIge82455 */
    psc_vol_index = 0;

    if(PSD_ON == local_tg)
    {
        posstart = RUP_GRD(IMax(2, pw_gyrf1mps1a, pw_gzrf1cfla) + 1000);
    }
    else
    {
        posstart = RUP_GRD(IMax(2, pw_gzrf1mps1a, pw_gzrf1cfla) + 1000);
    }

    /***********************************************************************
     * MPS1/APS1 SECTION
     ***********************************************************************/

    PS1pulsegen( posstart );

    /***********************************************************************
     * CFL SECTION
     ***********************************************************************/

    CFLpulsegen( posstart );

    /***********************************************************************
     * RCVN SECTION
     ***********************************************************************/

    /* GEHmr03545 */
    RCVNpulsegen( posstart );

    /***********************************************************************
     * CFH SECTION
     ***********************************************************************/

    CFHpulsegen( posstart );

    /***********************************************************************
     * CoilSwitch SECTION
     ***********************************************************************/

    CoilSwitchPG( );

    return SUCCESS;
}   /* end PSpulsegen() */


/*
 *  FTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
FTGpulsegen( void )
{
    INT ftgl_tr = 2000000;
    INT PosGz1FTG;          /* Slice dephaser location   */
    INT PosReadoutWindow;   /* Readout window location   */
    INT PosReadoutWindow2;  /* Readout window location   */
    INT postemp;
    INT prescan_start;

    ftgl_tr = ftgtr;

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    prescan_start = RUP_GRD(pw_gzrf1ftga + 1000);

    /* Z-axis slice selective with x readout gradient for 1-d projection
       after theta2 pulse; positioning of signals after theta3 pulse */

    /* Theta1 selective pulse */
         
                 
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1ftg", 
                                    (WF_PROCESSOR)wg_rf1ftg);

    /* Modify resolution if scaling required */
    temp_res_rf1ftg = res_rf1ftg;
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = rfpulseInfo[RF1_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1ftga,"gzrf1ftga");
    pulsename(&gzrf1ftg,"gzrf1ftg");
    pulsename(&gzrf1ftgd,"gzrf1ftgd");
    pulsename(&rf1ftg,"rf1ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf1ftga,ZGRAD,pw_gzrf1ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1ftga,(LONG)(prescan_start-pw_gzrf1ftga),
		pw_gzrf1ftga,ia_gzrf1ftg);
    createconst(&gzrf1ftg,ZGRAD,pw_gzrf1ftg,MAX_PG_WAMP);
    createinstr( &gzrf1ftg,(LONG)(prescan_start),
		pw_gzrf1ftg,ia_gzrf1ftg);
    createramp(&gzrf1ftgd,ZGRAD,pw_gzrf1ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1ftgd,(LONG)(prescan_start+pw_gzrf1ftg),
		pw_gzrf1ftgd,ia_gzrf1ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf1ftg,(WF_PROCESSOR)wg_rf1ftg,res_rf1ftg,
	       MAX_PG_WAMP,cyc_rf1ftg, alpha_rf1ftg);
    createinstr( &rf1ftg,(LONG)(prescan_start) + psd_rf_wait,
		pw_rf1ftg,ia_rf1ftg);
    linkpulses(4,&rf1ftg,&gzrf1ftg,&gzrf1ftga,
	       &gzrf1ftgd);
    addrfbits(&rf1ftg,off_rf1ftg,(LONG)(prescan_start) + psd_rf_wait, 
	      pw_rf1ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_FTG_SLOT].change==PSD_ON)
       res_rf1ftg = temp_res_rf1ftg;
  }


    /* Theta1 rephaser - split into two parts, 2nd part after rf2tg */
    /*                   is defined.                                */
    PosGz1FTG = pendall(&gzrf1ftg, 0) + pw_gz1ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz1ftg, "gz1ftg", &gz1ftg, &gz1ftga,
                        &gz1ftgd, pw_gz1ftg, pw_gz1ftga, pw_gz1ftgd,
                        ia_gz1ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz1ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta2 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau1-pw_rf2ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2ftg", 
                                    (WF_PROCESSOR)wg_rf2ftg);

    /* Modify resolution if scaling required */
    temp_res_rf2ftg = res_rf2ftg;
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = rfpulseInfo[RF2_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2ftga,"gzrf2ftga");
    pulsename(&gzrf2ftg,"gzrf2ftg");
    pulsename(&gzrf2ftgd,"gzrf2ftgd");
    pulsename(&rf2ftg,"rf2ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2ftga,ZGRAD,pw_gzrf2ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf2ftga),
		pw_gzrf2ftga,ia_gzrf2ftg);
    createconst(&gzrf2ftg,ZGRAD,pw_gzrf2ftg,MAX_PG_WAMP);
    createinstr( &gzrf2ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2ftg,ia_gzrf2ftg);
    createramp(&gzrf2ftgd,ZGRAD,pw_gzrf2ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2ftg),
		pw_gzrf2ftgd,ia_gzrf2ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf2ftg,(WF_PROCESSOR)wg_rf2ftg,res_rf2ftg,
	       MAX_PG_WAMP,cyc_rf2ftg, alpha_rf2ftg);
    createinstr( &rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2ftg,ia_rf2ftg);
    linkpulses(4,&rf2ftg,&gzrf2ftg,&gzrf2ftga,
	       &gzrf2ftgd);
    addrfbits(&rf2ftg,off_rf2ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_FTG_SLOT].change==PSD_ON)
       res_rf2ftg = temp_res_rf2ftg;
  }


    /* Theta2 rephaser - split into two parts: gz2tg and gz2btg (below) */
    PosGz1FTG = pendall(&gzrf2ftg, 0)+pw_gz2ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz2ftg, "gz2ftg", &gz2ftg, &gz2ftga,
                        &gz2ftgd, pw_gz2ftg, pw_gz2ftga, pw_gz2ftgd,
                        ia_gz2ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2ftga, TRAP_ALL,
                        &ps1loggrd);



    /* Theta3 selective pulse */
    postemp = (int) (pend(&rf1ftg,"gzrf1ftg",0)-pw_rf1ftg/2+FTGtau2-pw_rf3ftg/2);

       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf3ftg", 
                                    (WF_PROCESSOR)wg_rf3ftg);

    /* Modify resolution if scaling required */
    temp_res_rf3ftg = res_rf3ftg;
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = rfpulseInfo[RF3_FTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf3ftga,"gzrf3ftga");
    pulsename(&gzrf3ftg,"gzrf3ftg");
    pulsename(&gzrf3ftgd,"gzrf3ftgd");
    pulsename(&rf3ftg,"rf3ftg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf3ftga,ZGRAD,pw_gzrf3ftga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf3ftga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf3ftga,(LONG)(RUP_GRD(postemp)-pw_gzrf3ftga),
		pw_gzrf3ftga,ia_gzrf3ftg);
    createconst(&gzrf3ftg,ZGRAD,pw_gzrf3ftg,MAX_PG_WAMP);
    createinstr( &gzrf3ftg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf3ftg,ia_gzrf3ftg);
    createramp(&gzrf3ftgd,ZGRAD,pw_gzrf3ftgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf3ftgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf3ftgd,(LONG)(RUP_GRD(postemp)+pw_gzrf3ftg),
		pw_gzrf3ftgd,ia_gzrf3ftg);
    
    /* Now create the rf pulse */
    createsinc(&rf3ftg,(WF_PROCESSOR)wg_rf3ftg,res_rf3ftg,
	       MAX_PG_WAMP,cyc_rf3ftg, alpha_rf3ftg);
    createinstr( &rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf3ftg,ia_rf3ftg);
    linkpulses(4,&rf3ftg,&gzrf3ftg,&gzrf3ftga,
	       &gzrf3ftgd);
    addrfbits(&rf3ftg,off_rf3ftg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf3ftg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF3_FTG_SLOT].change==PSD_ON)
       res_rf3ftg = temp_res_rf3ftg;
  }


    /* Theta3 rephaser */
    PosGz1FTG = pendall(&gzrf3ftg, 0)+pw_gz3ftga;

           

  trapezoid((WF_PROCESSOR)wg_gz3ftg, "gz3ftg", &gz3ftg, &gz3ftga,
                        &gz3ftgd, pw_gz3ftg, pw_gz3ftga, pw_gz3ftgd,
                        ia_gz3ftg, 0, 0, 0, 0, PosGz1FTG-pw_gz3ftga, TRAP_ALL,
                        &ps1loggrd);


    /*----------------------------------------------------------*/
    /* Readout windows and dephasers                            */ 
    /*----------------------------------------------------------*/

    postemp = (int) (pbeg(&rf2ftg,"gzrf2ftga",0)-pw_gx1ftg-pw_gx1ftgd);

           

  trapezoid((WF_PROCESSOR)wg_gx1ftg, "gx1ftg", &gx1ftg, &gx1ftga,
                        &gx1ftgd, pw_gx1ftg, pw_gx1ftga, pw_gx1ftgd,
                        ia_gx1ftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1ftga, TRAP_ALL,
                        &ps1loggrd);


    postemp = (int) (pendall(&gzrf2ftg,0) + pw_gx1bftga);

          

  trapezoid((WF_PROCESSOR)wg_gx1bftg, "gx1bftg", &gx1bftg, &gx1bftga,
                        &gx1bftgd, pw_gx1bftg, pw_gx1bftga, pw_gx1bftgd,
                        ia_gx1bftg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&rf1ftg,"gzrf1ftg",0) - pw_rf1ftg/2 + 2*FTGtau1 - pw_gxw1ftg/2));

    /* HD--Error Check For Gradient Overlapp. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg 
     */
    if ( pendall(&gx1bftg,0) >= (PosReadoutWindow - pw_gxw1ftga)){
        PosReadoutWindow = pendall(&gx1bftg,0) + pw_gxw1ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw1ftg, "gxw1ftg", &gxw1ftg, &gxw1ftga,
                        &gxw1ftgd, pw_gxw1ftg, pw_gxw1ftga, pw_gxw1ftgd,
                        ia_gxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow=RUP_GRD((int)(pend(&gxw1ftg,"gxw1ftgd",0))+pw_postgxw1ftga);

           

  trapezoid((WF_PROCESSOR)wg_postgxw1ftg, "postgxw1ftg", &postgxw1ftg, &postgxw1ftga,
                        &postgxw1ftgd, pw_postgxw1ftg, pw_postgxw1ftga, pw_postgxw1ftgd,
                        ia_postgxw1ftg, 0, 0, 0, 0, PosReadoutWindow-pw_postgxw1ftga, TRAP_ALL,
                        &ps1loggrd);


    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1ftg, "gxw1ftga", 0)));

         
  {
    pulsename(&echo1ftg,"echo1ftg");
    acqq(&echo1ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* Second part of theta2 rephaser */
    PosGz1FTG = pbegall(&rf3ftg, 0)-(pw_gz2bftg + pw_gz2bftgd + pw_gzrf3ftga);

          

  trapezoid((WF_PROCESSOR)wg_gz2bftg, "gz2bftg", &gz2bftg, &gz2bftga,
                        &gz2bftgd, pw_gz2bftg, pw_gz2bftga, pw_gz2bftgd,
                        ia_gz2bftg, 0, 0, 0, 0, PosGz1FTG-pw_gz2bftga, TRAP_ALL,
                        &ps1loggrd);


    /* Another refocusing pulse to insure S1 forms tau1 ms after
       center of rf3.  This is the time at which we want to
       the S1 signal to refocus:  */
    PosReadoutWindow =  RUP_GRD((int)(pendall(&rf3ftg, 0) + pw_gx2ftga));

          

  trapezoid((WF_PROCESSOR)wg_gx2ftg, "gx2ftg", &gx2ftg, &gx2ftga,
                        &gx2ftgd, pw_gx2ftg, pw_gx2ftga, pw_gx2ftgd,
                        ia_gx2ftg, 0, 0, 0, 0, PosReadoutWindow-pw_gx2ftga, TRAP_ALL,
                        &ps1loggrd);


    /* Second readout window */
    PosReadoutWindow2 = RUP_GRD((int)(pmidall(&rf3ftg, 0) + FTGtau1 - pw_gxw2ftgleft));

    /* HD--Error Check For Gradient Overlapp. If gradients gx2ftg and
     * gxw2ftg overlap then shift the start of gxw2ftg after end of
     * gx2ftg 
     */
    if ( pendall(&gx2ftg,0) >= (PosReadoutWindow2 - pw_gxw2ftga)){
        PosReadoutWindow2 = pendall(&gx2ftg,0) + pw_gxw2ftga ;
    }

           

  trapezoid((WF_PROCESSOR)wg_gxw2ftg, "gxw2ftg", &gxw2ftg, &gxw2ftga,
                        &gxw2ftgd, pw_gxw2ftg, pw_gxw2ftga, pw_gxw2ftgd,
                        ia_gxw2ftg, 0, 0, 0, 0, PosReadoutWindow2-pw_gxw2ftga, TRAP_ALL,
                        &ps1loggrd);


    if (FTGtestpulse == 1)
    {
        PosReadoutWindow =  RUP_GRD((int)(pbegall(&rf3ftg, 0)+pw_gx2test + pw_gx2testd));
              

  trapezoid((WF_PROCESSOR)wg_gx2test, "gx2test", &gx2test, &gx2testa,
                        &gx2testd, pw_gx2test, pw_gx2testa, pw_gx2testd,
                        ia_gx2test, 0, 0, 0, 0, PosReadoutWindow-pw_gx2testa, TRAP_ALL,
                        &ps1loggrd);

    }    

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw2ftg, "gxw2ftga", 0)));

        
  {
    pulsename(&echo2ftg,"echo2ftg");
    acqq(&echo2ftg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo2ftg,
        (TYPDAB_PACKETS)DABNORM);
  }


         
  {
  pulsename(&ftg_attenkey,"ftg_attenkey");
  createatten(&ftg_attenkey, (long)(RUP_GRD(pbegall(&gxw2ftg,0)+1000+pw_gxw2ftg)));
}


      
  {
    pulsename(&seqftg,"seqftg");
    createseq(&seqftg,ftgl_tr, off_seqftg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqftg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqftg = %d\n", idx_seqftg );
#endif
  }


    return SUCCESS;
}   /* end FTGpulsegen() */


/*
 *  XTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
XTGpulsegen( void )
{
    INT xtgl_tr = 2000000;
    INT PosGyKXTG;          /* Y Killer pulse location          */
    INT PosOffResXTG;       /* Off resonance pulse location     */
    INT PosGzDephaserXTG;   /* Slice dephaser location          */
    INT PosGzRephaserXTG;   /* Slice rephaser location          */
    INT PosReadoutWindow;   /* Readout window location          */
    INT postemp;
    INT prescan_start;

    xtgl_tr = RUP_GRD(xtgtr);

    /* MRIge30645 */
    /* Need to change posstart to eliminate dwnld failures with .8 G/cm. */
    if(PSD_ON == local_tg)
    {
        prescan_start = RUP_GRD(pw_gyrf1xtga + 1000);
    }
    else
    {
        prescan_start = RUP_GRD(pw_gzrf1xtga + 1000);
    }

    /* rf1xtg Theta1 selective pulse */
         
  {
    pulsename(&rf1xtg,"rf1xtg");
    createsinc(&rf1xtg,(WF_PROCESSOR)wg_rf1xtg,res_rf1xtg,
               MAX_PG_WAMP,cyc_rf1xtg,alpha_rf1xtg);
    if ((wg_rf1xtg==TYPRHO1)||(wg_rf1xtg==TYPRHO2) ||
        (wg_rf1xtg==TYPTHETA)||(wg_rf1xtg==TYPOMEGA))
      {
        createinstr( &rf1xtg,(long)(prescan_start) + psd_rf_wait,
                    pw_rf1xtg,ia_rf1xtg);
        addrfbits(&rf1xtg,off_rf1xtg,(long)(prescan_start) + psd_rf_wait,
                  pw_rf1xtg);
      }
    else
      {
        createinstr( &rf1xtg,(long)(prescan_start),
                    pw_rf1xtg,ia_rf1xtg);
      }
  }

    if(PSD_ON == local_tg)
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gyrf1xtg, "gyrf1xtg", &gyrf1xtg, &gyrf1xtga,
                        &gyrf1xtgd, pw_gyrf1xtg, pw_gyrf1xtga, pw_gyrf1xtgd,
                        ia_gyrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gyrf1xtga, TRAP_ALL,
                        &ps1loggrd);
  /* same axis as ykiller */
    }
    else
    {
            
                    

  trapezoid((WF_PROCESSOR)wg_gzrf1xtg, "gzrf1xtg", &gzrf1xtg, &gzrf1xtga,
                        &gzrf1xtgd, pw_gzrf1xtg, pw_gzrf1xtga, pw_gzrf1xtgd,
                        ia_gzrf1xtg, 0, 0, 0, 0, pbegall(&rf1xtg,0)-psd_rf_wait-pw_gzrf1xtga, TRAP_ALL,
                        &ps1loggrd);

    }

    /* Set timing for YKillerL */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerL at same time as ZDephaser */
        PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                            pw_rf2xtg/2 - IMax(2, pw_gykxtgla+pw_gykxtgl+pw_gykxtgld,
                            pw_gz1xtga+pw_gz1xtg+pw_gz1xtgd + pw_gzrf2xtga) + pw_gykxtgla);
    }
    else
    {
        /* Apply YKillerL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gyrf1xtgd + pw_gykxtgla);
        }
        else
        {
            /* RF1 + YKillerLa */
            PosGyKXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + pw_gykxtgla);
        }
    }
    /* Create YKillerL */
           

  trapezoid((WF_PROCESSOR)wg_gykxtgl, "gykxtgl", &gykxtgl, &gykxtgla,
                        &gykxtgld, pw_gykxtgl, pw_gykxtgla, pw_gykxtgld,
                        ia_gykxtgl, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgla, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiL, accounting for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiL after RF1 */
        if(PSD_ON == local_tg)
        {
            /* RF1 + GyRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gyrf1xtgd));
        }
        else
        {
            /* RF1 + GzRF1d */
            PosOffResXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) + IMax(2, min_ssp, pw_gzrf1xtgd));
        }
    }
    else
    {
        /* Apply FermiL after YKillerL */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf1xtg,"rf1xtg",0) + min_ssp, pendall(&gykxtgl,0)));
    }
    /* Create FermiL */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf3xtg", 
                                        (WF_PROCESSOR)wg_rf3xtg);

       pulsename(&rf3xtg,"rf3xtg");
       pulsename(&phs_rf3xtg,"phs_rf3xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf3xtg, (WF_PROCESSOR)wg_rf3xtg, res_rf3xtg, ext_filename);
       createinstr( &rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_rf3xtg);

       createconst( &phs_rf3xtg,THETA,pw_rf3xtg,MAX_PG_WAMP);
       createinstr( &phs_rf3xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf3xtg,ia_phs_rf3xtg);


       addrfbits(&rf3xtg,off_rf3xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf3xtg);
   }


    /* theta1 Slice Dephaser */
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzDephaserXTG = RUP_GRD(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 -
                               pw_rf2xtg/2 - pw_gzrf2xtga - pw_gz1xtgd - pw_gz1xtg);
           

  trapezoid((WF_PROCESSOR)wg_gz1xtg, "gz1xtg", &gz1xtg, &gz1xtga,
                        &gz1xtgd, pw_gz1xtg, pw_gz1xtga, pw_gz1xtgd,
                        ia_gz1xtg, 0, 0, 0, 0, PosGzDephaserXTG-pw_gz1xtga, TRAP_ALL,
                        &ps1loggrd);


    /* rf2xtg Theta2 selective pulse */
    postemp = (int) (pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 + XTGtau1 - pw_rf2xtg/2);
       
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2xtg", 
                                    (WF_PROCESSOR)wg_rf2xtg);

    /* Modify resolution if scaling required */
    temp_res_rf2xtg = res_rf2xtg;
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = rfpulseInfo[RF2_XTG_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf2xtga,"gzrf2xtga");
    pulsename(&gzrf2xtg,"gzrf2xtg");
    pulsename(&gzrf2xtgd,"gzrf2xtgd");
    pulsename(&rf2xtg,"rf2xtg");
    
    /*  Now create the slice select trapezoid */
	pg_beta = ps1loggrd.zbeta;
    createramp(&gzrf2xtga,ZGRAD,pw_gzrf2xtga,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf2xtga/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf2xtga,(LONG)(RUP_GRD(postemp)-pw_gzrf2xtga),
		pw_gzrf2xtga,ia_gzrf2xtg);
    createconst(&gzrf2xtg,ZGRAD,pw_gzrf2xtg,MAX_PG_WAMP);
    createinstr( &gzrf2xtg,(LONG)(RUP_GRD(postemp)),
		pw_gzrf2xtg,ia_gzrf2xtg);
    createramp(&gzrf2xtgd,ZGRAD,pw_gzrf2xtgd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf2xtgd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf2xtgd,(LONG)(RUP_GRD(postemp)+pw_gzrf2xtg),
		pw_gzrf2xtgd,ia_gzrf2xtg);
    
    /* Now create the rf pulse */
    createsinc(&rf2xtg,(WF_PROCESSOR)wg_rf2xtg,res_rf2xtg,
	       MAX_PG_WAMP,cyc_rf2xtg, alpha_rf2xtg);
    createinstr( &rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait,
		pw_rf2xtg,ia_rf2xtg);
    linkpulses(4,&rf2xtg,&gzrf2xtg,&gzrf2xtga,
	       &gzrf2xtgd);
    addrfbits(&rf2xtg,off_rf2xtg,(LONG)(RUP_GRD(postemp)) + psd_rf_wait, 
	      pw_rf2xtg);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2_XTG_SLOT].change==PSD_ON)
       res_rf2xtg = temp_res_rf2xtg;
  }


    /* theta2 Slice Rephaser */ 
    /* Note that Slice Dephaser/Rephaser pair is implemented in two parts:
     * 1) Theta1 dephaser before rf2xtg, and 2) Theta2 rephaser after rf2xtg */
    PosGzRephaserXTG = pendall(&gzrf2xtg, 0) + pw_gz2xtga;
           

  trapezoid((WF_PROCESSOR)wg_gz2xtg, "gz2xtg", &gz2xtg, &gz2xtga,
                        &gz2xtgd, pw_gz2xtg, pw_gz2xtga, pw_gz2xtgd,
                        ia_gz2xtg, 0, 0, 0, 0, PosGzRephaserXTG-pw_gz2xtga, TRAP_ALL,
                        &ps1loggrd);


    /* Set timing for FermiR, account for min_ssp */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply FermiR after both ZRephaser and YKillerR */
        PosOffResXTG = RUP_GRD(pendall(&gzrf2xtg,0) - pw_gzrf2xtgd +
                               IMax(2, min_ssp, IMax(2, pw_gzrf2xtgd + pw_gz2xtga+pw_gz2xtg+pw_gz2xtgd,
                                                     pw_gykxtgra+pw_gykxtgr+pw_gykxtgrd)));
    }
    else
    {
        /* Apply FermiR after ZRephaser */
        PosOffResXTG = RUP_GRD(IMax(2, pend(&rf2xtg,"rf2xtg",0) + min_ssp, pendall(&gz2xtg,0)));
    }
    /* Create FermiR */
       
   {

       EXTERN_FILENAME ext_filename;

       /* Check for RF waveform generator */
       RFEnvelopeWaveformGeneratorCheck("rf4xtg", 
                                        (WF_PROCESSOR)wg_rf4xtg);

       pulsename(&rf4xtg,"rf4xtg");
       pulsename(&phs_rf4xtg,"phs_rf4xtg");
       sprintf(ext_filename,"bls.rho");

       createextwave( &rf4xtg, (WF_PROCESSOR)wg_rf4xtg, res_rf4xtg, ext_filename);
       createinstr( &rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_rf4xtg);

       createconst( &phs_rf4xtg,THETA,pw_rf4xtg,MAX_PG_WAMP);
       createinstr( &phs_rf4xtg,(long)(PosOffResXTG) + psd_rf_wait, pw_rf4xtg,ia_phs_rf4xtg);


       addrfbits(&rf4xtg,off_rf4xtg,(long)(PosOffResXTG) + 
                 psd_rf_wait, pw_rf4xtg);
   }


    /* Set timing for YKillerR */
    if ( XTG_minimizeYKillerGap == PSD_ON )
    {
        /* Apply YKillerR after GzRF2 */
        PosGyKXTG = pendall(&gzrf2xtg,0) + pw_gykxtgra;
    }
    else
    {
        /* Apply YKillerR after FermiR */
        PosGyKXTG = RUP_GRD(pendall(&rf4xtg,0) + pw_gykxtgra);
    }
    /* Create YKillerR */
         

  trapezoid((WF_PROCESSOR)wg_gykxtgr, "gykxtgr", &gykxtgr, &gykxtgra,
                        &gykxtgrd, pw_gykxtgr, pw_gykxtgra, pw_gykxtgrd,
                        ia_gykxtgr, 0, 0, 0, 0, PosGyKXTG-pw_gykxtgra, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout dephaser */
    postemp = RUP_GRD(pendall(&rf2xtg,0) - pw_rf2xtg/2 + XTGtau1 - 
                      pw_gxw1xtg/2-pw_gxw1xtga - pw_gx1bxtgd - pw_gx1bxtg);
          

  trapezoid((WF_PROCESSOR)wg_gx1bxtg, "gx1bxtg", &gx1bxtg, &gx1bxtga,
                        &gx1bxtgd, pw_gx1bxtg, pw_gx1bxtga, pw_gx1bxtgd,
                        ia_gx1bxtg, 0, 0, 0, 0, RUP_GRD(postemp)-pw_gx1bxtga, TRAP_ALL,
                        &ps1loggrd);


    /* X Readout window */
    PosReadoutWindow=RUP_GRD((int)(pend(&rf1xtg,"rf1xtg",0) - pw_rf1xtg/2 +
                                   2*XTGtau1 - pw_gxw1xtg/2));
    /* HD--Error Check For Gradient Overlap. If gradients gx1bftg
     * and gxw1ftg overlap then shift the start of gxw1ftg after end of
     * gx1bftg
     */
    if ( pendall(&gx1bxtg,0) >= (PosReadoutWindow - pw_gxw1xtga))
    {
        PosReadoutWindow = pendall(&gx1bxtg,0) + pw_gxw1xtga ;
    }
           

  trapezoid((WF_PROCESSOR)wg_gxw1xtg, "gxw1xtg", &gxw1xtg, &gxw1xtga,
                        &gxw1xtgd, pw_gxw1xtg, pw_gxw1xtga, pw_gxw1xtgd,
                        ia_gxw1xtg, 0, 0, 0, 0, PosReadoutWindow-pw_gxw1xtga, TRAP_ALL,
                        &ps1loggrd);

    PosReadoutWindow =  RUP_GRD((int)(pend(&gxw1xtg, "gxw1xtga", 0))); /* Update PosReadoutWindow to final value */
         
  {
    pulsename(&echo1xtg,"echo1xtg");
    acqq(&echo1xtg, (long)(PosReadoutWindow+psd_grd_wait),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1xtg,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* position for ATTENUATOR */
    postemp = RUP_GRD(pbegall(&gxw1xtg,0) + 1000 + pw_gxw1xtg);
     
  {
  pulsename(&xtg_attenkey,"xtg_attenkey");
  createatten(&xtg_attenkey, (long)(postemp));
}


      
  {
    pulsename(&seqxtg,"seqxtg");
    createseq(&seqxtg,xtgl_tr, off_seqxtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqxtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqxtg = %d\n", idx_seqxtg );
#endif
  }


    getperiod( (long*)&init_xtg_deadtime, &seqxtg, 0 );

    return SUCCESS;
}   /* end XTGpulsegen() */


/*
 *  ASpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASpulsegen( void )
{
    INT PosTemp;

    /***************************************
     * Z board
     ***************************************/
    /* Z gradient slice select */
    PosTemp = RUP_GRD(td0as + tleadas - rfupa + pw_gzrf1asa);
          
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1as", 
                                    (WF_PROCESSOR)wg_rf1as);

    /* Modify resolution if scaling required */
    temp_res_rf1as = res_rf1as;
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = rfpulseInfo[RF1_AUTOSHIM].newres;
    /* First create the pulses */
    pulsename(&gzrf1asa,"gzrf1asa");
    pulsename(&gzrf1as,"gzrf1as");
    pulsename(&gzrf1asd,"gzrf1asd");
    pulsename(&rf1as,"rf1as");
    
    /*  Now create the slice select trapezoid */
	pg_beta = asloggrd.zbeta;
    createramp(&gzrf1asa,ZGRAD,pw_gzrf1asa,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1asa/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1asa,(LONG)(PosTemp-pw_gzrf1asa),
		pw_gzrf1asa,ia_gzrf1as);
    createconst(&gzrf1as,ZGRAD,pw_gzrf1as,MAX_PG_WAMP);
    createinstr( &gzrf1as,(LONG)(PosTemp),
		pw_gzrf1as,ia_gzrf1as);
    createramp(&gzrf1asd,ZGRAD,pw_gzrf1asd,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1asd/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1asd,(LONG)(PosTemp+pw_gzrf1as),
		pw_gzrf1asd,ia_gzrf1as);
    
    /* Now create the rf pulse */
    createsinc(&rf1as,(WF_PROCESSOR)wg_rf1as,res_rf1as,
	       MAX_PG_WAMP,cyc_rf1as, alpha_rf1as);
    createinstr( &rf1as,(LONG)(PosTemp) + psd_rf_wait,
		pw_rf1as,ia_rf1as);
    linkpulses(4,&rf1as,&gzrf1as,&gzrf1asa,
	       &gzrf1asd);
    addrfbits(&rf1as,off_rf1as,(LONG)(PosTemp) + psd_rf_wait, 
	      pw_rf1as);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1_AUTOSHIM].change==PSD_ON)
       res_rf1as = temp_res_rf1as;
  }
 

    /* Assert the ESSP flag on the rf1as pulse */
    attenflagon(&rf1as, 0);

    /* Z gradient rephaser */
    PosTemp = pendall(&gzrf1as, 0) + pw_gz1asa;
          
                

  trapezoid((WF_PROCESSOR)wg_gz1as, "gz1as", &gz1as, &gz1asa,
                        &gz1asd, pw_gz1as, pw_gz1asa, pw_gz1asd,
                        ia_gz1as, 0, 0, 0, 0, pendall(&gzrf1as,0)+pw_gz1asa-pw_gz1asa, TRAP_ALL,
                        &asloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pmid(&gzrf1as,"gzrf1as",0)-off90as+te_as-pw_gxwas/2);
           

  trapezoid((WF_PROCESSOR)wg_gxwas, "gxwas", &gxwas, &gxwasa,
                        &gxwasd, pw_gxwas, pw_gxwasa, pw_gxwasd,
                        ia_gxwas, 0, 0, 0, 0, PosTemp-pw_gxwasa, TRAP_ALL,
                        &asloggrd);


    PosTemp = RUP_GRD(PosTemp+psd_grd_wait);
        
  {
    pulsename(&echo1as,"echo1as");
    acqq(&echo1as, (long)(PosTemp),(long)(DEFAULTPOS),
        (long)(DEFAULTPOS),(long)filter_echo1as,
        (TYPDAB_PACKETS)DABNORM);
  }

    attenflagon(&echo1as,0);

    /* frequency dephaser */
    PosTemp = RUP_GRD(pbegall(&gxwas,0) - (pw_gx1as+pw_gx1asd));
           

  trapezoid((WF_PROCESSOR)wg_gx1as, "gx1as", &gx1as, &gx1asa,
                        &gx1asd, pw_gx1as, pw_gx1asa, pw_gx1asd,
                        ia_gx1as, 0, 0, 0, 0, PosTemp-pw_gx1asa, TRAP_ALL,
                        &asloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
    PosTemp = RUP_GRD( pend(&gxwas, "gxwas",0) );
     
  {
  pulsename(&attenuator_keyas,"attenuator_keyas");
  createatten(&attenuator_keyas, (long)(PosTemp));
}


    /*****************************************
     * Y board
     *****************************************/
    /* HSI - changed SINUSOID to TRAPEZOID2 */
    /* encode */
    PosTemp = RUP_GRD(pend(&gz1asd,"gz1asd",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1as,"gy1as",
              &gy1as,&gy1asa,&gy1asd,
              pw_gy1as,pw_gy1asa,pw_gy1asd,
              ia_gy1as,ia_gy1aswa,ia_gy1aswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);


    /* rewind */
    PosTemp= RUP_GRD(pend(&gxwas,"gxwas",0));
           
    trapezoid((WF_PROCESSOR)wg_gy1ras,"gy1ras",
              &gy1ras,&gy1rasa,&gy1rasd,
              pw_gy1ras,pw_gy1rasa,pw_gy1rasd,
              ia_gy1ras,ia_gy1raswa,ia_gy1raswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &asloggrd);



    /*******************
     * X and Z Killers
     *******************/
    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gxkasa);
         

  trapezoid((WF_PROCESSOR)wg_gxkas, "gxkas", &gxkas, &gxkasa,
                        &gxkasd, pw_gxkas, pw_gxkasa, pw_gxkasd,
                        ia_gxkas, 0, 0, 0, 0, PosTemp-pw_gxkasa, TRAP_ALL,
                        &asloggrd);


    PosTemp= RUP_GRD(pend(&gxwasd,"gxwasd",0) + pw_gzkasa);
         

  trapezoid((WF_PROCESSOR)wg_gzkas, "gzkas", &gzkas, &gzkasa,
                        &gzkasd, pw_gzkas, pw_gzkasa, pw_gzkasd,
                        ia_gzkas, 0, 0, 0, 0, PosTemp-pw_gzkasa, TRAP_ALL,
                        &asloggrd);


    /**************
     * dixon shifts
     **************/
    PosTemp = RUP_GRD(td0as + tleadas - rfupa);
         
  {
    pulsename(&xdixon,"xdixon");
    createconst(&xdixon,(WF_PROCESSOR)wg_xdixon,
                pw_xdixon,MAX_PG_WAMP);
    createinstr( &xdixon,(long)(PosTemp),
		pw_xdixon,ia_xdixon);
    if ((wg_xdixon==TYPRHO1)||(wg_xdixon==TYPRHO2))
      {
	addrfbits(&xdixon,0,(long)(PosTemp),pw_xdixon);
      }
  }

         
  {
    pulsename(&ydixon,"ydixon");
    createconst(&ydixon,(WF_PROCESSOR)wg_ydixon,
                pw_ydixon,MAX_PG_WAMP);
    createinstr( &ydixon,(long)(PosTemp),
		pw_ydixon,ia_ydixon);
    if ((wg_ydixon==TYPRHO1)||(wg_ydixon==TYPRHO2))
      {
	addrfbits(&ydixon,0,(long)(PosTemp),pw_ydixon);
      }
  }


    PosTemp = pend(&gz1asd,"gz1asd",0);
         
  {
    pulsename(&zdixon,"zdixon");
    createconst(&zdixon,(WF_PROCESSOR)wg_zdixon,
                pw_zdixon,MAX_PG_WAMP);
    createinstr( &zdixon,(long)(PosTemp),
		pw_zdixon,ia_zdixon);
    if ((wg_zdixon==TYPRHO1)||(wg_zdixon==TYPRHO2))
      {
	addrfbits(&zdixon,0,(long)(PosTemp),pw_zdixon);
      }
  }


    /* just pad the ssp somewhere beyond the rf unblank */
    rfdisable_add = YES;
    PosTemp = RUP_RF(pend(&rf1as,"rf1as",0) + rfupd + 12);
         
  {
    pulsename(&sdixon,"sdixon");
    createconst(&sdixon,(WF_PROCESSOR)wg_sdixon,
                pw_sdixon,MAX_PG_WAMP);
    createinstr( &sdixon,(long)(PosTemp),
		pw_sdixon,ia_sdixon);
    if ((wg_sdixon==TYPRHO1)||(wg_sdixon==TYPRHO2))
      {
	addrfbits(&sdixon,0,(long)(PosTemp),pw_sdixon);
      }
  }


    PosTemp = RUP_RF(pbeg(&gzkas,"gzkas",0));
         
  {
    pulsename(&sdixon2,"sdixon2");
    createconst(&sdixon2,(WF_PROCESSOR)wg_sdixon2,
                pw_sdixon2,MAX_PG_WAMP);
    createinstr( &sdixon2,(long)(PosTemp),
		pw_sdixon2,ia_sdixon2);
    if ((wg_sdixon2==TYPRHO1)||(wg_sdixon2==TYPRHO2))
      {
	addrfbits(&sdixon2,0,(long)(PosTemp),pw_sdixon2);
      }
  }


    rfdisable_add = NO;
        
  {
    pulsename(&seqaushim,"seqaushim");
    createseq(&seqaushim,RUP_GRD((int)(tr_as-time_ssias)), off_seqaushim);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqaushim );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqaushim = %d\n", idx_seqaushim );
#endif
  }

    attenflagon(&seqaushim, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_aushim,"pass_aushim");
    createpass(&pass_aushim,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

      
  {
    pulsename(&seqpassas,"seqpassas");
    createseq(&seqpassas,RUP_GRD(PSTR_PASS), off_seqpassas);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassas );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassas = %d\n", idx_seqpassas );
#endif
  }


    return SUCCESS;
}   /* end ASpulsegen() */


/*
 *  RSpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
RSpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_res, temp_time;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;
    short DDIQ_length = DDIQ_LENGTH;
    short DDIQ_bits[DDIQ_LENGTH] = {SSPDS, SSPOC, SSPD, SSPDS};

    DDIQ_bits[0]=SSPDS|EDC;
    DDIQ_bits[1]=SSPOC|DDIQSWOC;

    /* DD IQ Channel */
        
  {
    pulsename(&dDDIQ,"dDDIQ");
    createbits(&dDDIQ,TYPSSP,sizeof(DDIQ_bits)/2,DDIQ_bits);
    createinstr( &dDDIQ,(long)(GRAD_UPDATE_TIME+tleadrs),
		DDIQ_length,ia_dDDIQ);
  }

    DD_delay = 2000;
      
  {
    pulsename(&seqIQControl,"seqIQControl");
    createseq(&seqIQControl,RUP_GRD(DD_delay), off_seqIQControl);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqIQControl );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqIQControl = %d\n", idx_seqIQControl );
#endif
  }


    /* selective RF1 */
    PosTemp = td0rs + pw_gzrf1rsa;
    temp_res = res_rf1rs;

    switch (rf1rs_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_RFSHIM_SLOT].change)
            {
                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            usinc(wave_space, (short)res_rf1rs, (short)max_pg_wamp, cyc_rf1rs, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1rs*sizeof(short));
            uextwave(temp_wave_space, res_rf1rs, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_RFSHIM_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_RFSHIM_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_RFSHIM_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1rs = rfpulseInfo[RF1_RFSHIM_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1rs,"rf1rs");
    createreserve(&rf1rs,(WF_PROCESSOR)wg_rf1rs,
		  res_rf1rs);
  }

    createinstr( &rf1rs, PosTemp+psd_rf_wait, pw_rf1rs, ia_rf1rs );
    addrfbits(&rf1rs, 0, PosTemp+psd_rf_wait, pw_rf1rs);
    movewaveimm(wave_space, &rf1rs, (int)0, res_rf1rs, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1rs, &rf1rs, 0);

    res_rf1rs = temp_res;
    /* Z slice selective for rf1 */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1rs, "gzrf1rs", &gzrf1rs, &gzrf1rsa,
                        &gzrf1rsd, pw_gzrf1rs, pw_gzrf1rsa, pw_gzrf1rsd,
                        ia_gzrf1rs, 0, 0, 0, 0, PosTemp-pw_gzrf1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************
                X BS Killer
     *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsrs, "gxkbsrs", &gxkbsrs, &gxkbsrsa,
                        &gxkbsrsd, pw_gxkbsrs, pw_gxkbsrsa, pw_gxkbsrsd,
                        ia_gxkbsrs, 0, 0, 0, 0, RUP_GRD(pend(&rf1rs,"rf1rs",0)+pw_gxkbsrsa)-pw_gxkbsrsa, TRAP_ALL,
                        &rsloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1rs, 0 ) + pw_gz1rsa);

          

  trapezoid((WF_PROCESSOR)wg_gz1rs, "gz1rs", &gz1rs, &gz1rsa,
                        &gz1rsd, pw_gz1rs, pw_gz1rsa, pw_gz1rsd,
                        ia_gz1rs, 0, 0, 0, 0, PosTemp-pw_gz1rsa, TRAP_ALL,
                        &rsloggrd);


    /* RFBRS: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1rsd+pw_gz1rsa+pw_gz1rs+pw_gz1rsd, pw_gxkbsrsa + pw_gxkbsrs + pw_gxkbsrsd,
                     rffrequency_length[bd_index]-rfupa+rfupd );

    PosTemp = RUP_GRD(pend(&rf1rs, "rf1rs", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbrs; /* temp holder for old pulse resolution */

    if ( (wg_rfbrs != TYPRHO1)  && (wg_rfbrs != TYPRHO2) &&
         (wg_rfbrs != TYPTHETA) && (wg_rfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbrs,"rfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbrs, (WF_PROCESSOR)wg_rfbrs, new_res);

                movestretchedwave( fileloc_rfbrs, old_res,
                                   &rfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbrs,(WF_PROCESSOR)wg_rfbrs,
                          old_res,fileloc_rfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbrs,ia_rfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbrs,off_rfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbrs);
    

    /*** Reset Resolution ***/
    res_rfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbrs; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbrs != TYPRHO1)  && (wg_thetarfbrs != TYPRHO2) &&
         (wg_thetarfbrs != TYPTHETA) && (wg_thetarfbrs != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbrs += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbrs.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbrs,"thetarfbrs");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbrs].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbrs].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbrs, (WF_PROCESSOR)wg_thetarfbrs, new_res);

                movestretchedwave( fileloc_thetarfbrs, old_res,
                                   &thetarfbrs, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbrs = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbrs,(WF_PROCESSOR)wg_thetarfbrs,
                          old_res,fileloc_thetarfbrs);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbrs,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbrs,ia_thetarfbrs);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbrs,off_thetarfbrs,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbrs);
    

    /*** Reset Resolution ***/
    res_thetarfbrs = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbrs, &rfbrs, 0);
    setiamp(ia_thetarfbrs, &thetarfbrs, 0);

    /*******************************
     *        Z BS Killer
     *******************************/
    PosTemp = PosTemp + pw_rfbrs;
       

  trapezoid((WF_PROCESSOR)wg_gzkbsrs, "gzkbsrs", &gzkbsrs, &gzkbsrsa,
                        &gzkbsrsd, pw_gzkbsrs, pw_gzkbsrsa, pw_gzkbsrsd,
                        ia_gzkbsrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsrsa)-pw_gzkbsrsa, TRAP_ALL,
                        &rsloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1rs, "gzrf1rs", 0) - rs_iso_delay + min_rste - pw_gxwrs/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwrs, "gxwrs", &gxwrs, &gxwrsa,
                        &gxwrsd, pw_gxwrs, pw_gxwrsa, pw_gxwrsd,
                        ia_gxwrs, 0, 0, 0, 0, PosTemp-pw_gxwrsa, TRAP_ALL,
                        &rsloggrd);


        
  {
    pulsename(&echo1rs,"echo1rs");
    acqq(&echo1rs, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1rs,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(rfshim_etl >=2)
    {
        char pulse_name[20];

        rs_echo2toN = (WF_PULSE *)AllocNode(rfshim_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (rfshim_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) + pw_gx2rsa + echoind*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2rs, "gx2rs", &gx2rs, &gx2rsa,
                        &gx2rsd, pw_gx2rs, pw_gx2rsa, pw_gx2rsd,
                        ia_gx2rs, 0, 0, 0, 0, PosTemp-pw_gx2rsa, TRAP_ALL,
                        &rsloggrd);


            PosTemp = RUP_GRD(pendall( &gxwrs, 0 ) +  echoind*rs_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2rs,"gy2rs",
              &gy2rs,&gy2rsa,&gy2rsd,
              pw_gy2rs,pw_gy2rsa,pw_gy2rsd,
              ia_gy2rs,ia_gy2rswa,ia_gy2rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*rs_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*rs_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*rs_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2rs, "gxw2rs", &gxw2rs, &gxw2rsa,
                        &gxw2rsd, pw_gxw2rs, pw_gxw2rsa, pw_gxw2rsd,
                        ia_gxw2rs, 0, 0, 0, 0, PosTemp-pw_gxw2rsa, TRAP_ALL,
                        &rsloggrd);


            sprintf(pulse_name,"rs_echo2toN%d",echoind);
            pulsename(&(rs_echo2toN[echoind]),pulse_name);

            acqq(&(rs_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1rs,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1rs,0);

    PosTemp = RUP_GRD(pbegall(&gxwrs, 0)-pw_gx1rsd-pw_gx1rs);
           

  trapezoid((WF_PROCESSOR)wg_gx1rs, "gx1rs", &gx1rs, &gx1rsa,
                        &gx1rsd, pw_gx1rs, pw_gx1rsa, pw_gx1rsd,
                        ia_gx1rs, 0, 0, 0, 0, PosTemp-pw_gx1rsa, TRAP_ALL,
                        &rsloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           
    trapezoid((WF_PROCESSOR)wg_gy1rrs,"gy1rrs",
              &gy1rrs,&gy1rrsa,&gy1rrsd,
              pw_gy1rrs,pw_gy1rrsa,pw_gy1rrsd,
              ia_gy1rrs,ia_gy1rrswa,ia_gy1rrswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwrs, "gxwrs", 0 ) - pw_gy1rsd - pw_gy1rs - pw_gy1rsa);
           
    trapezoid((WF_PROCESSOR)wg_gy1rs,"gy1rs",
              &gy1rs,&gy1rsa,&gy1rsd,
              pw_gy1rs,pw_gy1rsa,pw_gy1rsd,
              ia_gy1rs,ia_gy1rswa,ia_gy1rswb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &rsloggrd);


    /* Z crusher */
    if(rfshim_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2rs,"gxw2rs", gxw2rs.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend( &gxwrs, "gxwrs", 0 ));
    }
           

  trapezoid((WF_PROCESSOR)wg_gzkrs, "gzkrs", &gzkrs, &gzkrsa,
                        &gzkrsd, pw_gzkrs, pw_gzkrsa, pw_gzkrsd,
                        ia_gzkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkrsa)-pw_gzkrsa, TRAP_ALL,
                        &rsloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkrs, "gxkrs", &gxkrs, &gxkrsa,
                        &gxkrsd, pw_gxkrs, pw_gxkrsa, pw_gxkrsd,
                        ia_gxkrs, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gxwrsd+pw_gxkrsa)-pw_gxkrsa, TRAP_ALL,
                        &rsloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keyrs,"attenuator_keyrs");
  createatten(&attenuator_keyrs, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqrs,"seqrs");
    createseq(&seqrs,RUP_GRD(tr_rs), off_seqrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrs = %d\n", idx_seqrs );
#endif
  }

    attenflagon(&seqrs, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_rs,"pass_rs");
    createpass(&pass_rs,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassrs,"seqpassrs");
    createseq(&seqpassrs,RUP_GRD(TR_PSCPASS), off_seqpassrs);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassrs );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassrs = %d\n", idx_seqpassrs );
#endif
  }


    return SUCCESS;
}

/*
 *  DTGpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
DTGpulsegen( void )
{
    EXTERN_FILENAME ext_filename;
    INT PosTemp, PosRead1;
    INT DabSetUp, PosDabPkt, PosXtrPkt;
    INT PosDabPkt2toN, PosXtrPkt2toN;
    INT temp_time;
    INT temp_res;
    INT echoind;
    short *wave_space;
    short *temp_wave_space;

    /* selective RF1 */
    PosTemp = td0dtg + pw_gzrf1dtga;
    temp_res = res_rf1dtg;

    switch (rf1dtg_type)
    {
        case B1RF1_SINC:
            if(PSD_ON == rfpulseInfo[RF1_DYNTG_SLOT].change)
            {
                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;
            }
            wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            usinc(wave_space, (short)res_rf1dtg, (short)max_pg_wamp, cyc_rf1dtg, 0.46);
            break;
        case B1RF1_TBW:
        default:
            strcpy(ext_filename,"tbw6_01_01_600.rho");
            /* Set new resolution and stretch external pulse */
            temp_wave_space = (short *)AllocNode(res_rf1dtg*sizeof(short));
            uextwave(temp_wave_space, res_rf1dtg, ext_filename);
            /* Stretch rf pw if needed */
            if (rfpulseInfo[RF1_DYNTG_SLOT].change==PSD_ON)
            {
                wave_space = (short *)AllocNode(rfpulseInfo[RF1_DYNTG_SLOT].newres*
                                                sizeof(short));
                stretchpulse((int)temp_res, (int)rfpulseInfo[RF1_DYNTG_SLOT].newres,
                             temp_wave_space,wave_space);

                res_rf1dtg = rfpulseInfo[RF1_DYNTG_SLOT].newres;

                FreeNode(temp_wave_space);
            }
            else
            {
                wave_space = temp_wave_space;
            }

            break;
    }
      
  {
    pulsename(&rf1dtg,"rf1dtg");
    createreserve(&rf1dtg,(WF_PROCESSOR)wg_rf1dtg,
		  res_rf1dtg);
  }

    createinstr( &rf1dtg, PosTemp+psd_rf_wait, pw_rf1dtg, ia_rf1dtg );
    addrfbits(&rf1dtg, 0, PosTemp+psd_rf_wait, pw_rf1dtg);
    movewaveimm(wave_space, &rf1dtg, (int)0, res_rf1dtg, TOHARDWARE);

    FreeNode(wave_space);
    setiamp(ia_rf1dtg, &rf1dtg, 0);

    res_rf1dtg = temp_res;
    /* Z slice selective for rf1dtg */
           

  trapezoid((WF_PROCESSOR)wg_gzrf1dtg, "gzrf1dtg", &gzrf1dtg, &gzrf1dtga,
                        &gzrf1dtgd, pw_gzrf1dtg, pw_gzrf1dtga, pw_gzrf1dtgd,
                        ia_gzrf1dtg, 0, 0, 0, 0, PosTemp-pw_gzrf1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************
           X BS Killer
    *******************************/
           

  trapezoid((WF_PROCESSOR)wg_gxkbsdtg, "gxkbsdtg", &gxkbsdtg, &gxkbsdtga,
                        &gxkbsdtgd, pw_gxkbsdtg, pw_gxkbsdtga, pw_gxkbsdtgd,
                        ia_gxkbsdtg, 0, 0, 0, 0, RUP_GRD(pend(&rf1dtg,"rf1dtg",0)+pw_gxkbsdtga)-pw_gxkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    PosTemp = RUP_GRD(pendall( &gzrf1dtg, 0 ) + pw_gz1dtga);

           

  trapezoid((WF_PROCESSOR)wg_gz1dtg, "gz1dtg", &gz1dtg, &gz1dtga,
                        &gz1dtgd, pw_gz1dtg, pw_gz1dtga, pw_gz1dtgd,
                        ia_gz1dtg, 0, 0, 0, 0, PosTemp-pw_gz1dtga, TRAP_ALL,
                        &dtgloggrd);


    /* RFBDTG: BLS RF pulse */
    temp_time = IMax(3, pw_gzrf1dtgd+pw_gz1dtga+pw_gz1dtg+pw_gz1dtgd, pw_gxkbsdtga + pw_gxkbsdtg + pw_gxkbsdtgd,
                     rffrequency_length[bd_index]-rfupa+rfupd);

    PosTemp = RUP_GRD(pend(&rf1dtg, "rf1dtg", 0)+ temp_time);

         
               
  {
        INT old_res =  res_rfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_rfbdtg != TYPRHO1)  && (wg_rfbdtg != TYPRHO2) &&
         (wg_rfbdtg != TYPTHETA) && (wg_rfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rfbdtg,"rfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rfbdtg, (WF_PROCESSOR)wg_rfbdtg, new_res);

                movestretchedwave( fileloc_rfbdtg, old_res,
                                   &rfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rfbdtg,(WF_PROCESSOR)wg_rfbdtg,
                          old_res,fileloc_rfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_rfbdtg,ia_rfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&rfbdtg,off_rfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_rfbdtg);
    

    /*** Reset Resolution ***/
    res_rfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }

         
               
  {
        INT old_res =  res_thetarfbdtg; /* temp holder for old pulse resolution */

    if ( (wg_thetarfbdtg != TYPRHO1)  && (wg_thetarfbdtg != TYPRHO2) &&
         (wg_thetarfbdtg != TYPTHETA) && (wg_thetarfbdtg != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_thetarfbdtg += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( thetarfbdtg.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&thetarfbdtg,"thetarfbdtg");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_thetarfbdtg].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_thetarfbdtg].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&thetarfbdtg, (WF_PROCESSOR)wg_thetarfbdtg, new_res);

                movestretchedwave( fileloc_thetarfbdtg, old_res,
                                   &thetarfbdtg, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_thetarfbdtg = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&thetarfbdtg,(WF_PROCESSOR)wg_thetarfbdtg,
                          old_res,fileloc_thetarfbdtg);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait, 
                 pw_thetarfbdtg,ia_thetarfbdtg);
    

    /*** Add RF Bits ***/
    addrfbits(&thetarfbdtg,off_thetarfbdtg,(LONG)(PosTemp) + psd_rf_wait,
              pw_thetarfbdtg);
    

    /*** Reset Resolution ***/
    res_thetarfbdtg = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rfbdtg, &rfbdtg, 0);
    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);

    /*******************************
       Z BS Killer
    *******************************/
    PosTemp = PosTemp + pw_rfbdtg; 
       

  trapezoid((WF_PROCESSOR)wg_gzkbsdtg, "gzkbsdtg", &gzkbsdtg, &gzkbsdtga,
                        &gzkbsdtgd, pw_gzkbsdtg, pw_gzkbsdtga, pw_gzkbsdtgd,
                        ia_gzkbsdtg, 0, 0, 0, 0, RUP_GRD(PosTemp+pw_gzkbsdtga)-pw_gzkbsdtga, TRAP_ALL,
                        &dtgloggrd);


    /***************************************
     * X board
     ***************************************/
    PosTemp = RUP_GRD(pend(&gzrf1dtg, "gzrf1dtg", 0) - dtg_iso_delay + min_dtgte - pw_gxwdtg/2.0);
    DabSetUp = IMax(2,DABSETUP,(XTRSETLNG+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-XTRSETLNG);

           

  trapezoid((WF_PROCESSOR)wg_gxwdtg, "gxwdtg", &gxwdtg, &gxwdtga,
                        &gxwdtgd, pw_gxwdtg, pw_gxwdtga, pw_gxwdtgd,
                        ia_gxwdtg, 0, 0, 0, 0, PosTemp-pw_gxwdtga, TRAP_ALL,
                        &dtgloggrd);


        
  {
    pulsename(&echo1dtg,"echo1dtg");
    acqq(&echo1dtg, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1dtg,
        (TYPDAB_PACKETS)DABNORM);
  }

    PosRead1 = PosTemp;

    if(dynTG_etl >=2)
    {
        char pulse_name[20];

        dtg_echo2toN = (WF_PULSE *)AllocNode(dynTG_etl*sizeof(WF_PULSE));

        for(echoind=0; echoind < (dynTG_etl-1); echoind++)
        {
            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) + pw_gx2dtga + echoind*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gx2dtg, "gx2dtg", &gx2dtg, &gx2dtga,
                        &gx2dtgd, pw_gx2dtg, pw_gx2dtga, pw_gx2dtgd,
                        ia_gx2dtg, 0, 0, 0, 0, PosTemp-pw_gx2dtga, TRAP_ALL,
                        &dtgloggrd);


            PosTemp = RUP_GRD(pendall( &gxwdtg, 0 ) +  echoind*dtg_esp);
                
    trapezoid((WF_PROCESSOR)wg_gy2dtg,"gy2dtg",
              &gy2dtg,&gy2dtga,&gy2dtgd,
              pw_gy2dtg,pw_gy2dtga,pw_gy2dtgd,
              ia_gy2dtg,ia_gy2dtgwa,ia_gy2dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


            PosDabPkt2toN = RUP_GRD(PosDabPkt + (echoind+1)*dtg_esp);
            PosTemp = RUP_GRD(PosRead1 + (echoind+1)*dtg_esp);
            PosXtrPkt2toN = RUP_GRD(PosXtrPkt + (echoind+1)*dtg_esp);
                   

  trapezoid((WF_PROCESSOR)wg_gxw2dtg, "gxw2dtg", &gxw2dtg, &gxw2dtga,
                        &gxw2dtgd, pw_gxw2dtg, pw_gxw2dtga, pw_gxw2dtgd,
                        ia_gxw2dtg, 0, 0, 0, 0, PosTemp-pw_gxw2dtga, TRAP_ALL,
                        &dtgloggrd);


            sprintf(pulse_name,"dtg_echo2toN%d",echoind);
            pulsename(&(dtg_echo2toN[echoind]),pulse_name);

            acqq(&(dtg_echo2toN[echoind]), (long) (PosTemp+psd_grd_wait), (long) PosDabPkt2toN,(long)(PosXtrPkt2toN),filter_echo1dtg,(TYPDAB_PACKETS)DABNORM);
        }

    }

    attenflagon(&echo1dtg,0);

    PosTemp = RUP_GRD(pbegall(&gxwdtg, 0)-pw_gx1dtgd-pw_gx1dtg);
           

  trapezoid((WF_PROCESSOR)wg_gx1dtg, "gx1dtg", &gx1dtg, &gx1dtga,
                        &gx1dtgd, pw_gx1dtg, pw_gx1dtga, pw_gx1dtgd,
                        ia_gx1dtg, 0, 0, 0, 0, PosTemp-pw_gx1dtga, TRAP_ALL,
                        &dtgloggrd);


    /*******************************************
     *  Y phase encoding and possible rewinder *
     *******************************************/
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg,"gxwdtg", 0));
    }
        
    trapezoid((WF_PROCESSOR)wg_gy1rdtg,"gy1rdtg",
              &gy1rdtg,&gy1rdtga,&gy1rdtgd,
              pw_gy1rdtg,pw_gy1rdtga,pw_gy1rdtgd,
              ia_gy1rdtg,ia_gy1rdtgwa,ia_gy1rdtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    PosTemp = RUP_GRD(pbeg( &gxwdtg, "gxwdtg", 0 ) - pw_gy1dtgd - pw_gy1dtg - pw_gy1dtga);
           
    trapezoid((WF_PROCESSOR)wg_gy1dtg,"gy1dtg",
              &gy1dtg,&gy1dtga,&gy1dtgd,
              pw_gy1dtg,pw_gy1dtga,pw_gy1dtgd,
              ia_gy1dtg,ia_gy1dtgwa,ia_gy1dtgwb,
              0,0,PosTemp,TRAP_ALL_SLOPED,
                          &dtgloggrd);


    /* Z crusher */
    if(dynTG_etl >=2)
    {
        PosTemp = RUP_GRD(pend(&gxw2dtg,"gxw2dtg", gxw2dtg.ninsts-1));
    }
    else
    {
        PosTemp = RUP_GRD(pend(&gxwdtg, "gxwdtg", 0));
    }

           

  trapezoid((WF_PROCESSOR)wg_gzkdtg, "gzkdtg", &gzkdtg, &gzkdtga,
                        &gzkdtgd, pw_gzkdtg, pw_gzkdtga, pw_gzkdtgd,
                        ia_gzkdtg, 0, 0, 0, 0, PosTemp+pw_gzkdtga-pw_gzkdtga, TRAP_ALL,
                        &dtgloggrd);


    /* X crusher */
           

  trapezoid((WF_PROCESSOR)wg_gxkdtg, "gxkdtg", &gxkdtg, &gxkdtga,
                        &gxkdtgd, pw_gxkdtg, pw_gxkdtga, pw_gxkdtgd,
                        ia_gxkdtg, 0, 0, 0, 0, PosTemp+pw_gxwdtgd+pw_gxkdtga-pw_gxkdtga, TRAP_ALL,
                        &dtgloggrd);


    /*****************************************
     * Attenuator lock
     *****************************************/
     
  {
  pulsename(&attenuator_keydtg,"attenuator_keydtg");
  createatten(&attenuator_keydtg, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}



      
  {
    pulsename(&seqdtg,"seqdtg");
    createseq(&seqdtg,RUP_GRD(tr_dtg), off_seqdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqdtg = %d\n", idx_seqdtg );
#endif
  }

    attenflagon(&seqdtg, 0);

    /***********************************************************
     * Pass Packet sequence
     ***********************************************************/
     
  {
    pulsename(&pass_dtg,"pass_dtg");
    createpass(&pass_dtg,(long)(RUP_GRD(TR_PSCPASS-1000)));
  }

      
  {
    pulsename(&seqpassdtg,"seqpassdtg");
    createseq(&seqpassdtg,RUP_GRD(TR_PSCPASS), off_seqpassdtg);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqpassdtg );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqpassdtg = %d\n", idx_seqpassdtg );
#endif
  }


    return SUCCESS;
}



/*
 *  ExtCalpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ExtCalpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcalwb = max_pg_wamp;

    ia_gzprcalwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcalwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0cal + pw_gzrf1cala;

         
               
  {
        INT old_res =  res_rf1cal; /* temp holder for old pulse resolution */

    if ( (wg_rf1cal != TYPRHO1)  && (wg_rf1cal != TYPRHO2) &&
         (wg_rf1cal != TYPTHETA) && (wg_rf1cal != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1cal += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1cal.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1cal,"rf1cal");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1cal].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1cal].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1cal, (WF_PROCESSOR)wg_rf1cal, new_res);

                movestretchedwave( fileloc_rf1cal, old_res,
                                   &rf1cal, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1cal = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1cal,(WF_PROCESSOR)wg_rf1cal,
                          old_res,fileloc_rf1cal);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1cal,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1cal,ia_rf1cal);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1cal,off_rf1cal,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1cal);
    

    /*** Reset Resolution ***/
    res_rf1cal = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1cal, &rf1cal, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1cal, "gzrf1cal", &gzrf1cal, &gzrf1cala,
                        &gzrf1cald, pw_gzrf1cal, pw_gzrf1cala, pw_gzrf1cald,
                        ia_gzrf1cal, 0, 0, 0, 0, pbeg(&rf1cal,"rf1cal",0)-psd_rf_wait-pw_gzrf1cala, TRAP_ALL,
                        &calloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) + pw_gzrf1cald);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcal_mem[res_gzcombcal];
        s16 gzcombcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcalf != 0))
        {
            uramp( (&gzcombcal_mem[gzcombcal_indx]),
                   (pw_gzcombcalf/per_gzcombcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcal_indx = ( pw_gzcombcalf/ per_gzcombcal );
            gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcala/per_gzcombcal),
               (short) 0, ia_gzcombcalwa , pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcalf)/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcal_mem[gzcombcal_indx]),
              (pw_gzcombcal/per_gzcombcal),
              ia_gzcombcalwa, ia_gzcombcalwb, pg_beta);
        /* Clear EOW */
        gzcombcal_indx = ( (pw_gzcombcala + pw_gzcombcal + pw_gzcombcalf )/ per_gzcombcal );
        gzcombcal_mem[gzcombcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcal_mem[gzcombcal_indx]),
               (pw_gzcombcald/per_gzcombcal),
               ia_gzcombcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcal, "gzcombcal" );
        createreserve( &gzcombcal, (WF_PROCESSOR)wg_gzcombcal, res_gzcombcal );
        createinstr( &gzcombcal,(LONG)(PosTemp+pw_gzcombcala-pw_gzcombcala - 
                                         pw_gzcombcalf),
                     (pw_gzcombcalf + pw_gzcombcala + 
                      pw_gzcombcal + pw_gzcombcald), 
                     ia_gzcombcal );
        /* Move user pulse into waveform mem */
        gzcombcal_mem[res_gzcombcal-1] |= WEOS_BIT;  
        movewaveimm(gzcombcal_mem, &gzcombcal, 
                    (int)0, res_gzcombcal, TOHARDWARE);
        if ((wg_gzcombcal==TYPRHO1)||(wg_gzcombcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcal,0,(LONG)(PosTemp+pw_gzcombcala),
                      (pw_gzcombcala + pw_gzcombcal + pw_gzcombcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcal, "gzcombcal",
                   &gzcombcal, &gzcombcala, &gzcombcald,
                   pw_gzcombcal, pw_gzcombcala, pw_gzcombcald,
                   ia_gzcombcal, ia_gzcombcalwa, ia_gzcombcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcala - pw_gzcombcala - pw_gzcombcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal + tacq_cal/2 + pw_gzprcala);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcal_mem[res_gzprcal];
        s16 gzprcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcalf != 0))
        {
            uramp( (&gzprcal_mem[gzprcal_indx]),
                   (pw_gzprcalf/per_gzprcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcal_indx = ( pw_gzprcalf/ per_gzprcal );
            gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcala/per_gzprcal),
               (short) 0, ia_gzprcalwa , pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcalf)/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcal_mem[gzprcal_indx]),
              (pw_gzprcal/per_gzprcal),
              ia_gzprcalwa, ia_gzprcalwb, pg_beta);
        /* Clear EOW */
        gzprcal_indx = ( (pw_gzprcala + pw_gzprcal + pw_gzprcalf )/ per_gzprcal );
        gzprcal_mem[gzprcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcal_mem[gzprcal_indx]),
               (pw_gzprcald/per_gzprcal),
               ia_gzprcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcal, "gzprcal" );
        createreserve( &gzprcal, (WF_PROCESSOR)wg_gzprcal, res_gzprcal );
        createinstr( &gzprcal,(LONG)(PosTemp-pw_gzprcala - 
                                         pw_gzprcalf),
                     (pw_gzprcalf + pw_gzprcala + 
                      pw_gzprcal + pw_gzprcald), 
                     ia_gzprcal );
        /* Move user pulse into waveform mem */
        gzprcal_mem[res_gzprcal-1] |= WEOS_BIT;  
        movewaveimm(gzprcal_mem, &gzprcal, 
                    (int)0, res_gzprcal, TOHARDWARE);
        if ((wg_gzprcal==TYPRHO1)||(wg_gzprcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcal,0,(LONG)(PosTemp),
                      (pw_gzprcala + pw_gzprcal + pw_gzprcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcal, "gzprcal",
                   &gzprcal, &gzprcala, &gzprcald,
                   pw_gzprcal, pw_gzprcala, pw_gzprcald,
                   ia_gzprcal, ia_gzprcalwa, ia_gzprcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcala - pw_gzprcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1cal, "gzrf1cal", 0) - calt_exb + te_cal - tacq_cal/2); /* from TE */
         

  trapezoid((WF_PROCESSOR)wg_gxwcal, "gxwcal", &gxwcal, &gxwcala,
                        &gxwcald, pw_gxwcal, pw_gxwcala, pw_gxwcald,
                        ia_gxwcal, 0, 0, 0, 0, PosTemp-pw_gxwcala, TRAP_ALL,
                        &calloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1cal,"echo1cal");
    acqq(&echo1cal, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1cal,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcal,"d3dcal");
    create3dim(&d3dcal,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcal, 0) - (pw_gx1cal + pw_gx1cald));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1cal_mem[res_gx1cal];
        s16 gx1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1calf != 0))
        {
            uramp( (&gx1cal_mem[gx1cal_indx]),
                   (pw_gx1calf/per_gx1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1cal_indx = ( pw_gx1calf/ per_gx1cal );
            gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cala/per_gx1cal),
               (short) 0, ia_gx1calwa , pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1calf)/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1cal_mem[gx1cal_indx]),
              (pw_gx1cal/per_gx1cal),
              ia_gx1calwa, ia_gx1calwb, pg_beta);
        /* Clear EOW */
        gx1cal_indx = ( (pw_gx1cala + pw_gx1cal + pw_gx1calf )/ per_gx1cal );
        gx1cal_mem[gx1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1cal_mem[gx1cal_indx]),
               (pw_gx1cald/per_gx1cal),
               ia_gx1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1cal, "gx1cal" );
        createreserve( &gx1cal, (WF_PROCESSOR)wg_gx1cal, res_gx1cal );
        createinstr( &gx1cal,(LONG)(PosTemp-pw_gx1cala - 
                                         pw_gx1calf),
                     (pw_gx1calf + pw_gx1cala + 
                      pw_gx1cal + pw_gx1cald), 
                     ia_gx1cal );
        /* Move user pulse into waveform mem */
        gx1cal_mem[res_gx1cal-1] |= WEOS_BIT;  
        movewaveimm(gx1cal_mem, &gx1cal, 
                    (int)0, res_gx1cal, TOHARDWARE);
        if ((wg_gx1cal==TYPRHO1)||(wg_gx1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1cal,0,(LONG)(PosTemp),
                      (pw_gx1cala + pw_gx1cal + pw_gx1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1cal, "gx1cal",
                   &gx1cal, &gx1cala, &gx1cald,
                   pw_gx1cal, pw_gx1cala, pw_gx1cald,
                   ia_gx1cal, ia_gx1calwa, ia_gx1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1cala - pw_gx1calf),
                   TRAP_ALL, &calloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1cal,"gzrf1cal",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1cal_mem[res_gy1cal];
        s16 gy1cal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1cal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1calf != 0))
        {
            uramp( (&gy1cal_mem[gy1cal_indx]),
                   (pw_gy1calf/per_gy1cal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1cal_indx = ( pw_gy1calf/ per_gy1cal );
            gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cala/per_gy1cal),
               (short) 0, ia_gy1calwa , pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1calf)/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1cal_mem[gy1cal_indx]),
              (pw_gy1cal/per_gy1cal),
              ia_gy1calwa, ia_gy1calwb, pg_beta);
        /* Clear EOW */
        gy1cal_indx = ( (pw_gy1cala + pw_gy1cal + pw_gy1calf )/ per_gy1cal );
        gy1cal_mem[gy1cal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1cal_mem[gy1cal_indx]),
               (pw_gy1cald/per_gy1cal),
               ia_gy1calwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1cal, "gy1cal" );
        createreserve( &gy1cal, (WF_PROCESSOR)wg_gy1cal, res_gy1cal );
        createinstr( &gy1cal,(LONG)(PosTemp+pw_gy1cala-pw_gy1cala - 
                                         pw_gy1calf),
                     (pw_gy1calf + pw_gy1cala + 
                      pw_gy1cal + pw_gy1cald), 
                     ia_gy1cal );
        /* Move user pulse into waveform mem */
        gy1cal_mem[res_gy1cal-1] |= WEOS_BIT;  
        movewaveimm(gy1cal_mem, &gy1cal, 
                    (int)0, res_gy1cal, TOHARDWARE);
        if ((wg_gy1cal==TYPRHO1)||(wg_gy1cal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1cal,0,(LONG)(PosTemp+pw_gy1cala),
                      (pw_gy1cala + pw_gy1cal + pw_gy1cald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1cal, "gy1cal",
                   &gy1cal, &gy1cala, &gy1cald,
                   pw_gy1cal, pw_gy1cala, pw_gy1cald,
                   ia_gy1cal, ia_gy1calwa, ia_gy1calwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1cala - pw_gy1cala - pw_gy1calf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcal,"gxwcal", 0) + tacq_cal);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcal_mem[res_gy1rcal];
        s16 gy1rcal_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcal, &calloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcalf != 0))
        {
            uramp( (&gy1rcal_mem[gy1rcal_indx]),
                   (pw_gy1rcalf/per_gy1rcal),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcal_indx = ( pw_gy1rcalf/ per_gy1rcal );
            gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcala/per_gy1rcal),
               (short) 0, ia_gy1rcalwa , pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcalf)/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcal_mem[gy1rcal_indx]),
              (pw_gy1rcal/per_gy1rcal),
              ia_gy1rcalwa, ia_gy1rcalwb, pg_beta);
        /* Clear EOW */
        gy1rcal_indx = ( (pw_gy1rcala + pw_gy1rcal + pw_gy1rcalf )/ per_gy1rcal );
        gy1rcal_mem[gy1rcal_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcal_mem[gy1rcal_indx]),
               (pw_gy1rcald/per_gy1rcal),
               ia_gy1rcalwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcal, "gy1rcal" );
        createreserve( &gy1rcal, (WF_PROCESSOR)wg_gy1rcal, res_gy1rcal );
        createinstr( &gy1rcal,(LONG)(PosTemp+pw_gy1rcala-pw_gy1rcala - 
                                         pw_gy1rcalf),
                     (pw_gy1rcalf + pw_gy1rcala + 
                      pw_gy1rcal + pw_gy1rcald), 
                     ia_gy1rcal );
        /* Move user pulse into waveform mem */
        gy1rcal_mem[res_gy1rcal-1] |= WEOS_BIT;  
        movewaveimm(gy1rcal_mem, &gy1rcal, 
                    (int)0, res_gy1rcal, TOHARDWARE);
        if ((wg_gy1rcal==TYPRHO1)||(wg_gy1rcal==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcal,0,(LONG)(PosTemp+pw_gy1rcala),
                      (pw_gy1rcala + pw_gy1rcal + pw_gy1rcald));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcal, "gy1rcal",
                   &gy1rcal, &gy1rcala, &gy1rcald,
                   pw_gy1rcal, pw_gy1rcala, pw_gy1rcald,
                   ia_gy1rcal, ia_gy1rcalwa, ia_gy1rcalwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcala - pw_gy1rcala - pw_gy1rcalf),
                   TRAP_ALL_SLOPED, &calloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycal,"attenuator_keycal");
  createatten(&attenuator_keycal, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcal,"seqcal");
    createseq(&seqcal,RUP_GRD(tr_cal), off_seqcal);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcal );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcal = %d\n", idx_seqcal );
#endif
  }

    attenflagon(&seqcal, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscal,"d3dpasscal");
    create3dim(&d3dpasscal,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecal,"pass_pulsecal");
    createpass(&pass_pulsecal,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcalpass,"seqcalpass");
    createseq(&seqcalpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssical), off_seqcalpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcalpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcalpass = %d\n", idx_seqcalpass );
#endif
  }


    return SUCCESS;
}   /* End of ExtCalpulsegen */


/*
 *  AutoCoilpulsegen
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
AutoCoilpulsegen( void )
{
    INT PosStart;
    INT PosTemp;
    INT DabSetUp, PosDabPkt, PosXtrPkt;

    /* set slice encoding to full scale */
    ia_gzcombcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzcombcoilwb = max_pg_wamp;
    
    ia_gzprcoilwa = (int)(PSDRAMPEDTRAP*max_pg_wamp);
    ia_gzprcoilwb = max_pg_wamp;

    /* selective RF1 */
    PosStart = td0coil + pw_gzrf1coila;

         
               
  {
        INT old_res =  res_rf1coil; /* temp holder for old pulse resolution */

    if ( (wg_rf1coil != TYPRHO1)  && (wg_rf1coil != TYPRHO2) &&
         (wg_rf1coil != TYPTHETA) && (wg_rf1coil != TYPOMEGA) ) {

        fprintf( stderr, "EXTWAVE2 macro must create pulses on RHO1 or RHO2.\n");
        fflush( stderr );

        return FAILURE;
    }

    n_rf1coil += 1;  /* Increment counter */

    /*** Read in waveform if it has not been created yet ***/

    if( rf1coil.ninsts == 0 ) {        

        /* Set pulsename */
        pulsename(&rf1coil,"rf1coil");
        
        /* Scale waveform if needed */
            if( rfpulseInfo[rfslot_rf1coil].change==PSD_ON )
            {
                INT new_res =  rfpulseInfo[rfslot_rf1coil].newres;

            /**************************************************************** 
             *  Create some board waveform space, scale the pulse, and then
             *  move the local memory to the reserved board memory, and set
             *  pulsepointers to new stretched pulse.
             *
             *  Now create the rf pulse & perform required system safety
             *  checks and create a temporary buffer for the stretched RF
             *  pulse. Stretch the pulse and copy stretched data into
             *  permanent waveform memory. It is important to have temp
             *  buffer have new resolution size waveform memory.
             ****************************************************************/

            /* Reserve waveform memory on the RF channel for
               stretched RF pulse */
            createreserve(&rf1coil, (WF_PROCESSOR)wg_rf1coil, new_res);

                movestretchedwave( fileloc_rf1coil, old_res,
                                   &rf1coil, 0, new_res );
            
            /*  Set the resolution of the RF pulse to the resolution of the
             *  stretched RF pulse.  This is done becaused the createinstr()
             *  access the RF pulse structure, which contains a reference to
             *  the resolution of the RF pulse.  When the instruction is
             *  created it must contain the resolution of the stretched RF
             *  pulse.
             */
            res_rf1coil = new_res;
        } else {
            
            /* No rf scaling required. Use createextwave
               to read pulse and move to HW.             */ 
            createextwave(&rf1coil,(WF_PROCESSOR)wg_rf1coil,
                          old_res,fileloc_rf1coil);
        }
    }


    /*** Create Instruction Node ***/
    createinstr( &rf1coil,(LONG)(PosStart) + psd_rf_wait, 
                 pw_rf1coil,ia_rf1coil);
    

    /*** Add RF Bits ***/
    addrfbits(&rf1coil,off_rf1coil,(LONG)(PosStart) + psd_rf_wait,
              pw_rf1coil);
    

    /*** Reset Resolution ***/
    res_rf1coil = old_res;
    /* Reset the resolution of the RF pulse to the original
       (unstretched) resolution. This is necessary to allow this macro
       to be called multiple times. */
  }


    setiamp(ia_rf1coil, &rf1coil, 0);

    /* Z slice selective for rf1 */
       
               

  trapezoid((WF_PROCESSOR)wg_gzrf1coil, "gzrf1coil", &gzrf1coil, &gzrf1coila,
                        &gzrf1coild, pw_gzrf1coil, pw_gzrf1coila, pw_gzrf1coild,
                        ia_gzrf1coil, 0, 0, 0, 0, pbeg(&rf1coil,"rf1coil",0)-psd_rf_wait-pw_gzrf1coila, TRAP_ALL,
                        &coilloggrd);


    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) + pw_gzrf1coild);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzcombcoil_mem[res_gzcombcoil];
        s16 gzcombcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcombcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzcombcoilf != 0))
        {
            uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
                   (pw_gzcombcoilf/per_gzcombcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzcombcoil_indx = ( pw_gzcombcoilf/ per_gzcombcoil );
            gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoila/per_gzcombcoil),
               (short) 0, ia_gzcombcoilwa , pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoilf)/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzcombcoil_mem[gzcombcoil_indx]),
              (pw_gzcombcoil/per_gzcombcoil),
              ia_gzcombcoilwa, ia_gzcombcoilwb, pg_beta);
        /* Clear EOW */
        gzcombcoil_indx = ( (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoilf )/ per_gzcombcoil );
        gzcombcoil_mem[gzcombcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzcombcoil_mem[gzcombcoil_indx]),
               (pw_gzcombcoild/per_gzcombcoil),
               ia_gzcombcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzcombcoil, "gzcombcoil" );
        createreserve( &gzcombcoil, (WF_PROCESSOR)wg_gzcombcoil, res_gzcombcoil );
        createinstr( &gzcombcoil,(LONG)(PosTemp+pw_gzcombcoila-pw_gzcombcoila - 
                                         pw_gzcombcoilf),
                     (pw_gzcombcoilf + pw_gzcombcoila + 
                      pw_gzcombcoil + pw_gzcombcoild), 
                     ia_gzcombcoil );
        /* Move user pulse into waveform mem */
        gzcombcoil_mem[res_gzcombcoil-1] |= WEOS_BIT;  
        movewaveimm(gzcombcoil_mem, &gzcombcoil, 
                    (int)0, res_gzcombcoil, TOHARDWARE);
        if ((wg_gzcombcoil==TYPRHO1)||(wg_gzcombcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzcombcoil,0,(LONG)(PosTemp+pw_gzcombcoila),
                      (pw_gzcombcoila + pw_gzcombcoil + pw_gzcombcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzcombcoil, "gzcombcoil",
                   &gzcombcoil, &gzcombcoila, &gzcombcoild,
                   pw_gzcombcoil, pw_gzcombcoila, pw_gzcombcoild,
                   ia_gzcombcoil, ia_gzcombcoilwa, ia_gzcombcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gzcombcoila - pw_gzcombcoila - pw_gzcombcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    /* Z rewinder */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil + tacq_coil/2 + pw_gzprcoila);
       
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gzprcoil_mem[res_gzprcoil];
        s16 gzprcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzprcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gzprcoilf != 0))
        {
            uramp( (&gzprcoil_mem[gzprcoil_indx]),
                   (pw_gzprcoilf/per_gzprcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gzprcoil_indx = ( pw_gzprcoilf/ per_gzprcoil );
            gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoila/per_gzprcoil),
               (short) 0, ia_gzprcoilwa , pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoilf)/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gzprcoil_mem[gzprcoil_indx]),
              (pw_gzprcoil/per_gzprcoil),
              ia_gzprcoilwa, ia_gzprcoilwb, pg_beta);
        /* Clear EOW */
        gzprcoil_indx = ( (pw_gzprcoila + pw_gzprcoil + pw_gzprcoilf )/ per_gzprcoil );
        gzprcoil_mem[gzprcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gzprcoil_mem[gzprcoil_indx]),
               (pw_gzprcoild/per_gzprcoil),
               ia_gzprcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gzprcoil, "gzprcoil" );
        createreserve( &gzprcoil, (WF_PROCESSOR)wg_gzprcoil, res_gzprcoil );
        createinstr( &gzprcoil,(LONG)(PosTemp-pw_gzprcoila - 
                                         pw_gzprcoilf),
                     (pw_gzprcoilf + pw_gzprcoila + 
                      pw_gzprcoil + pw_gzprcoild), 
                     ia_gzprcoil );
        /* Move user pulse into waveform mem */
        gzprcoil_mem[res_gzprcoil-1] |= WEOS_BIT;  
        movewaveimm(gzprcoil_mem, &gzprcoil, 
                    (int)0, res_gzprcoil, TOHARDWARE);
        if ((wg_gzprcoil==TYPRHO1)||(wg_gzprcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gzprcoil,0,(LONG)(PosTemp),
                      (pw_gzprcoila + pw_gzprcoil + pw_gzprcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gzprcoil, "gzprcoil",
                   &gzprcoil, &gzprcoila, &gzprcoild,
                   pw_gzprcoil, pw_gzprcoila, pw_gzprcoild,
                   ia_gzprcoil, ia_gzprcoilwa, ia_gzprcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gzprcoila - pw_gzprcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /* *******************************************
     * X Dephaser, Readout, and Data Acquisition
     * ***************************************** */
    PosTemp = RUP_GRD(pend(&gzrf1coil, "gzrf1coil", 0) - coilt_exb + te_coil - tacq_coil/2);
         

  trapezoid((WF_PROCESSOR)wg_gxwcoil, "gxwcoil", &gxwcoil, &gxwcoila,
                        &gxwcoild, pw_gxwcoil, pw_gxwcoila, pw_gxwcoild,
                        ia_gxwcoil, 0, 0, 0, 0, PosTemp-pw_gxwcoila, TRAP_ALL,
                        &coilloggrd);


    DabSetUp = IMax(2,DABSETUP,(fast_xtr+XTR_length[bd_index]+DAB_length[bd_index]));
    PosDabPkt = RUP_GRD(PosTemp+psd_grd_wait-DabSetUp);
    PosXtrPkt = RUP_GRD(PosTemp+psd_grd_wait-XTR_length[bd_index]-fast_xtr);

        
  {
    pulsename(&echo1coil,"echo1coil");
    acqq(&echo1coil, (long)(PosTemp+psd_grd_wait),(long)(PosDabPkt),
        (long)(PosXtrPkt),(long)filter_echo1coil,
        (TYPDAB_PACKETS)DABNORM);
  }


    /* ***************************************
        Create the 3d packet
       ***************************************** */
      
  {
    pulsename(&d3dcoil,"d3dcoil");
    create3dim(&d3dcoil,(long)(PosTemp+psd_grd_wait),(long)(PosDabPkt+DAB_length[bd_index]));
  }



    PosTemp = RUP_GRD(pbegall(&gxwcoil, 0) - (pw_gx1coil + pw_gx1coild));

              
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gx1coil_mem[res_gx1coil];
        s16 gx1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gx1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gx1coilf != 0))
        {
            uramp( (&gx1coil_mem[gx1coil_indx]),
                   (pw_gx1coilf/per_gx1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gx1coil_indx = ( pw_gx1coilf/ per_gx1coil );
            gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coila/per_gx1coil),
               (short) 0, ia_gx1coilwa , pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coilf)/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gx1coil_mem[gx1coil_indx]),
              (pw_gx1coil/per_gx1coil),
              ia_gx1coilwa, ia_gx1coilwb, pg_beta);
        /* Clear EOW */
        gx1coil_indx = ( (pw_gx1coila + pw_gx1coil + pw_gx1coilf )/ per_gx1coil );
        gx1coil_mem[gx1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gx1coil_mem[gx1coil_indx]),
               (pw_gx1coild/per_gx1coil),
               ia_gx1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gx1coil, "gx1coil" );
        createreserve( &gx1coil, (WF_PROCESSOR)wg_gx1coil, res_gx1coil );
        createinstr( &gx1coil,(LONG)(PosTemp-pw_gx1coila - 
                                         pw_gx1coilf),
                     (pw_gx1coilf + pw_gx1coila + 
                      pw_gx1coil + pw_gx1coild), 
                     ia_gx1coil );
        /* Move user pulse into waveform mem */
        gx1coil_mem[res_gx1coil-1] |= WEOS_BIT;  
        movewaveimm(gx1coil_mem, &gx1coil, 
                    (int)0, res_gx1coil, TOHARDWARE);
        if ((wg_gx1coil==TYPRHO1)||(wg_gx1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gx1coil,0,(LONG)(PosTemp),
                      (pw_gx1coila + pw_gx1coil + pw_gx1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gx1coil, "gx1coil",
                   &gx1coil, &gx1coila, &gx1coild,
                   pw_gx1coil, pw_gx1coila, pw_gx1coild,
                   ia_gx1coil, ia_gx1coilwa, ia_gx1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp - pw_gx1coila - pw_gx1coilf),
                   TRAP_ALL, &coilloggrd );
#endif
    }


    /* *******************************************
     * Y phase encode and rewind
     * *******************************************/
    PosTemp = RUP_GRD((INT)(pend(&gzrf1coil,"gzrf1coil",0)));
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1coil_mem[res_gy1coil];
        s16 gy1coil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1coil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1coilf != 0))
        {
            uramp( (&gy1coil_mem[gy1coil_indx]),
                   (pw_gy1coilf/per_gy1coil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1coil_indx = ( pw_gy1coilf/ per_gy1coil );
            gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coila/per_gy1coil),
               (short) 0, ia_gy1coilwa , pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coilf)/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1coil_mem[gy1coil_indx]),
              (pw_gy1coil/per_gy1coil),
              ia_gy1coilwa, ia_gy1coilwb, pg_beta);
        /* Clear EOW */
        gy1coil_indx = ( (pw_gy1coila + pw_gy1coil + pw_gy1coilf )/ per_gy1coil );
        gy1coil_mem[gy1coil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1coil_mem[gy1coil_indx]),
               (pw_gy1coild/per_gy1coil),
               ia_gy1coilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1coil, "gy1coil" );
        createreserve( &gy1coil, (WF_PROCESSOR)wg_gy1coil, res_gy1coil );
        createinstr( &gy1coil,(LONG)(PosTemp+pw_gy1coila-pw_gy1coila - 
                                         pw_gy1coilf),
                     (pw_gy1coilf + pw_gy1coila + 
                      pw_gy1coil + pw_gy1coild), 
                     ia_gy1coil );
        /* Move user pulse into waveform mem */
        gy1coil_mem[res_gy1coil-1] |= WEOS_BIT;  
        movewaveimm(gy1coil_mem, &gy1coil, 
                    (int)0, res_gy1coil, TOHARDWARE);
        if ((wg_gy1coil==TYPRHO1)||(wg_gy1coil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1coil,0,(LONG)(PosTemp+pw_gy1coila),
                      (pw_gy1coila + pw_gy1coil + pw_gy1coild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1coil, "gy1coil",
                   &gy1coil, &gy1coila, &gy1coild,
                   pw_gy1coil, pw_gy1coila, pw_gy1coild,
                   ia_gy1coil, ia_gy1coilwa, ia_gy1coilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1coila - pw_gy1coila - pw_gy1coilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }


    PosTemp = RUP_GRD(pbeg(&gxwcoil,"gxwcoil", 0) + tacq_coil);
      
    {
#if defined(IPG_TGT) || defined(MGD_TGT)
        s16 gy1rcoil_mem[res_gy1rcoil];
        s16 gy1rcoil_indx = 0;       /* indx into user memory */

        getbeta(&pg_beta, (WF_PROCESSOR)wg_gy1rcoil, &coilloggrd);

        /* leading edge of zeros */
        if ((0 != 0) && (pw_gy1rcoilf != 0))
        {
            uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
                   (pw_gy1rcoilf/per_gy1rcoil),
                   (short)0, (short)0, pg_beta );
            /* Clear EOW */
            gy1rcoil_indx = ( pw_gy1rcoilf/ per_gy1rcoil );
            gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        }
        /* Up ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoila/per_gy1rcoil),
               (short) 0, ia_gy1rcoilwa , pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoilf)/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Top const */
        uramp((&gy1rcoil_mem[gy1rcoil_indx]),
              (pw_gy1rcoil/per_gy1rcoil),
              ia_gy1rcoilwa, ia_gy1rcoilwb, pg_beta);
        /* Clear EOW */
        gy1rcoil_indx = ( (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoilf )/ per_gy1rcoil );
        gy1rcoil_mem[gy1rcoil_indx-1] &= ~WEOS_BIT;
        /* Decay Ramp */
        uramp( (&gy1rcoil_mem[gy1rcoil_indx]),
               (pw_gy1rcoild/per_gy1rcoil),
               ia_gy1rcoilwb, (short) 0, pg_beta );

        /* Create pulse and memory */
        pulsename( &gy1rcoil, "gy1rcoil" );
        createreserve( &gy1rcoil, (WF_PROCESSOR)wg_gy1rcoil, res_gy1rcoil );
        createinstr( &gy1rcoil,(LONG)(PosTemp+pw_gy1rcoila-pw_gy1rcoila - 
                                         pw_gy1rcoilf),
                     (pw_gy1rcoilf + pw_gy1rcoila + 
                      pw_gy1rcoil + pw_gy1rcoild), 
                     ia_gy1rcoil );
        /* Move user pulse into waveform mem */
        gy1rcoil_mem[res_gy1rcoil-1] |= WEOS_BIT;  
        movewaveimm(gy1rcoil_mem, &gy1rcoil, 
                    (int)0, res_gy1rcoil, TOHARDWARE);
        if ((wg_gy1rcoil==TYPRHO1)||(wg_gy1rcoil==TYPRHO2))
        {				/* Add rf control bits if rf pulse */
            addrfbits(&gy1rcoil,0,(LONG)(PosTemp+pw_gy1rcoila),
                      (pw_gy1rcoila + pw_gy1rcoil + pw_gy1rcoild));
        }
#elif defined(HOST_TGT)
        /* When the SINGLE_TRAP macro is expanded on the Host, we want a real
           trapezoid (a TRAPEZOID2) to be created instead. Note that the start
           and end amplitudes are not provided as arguments to this macro and
           are assumed to be zero. Also, the position of the trapezoid does
           not include the attack and leading parts. This is the same thing 
           that is done in the uramp() calls above. - GFN - 12/Aug/1998 */
        trapezoid( (WF_PROCESSOR)wg_gy1rcoil, "gy1rcoil",
                   &gy1rcoil, &gy1rcoila, &gy1rcoild,
                   pw_gy1rcoil, pw_gy1rcoila, pw_gy1rcoild,
                   ia_gy1rcoil, ia_gy1rcoilwa, ia_gy1rcoilwb,
                   0 /* trp_start */, 0 /* trp_end */,
                   (LONG)(PosTemp+pw_gy1rcoila - pw_gy1rcoila - pw_gy1rcoilf),
                   TRAP_ALL_SLOPED, &coilloggrd );
#endif
    }



    /*****************************************
    * Attenuator lock
    * *****************************************/
     
  {
  pulsename(&attenuator_keycoil,"attenuator_keycoil");
  createatten(&attenuator_keycoil, (long)(RUP_GRD(PosTemp+psd_grd_wait)));
}


      
  {
    pulsename(&seqcoil,"seqcoil");
    createseq(&seqcoil,RUP_GRD(tr_coil), off_seqcoil);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoil );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoil = %d\n", idx_seqcoil );
#endif
  }

    attenflagon(&seqcoil, 0);

    PosTemp = 10000;  /* time to make sure last processing is complete */

    
  {
    pulsename(&d3dpasscoil,"d3dpasscoil");
    create3dim(&d3dpasscoil,(long)(0),(long)(PosTemp));
  }

       
  {
    pulsename(&pass_pulsecoil,"pass_pulsecoil");
    createpass(&pass_pulsecoil,(long)(RUP_GRD(PSTR_PASS-1000)));
  }

          
  {
    pulsename(&seqcoilpass,"seqcoilpass");
    createseq(&seqcoilpass,RUP_GRD(PosTemp+PSTR_PASS-time_ssicoil), off_seqcoilpass);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqcoilpass );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqcoilpass = %d\n", idx_seqcoilpass );
#endif
  }


    return SUCCESS;
}   /* End of AutoCoilpulsegen */




/* FOR MERGE */
#include "RtpPsd.h"
#include "RtpCommon.h"
#include "smartprepRTP.h"
#include "rtp_feedback_task.h"

int smartprep_detected = 0;
float smartprep_signal = 0.0;

#if defined(MGD_TGT) && defined(PSD_HW)
long roundtrip_time = 0;
long max_roundtrip_time = 0;
long min_roundtrip_time = 9999;
#define SPREP_NUM_TIMING_POINTS 200 
long sprep_roundtrip_timing_array[SPREP_NUM_TIMING_POINTS];
long sprep_roundtrip_index = 0;
#endif

int *mon_receive_freq1;
int *rf1mon_freq, *rf2mon_freq, *rfmontipup_freq;

float datamax[MAX_DATA_POINTS];
long nav_timing[MAX_DATA_POINTS];
float last_buff[1024];
int buffmax,buffmaxloc;
float gycylr0_scale,gzcylr0_scale;
float gycylrtipup0_scale,gzcylrtipup0_scale;


STATUS monitor_PG(void)
{
    INT postemp;

    /* CYL Nav */
    EXTERN_FILENAME rf_ext;
    EXTERN_FILENAME th_ext;
    EXTERN_FILENAME gy_ext;
    EXTERN_FILENAME gz_ext;

    short *temp_wspace_mon;
    short *wspace_mon;
    int temp_res;

    if (navigator_flag && navigatorCYL_flag)
    {
        if (CYLR_CONSTANT_DENSITY == cylr_rf_type)
        {   /* XRM */
            strcpy(rf_ext,"cylrf2400.rho");
            strcpy(th_ext,"cylrf2400.rho");
            strcpy(gy_ext,"cylgy12c2400.grd");
            strcpy(gz_ext,"cylgz12c2400.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR75 == cylr_rf_type)
        {   /* TRM-W */
            strcpy(rf_ext,"cylrfsr75.rho");
            strcpy(th_ext,"cylrfsr75.rho");
            strcpy(gy_ext,"cylgysr75.grd");
            strcpy(gz_ext,"cylgzsr75.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR107 == cylr_rf_type)
        {   /* VRMW */
            strcpy(rf_ext,"cylrfsr107.rho");
            strcpy(th_ext,"cylrfsr107.rho");
            strcpy(gy_ext,"cylgysr107.grd");
            strcpy(gz_ext,"cylgzsr107.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR118 == cylr_rf_type)
        {   /* BRM/CRM */
            strcpy(rf_ext,"cylrfsr118.rho");
            strcpy(th_ext,"cylrfsr118.rho");
            strcpy(gy_ext,"cylgysr118.grd");
            strcpy(gz_ext,"cylgzsr118.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR145 == cylr_rf_type) 
        {   /* XRMW, TRM-Z */
            strcpy(rf_ext,"cylrfsr145.rho");
            strcpy(th_ext,"cylrfsr145.rho");
            strcpy(gy_ext,"cylgysr145.grd");
            strcpy(gz_ext,"cylgzsr145.grd");
        }
        else if (CYLR_VARIABLE_DENSITY_SR190 == cylr_rf_type)
        {   /* XRM */
            strcpy(rf_ext,"cylrfsr190.rho");
            strcpy(th_ext,"cylrfsr190.rho");
            strcpy(gy_ext,"cylgysr190.grd");
            strcpy(gz_ext,"cylgzsr190.grd");
        }
        else
        {
            psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "Invalid cylindrical pulse type",
                    PSD_ARG_STRING, "Monitor_PG()", 0);
            return FAILURE;
        }

        /* 2D Cylindrical RF */
        
  {
    pulsename(&gycylra,"gycylra");
 
        getbeta(&pg_beta, (WF_PROCESSOR)wg_gycylra, &monloggrd);
 
    if ( (start_gycylra>0.0) || (start_gycylra<0.0) )
      {
        createramp(&gycylra,(WF_PROCESSOR)wg_gycylra,pw_gycylra,
                   ia_stgycylra,ia_endgycylra,
                   (short)(maxGradRes*(pw_gycylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gycylra,(long)(tlead_monitor-pw_gycylra),pw_gycylra,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gycylra,(WF_PROCESSOR)wg_gycylra,pw_gycylra,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gycylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gycylra,(long)(tlead_monitor-pw_gycylra),pw_gycylra,
                    ia_endgycylra);
      }
  }

        
  {
    pulsename(&gzcylra,"gzcylra");
 
        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcylra, &monloggrd);
 
    if ( (start_gzcylra>0.0) || (start_gzcylra<0.0) )
      {
        createramp(&gzcylra,(WF_PROCESSOR)wg_gzcylra,pw_gzcylra,
                   ia_stgzcylra,ia_endgzcylra,
                   (short)(maxGradRes*(pw_gzcylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzcylra,(long)(tlead_monitor-pw_gzcylra),pw_gzcylra,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gzcylra,(WF_PROCESSOR)wg_gzcylra,pw_gzcylra,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gzcylra/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gzcylra,(long)(tlead_monitor-pw_gzcylra),pw_gzcylra,
                    ia_endgzcylra);
      }
  }


        postemp = tlead_monitor;
        /* RFCYLR */
        temp_wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,rf_ext);
#endif
        /* Stretch rf pw if needed */ 
        temp_res = res_rfcylr;
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(rfpulseInfo[RFCYLR_SLOT].newres*sizeof(short));
            stretchpulse((int)res_rfcylr,(int)rfpulseInfo[RFCYLR_SLOT].newres,temp_wspace_mon,wspace_mon);
            res_rfcylr = rfpulseInfo[RFCYLR_SLOT].newres;
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&rfcylr,"rfcylr");
    createreserve(&rfcylr,(WF_PROCESSOR)wg_rfcylr,
		  res_rfcylr);
  }

        addrfbits(&rfcylr, 0, postemp+psd_rf_wait, pw_rfcylr);
        createinstr(&rfcylr, postemp+psd_rf_wait, pw_rfcylr,ia_rfcylr);

        movewaveimm(wspace_mon, &rfcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* THCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,th_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&thcylr,"thcylr");
    createreserve(&thcylr,(WF_PROCESSOR)wg_thcylr,
		  res_thcylr);
  }

        addrfbits(&thcylr, 0, postemp+psd_rf_wait, pw_thcylr);
        createinstr(&thcylr, postemp+psd_rf_wait, pw_thcylr,ia_thcylr);

        movewaveimm(wspace_mon, &thcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* GYCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,gy_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&gycylr,"gycylr");
    createreserve(&gycylr,(WF_PROCESSOR)wg_gycylr,
		  res_gycylr);
  }

        createinstr(&gycylr, postemp, pw_gycylr,ia_gycylr);

        movewaveimm(wspace_mon, &gycylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* GZCYLR */
        temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
        uextwave(temp_wspace_mon,res_rfcylr,gz_ext);
#endif
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            wspace_mon = (short *)AllocNode(res_rfcylr*sizeof(short));
            stretchpulse((int)temp_res,(int)res_rfcylr,temp_wspace_mon,wspace_mon);
            FreeNode(temp_wspace_mon);
        } else {
            wspace_mon = temp_wspace_mon; 
        }

        /* move the wave to the hardware */
          
  {
    pulsename(&gzcylr,"gzcylr");
    createreserve(&gzcylr,(WF_PROCESSOR)wg_gzcylr,
		  res_gzcylr);
  }

        createinstr(&gzcylr, postemp, pw_gzcylr,ia_gzcylr);

        movewaveimm(wspace_mon, &gzcylr, (int)0, res_rfcylr, TOHARDWARE);
        FreeNode(wspace_mon);

        /* Change back incase external grad_file used */
        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            res_rfcylr = temp_res;
        }

        postemp = RUP_GRD(tlead_monitor+t_exa_cylr+act_te_cylr-rda_mon);
    } 
    else 
    {
        
                   
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf1mon", 
                                    (WF_PROCESSOR)wg_rf1mon);

    /* Modify resolution if scaling required */
    temp_res_rf1mon = res_rf1mon;
    if (rfpulseInfo[RF1MON_SLOT].change==PSD_ON)
       res_rf1mon = rfpulseInfo[RF1MON_SLOT].newres;
    /* First create the pulses */
    pulsename(&gzrf1mona,"gzrf1mona");
    pulsename(&gzrf1mon,"gzrf1mon");
    pulsename(&gzrf1mond,"gzrf1mond");
    pulsename(&rf1mon,"rf1mon");
    
    /*  Now create the slice select trapezoid */
	pg_beta = monloggrd.zbeta;
    createramp(&gzrf1mona,ZGRAD,pw_gzrf1mona,(short)0,
	       MAX_PG_WAMP,(short)(maxGradRes*(pw_gzrf1mona/
		   GRAD_UPDATE_TIME)),pg_beta);
    createinstr( &gzrf1mona,(LONG)(tlead_monitor-pw_gzrf1mona),
		pw_gzrf1mona,ia_gzrf1mon);
    createconst(&gzrf1mon,ZGRAD,pw_gzrf1mon,MAX_PG_WAMP);
    createinstr( &gzrf1mon,(LONG)(tlead_monitor),
		pw_gzrf1mon,ia_gzrf1mon);
    createramp(&gzrf1mond,ZGRAD,pw_gzrf1mond,MAX_PG_WAMP,
	       (short)0,(short)(maxGradRes*(pw_gzrf1mond/GRAD_UPDATE_TIME)),
		   pg_beta);
    createinstr( &gzrf1mond,(LONG)(tlead_monitor+pw_gzrf1mon),
		pw_gzrf1mond,ia_gzrf1mon);
    
    /* Now create the rf pulse */
    createsinc(&rf1mon,(WF_PROCESSOR)wg_rf1mon,res_rf1mon,
	       MAX_PG_WAMP,cyc_rf1mon, alpha_rf1mon);
    createinstr( &rf1mon,(LONG)(tlead_monitor) + psd_rf_wait,
		pw_rf1mon,ia_rf1mon);
    linkpulses(4,&rf1mon,&gzrf1mon,&gzrf1mona,
	       &gzrf1mond);
    addrfbits(&rf1mon,off_rf1mon,(LONG)(tlead_monitor) + psd_rf_wait, 
	      pw_rf1mon);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF1MON_SLOT].change==PSD_ON)
       res_rf1mon = temp_res_rf1mon;
  }


        

  trapezoid((WF_PROCESSOR)wg_gyrf1mon, "gyrf1mon", &gyrf1mon, &gyrf1mona,
                        &gyrf1mond, pw_gyrf1mon, pw_gyrf1mona, pw_gyrf1mond,
                        ia_gyrf1mon, 0, 0, 0, 0, tlead_monitor-pw_gyrf1mona, TRAP_ALL,
                        &monloggrd);


        /* Refocus on Z gradient */
        postemp = RUP_GRD(pend(&gzrf1mond,"gzrf1mond",0));
        

  trapezoid((WF_PROCESSOR)wg_gz1mon, "gz1mon", &gz1mon, &gz1mona,
                        &gz1mond, pw_gz1mon, pw_gz1mona, pw_gz1mond,
                        ia_gz1mon, 0, 0, 0, 0, postemp+pw_gz1mona-pw_gz1mona, TRAP_ALL,
                        &monloggrd);


        /* SVBranch HCSDM00313823. Do not generate gy1mon when selecting smartprep on SV system.
           On SV system, with 5mm tracker thickness, gy1mond and gyrf2lmona overlapped and triggered a download failure.
           As a quick solution, we removed gy1mon. This has no impact for smartprep, since amplitude of gy1mon is zero
           for smartprep. */
        if( !((VALUE_SYSTEM_SVEM == value_system_flag) || (VALUE_SYSTEM_SVDM == value_system_flag)) || !smartprep_flag)
        {
            

  trapezoid((WF_PROCESSOR)wg_gy1mon, "gy1mon", &gy1mon, &gy1mona,
                        &gy1mond, pw_gy1mon, pw_gy1mona, pw_gy1mond,
                        ia_gy1mon, 0, 0, 0, 0, postemp+pw_gy1mona-pw_gy1mona, TRAP_ALL,
                        &monloggrd);

        }

        postemp = RUP_GRD( (pbeg(&gzrf1mon,"gzrf1mon",0) + pw_gzrf1mon/2)
                   + te_180sp/2 - pw_gyrf2mon/2) ;

             
                    
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rf2mon", 
                                     (WF_PROCESSOR)wg_rf2mon);

    /* Modify resolution if scaling required */
    temp_res_rf2mon = res_rf2mon;
    if (rfpulseInfo[RF2MON_SLOT].change==PSD_ON)
      res_rf2mon = rfpulseInfo[RF2MON_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrf2mona,"gyrf2mona");
    pulsename(&gyrf2mon,"gyrf2mon");
    pulsename(&gyrf2mond,"gyrf2mond");
    pulsename(&rf2mon,"rf2mon");

	/*  Now create the slice select trapezoid */
  pg_beta = monloggrd.ybeta;
  createramp(&gyrf2mona,YGRAD,pw_gyrf2mona,(short)0,MAX_PG_WAMP,
			(short)(maxGradRes*(pw_gyrf2mona/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrf2mona,(LONG)(postemp-pw_gyrf2mona),
      pw_gyrf2mona,ia_gyrf2mon);
  createconst(&gyrf2mon,YGRAD,pw_gyrf2mon,MAX_PG_WAMP);
  createinstr( &gyrf2mon,(LONG)(postemp),
      pw_gyrf2mon,ia_gyrf2mon);
  createramp(&gyrf2mond,YGRAD,pw_gyrf2mond,MAX_PG_WAMP,
			(short)0,(short)(maxGradRes*(pw_gyrf2mond/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrf2mond,(LONG)(postemp+pw_gyrf2mon),
      pw_gyrf2mond,ia_gyrf2mon);

    /* Now create the rf pulse */
    createsinc(&rf2mon,(WF_PROCESSOR)wg_rf2mon,res_rf2mon,
	       MAX_PG_WAMP,cyc_rf2mon, alpha_rf2mon);
    createinstr( &rf2mon,(LONG)(postemp) + psd_rf_wait,
		pw_rf2mon,ia_rf2mon);
    linkpulses(4,&rf2mon,&gyrf2mon,&gyrf2mona,&gyrf2mond);
    addrfbits(&rf2mon,off_rf2mon,(LONG)(postemp) + psd_rf_wait,
	      pw_rf2mon);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RF2MON_SLOT].change==PSD_ON)
      res_rf2mon = temp_res_rf2mon;
}


        /* Apply 90 phase shift to 180 pulse */
        setphase((float)(M_PI/-2.0), &rf2mon, 0);
  
        /* crushers */
        postemp = pbeg(&gyrf2mon,"gyrf2mon",0) - pw_gyrf2lmon - pw_gyrf2lmond;
           

  trapezoid((WF_PROCESSOR)wg_gyrf2lmon, "gyrf2lmon", &gyrf2lmon, &gyrf2lmona,
                        &gyrf2lmond, pw_gyrf2lmon, pw_gyrf2lmona, pw_gyrf2lmond,
                        ia_gyrf2lmon, 0, 0, 0, 0, postemp-pw_gyrf2lmona, TRAP_ALL,
                        &monloggrd);

  
             

  trapezoid((WF_PROCESSOR)wg_gyrf2rmon, "gyrf2rmon", &gyrf2rmon, &gyrf2rmona,
                        &gyrf2rmond, pw_gyrf2rmon, pw_gyrf2rmona, pw_gyrf2rmond,
                        ia_gyrf2rmon, 0, 0, 0, 0, pendall(&gyrf2mon,0)-pw_gyrf2rmona, TRAP_ALL,
                        &monloggrd);


        postemp = RUP_GRD(pmid(&gyrf2mon,"gyrf2mon",0)+ (te_180sp/2) - rda_mon);
    }

    

  trapezoid((WF_PROCESSOR)wg_gxwmon, "gxwmon", &gxwmon, &gxwmona,
                        &gxwmond, pw_gxwmon, pw_gxwmona, pw_gxwmond,
                        ia_gxwmon, 0, 0, 0, 0, postemp-pw_gxwmona, TRAP_ALL,
                        &monloggrd);
    
  
    /* read dephaser */
    postemp = RUP_GRD(pbeg(&gxwmon, "gxwmon", 0) - pw_gxwmona - pw_gx1mond - pw_gx1mon);

    

  trapezoid((WF_PROCESSOR)wg_gx1mon, "gx1mon", &gx1mon, &gx1mona,
                        &gx1mond, pw_gx1mon, pw_gx1mona, pw_gx1mond,
                        ia_gx1mon, 0, 0, 0, 0, postemp-pw_gx1mona, TRAP_ALL,
                        &monloggrd);


    if (mon_fcomp)
    {			
        /* 1st echo flow comp pulse */
        postemp = pbegall(&gx1mon,0)-(pw_gxfcmon+pw_gxfcmond);
              

  trapezoid((WF_PROCESSOR)wg_gxfcmon, "gxfcmon", &gxfcmon, &gxfcmona,
                        &gxfcmond, pw_gxfcmon, pw_gxfcmona, pw_gxfcmond,
                        ia_gxfcmon, 0, 0, 0, 0, postemp-pw_gxfcmona, TRAP_ALL,
                        &monloggrd);

    }

    /* MRIge42228  */
    /* FOR MERGE */
    /*
    ACQUIREDATA(echo1mon, pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait,pbeg(&gxwmon,"gxwmon",0)-mon_dabdelay,, 
      filter_echo1mon, TYPRECVALL, DABNORM, );        
    */
     
  {
    pulsename(&echo1mon,"echo1mon");
    acqq(&echo1mon, (long)(pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait),(long)(pbeg(&gxwmon,"gxwmon",0)-mon_dabdelay),
        (long)(DEFAULTPOS),(long)filter_echo1mon,
        (TYPDAB_PACKETS)DABNORM);
  }
        

     
  {
    e1entnsmon_pack[0] = SSPDS+EDC;
    pulsename(&e1entnsmon,"e1entnsmon");
    createbits(&e1entnsmon,TYPSSP,4,e1entnsmon_pack);
    createinstr( &e1entnsmon,(LONG)(pbeg(&gxwmon,"gxwmon",0)+psd_grd_wait),4,0);
  }
 
     
  {
    e1distnsmon_pack[0] = SSPDS+EDC;
    pulsename(&e1distnsmon,"e1distnsmon");
    createbits(&e1distnsmon,TYPSSP,4,e1distnsmon_pack);
    createinstr( &e1distnsmon,(LONG)(pend(&gxwmon,"gxwmon",0)+psd_grd_wait),4,0);
  }


    postemp = pend(&gxwmon,"gxwmon",0)+pw_gzkmona;

         

  trapezoid((WF_PROCESSOR)wg_gzkmon, "gzkmon", &gzkmon, &gzkmona,
                        &gzkmond, pw_gzkmon, pw_gzkmona, pw_gzkmond,
                        ia_gzkmon, 0, 0, 0, 0, postemp-pw_gzkmona, TRAP_ALL,
                        &monloggrd);

    postemp = pendall(&gzkmon,0);

    {
        LONG tseq_mon_duration = RUP_GRD(mon_tr_nav - mon_ssi_time);
        if(smartprep_flag)
        {
            tseq_mon_duration = RUP_GRD(mon_tr - mon_ssi_time);
        }
          
  {
    pulsename(&seqmon,"seqmon");
    createseq(&seqmon,tseq_mon_duration, off_seqmon);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmon );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmon = %d\n", idx_seqmon );
#endif
  }

    }

    if (!smartprep_flag)
    {
            
  {
    pulsename(&seqmonwait,"seqmonwait");
    createseq(&seqmonwait,RUP_GRD(mon_tr_wait-mon_ssi_time), off_seqmonwait);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmonwait );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmonwait = %d\n", idx_seqmonwait );
#endif
  }

    }
    attenflagon(&seqmon, 0);

    if (opcgate && (nav_irprep_flag || navsat_flag) && slabtracking_flag)
    {
        if (navigatorCYL_flag)
        {
             /* Nav. IRPREP Tipup */
             
                  
  {
    pulsename(&gycylratipup,"gycylratipup");
 
        getbeta(&pg_beta, (WF_PROCESSOR)wg_gycylratipup, &monloggrd);
 
    if ( (start_gycylratipup>0.0) || (start_gycylratipup<0.0) )
      {
        createramp(&gycylratipup,(WF_PROCESSOR)wg_gycylratipup,pw_gycylratipup,
                   ia_stgycylratipup,ia_endgycylratipup,
                   (short)(maxGradRes*(pw_gycylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gycylratipup,(long)(tlead_montipup-pw_gycylratipup),pw_gycylratipup,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gycylratipup,(WF_PROCESSOR)wg_gycylratipup,pw_gycylratipup,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gycylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gycylratipup,(long)(tlead_montipup-pw_gycylratipup),pw_gycylratipup,
                    ia_endgycylratipup);
      }
  }

             
                  
  {
    pulsename(&gzcylratipup,"gzcylratipup");
 
        getbeta(&pg_beta, (WF_PROCESSOR)wg_gzcylratipup, &monloggrd);
 
    if ( (start_gzcylratipup>0.0) || (start_gzcylratipup<0.0) )
      {
        createramp(&gzcylratipup,(WF_PROCESSOR)wg_gzcylratipup,pw_gzcylratipup,
                   ia_stgzcylratipup,ia_endgzcylratipup,
                   (short)(maxGradRes*(pw_gzcylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr( &gzcylratipup,(long)(tlead_montipup-pw_gzcylratipup),pw_gzcylratipup,MAX_PG_IAMP);
      }
    else
      {
        createramp(&gzcylratipup,(WF_PROCESSOR)wg_gzcylratipup,pw_gzcylratipup,
                   (short)0,MAX_PG_WAMP,
                   (short)(maxGradRes*(pw_gzcylratipup/GRAD_UPDATE_TIME)),
                   pg_beta);
        createinstr(&gzcylratipup,(long)(tlead_montipup-pw_gzcylratipup),pw_gzcylratipup,
                    ia_endgzcylratipup);
      }
  }

             postemp = tlead_montipup; 
             /* RFCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,rf_ext);
#endif
             /* Stretch rf pw if needed */ 
             temp_res = res_rfcylrtipup;
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(rfpulseInfo[RFCYLRTIPUP_SLOT].newres*sizeof(short));
                 stretchpulse((int)res_rfcylrtipup,(int)rfpulseInfo[RFCYLRTIPUP_SLOT].newres,
                              temp_wspace_mon,wspace_mon);
                 res_rfcylrtipup = rfpulseInfo[RFCYLRTIPUP_SLOT].newres;
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&rfcylrtipup,"rfcylrtipup");
    createreserve(&rfcylrtipup,(WF_PROCESSOR)wg_rfcylrtipup,
		  res_rfcylrtipup);
  }

             addrfbits(&rfcylrtipup, 0, postemp+psd_rf_wait, pw_rfcylrtipup);
             createinstr(&rfcylrtipup, postemp+psd_rf_wait, pw_rfcylrtipup,ia_rfcylrtipup);
             movewaveimm(wspace_mon, &rfcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* THCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,th_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&thcylrtipup,"thcylrtipup");
    createreserve(&thcylrtipup,(WF_PROCESSOR)wg_thcylrtipup,
		  res_thcylrtipup);
  }

             addrfbits(&thcylrtipup, 0, postemp+psd_rf_wait, pw_thcylrtipup);
             createinstr(&thcylrtipup, postemp+psd_rf_wait, pw_thcylrtipup,ia_thcylrtipup);
             movewaveimm(wspace_mon, &thcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* GYCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,gy_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&gycylrtipup,"gycylrtipup");
    createreserve(&gycylrtipup,(WF_PROCESSOR)wg_gycylrtipup,
		  res_gycylrtipup);
  }

             createinstr(&gycylrtipup, postemp, pw_gycylrtipup,ia_gycylrtipup);
             movewaveimm(wspace_mon, &gycylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* GZCYLRTIPUP */
             temp_wspace_mon = (short *)AllocNode(temp_res*sizeof(short));
#if defined(MGD_TGT)
             uextwave(temp_wspace_mon,res_rfcylrtipup,gz_ext);
#endif
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 wspace_mon = (short *)AllocNode(res_rfcylrtipup*sizeof(short));
                 stretchpulse((int)temp_res,(int)res_rfcylrtipup,temp_wspace_mon,wspace_mon);
                 FreeNode(temp_wspace_mon);
             } else {
                 wspace_mon = temp_wspace_mon; 
             }
             /* move the wave to the hardware */
               
  {
    pulsename(&gzcylrtipup,"gzcylrtipup");
    createreserve(&gzcylrtipup,(WF_PROCESSOR)wg_gzcylrtipup,
		  res_gzcylrtipup);
  }

             createinstr(&gzcylrtipup, postemp, pw_gzcylrtipup,ia_gzcylrtipup);
             movewaveimm(wspace_mon, &gzcylrtipup, (int)0, res_rfcylrtipup, TOHARDWARE);
             FreeNode(wspace_mon);

             /* Change back incase external grad_file used */
             if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
             {
                 res_rfcylrtipup = temp_res;
             }

             postemp = tlead_montipup + pw_gycylrtipup + GRAD_UPDATE_TIME;
        }
        else 
        { 
            postemp = tlead_montipup + pw_gyrfmontipupa; 

                 
                         
  {
    /* Check for RF waveform generator */
    RFEnvelopeWaveformGeneratorCheck("rfmontipup", 
                                     (WF_PROCESSOR)wg_rfmontipup);

    /* Modify resolution if scaling required */
    temp_res_rfmontipup = res_rfmontipup;
    if (rfpulseInfo[RFMONTIPUP_SLOT].change==PSD_ON)
      res_rfmontipup = rfpulseInfo[RFMONTIPUP_SLOT].newres;
    /* First create the pulses */
    pulsename(&gyrfmontipupa,"gyrfmontipupa");
    pulsename(&gyrfmontipup,"gyrfmontipup");
    pulsename(&gyrfmontipupd,"gyrfmontipupd");
    pulsename(&rfmontipup,"rfmontipup");

	/*  Now create the slice select trapezoid */
  pg_beta = monloggrd.ybeta;
  createramp(&gyrfmontipupa,YGRAD,pw_gyrfmontipupa,(short)0,MAX_PG_WAMP,
			(short)(maxGradRes*(pw_gyrfmontipupa/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrfmontipupa,(LONG)(postemp-pw_gyrfmontipupa),
      pw_gyrfmontipupa,ia_gyrfmontipup);
  createconst(&gyrfmontipup,YGRAD,pw_gyrfmontipup,MAX_PG_WAMP);
  createinstr( &gyrfmontipup,(LONG)(postemp),
      pw_gyrfmontipup,ia_gyrfmontipup);
  createramp(&gyrfmontipupd,YGRAD,pw_gyrfmontipupd,MAX_PG_WAMP,
			(short)0,(short)(maxGradRes*(pw_gyrfmontipupd/GRAD_UPDATE_TIME))
			,pg_beta);
  createinstr( &gyrfmontipupd,(LONG)(postemp+pw_gyrfmontipup),
      pw_gyrfmontipupd,ia_gyrfmontipup);

    /* Now create the rf pulse */
    createsinc(&rfmontipup,(WF_PROCESSOR)wg_rfmontipup,res_rfmontipup,
	       MAX_PG_WAMP,cyc_rfmontipup, alpha_rfmontipup);
    createinstr( &rfmontipup,(LONG)(postemp) + psd_rf_wait,
		pw_rfmontipup,ia_rfmontipup);
    linkpulses(4,&rfmontipup,&gyrfmontipup,&gyrfmontipupa,&gyrfmontipupd);
    addrfbits(&rfmontipup,off_rfmontipup,(LONG)(postemp) + psd_rf_wait,
	      pw_rfmontipup);
    /* Changed back resolution incase external rf used later in pulsegen. We need
     * original resolution to scale pulses that are external
     */
    if (rfpulseInfo[RFMONTIPUP_SLOT].change==PSD_ON)
      res_rfmontipup = temp_res_rfmontipup;
}


            postemp = pend(&gyrfmontipup, "gyrfmontipup", 0);
        }

        /* Gzk Nav Tipup */
             

  trapezoid((WF_PROCESSOR)wg_gzkmontipup, "gzkmontipup", &gzkmontipup, &gzkmontipupa,
                        &gzkmontipupd, pw_gzkmontipup, pw_gzkmontipupa, pw_gzkmontipupd,
                        ia_gzkmontipup, 0, 0, 0, 0, postemp+pw_gzkmontipupa-pw_gzkmontipupa, TRAP_ALL,
                        &monloggrd);


        postemp = nav_tseq_irprep - nav_min_tseq_irprep;
        
  {
    pulsename(&seqmontipup,"seqmontipup");
    createseq(&seqmontipup,RUP_GRD(tmin_montipup+postemp), off_seqmontipup);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqmontipup );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqmontipup = %d\n", idx_seqmontipup );
#endif
  }

        attenflagon(&seqmontipup, 0);
    } /*end tipup*/
   
    if (navigator_flag && navigatorCYL_flag)
    {   /* Offset phase calculation */
        float xmod,ymod;
        float phiw;
        float arot;
        float brot;

        float ysum,zsum,kfact;
        int iw, iwb;
        float* kynorm=NULL;
        float* kznorm=NULL;
        short* wspace_theta=NULL;
        short* wspace_gy=NULL;
        short* wspace_gz=NULL;
        int act_res_rfcylr;
        int act_res_rfcylrtipup;

        /* convert mm to cm ahead of time */
        arot = cos(cylr_dtheta)/10.0;
        brot = sin(cylr_dtheta)/10.0;

        if (rfpulseInfo[RFCYLR_SLOT].change==PSD_ON)
        {
            act_res_rfcylr = rfpulseInfo[RFCYLR_SLOT].newres;
        } else {
            act_res_rfcylr = res_rfcylr;
        }

        /* navCYL: prepare fm calculation for pencil offsets */
        ysum = 0;
        zsum = 0;
        kfact = -2.0*PI*GAM*(((float)pw_rfcylr/1000000)/(float)act_res_rfcylr);

        kynorm = (float *)AllocNode(act_res_rfcylr*sizeof(float));
        kznorm = (float *)AllocNode(act_res_rfcylr*sizeof(float));

        wspace_gy = (short *)AllocNode(act_res_rfcylr*sizeof(short));
        wspace_gz = (short *)AllocNode(act_res_rfcylr*sizeof(short));
        movewaveimm(wspace_gy, &gycylr, (int)0, act_res_rfcylr, FROMHARDWARE);
        movewaveimm(wspace_gz, &gzcylr, (int)0, act_res_rfcylr, FROMHARDWARE);

        gycylr0_scale = (float)wspace_gy[0]/(float)max_pg_wamp;
        gzcylr0_scale = (float)wspace_gz[0]/(float)max_pg_wamp;

        for (iw = 0; iw < (act_res_rfcylr); iw++)
        {
            iwb = (act_res_rfcylr - 1) - iw;   /* integrate backwards!! (w/neg kfact) */
            ysum=ysum+(float)(wspace_gy[iwb])*(a_gycylr/max_pg_wamp);
            zsum=zsum+(float)(wspace_gz[iwb])*(a_gzcylr/max_pg_wamp);
            kynorm[iwb] = kfact*ysum;
            kznorm[iwb] = kfact*zsum;
        }

        FreeNode(wspace_gy);
        FreeNode(wspace_gz);

        if (cylr_manoff) /* manual offsets, reset xo and yo */
        {
            xo = (int)cylr_xoff;
            yo = (int)cylr_yoff;
        } else {
            xo = (int)mon_rsp_info[0].rsptloc;
            yo = (int)mon_rsp_info[0].rspphasoff;
        }

        xmod = (arot*xo + brot*yo);
        ymod = (-brot*xo + arot*yo);

        wspace_theta = (short *)AllocNode(act_res_rfcylr*sizeof(short));

        for (iw = 0; iw < act_res_rfcylr; iw++)
        {
            phiw = (kznorm[iw]*xmod + kynorm[iw]*ymod)/PI;
            if(phiw>=0)
            {
                wspace_theta[iw]=(short)((phiw-(int)((phiw+1)/2)*2)*max_pg_wamp);
            } else {
                wspace_theta[iw]=(short)((phiw-(int)((phiw-1)/2)*2)*max_pg_wamp);
            }
            if(wspace_theta[iw]%2 !=0 )
            {
                wspace_theta[iw] += 1;
            }
        }
        wspace_theta[act_res_rfcylr-1]=1;
        movewaveimm(wspace_theta, &thcylr, (int)0, act_res_rfcylr, TOHARDWARE);
        FreeNode(wspace_theta);
        FreeNode(kynorm);
        FreeNode(kznorm);

        if ((opcgate && (nav_irprep_flag || navsat_flag) && slabtracking_flag) && navigatorCYL_flag)
        {
            if (rfpulseInfo[RFCYLRTIPUP_SLOT].change==PSD_ON)
            {
                act_res_rfcylrtipup = rfpulseInfo[RFCYLRTIPUP_SLOT].newres;
            } else {
                act_res_rfcylrtipup = res_rfcylrtipup;
            }

            /* navCYL: prepare fm calculation for pencil offsets */
            ysum = 0;
            zsum = 0;
            kfact = -2.0*PI*GAM*(((float)pw_rfcylrtipup/1000000)/(float)act_res_rfcylrtipup);

            kynorm = (float *)AllocNode(act_res_rfcylrtipup*sizeof(float));
            kznorm = (float *)AllocNode(act_res_rfcylrtipup*sizeof(float));

            wspace_gy = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));
            wspace_gz = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));
            movewaveimm(wspace_gy, &gycylrtipup, (int)0, act_res_rfcylrtipup, FROMHARDWARE);
            movewaveimm(wspace_gz, &gzcylrtipup, (int)0, act_res_rfcylrtipup, FROMHARDWARE);

            gycylrtipup0_scale = (float)wspace_gy[0]/(float)max_pg_wamp;
            gzcylrtipup0_scale = (float)wspace_gz[0]/(float)max_pg_wamp;

            for (iw = 0; iw < (act_res_rfcylrtipup); iw++)
            {
                iwb = (act_res_rfcylrtipup - 1) - iw;   /* integrate backwards!! (w/neg kfact) */
                ysum=ysum+(float)(wspace_gy[iwb])*(a_gycylrtipup/max_pg_wamp);
                zsum=zsum+(float)(wspace_gz[iwb])*(a_gzcylrtipup/max_pg_wamp);
                kynorm[iwb] = kfact*ysum;
                kznorm[iwb] = kfact*zsum;
            }

            FreeNode(wspace_gy);
            FreeNode(wspace_gz);

            if (cylr_manoff) /* manual offsets, reset xo and yo */
            {
                xo = (int)cylr_xoff;
                yo = (int)cylr_yoff;
            } else {
                xo = (int)mon_rsp_info[0].rsptloc;
                yo = (int)mon_rsp_info[0].rspphasoff;
            }

            xmod = (arot*xo + brot*yo);
            ymod = (-brot*xo + arot*yo);

            wspace_theta = (short *)AllocNode(act_res_rfcylrtipup*sizeof(short));

            for (iw = 0; iw < act_res_rfcylrtipup; iw++)
            {
                phiw = (kznorm[iw]*xmod + kynorm[iw]*ymod)/PI;
                if(phiw>=0)
                {
                    wspace_theta[iw]=(short)((phiw-(int)((phiw+1)/2)*2)*max_pg_wamp);
                } else {
                    wspace_theta[iw]=(short)((phiw-(int)((phiw-1)/2)*2)*max_pg_wamp);
                }
                if(wspace_theta[iw]%2 !=0 )
                {
                    wspace_theta[iw] += 1;
                }
            }
            wspace_theta[act_res_rfcylrtipup-1]=1;
            movewaveimm(wspace_theta, &thcylrtipup, (int)0, act_res_rfcylrtipup, TOHARDWARE);
            FreeNode(wspace_theta);
            FreeNode(kynorm);
            FreeNode(kznorm);
        }
    }

    return SUCCESS;
}

STATUS Monitor_pulsegen(void)
{
    if (smartprep_flag || navigator_flag) 
    {
        if (FAILURE == monitor_PG())
        {
            printf("pulsegen(): monitor_PG() returned FAILURE.\n");
            return FAILURE; 
        }

        if (smartprep_flag)
            getperiod((long*)&mon_deadtime, &seqmon, 0);
        else
            getperiod((long*)&mon_deadtime, &seqmonwait, 0);
    }

    /*********************
    Dummy wait sequence 
     *********************/

          
  {
    pulsename(&seqloopdelay,"seqloopdelay");
    createseq(&seqloopdelay,RUP_GRD(IMax(2,1,loopdelay-mon_ssi_time)), off_seqloopdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqloopdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqloopdelay = %d\n", idx_seqloopdelay );
#endif
  }

           
  {
    pulsename(&seqloopdelay2,"seqloopdelay2");
    createseq(&seqloopdelay2,RUP_GRD(IMax(2,1,loopdelay2-mon_ssi_time)), off_seqloopdelay2);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqloopdelay2 );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqloopdelay2 = %d\n", idx_seqloopdelay2 );
#endif
  }

      
  {
    pulsename(&seqsmartprepdelay,"seqsmartprepdelay");
    createseq(&seqsmartprepdelay,RUP_GRD(30000), off_seqsmartprepdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqsmartprepdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqsmartprepdelay = %d\n", idx_seqsmartprepdelay );
#endif
  }


    /* NAV delay after last slice in nav gating */
#ifdef NAV_EFGRE3D
          
  {
    pulsename(&seqnavend,"seqnavend");
    createseq(&seqnavend,RUP_GRD(IMax(2,1,navend_time-mon_ssi_time)), off_seqnavend);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqnavend );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqnavend = %d\n", idx_seqnavend );
#endif
  }

#endif
    /* Dummy sequence played when histogram is being calculated */
          
  {
    pulsename(&seqnavhistdelay,"seqnavhistdelay");
    createseq(&seqnavhistdelay,RUP_GRD(IMax(2,1,hist_wait_time-mon_ssi_time)), off_seqnavhistdelay);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqnavhistdelay );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqnavhistdelay = %d\n", idx_seqnavhistdelay );
#endif
  }


    /* Wait pulse Navigator feedback */
      
  {
    pulsename(&seqrtpnav,"seqrtpnav");
    createseq(&seqrtpnav,rtpresultwait, off_seqrtpnav);
#if defined(HOST_TGT)
    /* Update sequence counter and get current sequence entry index */
    updateIndex( &idx_seqrtpnav );
    printDebug( DBLEVEL1, (dbLevel_t)seg_debug, "SEQLENGTH",
                "idx_seqrtpnav = %d\n", idx_seqrtpnav );
#endif
  }


    mon_receive_freq1 = (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 
    rf1mon_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int));
    rf2mon_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 
    rfmontipup_freq =  (int *)AllocNode((tracker_quant + 2)*sizeof(int)); 

    return SUCCESS;
}


#include "pgen_tmpl.h"
#include "epic_loadcvs.h"
#include <math.h>

#include <stdlib.h> /*RTB0 correction*/ 
#include <stdio.h> /*RTB0 correction*/
#include <string.h> /*RTB0 correction*/

int * rpgUnitTestPtr = NULL; /* Distortion Correction Unit Test */
int rpgUnitTestPtrSize = -1;

const CHAR *entry_name_list[ENTRY_POINT_MAX] = { "scan",
					   "mps2",
					   "aps2",
					   "ref",
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                           PSeplist                                *
 *                                                                   *
 * Additional list of entry points for Prescan.                      *
 *********************************************************************/
         "cfl",
         "cfh",
         "mps1",
         "aps1", 
         "autoshim",
         "fasttg",
         "rcvn",
         "expresstg",
         "RFshim",
         "DynTG",
         "extcal",
         "Autocoil",
         0	/* 0 is needed for the parser */


};

float TENSOR_AGP[3][MAX_DIRECTIONS + MAX_T2];  /* Tensor Dif Amp Array (directions + t2) */
float WAVE_AGP[MAX_DIRECTIONS + MAX_T2]; /* granty edit for waveform shape */
float TENSOR_AGP_temp[3][MAX_DIRECTIONS + MAX_T2]; /*MRIhc05854*/


/* SVBranch HCSDM00155611 Sets the amp/freq/phase for walk sat RF */
void setrfwk(void)
{   
    setwave(rfwkslp[0], &rfwk, INSTRALL);
    setiamp(ia_rfwk, &rfwk, 0);

    setwave(thrfwkslp[0], &thrfwk, INSTRALL);
    setiamp(ia_thrfwk, &thrfwk, 0);   

    setfrequency((int)(loc_satcen_Hz/TARDIS_FREQ_RES), &rfwk, 0);     
}

/* Sets the theta rf1 waveform for each slice */
void setthetarf1(int num)
{
    setwave(thrf1slp[num], &thrf1, INSTRALL);
    setiamp(freqSign_ex*ia_thrf1, &thrf1, 0);
}

/* phase correction offset factor, actual phase correction=nav_corr_phase_xyz*disp_xyz */
float nav_corr_phase_z = 0.0;
float nav_corr_phase_y = 0.0;
float nav_corr_phase_x = 0.0; 

float disp_z = 0.0;  /* z displacement from navigator(Nav is always S/I) */
float disp_y = 0.0;  /* y displacement from navigator(Nav is always S/I) */
float disp_x = 0.0;  /* x displacement from navigator(Nav is always S/I) */

float disp_loggrd[3]={0.0,0.0,0.0}; /* Displacement in logical scan domain */

int nav_frq2sync_dly = 9; /* Time from begin of frq to sync phase */

/* Rsp_info structure to store temporary location info 
 * used to set up slice using the navigator output */
RSP_INFO rsp_info_track[MAXSLQUANT3D];

float tmpcurrthresh = 0.0;  /* keeps track of recent current threshold (MRIhc07115) */

char nav_filename[255];

/* Debugging related */
#ifdef PSD_HW
    struct timespec host_clock; 
#endif
LONG seconds=0;


long deadtime;               /* amount of deadtime */
short viewtable[1025];        /* view table */
int xrr_trig_time;             /* trigger time for filled or unfilled
		                  R-R interval which is not last R-R */

short tempamp;

static INT set_tensor_orientationsAGP( void );

/*
 * BJM 4/25/00 - set_tensor_orientationsAGP()
 *
 * This function is designed to either read the tensor directions from a
 * file on disk called tensor.dat (/usr/g/bin).  It was added during Linux
 * development since it was found that the TENS[][] array was corrupted during
 * download.  Thus, the quick solution was to re-read the tensor.dat file from the
 * AGP and re-fill the TENSOR_AGP[][] array...
 *
 */
static INT set_tensor_orientationsAGP( void )
{
    int read_from_file = PSD_ON;
    int j;

    if( read_from_file == PSD_ON  && tensor_flag == PSD_ON ) {

        FILE *fp;                           /* file pointer */
        char filestring[MAXCHAR];           /* buffer used to open data file */ 
        char compstring[MAXCHAR];           /* buffer used to open data file */ 
        char tempstring[MAXCHAR];           /* buffer to access file */
        int max_chars_per_line = MAXCHAR;   /* lines in tensor.dat header */ 
        int num_tensor_len;
#ifndef SIM
        const char *tensor_datapath="/usr/g/bin/";/* path to tensor.dat files - hw  */
        char tensor_datafile[80]; /* filename of tensor.dat file */
        if (rhtensor_file_number == 0)
        {
            sprintf(tensor_datafile, "tensor.dat");
        }
        else
        {
            sprintf(tensor_datafile, "tensor%d.dat", rhtensor_file_number);
        }
#else /* !SIM */
        const char *tensor_datapath="./";         /* path to tensor.dat files - sim */
        char tensor_datafile[80];                    /* filename of tensor.dat file */

        if (rhtensor_file_number == 0)
        {
            if(PSD_VRMW_COIL == gCoilType)
            {
                sprintf(tensor_datafile, "tensor.dat.VRMW");
            }
            else
            {
                sprintf(tensor_datafile, "tensor.dat.default");
            }
        }
        else 
        {
            sprintf(tensor_datafile, "tensor%d.dat", rhtensor_file_number);
        }
#endif /* SIM */

        /* Setup for file search - set the number of directions requested */
        sprintf( compstring, "%d", num_tensor );
        num_tensor_len = strlen( compstring );

        /* Set tensor.dat file path and append filename base and suffix */
        strcpy( filestring, tensor_datapath );
        strcat( filestring, tensor_datafile );

        /* Open file */
        if( (fp = fopen( filestring, "r" )) == NULL ) { 
            printf( "Cant read %s", filestring );
            fflush( stdout );
            return FAILURE;
        }

        /*
         * The tensor.dat file is a concatanation of several files.
         * We need to skip over all the lines until we reach the location
         * that stores the "num_tensor" orientations.
         */
        {
            int read_skip = 1;

            while( read_skip ) {
                fgets( tempstring, max_chars_per_line, fp );
                read_skip = strncmp( compstring, tempstring, num_tensor_len );
            }
        }

        if(debugTensor == PSD_ON) {
            printf( "Tensor Directions Read (AGP) = %d\n", num_tensor );
        }

        /*
         * Next, after reaching the desired point in the file           
         * iterate over num_tensor & put the data in TENS[i][j] 
         */

        /* BJM: assign the T2 images first - want multiple B = 0 images */
        for( j = 0; j < num_B0; ++j ) {

            TENSOR_AGP[0][j] = TENSOR_AGP[1][j] = TENSOR_AGP[2][j] = 0.0;
            
            if(debugTensor == PSD_ON) {
                printf( "T2 #%d, X = %f, Y=%f, Z= %f\n", j, TENSOR_AGP[0][j], TENSOR_AGP[1][j], TENSOR_AGP[2][j] );
                fflush( stdout );
            }

        }

        /* Now do the rest of the shots */
        /*  Skip the multiple B = 0 images.  Start at num_B0 plus 1 in
            the TENSOR_AGP[][] array. */
        for ( j = num_B0; j < num_tensor + num_B0; ++j ) {          
            if( fgets( tempstring, MAXCHAR, fp ) == NULL ) { 
                printf( "ERROR: invalid tensor.dat file format!\n" ); 
            }          
            sscanf( tempstring, "%f %f %f", &TENSOR_AGP_temp[0][j], &TENSOR_AGP_temp[1][j], &TENSOR_AGP_temp[2][j] );

            TENSOR_AGP[0][j] = TENSOR_AGP_temp[0][j];
            TENSOR_AGP[1][j] = TENSOR_AGP_temp[1][j];
            TENSOR_AGP[2][j] = TENSOR_AGP_temp[2][j];

            if(debugTensor == PSD_ON)
            {
                printf( "Shot = %d, X = %f, Y=%f, Z= %f\n", j, TENSOR_AGP[0][j], TENSOR_AGP[1][j], TENSOR_AGP[2][j] );
                fflush( stdout );
            }

        }

        fclose(fp); 

    } 
    else {

        /* Assign the T2 image first */
        TENSOR_AGP[0][0] = TENSOR_AGP[1][0] = TENSOR_AGP[2][0] = 0.0;

    }
/* granty edit to specify waveform type */
    if( read_from_file == PSD_ON  && tensor_flag == PSD_ON ) {

        FILE *fp;                           /* file pointer */
        char filestring[MAXCHAR];           /* buffer used to open data file */ 
        char compstring[MAXCHAR];           /* buffer used to open data file */ 
        char tempstring[MAXCHAR];           /* buffer to access file */
        int max_chars_per_line = MAXCHAR;   /* lines in tensor.dat header */ 
        int num_tensor_len;
#ifndef SIM
        const char *tensor_datapath="/usr/g/research/grant/nqti/";/* path to tensor.dat files - hw  */
        char tensor_datafile[80]; /* filename of tensor.dat file */
        if (rhtensor_file_number == 0)
        {
            sprintf(tensor_datafile, "waveform.dat");
        }
        else
        {
            sprintf(tensor_datafile, "waveform%d.dat", rhtensor_file_number);
        }
#else /* !SIM */
        const char *tensor_datapath="./";         /* path to tensor.dat files - sim */
        char tensor_datafile[80];                    /* filename of tensor.dat file */

        if (rhtensor_file_number == 0)
        {
            if(PSD_VRMW_COIL == gCoilType)
            {
                sprintf(tensor_datafile, "waveform.dat");
            }
            else
            {
                sprintf(tensor_datafile, "waveform.dat");
            }
        }
        else 
        {
            sprintf(tensor_datafile, "waveform%d.dat", rhtensor_file_number);
        }
#endif /* SIM */

        /* Setup for file search - set the number of directions requested */
        sprintf( compstring, "%d", num_tensor );
        num_tensor_len = strlen( compstring );

        /* Set tensor.dat file path and append filename base and suffix */
        strcpy( filestring, tensor_datapath );
        strcat( filestring, tensor_datafile );

        /* Open file */
        if( (fp = fopen( filestring, "r" )) == NULL ) { 
            printf( "Cant read %s", filestring );
            fflush( stdout );
            return FAILURE;
        }

        /*
         * The tensor.dat file is a concatanation of several files.
         * We need to skip over all the lines until we reach the location
         * that stores the "num_tensor" orientations.
         */
        {
            int read_skip = 1;

            while( read_skip ) {
                fgets( tempstring, max_chars_per_line, fp );
                read_skip = strncmp( compstring, tempstring, num_tensor_len );
            }
        }

        if(debugTensor == PSD_ON) {
            printf( "Waveform type Read (AGP) = %d\n", num_tensor );
        }

        /*
         * Next, after reaching the desired point in the file           
         * iterate over num_tensor & put the data in TENS[i][j] 
         */

        /* BJM: assign the T2 images first - want multiple B = 0 images */
        for( j = 0; j < num_B0; ++j ) {

            WAVE_AGP[0] = 0.0;
            
            if(debugTensor == PSD_ON) {
                printf( "T2 #%d, B-tensor rank = %f\n", j, WAVE_AGP[j] );
                fflush( stdout );
            }

        }

        /* Now do the rest of the shots */
        /*  Skip the multiple B = 0 images.  Start at num_B0 plus 1 in
            the TENSOR_AGP[][] array. */
        for ( j = num_B0; j < num_tensor + num_B0; ++j ) {          
            if( fgets( tempstring, MAXCHAR, fp ) == NULL ) { 
                printf( "ERROR: invalid tensor.dat file format!\n" ); 
            }          
            sscanf( tempstring, "%f", &WAVE_AGP[j] );

            if(debugTensor == PSD_ON)
            {
                printf( "Shot = %d, B-tensor rank = %f\n", j, WAVE_AGP[j] );
                fflush( stdout );
            }

        }

        fclose(fp); 

    } 
    else {

        /* Assign the T2 image first */
        WAVE_AGP[j] = 0.0;

    }

    return SUCCESS;

}   /* end set_tensor_orientationsAGP() */


/* MRIge54172 - maxwell correction */
float delta_fre_MAX[SLTAB_MAX]; /* Maxwell frequency offset */ /* YMSmr06515 */
float delta_phase_MAX_l[SLTAB_MAX]; /* Maxwell phase offset for thefirst echo */
float delta_phase_MAX[SLTAB_MAX]; /* Maxwell phase offset for all echoes */

/* Function Declaration */
STATUS epiMaxwellCorrection(void);

/* BJM - correct receiver phase to account for maxwell terms - see Tech Note by Joe Zhou 97-08    */
/*       Most of this code taken from epi2.e.  However, Ive added the phase encode blip term and  */
/*       and removed the g2z2_delta factor which was an empirical test factor for the phase blips */
/*       It was set = 2.0 which was way too large since the phase blip contribution is small      */

STATUS epiMaxwellCorrection(void) {
 
  int ii, jj, kk;  /* Maxwell comp: index to set the receiver frequency array */
  
  if((maxwell_flag==PSD_ON)&&(opplane==PSD_AXIAL)&&((rspent==L_SCAN) || (rspent==L_REF))) {
      
      float Gx2 = 0.0;                    /* readout gradient squared */
      float Gy2 = 0.0;                    /* phase gradient squared */
      float Z2 = 0.0;                     /* z location squared */
      float field_fact = 0.0;             /* constant term that includes B field */
      float mxwtmp1,mxwtmp2;
      float mxwtmp_gxw1,mxwtmp_gxw2;      /* tmp variables for maxwell offset computation */
      float mxwtmp_gyb1,mxwtmp_gyb2;
      
      /* BJM: readout gradient timing */
      pw_gxw_MAX_l = (1.0/3.0*(float)pw_gxwad+0.5*(float)pw_gxw+(float)pw_gxwl)/1.0e6;
      /* timing for the left half of readout trapezoid; unit: sec. */
      pw_gxw_MAX_r = (1.0/3.0*(float)pw_gxwad+0.5*(float)pw_gxw+(float)pw_gxwr)/1.0e6;
      /* timing for the right half of readout trapezoid; unit: sec. */
      
      /* BJM: account for phase blips also */
      pw_gyb_MAX_l = (1.0/3.0*(float)pw_gyba+0.5*(float)pw_gyb)/1.0e6;
      /* timing for the left half of phase trapezoid; unit: sec. */
      pw_gyb_MAX_r = (1.0/3.0*(float)pw_gybd+0.5*(float)pw_gyb)/1.0e6;
      /* timing for the right half of phase trapezoid; unit: sec. */
      
      if(max_debug==1)
          printf("left Maxwell width = %f s\nright Maxwell width = %f s\n", 
                 pw_gxw_MAX_l, pw_gxw_MAX_r);
      
      field_fact = 2.0*PI*GAM/(2.0*B0_field);      /* Field dependance */
      Gx2 =a_gxw*a_gxw/100.0;                      /* Readout Gx^2 term */
      mxwtmp_gxw1 = pw_gxw_MAX_l;
      mxwtmp_gxw2 = (pw_gxw_MAX_l+pw_gxw_MAX_r);
      
      Gy2 = a_gyb*a_gyb/100.0;                   /* Phase encode term */
      mxwtmp_gyb1 = pw_gyb_MAX_l;
      mxwtmp_gyb2 = (pw_gyb_MAX_r+pw_gyb_MAX_l);
      
      for (kk=0; kk<opslquant; kk++) {
          
          Z2 = rsp_info[kk].rsptloc*rsp_info[kk].rsptloc;  
          
          /* BJM: this code accounts for the readout term */       
          delta_fre_MAX[kk] = field_fact*Gx2*Z2;           /* purely for debugging */
          delta_phase_MAX_l[kk] = field_fact*Gx2*Z2*(mxwtmp_gxw1);    /* unit: radians */
          delta_phase_MAX[kk] = field_fact*Gx2*Z2*(mxwtmp_gxw2);      /* unit: radians */
          
          if(max_debug==1) /* readout comp. */
              printf("%d freq offset: %f phase: %f loc: %f  \n",
                     kk,delta_fre_MAX[kk],delta_phase_MAX[kk],rsp_info[kk].rsptloc);
          
          if(maxwell_blip == PSD_ON) {
              /* BJM: now account for the phase encode blips... */

              delta_phase_MAX_l[kk] += field_fact*Gy2*Z2*(mxwtmp_gyb1);    /* unit: radians */
              delta_phase_MAX[kk] += field_fact*Gy2*Z2*(mxwtmp_gyb2);      /* unit: radians */
              
              if(max_debug==1) /* phase comp */ 
                  printf("%d phase w/ blip: %f loc: %f  \n",
                         kk,delta_phase_MAX[kk],rsp_info[kk].rsptloc);
          }
          
      } /* end opslquant loop */ 
      
      /* Now loop over each slice, echo, etc and reset the receiver phase */
      for (ii=0; ii<opslquant; ii++) {

          mxwtmp1=((double)(delta_phase_MAX_l[ii]));   /* The constant phase term -> BJM: not really needed*/
          mxwtmp2=((double)(delta_phase_MAX[ii]));     /* Phase term accumlates with each echo */

          for(jj=0; jj<intleaves; jj++) {
              for(kk=0; kk<etl+iref_etl; kk++) {

                  if(kk < iref_etl) continue; /* interref echo is apart from normal echo train */
                  recv_phase_angle[ii][jj][kk] += (mxwtmp1 + mxwtmp2*(float)(kk-iref_etl));
                  recv_phase[ii][jj][kk] = calciphase(recv_phase_angle[ii][jj][kk]);

                  if(max_debug==1)
                      printf("%d freq offset: %d \n",kk, recv_freq[ii][jj][kk]);             

              } /* echo */

          } /* interleave */

      } /* slice */

  } /* end Maxwell compensation */
  
  return SUCCESS;
} 

/*RTB0 correction*/
#include "RtpPsd.h"
#include "RTB0.h"
#include "rtB0RTP.h"
#include "rtp_feedback_task.h"

#ifdef PSD_HW
#include "clockApi.h"
#endif

/*for epi2.e*/
int rtb0_processed_index = 0;
float rtb0_cfoffset = 0;
float rtb0_fidmean = 0; /*MF weighted fit*/
float rtb0_cfresidual = 0; /* Confidence metric when rtb0_confidence_method = 1 */
float rtb0_cfstddev = 0;   /* Confidence metric when rtb0_confidence_method = 2 */
int rtb0_initialized = 0;
int in_rtb0_loop = 0; /*indicate whether to play rtb0 related code*/
int rtb0_CFupdated = 0; /*indicate whether new CF is updated in L_SCAN (only used when ref_in_scan_flag is ON)*/

/*for epi.e*/
float rtb0_base_cfoffset = 0.0; /* center frequency offste at the first time point */
float rtb0_comp_cfoffset = 0.0; /* center frequency offset for compensation */
int rtb0_comp_cfoffset_TARDIS = 0;
int rtb0_rtp_1streturn = PSD_OFF;
int rtb0_outlier_count = 0;

/* DVMR: Variables to measure VRF and Ethernet feedback pathway times */
#if defined(MGD_TGT) && defined(PSD_HW)
long rtb0_feedback_time = 0;
long max_rtb0_feedback_time = 0;
long min_rtb0_feedback_time = 9999;
long sum_rtb0_feedback_times = 0;
double rtb0_fitting_time = 0.0;
long rtb0_num_frames_processed = 0;
#define RTB0_NUM_TIMING_POINTS 200
long rtb0_roundtrip_timing_array[RTB0_NUM_TIMING_POINTS];
long rtb0_roundtrip_index = 0;
# endif

STATUS rtB0ComRspInit( void )
{

#ifdef PSD_HW
    int status;
#endif
    RtpDataValuesPkt rtB0RtpPkt;

#if defined(MGD_TGT) && defined(PSD_HW)
    status = rtp_register_opcode(RTP_RESULT_RTB0, sizeof(rtB0Result), NULL);
    if (0 != status)
    {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "rtp_register_opcode failed",
            PSD_ARG_STRING, "rtp_register_opcode:RTB0", 0);
    }
#endif


    /* Fill RtpDataTransportPkt values */
    strncpy(rtB0RtpPkt.rtpDataVal.path, "/usr/g/bin", sizeof(rtB0RtpPkt.rtpDataVal.path));
    strncpy(rtB0RtpPkt.rtpDataVal.func, "rtB0RTP", sizeof(rtB0RtpPkt.rtpDataVal.func));

    /* BAM Allocations */
    rtB0RtpPkt.rtpDataVal.frameSize = rhfrsize; /* xres */
    rtB0RtpPkt.rtpDataVal.dacqType = dacq_data_type;
    rtB0RtpPkt.rtpDataVal.hubIndex = coilInfo_tgt[0].hubIndex;
    rtB0RtpPkt.rtpDataVal.numRtpReceivers = 0;
    rtB0RtpPkt.rtpDataVal.bodyCoilCombine = rtp_bodyCoilCombine;
    rtB0RtpPkt.rtpDataVal.acquiredIndex = 0;
    rtB0RtpPkt.rtpDataVal.processedIndex = 0;

    rtb0_processed_index = 0; /*MF B0 correction, initialize it*/

    rtB0RtpPkt.rtpDataVal.floatVar_1 = oprbw; /* send BW to RTP for freq calculation */

    rtB0RtpPkt.rtpDataVal.intVar_1 = rtb0_first_skip; /* num of points skipped in the beginning */
    rtB0RtpPkt.rtpDataVal.intVar_2 = rtb0_last_skip; /* num of points skipped in the end */
    rtB0RtpPkt.rtpDataVal.intVar_3 = rtb0_movAvg;  /* num of points for moving average */
    rtB0RtpPkt.rtpDataVal.intVar_4 = rtb0_coil_combine;  /* MF B0 correction: coil combine method */
    rtB0RtpPkt.rtpDataVal.intVar_5 = rtb0_phase_method;  /* MF B0 correction: phase estimation method*/
    
    rtB0RtpPkt.rtpDataVal.vreDebug = rtb0DebugFlag;
    rtB0RtpPkt.rtpDataVal.writeRawData = rtb0SaveRaw;  /* flag to save nav data */

#ifdef PSD_HW

    status = RtpInit(&rtB0RtpPkt);
    if(status!=SUCCESS) {
        RtpEnd();  /* do this to be safe? */
        psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "RtpInit failed", PSD_ARG_STRING, "RtpInit:rtB0", 0);
    }

    rtb0_roundtrip_index = 0; /* Initialize index for Roundtrip time computation */

    isrtplaunched = 1;

#endif

    return SUCCESS;
}


/*
 * gets rtB0 processedIndex and cfoffset from RTP App.  ProcessedIndex and cfoffset are 
 * unchanged if there is no new data available.
 *
 * @param[out] *processedIndex - Pointer to the processedIndex
 * @param[out] *phase - pointer to the cfoffset 
 * @return 1 if new data available.  0 otherwise
 *
 */

int getRTB0Feedback(int * processedIndex, float * cfoffset, float * fidmean, float * cfstddev, float * cfresidual)
{
    n32 packed = 1;
    rtB0Result rtpResult;
    int nBytes = 0;

#if defined(MGD_TGT) && defined(PSD_HW)
    nBytes = rtp_get_feedback_data(&rtpResult, sizeof(rtpResult), &packed, RTP_RESULT_RTB0, RTP_QUEUE_OLDEST);
#endif    

    if( nBytes > 0 )
    {
        if (0 == packed)
        {
            /* Results are a rtB0Result structure */
            if( nBytes != sizeof(rtpResult) )
            {
                RtpEnd();
                psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "Failure in reading results", 
                        PSD_ARG_STRING, "rtB0:getRTBOFeedback", 0);
            }

            *processedIndex = rtpResult.processedIndex;
            *cfoffset = rtpResult.cfoffset;
            *fidmean = rtpResult.fidmean;
            *cfstddev = rtpResult.cfstddev;
            *cfresidual = rtpResult.cfresidual;
        }
        else
        {
            RtpEnd(); 
            psdexit(EM_PSD_ROUTINE_FAILURE,0,"","Received packed result",PSD_ARG_STRING,"getRTB0Feedback:RTB0",0);  
        }    
        return 1;
    }
    else
    {
        /* No new feedback data */
        return 0;
    }
}

void play_rtb0dummyseq(int count)
{
    int i = 0;
    if (rtb0dummyseq){
        boffset(off_seqrtb0dummy);
        settriggerarray((SHORT)1, rsptrigger_temp); /*set trigger to TRIG_INTERN for dummy seq*/
        for (i = 0; i < count; i++)
        {
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        }
    }
}

void play_rtb0resultwaitseq(int count)
{
    int i = 0;
    boffset(off_seqrtprtb0); /* offset to feedback wait pulse */
    settriggerarray((SHORT)1, rsptrigger_temp); /*set trigger to TRIG_INTERN for dummy seq*/
    for (i = 0; i < count; i++)
    {
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }
}

void play_rtb0fitwaitseq(int count)
{
    int i = 0;
    boffset(off_seqrtb0fitwait);
    settriggerarray((SHORT)1, rsptrigger_temp); /*set trigger to TRIG_INTERN for dummy seq*/
    for (i = 0; i < count; i++)
    {
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }
}


void set_dynr1(int r1)
{
    attenlockoff(&atten);
    setwamp(SSPDS+RDC,&dynr1,0);
    setwamp(SSPOC+RFHUBSEL,&dynr1,1);
    setwamp(SSPD+R1IND+r1-1,&dynr1,2);
}

/*MF B0 correction*/
void cf_medianfilter_acqinterpolation(const int slcindex_num, const int kernel_size, const int confidence_method, const float *slice_cfconfidence, const float conf_threshold)
{
    int i = 0, pass2 = 0, slcindex = 0;

    int cnt            = 0;
    int slcno          = 0;
    int validPts       = 0;
    int nextValidIndex = 0;

    float cfd[5];
    int half_kernel     = 0;
    int half_kernel_tmp = 0;
    int validity[slcindex_num];

    half_kernel = (kernel_size%2==0)?(kernel_size/2):(kernel_size-1)/2;

    /* median filtering */
    if (rtb0_debug)
    {
        fprintf(fp_cfdata, "Pass Slice-Index Slice-Loc \
                            Fid-Mean Measure-CF Filtered-CF \
                            CF-stddev CF-residual \
                            Slc-No p0Slc1 p0Slc2 \
                            p0SlcInd1 p0SlcInd2\n");
    }

    if(rtb0_filter_cf_flag)
    {
        if (confidence_method > 0)
        {
            /* Compute validity mask */
            for (slcindex = 0; slcindex < slcindex_num; slcindex++)
            {            
                validity[slcindex] = (slice_cfconfidence[slcindex] <= conf_threshold) ? 1 : 0;
            }

            for (slcindex = 0; slcindex < slcindex_num; slcindex++)
            {
                if (validity[slcindex]==1)
                {
                    cfd[0]=slice_cfoffset[slcindex];/*fill center point*/
                    cnt = 1;
                    half_kernel_tmp = half_kernel; /*3 point median, 1 on each side + 1 in the middle*/
                }
                else
                {
                    cnt = 0;
                    half_kernel_tmp = half_kernel+1; /*4 point median, 2 on each side*/
                }

                validPts = 0;
                slcno = sltime2slloc[slcindex];

                /*search on -ve side*/
                nextValidIndex = slcno-1*acqs; 
                while (validPts < half_kernel_tmp && nextValidIndex>=0)
                {
                    if (validity[slloc2sltime[nextValidIndex]]==1)
                    {
                        cfd[cnt]=slice_cfoffset[slloc2sltime[nextValidIndex]];
                        cnt++;
                        validPts++;
                        nextValidIndex -= acqs;
                    }
                    else
                    {
                        nextValidIndex -= acqs;
                    }
                }	

                validPts = 0; /*restart*/
			
                /*search on +ve side*/
                nextValidIndex = slcno+1*acqs;
                while (validPts < half_kernel_tmp && nextValidIndex < opslquant)
                {
                    if (validity[slloc2sltime[nextValidIndex]]==1)
                    {
                        cfd[cnt]=slice_cfoffset[slloc2sltime[nextValidIndex]];
                        cnt++;
                        validPts++;
                        nextValidIndex += acqs;
                    }
                    else
                    {
                        nextValidIndex += acqs;
                    }
                }

                /* sorting to find the median*/
                if(cnt == 1)
                {
                    slice_cfoffset_filtered[slcindex] = cfd[0];
                }
                else
                {
                    slice_cfoffset_filtered[slcindex]= median(cfd, cnt);
                }
            }/*end for loop*/
        }
        else
        {
            for (slcindex = 0; slcindex < slcindex_num; slcindex++)
            {
                cnt = 0;
                slcno = sltime2slloc[slcindex];
                for (i = -half_kernel; i <= half_kernel; i++)
                {
                    if((slcno+i*acqs >= 0) && (slcno+i*acqs < opslquant))
                    {
                        cfd[cnt] = slice_cfoffset[slloc2sltime[slcno+i*acqs]];
                        cnt++;
                    }
                }
                
                /* sorting to find the median */
                if (cnt == 1) 
                {
                    slice_cfoffset_filtered[slcindex] = cfd[0];
                }
                else
                {
                    slice_cfoffset_filtered[slcindex]= median(cfd, cnt);
                }
            }
        }/*end if confidence_method > 0*/
    }
    else
    {
        for (slcindex = 0; slcindex < slcindex_num; slcindex++)
        {
            slice_cfoffset_filtered[slcindex] = slice_cfoffset[slcindex];
        }
    }
    
    /*print for debug*/
    if (rtb0_debug)
    {
        for (slcindex = 0; slcindex < slcindex_num; slcindex++)
        {
            fprintf(fp_cfdata, "0 %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f\n",
                    slcindex, rsp_info[slcindex].rsptloc,
                    slice_fidmean[slcindex], slice_cfoffset[slcindex], slice_cfoffset_filtered[slcindex], 
                    slice_cfstddev[slcindex], slice_cfresidual[slcindex]);
        }
    }

    /*fill in 2nd pass*/
    for (pass2 = 1; pass2 < rspacq; pass2++)
    {
        int p0slcno1 = 0, p0slcindex1 = 0;
        int p0slcno2 = 0, p0slcindex2 = 0;
        int the_slcindex = 0;
        int slcno        = 0;

        for (slcindex = 0; slcindex < slc_in_acq[pass2]; slcindex++)
        {
            the_slcindex = (acq_ptr[pass2] + slcindex)%opslquant;
            slcno = sltime2slloc[the_slcindex];

            p0slcno1 = slcno/rspacq*rspacq;
            p0slcindex1 = slloc2sltime[p0slcno1];
            p0slcno2 = p0slcno1+rspacq;
            p0slcindex2 = slloc2sltime[p0slcno2];

            if(p0slcno2 >= opslquant)
            {
                slice_cfoffset_filtered[the_slcindex] = slice_cfoffset_filtered[p0slcindex1];
                if (rtb0_debug)
                {
                    fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d * %d *\n", 
                            pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                            slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                            slice_cfstddev[slcindex], slice_cfresidual[slcindex],
                            slcno, p0slcno1, p0slcindex1);
                }
                continue;
            }
            else
            {	
                slice_cfoffset_filtered[the_slcindex]
                = (slice_cfoffset_filtered[p0slcindex2]-slice_cfoffset_filtered[p0slcindex1])*
                  (float)(slcno-p0slcno1)/(float)(p0slcno2-p0slcno1)+slice_cfoffset_filtered[p0slcindex1];

                if (rtb0_debug)
                {
                    fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d %d %d %d\n", 
                            pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                            slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                            slice_cfstddev[slcindex], slice_cfresidual[slcindex],
                            slcno, p0slcno1, p0slcno2, 
                            p0slcindex1, p0slcindex2);
                }
            }	
        }
    }
}

/* Moving average filter with variable kernel size for RTB0 correction.
 * Designed to keep values near edge of slice coverage closer to original RTP values.
 * Implemented to improve DWIBS inter-station connectivity.*/
void cf_smooth_with_keep_edge(const int slcindex_num, const int min_kernel_size, const int max_kernel_size, const int confidence_method, const float *slice_cfconfidence, const float conf_threshold)
{
    int pass2 = 0, slcindex = 0, slcno = 0, slcno_for_ave = 0;

    /* Range of points used for moving average will depend on kernel size & number of points from edge */
    int half_kernel        = 0;
    int points_from_edge   = 0;
    int min_slcno_for_ave  = 0;
    int max_slcno_for_ave  = 0;
    int all_slices_invalid = 1; /* Later, if valid slice(s) exist, flag will be updated to 0 */

    int   n_averageSlices = 0;   /* Number of  RTB0 which were added up */
    float sum_delta_CF    = 0.0; /* Sum of all RTB0 for all edge slices */

    int validity[slcindex_num];

    for (slcindex = 0; slcindex < slcindex_num; slcindex++)
    {
        if ((confidence_method > 0) && (slice_cfconfidence[slcindex] > conf_threshold))
        {
            validity[slcindex] = 0;
        }
        else /* If Confidence thresholding is turned Off, or if confidence_value <= threshold */
        {
            all_slices_invalid = 0; /* At least one of the slices is valid */
            validity[slcindex] = 1;
        }
    }

    /* Print for debug */
    if (rtb0_debug)
    {
        fprintf(fp_cfdata, "Pass Slice-Index Slice-Loc \
                            Fid-Mean Measure-CF Filtered-CF \
                            CF-stddev CF-residual \
                            Slc-No p0Slc1 p0Slc2 \
                            p0SlcInd1 p0SlcInd2\n");
    }

    for (slcno = 0; slcno < slcindex_num; slcno++)
    {
        points_from_edge = IMin(2, slcno, slcindex_num - 1 - slcno);
        half_kernel = IMin(2, IMax(2, points_from_edge, (min_kernel_size - 1)/ 2), (max_kernel_size - 1)/ 2);
        min_slcno_for_ave = IMax(2, 0, slcno - half_kernel);
        max_slcno_for_ave = IMin(2, slcindex_num - 1, slcno + half_kernel);
        
        if (all_slices_invalid)
        {
            slice_cfoffset_filtered[slloc2sltime[slcno * acqs]] = slice_cfoffset[slloc2sltime[slcno * acqs]];
        }
        else /* Compute cf offset based on valid point(s) */
        {
            /* 1. Set min/max range for averaging */

            n_averageSlices = 0;

            while (n_averageSlices == 0)
            {
                for (slcno_for_ave = min_slcno_for_ave; slcno_for_ave <= max_slcno_for_ave; slcno_for_ave++)
                {
                    if (validity[slloc2sltime[slcno_for_ave * acqs]] == 1)
                    {
                        n_averageSlices = n_averageSlices + 1;
                    }
                }
                
                /* If no points to average, extend min/max slice range and interatively find valid slice(s) */
                if (n_averageSlices == 0)
                {
                    min_slcno_for_ave = IMax(2, 0, min_slcno_for_ave - 1);
                    max_slcno_for_ave = IMin(2, slcindex_num - 1, max_slcno_for_ave + 1);
                }

                /* If end of slice coverage reached, break from while loop */
                if ((min_slcno_for_ave == 0) && (max_slcno_for_ave == (slcindex_num - 1)))
                {
                    min_slcno_for_ave = 0;
                    max_slcno_for_ave = slcindex_num;
                    break;
                }
            }

            /* 2. Perform averaging over min/max range */
            
            n_averageSlices = 0;
            sum_delta_CF    = 0.0;

            for (slcno_for_ave = min_slcno_for_ave; slcno_for_ave <= max_slcno_for_ave; slcno_for_ave++)
            {
                if (validity[slloc2sltime[slcno_for_ave * acqs]] == 1)
                {
                    n_averageSlices = n_averageSlices + 1;
                    sum_delta_CF = sum_delta_CF + slice_cfoffset[slloc2sltime[slcno_for_ave * acqs]];
                }
            }
            slice_cfoffset_filtered[slloc2sltime[slcno * acqs]] = sum_delta_CF/ n_averageSlices;
        } /* End computation of cf offset */
    } /* End loop over all slices */

    /* Print linear interpolated CF values for debug */
    if (rtb0_debug)
    {
        for (slcindex = 0; slcindex < slcindex_num; slcindex++)
        {
            fprintf(fp_cfdata, "0 %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f\n",
                    slcindex, rsp_info[slcindex].rsptloc,
                    slice_fidmean[slcindex], slice_cfoffset[slcindex], slice_cfoffset_filtered[slcindex], 
                    slice_cfstddev[slcindex], slice_cfresidual[slcindex]);
        }
    }

    /* Fill in 2nd Pass using 1st Pass information */
    for(pass2 = 1; pass2 < rspacq; pass2++)
    {
        int p0slcno1 = 0, p0slcindex1 = 0;
        int p0slcno2 = 0, p0slcindex2 = 0;
        int the_slcindex = 0;
        int slcno        = 0;

        for(slcindex = 0; slcindex < slc_in_acq[pass2]; slcindex++)
        {
            the_slcindex = (acq_ptr[pass2] + slcindex)%opslquant;
            slcno = sltime2slloc[the_slcindex];

            p0slcno1 = slcno/rspacq*rspacq;
            p0slcindex1 = slloc2sltime[p0slcno1];
            p0slcno2 = p0slcno1+rspacq;
            p0slcindex2 = slloc2sltime[p0slcno2];

            if(p0slcno2 >= opslquant)
            {
                slice_cfoffset_filtered[the_slcindex] = slice_cfoffset_filtered[p0slcindex1];
                if (rtb0_debug)
                {
                    fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d * %d *\n", 
                            pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                            slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                            slice_cfstddev[slcindex], slice_cfresidual[slcindex], 
                            slcno, p0slcno1, p0slcindex1);
                }
                continue;
            }
            else
            {	
                slice_cfoffset_filtered[the_slcindex]
                = (slice_cfoffset_filtered[p0slcindex2]-slice_cfoffset_filtered[p0slcindex1])*
                  (float)(slcno-p0slcno1)/(float)(p0slcno2-p0slcno1)+slice_cfoffset_filtered[p0slcindex1];

                if (rtb0_debug)
                {
                    fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d %d %d %d\n", 
                            pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                            slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                            slice_cfstddev[slcindex], slice_cfresidual[slcindex], 
                            slcno, p0slcno1, p0slcno2, 
                            p0slcindex1, p0slcindex2);
                }
            }	
        }
    } /* End sorting of filered CF data */
}

/*MF B0 correction weighted fit*/
void printCFResult(int slcindex_num)
{    
    fprintf(fp_cfdata, "Pass Slice-Index Slice-Loc \
                        Fid-Mean Measure-CF Filtered-CF \
                        CF-stddev CF-residual \
                        Slc-No p0Slc1 p0Slc2 \
                        p0SlcInd1 p0SlcInd2\n");

    int slcindex = 0, pass2 = 0;

    for(slcindex = 0; slcindex < slcindex_num; slcindex++)
    {
        fprintf(fp_cfdata, "0 %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f\n", 
                slcindex, rsp_info[slcindex].rsptloc,
                slice_fidmean[slcindex], slice_cfoffset[slcindex], slice_cfoffset_filtered[slcindex], 
                slice_cfstddev[slcindex], slice_cfresidual[slcindex]);
    }

    for(pass2 = 1; pass2 < rspacq; pass2++)
    {
        int p0slcno1 = 0, p0slcindex1 = 0;
        int p0slcno2 = 0, p0slcindex2 = 0;
        int the_slcindex = 0;
        int slcno        = 0;

        for(slcindex = 0; slcindex < slc_in_acq[pass2]; slcindex++)
        {
            the_slcindex = (acq_ptr[pass2] + slcindex)%opslquant;
            slcno = sltime2slloc[the_slcindex];

            p0slcno1 = slcno/rspacq*rspacq;
            p0slcindex1 = slloc2sltime[p0slcno1];
            if(p0slcindex1 >= slc_in_acq[0]-1)
            {
                fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d * %d *\n", 
                        pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                        slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                        slice_cfstddev[slcindex], slice_cfresidual[slcindex],
                        slcno, p0slcno1, p0slcindex1);
                continue;
            }

            p0slcno2 = p0slcno1+rspacq;
            p0slcindex2 = slloc2sltime[p0slcno2];

            fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d %d %d %d\n", 
                    pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                    slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex],
                    slice_cfstddev[slcindex], slice_cfresidual[slcindex],
                    slcno, p0slcno1, p0slcno2,
                    p0slcindex1, p0slcindex2);
        }
    }

}


void interpolatePass(void)
{
    int pass2 = 0, slcindex = 0;

    for (pass2 = 1; pass2 < rspacq; pass2++)
    {
        int p0slcno1 = 0, p0slcindex1 = 0;
        int p0slcno2 = 0, p0slcindex2 = 0;
        int the_slcindex = 0;
        int slcno        = 0;

        for (slcindex = 0; slcindex < slc_in_acq[pass2]; slcindex++)
        {
            the_slcindex = (acq_ptr[pass2] + slcindex)%opslquant;
            slcno = sltime2slloc[the_slcindex];

            p0slcno1 = slcno/rspacq*rspacq;
            p0slcindex1 = slloc2sltime[p0slcno1];
            if(p0slcindex1 >= slc_in_acq[0]-1)
            {
                slice_cfoffset_filtered[the_slcindex] = slice_cfoffset_filtered[p0slcindex1];
                if (rtb0_debug)
                {
                    fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d * %d *\n", 
                            pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                            slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                            slice_cfstddev[slcindex], slice_cfresidual[slcindex], 
                            slcno, p0slcno1, p0slcindex1);
                }
                continue;
            }

            p0slcno2 = p0slcno1+rspacq;
            p0slcindex2 = slloc2sltime[p0slcno2];
            slice_cfoffset_filtered[the_slcindex]
                = (slice_cfoffset_filtered[p0slcindex2]-slice_cfoffset_filtered[p0slcindex1])*
                  (slcno-p0slcno1)/(p0slcno2-p0slcno1)+slice_cfoffset_filtered[p0slcindex1];
    	
            if (rtb0_debug)
            {
                 fprintf(fp_cfdata, "%d %d %8.2f %8.2f %7.2f %7.2f %8.2f %8.2f %d %d %d %d %d\n", 
                         pass2, the_slcindex, rsp_info[the_slcindex].rsptloc,
                         slice_fidmean[p0slcindex1], slice_cfoffset[p0slcindex1], slice_cfoffset_filtered[the_slcindex], 
                         slice_cfstddev[slcindex], slice_cfresidual[slcindex],
                         slcno, p0slcno1, p0slcno2, 
                         p0slcindex1, p0slcindex2);
            }
        }
    }

}

/*sort cfoffset by either location (dir =0) or time (dir = 1)*/
void reorder_cfoffset(float *cfoffset_reorder, float *cfoffset, int slquant, int *loc2time, int dir)
{
    int i = 0;

    if (dir==0) /*convert sort by time to sort by loc*/
    {
        for (i = 0; i < slquant; i++)
        {
            cfoffset_reorder[i]=cfoffset[loc2time[i]];
        }
    }
    else /*convert sort by loc back to sort by time*/
    {
        for (i = 0; i < slquant; i++)
        {
            cfoffset_reorder[loc2time[i]]=cfoffset[i];
        }
    }
}

#if defined(MGD_TGT) && defined(PSD_HW)
/**
 * This function is not used in product, but is useful function for debug
 * Min and Max RTB0 roundtrip time will be logged
 */
void computeRTB0TimingStats()
{
    char rtb0filepath[170] = "/export/home/service/log/RTB0Stat_";
    struct timespec nCurrTimeRtb0;
    char timestampRtb0[20];
    struct tm *Rtb0timePtr;
    FILE *fp_rtb0Stat;
    long rtb0timingidx = 0;

    mgd_clock_gettime (HOST_TIME_OF_DAY, &nCurrTimeRtb0);
    Rtb0timePtr  = localtime(&nCurrTimeRtb0.tv_sec);

    strftime(timestampRtb0,20,"_%m%d%Y%H_%M_%S",Rtb0timePtr);

    strcat(rtb0filepath,timestampRtb0);

    fp_rtb0Stat=fopen(rtb0filepath, "w");
    if (fp_rtb0Stat == NULL) 
    {
        printf("Failed to open %s\n", rtb0filepath);
        return;
    }
    /* Send Timing Stats to File */

    fprintf(fp_rtb0Stat, "Min RTB0 roundtrip time: %ld \n", min_rtb0_feedback_time);
    fprintf(fp_rtb0Stat, "Max RTB0 roundtrip time: %ld \n", max_rtb0_feedback_time);
    fprintf(fp_rtb0Stat, "RTB0 interslice fitting time: %.6f \n", rtb0_fitting_time);
    for (rtb0timingidx = 0; rtb0timingidx < rtb0_roundtrip_index; rtb0timingidx++)
    {
        fprintf(fp_rtb0Stat, "%ld\n", rtb0_roundtrip_timing_array[rtb0timingidx]);
    }

    fclose(fp_rtb0Stat);

    return;
}
#endif



/* t1flair_stir */
void
T1flair_calc_edgeslice_freq_pha(void)
{
    if (PSD_ON == t1flair_flag && PSD_ON == act_edge_slice_enh_flag)
    {
        int s, dfreq, dpha;
        int m1 = 0;
        int m2 = 0;
        int edgecount = 0;

        for (s = 0; s < slquant1; s++)
        {
            if (EDGESLICE == T1flair_slice_flag[pass][s])
            {
                if (0 == edgecount)
                {
                    edgeslice1 = s;
                    m1 =  (real_slice_acq_seq[pass][s] + acq_ptr[pass])%opslquant;
                    edgecount++;
                }
                else
                {
                    edgeslice2 = s;
                    m2 =  (real_slice_acq_seq[pass][s] + acq_ptr[pass])%opslquant;
                }
            }
        }
        dfreq = (rf0_freq[m2] - rf0_freq[m1])/(slc_in_acq[pass]-1);
        dpha = (rf0_pha[m2] - rf0_pha[m1])/(slc_in_acq[pass]-1);

        edgeslice1freq = rf0_freq[m1] - dfreq;
        edgeslice2freq = rf0_freq[m2] + dfreq;

        edgeslice1pha = rf0_pha[m1] - dpha;
        edgeslice2pha = rf0_pha[m2] + dpha;
        if (debug_t1flairenh == 1)
        {
            printf("slicinaca=%d m1 = %d m2=%d edgeslice1=%d edgeslice2=%d dfreq=%d dpha=%d \nedgeslice1fre pha=%d  %d slice2freq pha= %d %d\n",
                   slc_in_acq[pass], m1, m2, edgeslice1, edgeslice2,
                   dfreq, dpha, edgeslice1freq, edgeslice1pha, edgeslice2freq,edgeslice2pha);
            fflush(stdout);
        }
    }
}

/*Diffusion hyper DAB*/
typedef enum FRAME_TYPE {
    REF_FRAME,
    T2_FRAME,
    DIFF_FRAME
} E_FRAME_TYPE;
E_FRAME_TYPE frame_type;

int diff_index = 0;
int nex_index = 0;
int instance_index =0;
int b_index = 0;
int dir_index = 0;
int vol_index =0;
int gradpol_dab = 0;
/*******************************   PS   ***************************/
/*********************************************************************
 *                    PRESCAN.E RSP SECTION                          *
 *                            PScore                                 *
 *                                                                   *
 * Write here the functional code for the real time processing (Tgt  *
 * side). You may declare standard C variables, but of limited types *
 * short, int, long, float, double, and 1D arrays of those types.    *
 *********************************************************************/

long PSrsptrigger[MAX_PSC_VQUANT]={0};   /* prescan trigger */ /* vmx 10/13/94 YI */

void
dump_rsp_psc_info( void )
{
    INT i ;
    printf("\nPSD-> Dump of Prescan Shim Vol. Info\n");

    for (i=0; i<oppscvquant; i++)
    {
        printf("PSD->\nPSD->PscVol %d\t\t\t\ttloc = %+6f, rloc = %+6f, phaseoff = %+6f\n",
               i, rsp_psc_info[i].rsppsctloc, rsp_psc_info[i].rsppscrloc, rsp_psc_info[i].rsppscphasoff);
        printf("PSD->\nPSD->Index %d\t\t\t\tlenx = %+6d, leny = %+6d, lenz = %+6d\n",
               i, rsp_psc_info[i].rsppsclenx, rsp_psc_info[i].rsppscleny, rsp_psc_info[i].rsppsclenz);

        printf("\n Shim volume rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[0], rsp_psc_info[i].rsppscrot[1], rsp_psc_info[i].rsppscrot[2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[3], rsp_psc_info[i].rsppscrot[4], rsp_psc_info[i].rsppscrot[5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsp_psc_info[i].rsppscrot[6], rsp_psc_info[i].rsppscrot[7], rsp_psc_info[i].rsppscrot[8]);
    }
}

INT
get_psc_vol_index( void )
{
    int vol_index = 0;

    vol_index = (noswitch_slab_psc == PSD_ON) ? (PStest_slab-1) : (psc_vol_index-1);
    vol_index = (vol_index > 0) ? vol_index : 0;

    return vol_index;
}

/*
 *  mps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
mps1( void )
{
    rspent = L_MPS1;
    strcpy(psdexitarg.text_arg, "MPS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);

    PSmps1(2);
    rspexit();

    return SUCCESS;
}   /* end mps1() */


/*
 *  aps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
aps1( void )
{
    rspent=L_APS1;
    strcpy(psdexitarg.text_arg, "APS1");

/* begin aps1_mod changes (GE) */
    PSinit(PSrot_mod);
    PSmps1(1);
    rspexit();

    return SUCCESS;
}   /* end aps1() */


/*
 *  cfl
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfl( void )
{
    rspent=L_CFL;
    strcpy(psdexitarg.text_arg, "CFL");

    PSinit(PSrot);
    PScfl();
    rspexit();

    return SUCCESS;
}   /* end cfl() */


/*
 *  rcvn
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
rcvn( void )
{
    rspent=L_RCVN;
    strcpy(psdexitarg.text_arg, "RCVN");

    PSinit(rsp_rcvnrot);

    /* Check if need to run RCVN for Full Rec coil mode */
    rcvn_usefullcoil = rspusefullcoil & RCVN_FULLCOIL;
        
    if (RCVN_FULLCOIL == rcvn_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for RCVN \n");
        }
        rspusefullcoil &= ~RCVN_FULLCOIL;
    }

    PSrcvn();
    rspexit();

    return SUCCESS;
}   /* end rcvn() */


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This sets the rotation matrix with the one from the scan plane before the 3rd refocus pulse,
   and sets the rotation matrix back to the default one after the 3rd refocus pulse.
 */
void
cfh_set_rot_matrix_slice( void )
{
    static int rot_matrix_index = 0;
    int cfh_slab_index = get_psc_vol_index();

    if (rot_matrix_index == 0)
    {
        setrotateimm(PSrot[0], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 1;
    }
    else
    {
        setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
        rot_matrix_index = 0;
    }
    return;
}

void
cfh_set_rot_matrix_default( void )
{
    int cfh_slab_index = get_psc_vol_index();

    setrotateimm(rsp_PSrot[cfh_slab_index], WARP_UPDATE_ON_SSP_INT);
    return;
}


/*
 *  cfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
cfh( void )
{
    /* Insert wait sequence before CFH for T1 recovery if the previous entry is XTG */
    if (rspent == L_XTG)
    {
        setperiod(wait_time_before_cfh, &seqcfhwait, 0);
        boffset(off_seqcfhwait);
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    rspent=L_CFH;
    strcpy(psdexitarg.text_arg, "CFH");


    if ( (presscfh_ctrl == PRESSCFH_SHIMVOL) || (presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE) )
    {
        int cfh_slab_index = get_psc_vol_index();
        PSinit(&rsp_PSrot[cfh_slab_index]);
    }
    else
    {
        PSinit(rsp_PSrot);
    }

    if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
    {
        isivector(3, cfh_set_rot_matrix_slice, (short) FALSE);
    }
    else
    {
        isivector(3, cfh_set_rot_matrix_default, (short) FALSE);
    }

    cfh_usefullcoil = rspusefullcoil & CFH_FULLCOIL;
    if (CFH_FULLCOIL == cfh_usefullcoil)
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for CFH \n");
        }
        rspusefullcoil &= ~CFH_FULLCOIL;
    }

    PScfh();
    rspexit();

    return SUCCESS;
}   /* end cfh() */

/*
 *  fasttg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
fasttg( void )
{
    rspent=L_FTG;
    PSinit(PSrot_mod);
    PSfasttg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;
}   /* end fasttg() */

/*
 *  expresstg
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
expresstg( void )
{
    rspent=L_XTG;
    PSinit(PSrot_mod);

    xtg_usefullcoil = rspusefullcoil & XTG_FULLCOIL;
    if ((XTG_FULLCOIL == xtg_usefullcoil) && (PSD_OFF == xtg_volRecCoil))
    {
        if (FAILURE == CoilSwitchSetCoil(fullRecCoilInfo_tgt[0], 0))
        {
            return FAILURE;
        }

        if(PSdebugstate)
        {
            printf("switch to full coil for XTG \n");
        }
        rspusefullcoil &= ~XTG_FULLCOIL;
    }

    PSexpresstg(pre_slice, PSdebugstate);
    rspexit();

    return SUCCESS;    
}   /* end expresstg() */

/*
 * B1 Map acquisition for RF Shim 
 *
 * Type: Public Function
 *
 */
STATUS
RFshim( void )
{
    rspent=L_RFSHIM;
    strcpy(psdexitarg.text_arg, "RFshim");

    PSrfshim();    /* flag on for RFShim mode */
    printdbg("Normal End of RFshim", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

int rspdtg = PSD_OFF;              /* rsp update for DynTG setting, set by prescan server */
int deltatg_temp[MAX_DYNTG_NOSLICES];
int *deltatg = (int *) deltatg_temp;    /* rsp update for DynTG setting, set by prescan server. */

STATUS DtgInitPsc()
{
    INT i;

    rspdtg = PSD_OFF;
    for (i=0; i<opslquant; i++)
    {
        deltatg[i] = 0;
    }
    return SUCCESS;
}

/* 
 * B1 Map for Dynamic TG
 *
 * Type: Public Function
 *
 */
STATUS
DynTG( void )
{
    rspent=L_DYNTG;
    strcpy(psdexitarg.text_arg, "DynTG");

    DtgInitPsc();
    PSdyntg();
    printdbg("Normal End of DynTG", PSdebugstate);

    rspexit();
    return SUCCESS;    
}


/* 
 * ExtCal Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
extcal( void )
{
    if((L_AUTOSHIM == rspent) || (L_RCVN == rspent) || (L_AUTOCOIL == rspent))
    {
        rspdda = cal_dda;
    }
    else
    {
        rspdda = cal_dda + cal_delay_dda;
    }

    rspent=L_EXTCAL;
    strcpy(psdexitarg.text_arg, "ExtCal");

    printdbg("Start of extcal", PSdebugstate);

    /* reset for coil switching */
    loaddab_hub_r1(&echo1cal, 0, 0, 0, 1, 0, 0, (TYPDAB_PACKETS)DABOFF, PSD_LOAD_DAB_HUB_R1_RESET);

    PSextcal();
    printdbg("Normal End of extcal", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/* 
 * AutoCoil Entry point 
 *
 * Type: Public Function
 *
 */
STATUS
Autocoil( void )
{
    rspdda = coil_dda;

    rspent=L_AUTOCOIL;
    strcpy(psdexitarg.text_arg, "Autocoil");
    printdbg("Start of Autocoil", PSdebugstate);

    PSautocoil();
    printdbg("Normal End of Autocoil", PSdebugstate);

    rspexit();
    return SUCCESS;    
}

/*
 *  autoshim
 *
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
autoshim( void )
{
    rspent=L_AUTOSHIM;
    strcpy(psdexitarg.text_arg, "Autoshim");

    ASautoshim(rspsct);
    rspexit();

    return SUCCESS;
}   /* end autoshim() */


/*
 *  PSmps1
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSmps1( INT mps1nex )
{
    INT acq_type;
    SHORT temp_short;
    INT slice_freq;
    FLOAT receive_freq;
    FLOAT rsp_PStloc=0.0;
    FLOAT rsp_PSrloc=0.0;
    FLOAT rsp_PSphasloc=0.0;
    INT old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Starting PSmps1",PSdebugstate);
    boffset(off_seqmps1);

    scopeon(&seqmps1);	/* Activate scope for core */
    syncon(&seqmps1);	/* Activate sync for core */

    rsp_PStloc = PStloc_mod;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasloc = PSphasoff_mod;
    /* begin aps1_mod changes (GE) */

    if(PSD_ON == local_tg)
    {
        slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                            (10* TARDIS_FREQ_RES) );
    }
    else
    {
        slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                            (10* TARDIS_FREQ_RES) );
    }
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf1mps1,0);

    slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
    /* factor 10 is because rsptloc is in mm */
    setfrequency(slice_freq, &rf2mps1,0);

    receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

    /* end aps1_mod changes (GE) */ 

    setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
		 &echo1mps1, 0);

    if(PSdebugstate)
    {
        printf("\nAPS1/MPS1 Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                thickPS_mod,mpsfov, PStloc_mod, PSrloc_mod);
        printf("\nAPS1/MPS1 Xmit Freq = %i, Rcv Freq  = %f\n", slice_freq, receive_freq);
        printf("%s\n","APS1/MPS1 Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("PSmps1: psc_vol_index = %d\n",psc_vol_index );
    }


    
    for (view = -1; view <= 30000; view++)
    {
        for (excitation = 1; excitation <= mps1nex; excitation++)
    	{
            if (view > 0)

      	    {
                if (excitation == mps1nex)
      	      	{
                    attenlockoff(&attenuator_keymps1);
      	      	}
                else
      	      	{
                    attenlockon(&attenuator_keymps1);
      	      	}
      	    }

            if ((view > 0) && (excitation >= 1))
      	    {
                acq_type = (int)DABON;
      	    }
            else
      	    {
                acq_type = (int)DABOFF;
      	    }

            loaddab(&echo1mps1, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL); 

            /* For SWIFT(PSmps1): We are trying not to use the CV opswift.
               Instead use psc_vol_index.  */
            if( (psc_vol_index > 0) && (opvquant > 1))
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqmps1);
                    }
                        
                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSmps1: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq = (int)( GAM * a_gyrf1mps1 * rsp_PSphasloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            else
            {
                slice_freq = (int)( GAM * a_gzrf1mps1 * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES) );
            }
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf1mps1,0);

            slice_freq = (int)( GAM * a_gzrf2mps1 * rsp_PStloc
/ (10* TARDIS_FREQ_RES) );
            /* factor 10 is because rsptloc is in mm */
            setfrequency(slice_freq, &rf2mps1,0);

            receive_freq = 2 * 16000 * rsp_PSrloc/ mpsfov;

            /* end aps1_mod changes (GE) */

            setfrequency((int)((PSfreq_offset[rspent] + receive_freq)/TARDIS_FREQ_RES),
                    &echo1mps1, 0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            syncoff(&seqmps1);

            /* Chopper logic */
            getiamp(&temp_short, &rf1mps1,0);
            setiamp((-temp_short),&rf1mps1,0);
	}
    }

    printdbg("Returning from PSmps1",PSdebugstate);

    return SUCCESS;
}   /* end PSmps1() */


/*
 *  PScfl
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PScfl( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    INT slice_freq; /* transmit frequency for the prescan slice */
    SHORT temp_short; /* temp variable */
    float rsp_PStloc;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PScfl", PSdebugstate);
    boffset(off_seqcfl); 
    scopeon(&seqcfl);
    syncon(&seqcfl); 
    attenlockoff(&cfl_attenkey);
  
    rsp_PStloc = PStloc;
    slice_freq = (int)(GAM * a_gzrf1cfl * PStloc/
                       (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
  
    setfrequency(slice_freq, &rf1cfl,0);
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &cfl_fid, 0);

    if( PSdebugstate )
    {
        printf("PScfl: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -cfl_dda+1 ; view <= 30000; view ++)
    {
        for (excitation = 1; excitation <= cfl_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == cfl_nex)
                    attenlockoff(&cfl_attenkey);
                else
                    attenlockon(&cfl_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&cfl_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PScfl): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                    }

                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfl); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfl: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq = (int)(GAM * a_gzrf1cfl * rsp_PStloc/
                               (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */

            setfrequency(slice_freq, &rf1cfl,0);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfl);

            if(PSdebugstate && view == 0)
            {
                printf("\n CFL:  Xmit Location = %f Receive Location = %f\n ", PStloc, 0.0 );
                printf ("%s\n","CFL : Rotation Matrix");
                printf("\t %6ld %6ld %6ld \n", PSrot[0][0], PSrot[0][1], PSrot[0][2]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][3], PSrot[0][4], PSrot[0][5]);
                printf("\t %6ld %6ld %6ld \n", PSrot[0][6], PSrot[0][7], PSrot[0][8]);
                fflush(stdout);
            }

            getiamp(&temp_short, &rf1cfl, 0);
            setiamp(-temp_short, &rf1cfl, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfl() */


/*
 *  PSrcvn
 *  
 *  Type: 
 *  
 *  Description:
 *  
 */
STATUS
PSrcvn( void )
{
    INT acq_type; /* enable or disable data acquisiton */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    printdbg("Entering PSrcvn", PSdebugstate);

    /* GEHmr03545 */
    if ( rcvn_flag != PSD_OFF )
    {
        boffset( off_pre_rcvn );
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    boffset(off_seqrcvn); 
    scopeon(&seqrcvn);
    syncon(&seqrcvn); 
    attenlockoff(&rcvn_attenkey);
  
    setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                 &rcvn_fid, 0);

    if( PSdebugstate )
    {
        printf("PSrcvn: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = -rcvn_dda+1 ; view <= rcvn_loops ; view ++)
    {
        for (excitation = 1; excitation <= rcvn_nex; excitation ++)
        {
            if (view > 0) 
            {
                acq_type = (int)DABON;

                if(excitation == rcvn_nex)
                    attenlockoff(&rcvn_attenkey);
                else
                    attenlockon(&rcvn_attenkey);
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */

            loaddab(&rcvn_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* For SWIFT(PSrcvn): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
             */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch slab*/
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqrcvn); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PSrcvn: psc_vol_index=%d\n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            startseq((short)0,(short)MAY_PAUSE);

            syncoff(&seqrcvn);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }

        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PSrcvn() */

/*
 *  NoiseCalrcvn
 *  
 *  Type: Public Function
 *  
 *  Description: NoiseCal in scan. Override opcode to DNOISE (16) for rcvn_fid
 *  
 */
STATUS
NoiseCalrcvn( void )
{
    short dabbits;
    LONG resolution;

    if(noisecal_in_scan_flag || !(fopen(".OnWatchNoiseCal","r")==NULL))
    {
        printdbg("Entering NoiseCalrcvn", PSdebugstate);

        /* GEHmr03545 */
        if ( rcvn_flag != PSD_OFF )
        {
            boffset( off_pre_rcvn );
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        }

        boffset(off_seqrcvn); 
        scopeon(&seqrcvn);
        syncon(&seqrcvn); 
        attenlockoff(&rcvn_attenkey);

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES),
                     &rcvn_fid, 0);

        dabbits = DNOISECAL;
        sspload(&dabbits,
                &rcvn_fid,
                1, /*opcode*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        dabbits = 1; 
        sspload(&dabbits,
                &rcvn_fid,
                2, /*frame*/
                1,
                (HW_DIRECTION)TOHARDWARE,
                (SSP_S_ATTRIB)SSPS1);

        resolution = rcvn_xres; 
        sspextload(&resolution,
                   &rcvn_fid,
                   3, /*resolution*/
                   1,
                   (HW_DIRECTION)TOHARDWARE,
                   (SSP_S_ATTRIB)SSPS2);

        startseq((short)0,(short)MAY_PAUSE);

        syncoff(&seqrcvn);

        boffset(off_seqcore); 
    }
    return SUCCESS;
}   /* end NoiseCalrcvn() */



/*
 *  PScfh
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PScfh( void )
{
    static INT rsp_PSshift = 0;  /* RSP shimvol shift for debug purpose */
    INT acq_type;      /* enable or disable data acquisiton */
    INT slice_freq  = 0;   /* transmit frequency for the prescan slice */
    INT slice2_freq = 0;   /* transmit frequency for the prescan slice */
    INT slice3_freq = 0;   /* presscfh: transmit frequency for the prescan slice */
    INT slice4_freq = 0;   /* presscfh-slice: transmit frequency for the prescan slice */
    INT ir_slice_freq = 0; /* IR sequence transmit freq. for the prescan slice */
    SHORT temp_short;  /* temp variable */
    long init_cfh_deadtime; /* initial deadtime of the seqcfh sequence */
    long new_cfh_deadtime;  /* updated cfh deadtime */

    float rsp_PStloc = 0;    /* RSP transmit location */
    float rsp_PSrloc = 0;    /* RSP receive location */
    float rsp_PSphasoff = 0; /* RSP phase off location */
    float rsp_PSslicetloc = 0;    /* RSP slice refocus location */
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    
    showfp = 0;

    printdbg("Entering PScfh", PSdebugstate);
    boffset(off_seqcfh); 
    scopeon(&seqcfh);
    syncon(&seqcfh); 
    attenlockoff(&cfh_attenkey);

    if (psc_vol_index == 0) {

        slice_freq = (int)cfh_rf1freq;
        setfrequency(slice_freq, &rf1cfh,0);

        slice2_freq = (int)cfh_rf2freq;
        setfrequency(slice2_freq, &rf2cfh,0);
        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);
    }

#ifdef PSD_CFH_CHEMSAT

    if ((cs_sat == PSD_ON) && PScs_sat)
    {
        if (PSir != PSD_ON)
        {
            setiamp(ia_rfcssatcfh, &rfcssat, cscfh_satindex);
        }
        else
        {
            setiamp(0, &rfcssat, cscfh_satindex);
        }
    }
    cstun = 0;

#endif


    if (PSD_ON == PSir)
    {
        /* Inversion */
        /* factor 10 is because rsptloc is in mm */
        ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
        setfrequency(ir_slice_freq, &rf0cfh,0);
    }

    /* Setting tislice to PSslice_num+1 so user sees slices start at 1*/
    tislice=PSslice_num+1;
    tislice_start=PSslice_num+1;

    /* Setting psctitime to opti; results in every entry into CFH having
       psctitime=opti*/
    psctitime = cfh_ti/1000;
    noir = 0;

    /* Finding initial deadtime (psctitime = opti) of seqcfh */
    getperiod( &init_cfh_deadtime, &seqcfh, 0 );

    if( PSdebugstate )
    {
        printf("PScfh: psc_vol_index = %d\n",psc_vol_index );
    }


    for (view = -cfh_dda+1 ; view <= 30000; view ++)
    {
        /* Modified for MULTI VOLUME Prescan - AP */
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            int cfh_slab_index = get_psc_vol_index();

            if( ( presscfh_ctrl != PRESSCFH_SHIMVOL ) && ( presscfh_ctrl != PRESSCFH_SHIMVOL_SLICE ) )
            {
                rsp_PStloc = presscfh_info[cfh_slab_index].oppsctloc;
                rsp_PSrloc = presscfh_info[cfh_slab_index].oppscrloc;
                rsp_PSphasoff = presscfh_info[cfh_slab_index].oppscphasoff;
            }
            else
            {
                rsp_PStloc = rsp_psc_info[cfh_slab_index].rsppsctloc;
                rsp_PSrloc = rsp_psc_info[cfh_slab_index].rsppscrloc;
                rsp_PSphasoff = rsp_psc_info[cfh_slab_index].rsppscphasoff;
            }

            if (PScfh_shimvol_debug != PSCFH_SHIMVOL_DEBUG_NONE)
            {
                rsp_PSshift = rsp_PSshift + 10;
                if ( rsp_PSshift > 100 )
                {
                    rsp_PSshift = -100;
                }
            }
            else
            {
                rsp_PSshift = 0;
            }

            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Z)
            {
                rsp_PStloc = rsp_PStloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_X)
            {
                rsp_PSrloc = rsp_PSrloc + rsp_PSshift;
            }
            if (PScfh_shimvol_debug & PSCFH_SHIMVOL_DEBUG_Y)
            {
                rsp_PSphasoff = rsp_PSphasoff + rsp_PSshift;
            }

            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/ (10 * TARDIS_FREQ_RES));
            slice2_freq = (int)(GAM * a_gxrf2cfh * rsp_PSrloc/ (10 * TARDIS_FREQ_RES));
            slice3_freq = (int)(GAM * a_gyrf3cfh * rsp_PSphasoff/ (10 * TARDIS_FREQ_RES));

            if(PSdebugstate)
            {
                printf("\n");
                printf(" slice1_freq -> rsp_PStloc %0f \n", rsp_PStloc);
                printf(" slice2_freq -> rsp_PSrloc %0f \n", rsp_PSrloc);
                printf(" slice3_freq -> rsp_PSphasoff %0f \n", rsp_PSphasoff);
            }

            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                rsp_PSslicetloc = PStloc;
                slice4_freq = (int)(GAM * a_gzrf4cfh * rsp_PSslicetloc/ (10 * TARDIS_FREQ_RES));

                if(PSdebugstate)
                {
                    printf(" slice4_freq -> rsp_PSslicetloc %0f \n", rsp_PSslicetloc);
                }
            }

            if( PSD_ON == PSir ) {
                ir_slice_freq = (int)( GAM * a_gzrf0cfh * rsp_PStloc
/ (10 * TARDIS_FREQ_RES) );
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else if ( psc_vol_index > 0 )
        {
            /* PRESSCFH_NONE */

            int cfh_switch_coil=0;

            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            if ( opswift == PSD_ON )
            {
                    cfh_switch_coil = 1;
            }

            if( cfh_switch_coil )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    if( noswitch_coil_psc == PSD_OFF )
                    {
                        if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[psc_vol_index-1], 0))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcfh); 
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"PScfh: psc_vol_index=%d \n",psc_vol_index);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }
            slice_freq = (int)(GAM * a_gzrf1cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
            if((opcoax != 0) && cfh_newmode)
            {
                slice2_freq = (int)(GAM * (opspf ? rsp_PSphasoff * a_gyrf2cfh : rsp_PSrloc * a_gxrf2cfh )/(10 * TARDIS_FREQ_RES));
            }
            else
            {
                slice2_freq = 0;
            }

            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * rsp_PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }
        else
        {
            /* This is for the 3D scan volume - psc_vol_index = 0 */
            rsp_PStloc = PStloc;
            rsp_PSrloc = PSrloc;
            rsp_PSphasoff = PSphasoff;

            slice_freq = (int)cfh_rf1freq;
            slice2_freq = (int)cfh_rf2freq;
            if( PSD_ON == PSir )
            {
                ir_slice_freq = (int)(GAM * a_gzrf0cfh * PStloc/(10 * TARDIS_FREQ_RES));
                setfrequency(ir_slice_freq, &rf0cfh,0);
            }
        }  /* end of psc_vol_index */

        setfrequency(slice_freq, &rf1cfh,0);
        setfrequency(slice2_freq, &rf2cfh,0);
        if( presscfh_ctrl != PRESSCFH_NONE )
        {
            setfrequency(slice3_freq, &rf3cfh,0); /* for presscfh_ctrl */
            if( presscfh_ctrl == PRESSCFH_SHIMVOL_SLICE )
            {
                setfrequency(slice4_freq, &rf4cfh,0); /* for presscfh_ctrl */
            }
        }

        setfrequency((int)(PSfreq_offset[rspent]/TARDIS_FREQ_RES), &cfh_fid, 0);

        if(PSdebugstate)
        {
            INT pscrot_idx;

            pscrot_idx = psc_vol_index;
            if (psc_vol_index > 0)
            {
                pscrot_idx = psc_vol_index-1;
            }
            printf("\n %d rsp_PStloc (tx, rec, phase) -> %0f %0f %0f\n",
                   psc_vol_index, rsp_PStloc, rsp_PSrloc, rsp_PSphasoff);
            printf ("CFH : Rotation Matrix for Prescan Volume Index %d\n", psc_vol_index);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][0], rsp_PSrot[pscrot_idx][1], rsp_PSrot[pscrot_idx][2]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][3], rsp_PSrot[pscrot_idx][4], rsp_PSrot[pscrot_idx][5]);
            printf("\t %6ld %6ld %6ld \n", rsp_PSrot[pscrot_idx][6], rsp_PSrot[pscrot_idx][7], rsp_PSrot[pscrot_idx][8]);

            fflush(stdout);
        }


        /* INVERSION RECOVERY CODE */
        if (PSD_ON == PSir)
        {
            /* Check for IR pulse being turned off */
            if (noir==1)
            {
                setiamp(0,&rf0cfh,0);
            }
            else
            {
                setiamp(ia_rf0cfh,&rf0cfh,0);
            }
            /* End check for IR pulse being on/off */

            if (tislice != (PSslice_num+1))
            {
                /* user has changed slice, so change frequencies */
                /* Check for proper range */
                if ((tislice < 1) || (tislice > opslquant)) 
                {
                    tislice=tislice_start;
                    PSslice_num=tislice-1;
                } 
                else
                {
                    PSslice_num=tislice-1;
                    /* changing the slice */

                    /* Calculation of new slice loc */
                    new_slice_loc = PStloc - ((opslspace + opslthick) *
                                              (tislice_start - tislice));
                    /* Inversion */
                    /* factor 10 is because rsptloc is in mm */
                    ir_slice_freq = (int)(GAM * a_gzrf0cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(ir_slice_freq, &rf0cfh,0);

                    /* Spin Echo */
                    /* factor 10 is because rsptloc is in mm */
                    slice_freq = (int)(GAM * a_gzrf1cfh * new_slice_loc/(10 * TARDIS_FREQ_RES));

                    setfrequency(slice_freq, &rf1cfh,0);
                    /* end of changing the slice */
                }
            }

            /* Changing the inversion time realtime */
            if (psctitime<50)
            {
                psctitime=50;
            }

            /* Need this check to reset psctitime to opti. Download error were
               happening because of invalid titimes */
            if(psctitime > 300)
            {
                psctitime = cfh_ti/1000;
            }

            titime_us = (psctitime*1000);
            new_dur=dur_invse + (titime_us - cfh_ti);
            new_dur = RUP_GRD(new_dur);
            setperiod(new_dur,&zticfh,0);
            setperiod(new_dur,&xticfh,0);
            setperiod(new_dur,&yticfh,0);
            setperiod(new_dur,&rticfh,0);
            setperiod(new_dur,&sticfh,0);

            /* Change the deadtime of seqcfh to preserve the cfh_tr value */
            /* If the seqcfh deadtime < 5 then set to the minimum of 4us */
            new_cfh_deadtime = init_cfh_deadtime + (cfh_ti - titime_us);
            if (new_cfh_deadtime < 5)
            {
                new_cfh_deadtime = 4;
            }

            setperiod( new_cfh_deadtime, &seqcfh, 0 );
            /* End deadtime change */

            /* End inversion time change */

            /* END INVERSION CORE CODE */
        } 
#ifdef PSD_CFH_CHEMSAT
        if( (cs_sat == PSD_ON) && PScs_sat )
        {
            CsSatMod((int)(cscfh_satindex+1));
        }
#endif
        /* Check should play cs/mt or stir for manual cfh */
        if( PSir )
        {
            StIRMod();
        }

        for( excitation = 1; excitation <= cfh_nex; excitation ++ )
        {
            if( view > 0 ) 
            {
                acq_type = (int)DABON;

                if( excitation == cfh_nex )
                {
                    attenlockoff(&cfh_attenkey);
                }
                else
                {
                    attenlockon(&cfh_attenkey);
                }
            } 
            else
            {
                acq_type = (int)DABOFF;
            }

            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&cfh_fid, (int)1,(int)1,(int)1,(int)1,
                    (TYPDAB_PACKETS)acq_type, PSD_LOAD_DAB_ALL);

            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            /*printdbg("S", PSdebugstate);*/
            syncoff(&seqcfh); 

            getiamp(&temp_short, &rf1cfh, 0);
            setiamp(-temp_short, &rf1cfh, 0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
        }  /* end excitation */
    }  /* end view */

    return SUCCESS;
}   /* end PScfh() */


/* disable STIR cfh if cs/mttun is on */
void
StIRMod(void)
{
    int do_mttun = 0;
    int do_cstun = 0;


#ifdef PSD_CFH_CHEMSAT
    if(PSD_ON == PScs_sat)
    {
        do_cstun = cstun;
    }
    else
    {
        do_cstun = PSD_OFF;
    }
#endif /* PSD_CFH_CHEMSAT */

    if( do_cstun || do_mttun || showfp ) 
    {
        /* disable stir cfh pulse */
        rfoff(&rf0cfh, 0);
        setiampt(0, &gyrf0kcfh, 0);
    }
    else {
        rfon(&rf0cfh, 0);
        setiampt(amp_gyrf0kcfh, &gyrf0kcfh, 0);
    }
    return;
}


/*  begin aps1_mod changes (GE) */
/*
 *  PSinit
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSinit( long (*PSrotmat)[9] )
{   
    INT i;

    /* Range check for psc_vol_index */
    if ( psc_vol_index < 0 )
    {
        if(PSdebugstate)
            printf("WRONG psc_vol_index =%d\n",psc_vol_index);
        psc_vol_index = 0;
    }

    setrfconfig((short) 5);	/* only activate rho1 */
    setssitime(100);	/* set ssi counter to 400 us. */
    rspqueueinit(200);	/* initialize to 200 entries */

    if( presscfh_cgate && rspent == L_CFH ){
        PSrsptrigger[0] = TRIG_ECG;
    } else{
        PSrsptrigger[0] = PStrigger;
    }
    setrotatearray((short)1, *PSrotmat);
    settriggerarray((short)1, PSrsptrigger);
    
    /* Always use scan rot matrix for SWIFT*/
    if(opswift == PSD_ON)
    {
        setrotatearray((short)opvquant,rsprot[0]);
        for(i=0;i<opvquant;i++)
            PSrsptrigger[i] = PStrigger;

        settriggerarray((short)opvquant,PSrsptrigger);
    }


    return SUCCESS;
}   /* end PSinit() */

/* end aps1_mod changes (GE) */

/*
 *  PSfasttg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSfasttg( INT preslice,
          INT debugstate)
{
    printdbg("Greetings from FastTG", PSdebugstate);
    rspent = L_FTG;
    rspdda = ftg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "FastTG");
    
    FastTGCore( PStloc_mod,
                (int)rspdda,
                (int)rspvus,
                (int)rspnex,
                (int)PSdebugstate);
 
    printdbg("Normal End of FastTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSfasttg() */


/*
 *  PSexpresstg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSexpresstg( INT preslice,
             INT debugstate)
{
    printdbg("Greetings from eXpress TG", PSdebugstate);
    rspdda = xtg_dda;
    rspbas = 0;
    rspvus = 30000;
    rspgy1 = 0;
    rspnex = 1;
    rspesl = preslice;
    rspasl = 0;
    rspslq = 1;
    rspsct = -1;

    strcpy(psdexitarg.text_arg, "eXpressTG");
    
    eXpressTGCore( PStloc_mod,
                   (int)rspdda,
                   (int)rspvus,
                   (int)rspnex,
                   (int)PSdebugstate);
 
    printdbg("Normal End of eXpressTG", debugstate);
    rspexit();

    return SUCCESS;
}   /* end PSexpresstg() */


/*
 *  FastTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    ftg_disdaqs: number of disdaq pairs
 *    ftg_views: # of max views to be executed in ftg
 *    ftg_nex: # of excitations in ftg
 *    ftg_chop: No chop if = 2
 *    ftg_debug: debug state
 */
STATUS
FastTGCore( DOUBLE slice_loc,
            INT ftg_disdaqs,
            INT ftg_views,
            INT ftg_nex,
            INT ftg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT slice_freq3;
    INT rcv_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */

    if (FTGacq1 == 1)
    {
        ftg_acq1 = (int)DABON;
    }
    else
    {
        ftg_acq1 = (int)DABOFF;
    }
      
    if (FTGacq2 == 1)
    {
        ftg_acq2 = (int)DABON;
    }
    else
    {
        ftg_acq2 = (int)DABOFF;
    }
      
    printdbg("Entering FastTGCORE", (SHORT)ftg_debug);
    boffset(off_seqftg);
    scopeon(&seqftg);
    syncon(&seqftg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;

    attenlockoff(&ftg_attenkey);
    slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

    setfrequency(slice_freq1, &rf1ftg,0);
    setfrequency(slice_freq2, &rf2ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1ftg, 0);
    setfrequency(slice_freq3, &rf3ftg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo2ftg, 0);
 
    if(PSdebugstate)
    {
        printf("\nFTG Slthick = %f FOV = %f Xmit location = %f, Rcv location  = %f\n", 
                FTGslthk,FTGfov, slice_loc, PSrloc_mod);
        printf("\nFTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","FTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
    }

    if( PSdebugstate )
    {
        printf("FTG: psc_vol_index = %d\n",psc_vol_index );
    }

    for (view = (-ftg_disdaqs + 1) ; view <= ftg_views; view ++)
    {
        for (excitation = 1; excitation <= ftg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&ftg_attenkey);
                if (excitation == ftg_nex)
                    attenlockoff(&ftg_attenkey);
                ftg_acq2 = (int)DABON;
            }
            else
            {
                ftg_acq2 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq1, PSD_LOAD_DAB_ALL);
            loaddab(&echo2ftg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)ftg_acq2, PSD_LOAD_DAB_ALL);

            /* For SWIFT(fasttg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                    }

                    {
                        char tempstr[200] = "";
                        sprintf(tempstr,"fasttgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            slice_freq1 = (int)(GAM * a_gzrf1ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq2 = (int)(GAM * a_gzrf2ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            slice_freq3 = (int)(GAM * a_gzrf3ftg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*FTGecho1bw*rsp_PSrloc/ FTGfov);

            setfrequency(slice_freq1, &rf1ftg,0);
            setfrequency(slice_freq2, &rf2ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo1ftg, 0);
            setfrequency(slice_freq3, &rf3ftg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                    &echo2ftg, 0);


            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)ftg_debug);
            syncoff(&seqftg);
 
 
            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end FastTGCore() */


/*
 *  eXpressTGCore
 *  
 *  Type: Public Function
 *  
 *  Description:
 *    slice_loc: location of prescan slice  in mm
 *    slice_num: slice number to be excited
 *    xtg_disdaqs: number of disdaq pairs
 *    xtg_views: # of max views to be executed in xtg
 *    xtg_nex: # of excitations in xtg
 *    xtg_chop: No chop if = 2
 *    xtg_debug: debug state
 */
STATUS
eXpressTGCore( DOUBLE slice_loc,
            INT xtg_disdaqs,
            INT xtg_views,
            INT xtg_nex,
            INT xtg_debug )
{
    INT slice_freq1;    /* transmit frequency for the prescan slices */
    INT slice_freq2;
    INT rcv_freq;
    SHORT temp_short;
    INT rf3xtg_freq, rf4xtg_freq;
    float rsp_PStloc=0.0;
    float rsp_PSrloc=0.0;
    float rsp_PSphasoff=0.0;
    int old_psc_vol_index = -1; /* Last prescan volume for SWIFT switching */
    long tmp_period;

    if (XTGacq1 == PSD_ON)
    {
        xtg_acq1 = (int)DABON;
    }
    else
    {
        xtg_acq1 = (int)DABOFF;
    }
            
    printdbg("Entering eXpressTGCORE", (SHORT)xtg_debug);

    tmp_period = (long)init_xtg_deadtime;
    tmp_period = RUP_GRD(tmp_period);
                                                  
    boffset(off_seqxtg);
    setperiod(tmp_period, &seqxtg, 0);

    scopeon(&seqxtg);
    syncon(&seqxtg);
 
    /* Initialize */
    rsp_PStloc = slice_loc;
    rsp_PSrloc = PSrloc_mod;
    rsp_PSphasoff = PSphasoff_mod;

    attenlockoff(&xtg_attenkey);
    if(PSD_ON == local_tg)
    {
        slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }
    else
    {
        slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                            (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    }

    slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                        (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
    rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);

    setfrequency(slice_freq1, &rf1xtg,0);
    setfrequency(slice_freq2, &rf2xtg,0);
    setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                 &echo1xtg, 0);
 
    if(PSdebugstate)
    {
        printf("\nXTG Slthick = %f xFOV = %f yFOV = %f Xmit location = %f, Rcv location  = %f, Phase off = %f\n", 
               TGopslthick, TGopslthickx, TGopslthicky, PStloc_mod, PSrloc_mod, PSphasoff_mod);

        printf("\nXTG Xmit Freq = %f, Rcv Freq  = %f\n", (float)slice_freq1, (float)rcv_freq);
        printf("%s\n","XTG Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][0], PSrot_mod[0][1], PSrot_mod[0][2]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][3], PSrot_mod[0][4], PSrot_mod[0][5]);
        printf("\t %6ld %6ld %6ld \n", PSrot_mod[0][6], PSrot_mod[0][7], PSrot_mod[0][8]);
        fflush(stdout);
        printf("XTG: psc_vol_index = %d\n",psc_vol_index );
    }

    rf4xtg_freq = (int)(xtg_offres_freq/TARDIS_FREQ_RES);
    rf3xtg_freq = rf4xtg_freq;

    if(L_MPS1 == rspent)  /* set it off for MPS1 */
    {
        setiamp(0, &rf3xtg, 0);
        setiamp(0, &rf4xtg, 0);
    }
    else
    {
        setiamp(-ia_rf4xtg, &rf3xtg, 0);
        setiamp(ia_rf4xtg, &rf4xtg, 0);
    }

    for (view = (-xtg_disdaqs + 1) ; view <= xtg_views; view ++)
    {
        if( PSdebugstate )
        {
            printf("XTG: view = %d\n",view);
        }

        if(view == (-xtg_disdaqs + 1))
        {
            getiamp(&temp_short, &rf4xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            getiamp(&temp_short, &rf1xtg, 0);
            if(temp_short < 0.0)
            {
                setiamp(-temp_short, &rf1xtg, 0);
            }
        }

        for (excitation = 1; excitation <= xtg_nex; excitation ++)
        {
            if (view > 0)
            {
                if (excitation == 1)
                    attenlockon(&xtg_attenkey);
                if (excitation == xtg_nex)
                    attenlockoff(&xtg_attenkey);
                if(XTGacq1 == PSD_ON)
                {
                    xtg_acq1 = (int)DABON;
                }
            }
            else
            {
                xtg_acq1 = (int)DABOFF;
            }
 
            /* DAB packet is not used in prescan.  loaddab
               is used just to turn on or off the receiver */
            loaddab(&echo1xtg, (INT)1,(INT)1,(INT)1,(INT)1,
                    (TYPDAB_PACKETS)xtg_acq1, PSD_LOAD_DAB_ALL);

            /* For SWIFT(expresstg): We are trying not to use the CV opswift.
               Instead use psc_vol_index.
               */
            if( (psc_vol_index > 0) && (opvquant > 1) )
            {
                if( old_psc_vol_index != psc_vol_index )
                {
                    /* No need to switch coil*/
                    if( noswitch_slab_psc == PSD_OFF )
                    {
                        rsp_PStloc = rsp_info[psc_vol_index-1].rsptloc;
                        rsp_PSrloc = rsp_info[psc_vol_index-1].rsprloc;
                        rsp_PSphasoff = rsp_info[psc_vol_index-1].rspphasoff;
                    }
                    else
                    {
                        rsp_PStloc = rsp_info[PStest_slab-1].rsptloc;
                        rsp_PSrloc = rsp_info[PStest_slab-1].rsprloc;
                        rsp_PSphasoff = rsp_info[PStest_slab-1].rspphasoff;
                    }

                    {
                        char tempstr[200]={0};
                        sprintf(tempstr,"eXpresstgcore: psc_vol_index=%d,rsp_PStloc=%f\n",psc_vol_index,rsp_PStloc);
                        printdbg(tempstr,PSdebugstate);
                    }
                    old_psc_vol_index = psc_vol_index;
                }
            }

            if(PSD_ON == local_tg)
            {
                slice_freq1 = (int)(GAM * a_gyrf1xtg * rsp_PSphasoff/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }
            else
            {
                slice_freq1 = (int)(GAM * a_gzrf1xtg * rsp_PStloc/
                                    (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            }

            slice_freq2 = (int)(GAM * a_gzrf2xtg * rsp_PStloc/
                                (10* TARDIS_FREQ_RES)); /* factor 10 is because rsptloc is in mm */
            rcv_freq = (int)(2*1000*XTGecho1bw*rsp_PSrloc/ XTGfov);
            
            setfrequency(slice_freq1, &rf1xtg,0);
            setfrequency(slice_freq2, &rf2xtg,0);
            setfrequency((INT)((rcv_freq + PSfreq_offset[rspent])/TARDIS_FREQ_RES),
                         &echo1xtg, 0);

            /* phase and freq cycling  */
            if(view%2 == 1) /* freq and phase cycling */
            {
                setfrequency(rf4xtg_freq, &rf4xtg, 0);
                setfrequency((-rf3xtg_freq), &rf3xtg, 0);

                /* phase cycling */
                getiamp(&temp_short, &rf4xtg, 0);
                setiamp(-temp_short, &rf4xtg, 0);
                getiamp(&temp_short, &rf3xtg, 0);
                setiamp(-temp_short, &rf3xtg, 0);
            }
            else
            {
                setfrequency((-rf4xtg_freq), &rf4xtg, 0);
                setfrequency(rf3xtg_freq, &rf3xtg, 0);
            }
            
            /* Makesure psc_vol_index is in range */
            if( (psc_vol_index > 0 && psc_vol_index <= opvquant) && (opvquant > 1)) 
            {
                if(noswitch_slab_psc == PSD_OFF)
                    startseq((short)(psc_vol_index-1), (SHORT)MAY_PAUSE);
                else
                    startseq((short)(PStest_slab-1),(SHORT)MAY_PAUSE);
            }
            else
                startseq((short)0, (SHORT)MAY_PAUSE);

            printdbg("S", (SHORT)xtg_debug);
            syncoff(&seqxtg);
 
            /* Chopper logic */
            getiamp(&temp_short, &rf1xtg,0);
            setiamp((-temp_short),&rf1xtg,0);

            if (view < 1)
            {
                break; /* Skip excitation loop for disdaqs */
            }
 
        }  /* end excitation */
 
    }  /* end view */

    return SUCCESS;
}   /* end eXpressTGCore() */


/*
 *  ASautoshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
ASautoshim( INT rspsct_ )
{
    SHORT temp_short;
    INT dix_shift;

    INT phase_step[3];
    INT phase_sign[3];
    INT yres_phase;

    long asrottemp[3][9]; /* vmx 3/6/95 YI */
    INT *rf1_freq;
    INT *receive_freq1;
    SHORT viewtable[513];
    long trigger_temp[3]; /* vmx 10/13/94 YI */
    INT acquire_echo1;
    INT dab_view,dab_op;
    SHORT disdaqs;
    FLOAT tempGAM;

    printdbg("Greetings from autoshim", PSdebugstate);
    boffset(off_seqaushim);

    disdaqs = as_dda;
    tempGAM = GAM;
    GAM = GAMMA_PROTON; /*only shim on proton*/

    /**************************************************************
      so here's how we loop through this entry point:

        pass = rspslq;               each slice is a pass
        for all slices
           for all views              
             (first echo)           note: these aren't really 2echos,
             reset dixon shift to 0       we just pretend they are.
             do the disdaqs               there's really a separate
             do the baselines             excitation for each 'echo'.
             collect the data 'echo'
             (second echo)
             do dixon shift
             do the disdaqs
             do the baselines
             collect the data 'echo'
           next view
           decrement pass
           send pass packet
        next slice
        send end of scan packet
     ******************************************************************/

    setrfconfig((short) 5);

    /* Allocate memory for various arrays.
     * An extra 2 locations are saved in case the user wants to do
     * some tricks. */
    rf1_freq = (int *)AllocNode((as_slquant + 2)*sizeof(int));
    receive_freq1 = (int *)AllocNode((as_slquant + 2)*sizeof(int));

    rf1_freq[0] = (int)(astloc1*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[1] = (int)(astloc2*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));
    rf1_freq[2] = (int)(astloc3*GAM * a_gzrf1as/(10 * TARDIS_FREQ_RES));

    asrottemp[0][0] = hostToRspRotMat( asrot0 );  asrottemp[0][1] = hostToRspRotMat( asrot1 ); asrottemp[0][2] = hostToRspRotMat( asrot2 );  
    asrottemp[0][3] = hostToRspRotMat( asrot3 );  asrottemp[0][4] = hostToRspRotMat( asrot4 ); asrottemp[0][5] = hostToRspRotMat( asrot5 );
    asrottemp[0][6] = hostToRspRotMat( asrot6 );  asrottemp[0][7] = hostToRspRotMat( asrot7 ); asrottemp[0][8] = hostToRspRotMat( asrot8 );

    asrottemp[1][0] = hostToRspRotMat( asrot9 );  asrottemp[1][1] = hostToRspRotMat( asrot10 ); asrottemp[1][2] = hostToRspRotMat( asrot11 ); 
    asrottemp[1][3] = hostToRspRotMat( asrot12 ); asrottemp[1][4] = hostToRspRotMat( asrot13 ); asrottemp[1][5] = hostToRspRotMat( asrot14 );
    asrottemp[1][6] = hostToRspRotMat( asrot15 ); asrottemp[1][7] = hostToRspRotMat( asrot16 ); asrottemp[1][8] = hostToRspRotMat( asrot17 );

    asrottemp[2][0] = hostToRspRotMat( asrot18 ); asrottemp[2][1] = hostToRspRotMat( asrot19 ); asrottemp[2][2] = hostToRspRotMat( asrot20 ); 
    asrottemp[2][3] = hostToRspRotMat( asrot21 ); asrottemp[2][4] = hostToRspRotMat( asrot22 ); asrottemp[2][5] = hostToRspRotMat( asrot23 );
    asrottemp[2][6] = hostToRspRotMat( asrot24 ); asrottemp[2][7] = hostToRspRotMat( asrot25 ); asrottemp[2][8] = hostToRspRotMat( asrot26 );

    scalerotmats(asrottemp, &asloggrd, &phygrd, 3, asobl_debug);

    if(PSdebugstate)
    {
        printf("\n%d astlocs (1,2,3) -> %0f %0f %0f\n",
               as_slquant, astloc1, astloc2, astloc3);
        printf("\nrf1_freq (1,2,3) -> %d %d %d\n",
               rf1_freq[0], rf1_freq[1], rf1_freq[2]);
    }

    /* AutoShim Changes to Center Image always - HH- Sept 21, 2004 */
    /* Use asrot0 , asrot11 and asrot20 to decide on read and phase directions on the 3 planes */
    /* Slice 1 = Axial    - Z slice (astloc1) - X/Y read (astloc2/astloc3) - Y/X Phase (astloc3/astloc2) */
    /* Slice 2 = Sagittal - X slice (astloc2) - Z/Y read (astloc1/astloc3) - Y/Z Phase (astloc3/astloc1) */
    /* Slice 3 = Coronal  - Y slice (astloc3) - Z/X read (astloc1/astloc2) - X/Z Phase (astloc2/astloc1) */

/* Old Code */
    receive_freq1[0] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc1))/ TARDIS_FREQ_RES);
    receive_freq1[1] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc2))/ TARDIS_FREQ_RES);
    receive_freq1[2] = (int)((PSfreq_offset[rspent] +
                              ((2 * echo1bwas*1000/ (asfov))
                               * asrloc3))/ TARDIS_FREQ_RES);

    phase_sign[0] = (asploc1 >= 0) ? 1 : -1;
    phase_step[0] = (int)(.5 + fabs(FS_2PI*asploc1/asfov));
    phase_step[0] = (phase_step[0] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[1] = (asploc2 >= 0) ? 1 : -1;
    phase_step[1] = (int)(.5 + fabs(FS_2PI*asploc2/asfov));
    phase_step[1] = (phase_step[1] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    phase_sign[2] = (asploc3 >= 0) ? 1 : -1;
    phase_step[2] = (int)(.5 + fabs(FS_2PI*asploc3/asfov));
    phase_step[2] = (phase_step[2] + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    trigger_temp[0] = TRIG_INTERN;
    trigger_temp[1] = TRIG_INTERN;
    trigger_temp[2] = TRIG_INTERN;

    setupphasetable(viewtable, TYPNORM,(int)asyres);


    /* Set ssi time.  This is time from eos to start of sequence   */
    /* interrupt in internal triggering.  The minimum time is 50us */
    /* plus 2us*(number of waveform and instruction words modified */
    /* in the update queue).                                       */
    setssitime((LONG)time_ssias/HW_GRAD_UPDATE_TIME);

    settriggerarray(as_slquant, trigger_temp);

    if(PSdebugstate)
    {
        printf("\n AUTOSHIM VOLUME INDEX:  %d\n", as_index); 
        printf("\n AUTOSHIM:  FOV = %f astloc1 = %f, astloc2 = %f  astloc3  = %f\n", asfov, astloc1,astloc2,astloc3); 
        printf("\n AUTOSHIM:  asrloc1 = %f, asrloc2 = %f  asrloc3  = %f\n", asrloc1,asrloc2,asrloc3); 
        printf("\n AUTOSHIM:  asploc1 = %f, asploc2 = %f  asploc3  = %f\n", asploc1,asploc2,asploc3); 
        printf("\n AUTOSHIM:  asdim1 = %f, asdim2 = %f  asdim3  = %f\n", asdim1,asdim2,asdim3); 
        printf("%s\n", "AUTOSHIM:  Slice 1 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][0],asrottemp[0][1],asrottemp[0][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][3],asrottemp[0][4],asrottemp[0][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[0][6],asrottemp[0][7],asrottemp[0][8]);
        printf("%s\n", "AUTOSHIM:  Slice 2 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][0],asrottemp[1][1],asrottemp[1][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][3],asrottemp[1][4],asrottemp[1][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[1][6],asrottemp[1][7],asrottemp[1][8]);
        printf("%s\n", "AUTOSHIM:  Slice 3 Rotation Matrix");
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][0],asrottemp[2][1],asrottemp[2][2]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][3],asrottemp[2][4],asrottemp[2][5]);
        printf("\t %6ld  %6ld  %6ld\n", asrottemp[2][6],asrottemp[2][7],asrottemp[2][8]);

        printf("\n AUTOSHIM SLICE1:   slice loc= %f read loc= %f phase loc= %f \n", astloc1, asrloc1, asploc1); 
        printf("\n AUTOSHIM SLICE2:   slice loc= %f read loc= %f phase loc= %f \n", astloc2, asrloc2, asploc2); 
        printf("\n AUTOSHIM SLICE3:   slice loc= %f read loc= %f phase loc= %f \n", astloc3, asrloc3, asploc3); 

        fflush(stdout);
    }

    setrotatearray(as_slquant,asrottemp[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyas);
    scopeon(&seqaushim);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqaushim);
    syncoff(&seqpassas);


    for (as_slice = 0; as_slice < as_slquant; as_slice++)
    {
        dab_op = DABSTORE;

        setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);

        for (as_view=(-(disdaqs+asbaseline)+1); as_view<= asyres; as_view++)
        {
            /* Collect baseline first and set RF to 0 for baseline collection */
            if (as_view <= -disdaqs)
            {
                setiamp((short)0, &rf1as, 0);
            }
            else if (as_view == -disdaqs+1) /* Disdaq collection after baseline and set RF amp for disdaqs/data acq */
            {
                setiamp((short)(ia_rf1as*flip_pctas), &rf1as, 0);
            }

            if (as_view<=0)
            {
                /* for the baselines in each slice, set the phase encode
                   amplitude to the first view */
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[1], &gy1as, 0);
                setiampt(viewtable[1], &gy1ras, 0);

                setiphase(0,&echo1as,0);
            }
            else
            {
                /* HSI change to setiampt from setiamp */
                setiampt(-viewtable[as_view], &gy1as, 0);
                setiampt(viewtable[as_view], &gy1ras, 0);

                setiphase(0,&echo1as,0);
                yres_phase = -phase_sign[as_slice]*(((as_view-1)* phase_step[as_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                setiphase(yres_phase, &echo1as, 0);
            }
            for (as_excitation=1; as_excitation <= 1; as_excitation++)
            {
                /* Scope Trigger */
                if ((rspsct_ == as_slice) || (rspsct_ == -1))
                {
                    scopeon(&seqaushim);
                }
                else
                {
                    scopeoff(&seqaushim);
                }
                /*MRIge33520 - VB*/
                acquire_echo1 = DABON; /* ON for baseline */
                if ((as_view > -disdaqs) && (as_view <= 0))  /* DABOFF for disdaq */
                {
                    acquire_echo1 = (int)DABOFF;
                }

                /* Load Transmit and Receive frequencies */
                setfrequency(rf1_freq[as_slice], &rf1as, 0);
                setfrequency(receive_freq1[as_slice], &echo1as, 0);

                if (as_view > 0)
                {
                    dab_view = as_view;
                    if (as_excitation == 1)
                    {
                        dab_op = 0;
                    }
                    else
                    {
                        dab_op = 3 - 2*(as_excitation % 2);
                    }
                }
                else
                {
                    dab_op = 0;
                    dab_view = 0;
                }

                /* set up the dixon shift for every other seq */
                for(dixon=0;dixon<=1;++dixon)
                {
                    dix_shift = (dixon % 2)*RUP_GRD((dix_timeas))+GRAD_UPDATE_TIME;
                    setperiod(dix_shift,&xdixon,0);
                    setperiod(dix_shift,&ydixon,0);
                    setperiod(dix_shift,&zdixon,0);
                    setperiod(dix_shift,&sdixon,0);
                    setperiod((int)(dix_shift - dixon*dix_timeas),&sdixon2,0);
                    /* All DAB Info is Set. Pretend even views are 2nd echo. */
                    /* Load up dab packet!                                   */
                    loaddab(&echo1as,(short)0,dixon,dab_op,dab_view,(TYPDAB_PACKETS)acquire_echo1, PSD_LOAD_DAB_ALL);

                    startseq((short)as_slice, (short)MAY_PAUSE);

                    syncoff(&seqaushim);
                }

                getiamp(&temp_short, &rf1as, 0);
                setiamp(-temp_short, &rf1as, 0);

            } /* as_excitation */

        }  /* as_view */


        boffset(off_seqpassas);
        if (as_slice == (as_slquant-1)  ) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_aushim, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_aushim, 2);
            printdbg("End of Pass", PSdebugstate);
        }


        startseq((short)0, (short)MAY_PAUSE);
        boffset(off_seqaushim);

    }

    /* Reset the rotation matrix */
    setrotatearray((short)opslquant,rsprot[0]);

    GAM = tempGAM;

    printdbg("Normal End of autoshim", PSdebugstate);

    return SUCCESS;
} /* End of ASautoshim */

/*
 *  PSrfshim
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSrfshim( void )
{
    INT *rf1rs_freq;
    INT *rec_freq1rs;
    INT rs_slice, rs_view, DD_loop, tmp_DD_nCh;
    long rs_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT rs_yres_phase, rs_trains; 
    INT rs_yres_phase2toN[16];
    INT dab_view,dab_op, dabechors;
    INT acq_echors;
    INT i, tempi, rs_seq_count, rs_exphase, rs_rcphase;
    INT train_idx, bls_idx, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from RFShim B1 Map", PSdebugstate);
    rspdda = rs_dda;
    rspsct = 0;

    rs_trains = rfshim_yres/rfshim_etl;

    boffset(off_seqrs);

    dabechors = 0;
    rs_seq_count = 1;
    rs_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < rfshim_slquant; i++)
    {
        if (rsrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*rsrsp_info[i].rspphasoff/rfshim_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1rs_freq = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));
    rec_freq1rs = (int *)AllocNode((rfshim_slquant + 2)*sizeof(int));

    setupslices(rf1rs_freq, rsrsp_info, rfshim_slquant, a_gzrf1rs,
                               (float)1, rfshim_fov, TYPTRANSMIT);

    setupslices(rec_freq1rs, rsrsp_info, rfshim_slquant, (float)0,
                echo1bwrs, rfshim_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)rfshim_yres);
    phase_ordering(viewtab, rsphorder, rfshim_yres, rfshim_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1rs, 0);
    setiampt(0, &gy1rrs, 0);
    if(rfshim_etl >=2)
    {
        for(i=0;i<rfshim_etl-1;i++)
        {
            setiampt(0, &gy2rs, i);
        }
    }

    setiamp((short)ia_rf1rs, &rf1rs, 0);
    setiphase(0, &rf1rs, 0);

    setssitime((LONG)time_ssirs/HW_GRAD_UPDATE_TIME);

    for ( rs_slice = 0 ; rs_slice < rfshim_slquant; rs_slice++ )
    {
        rs_trigger[rs_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)rfshim_slquant, rs_trigger);

    setrotatearray((short)rfshim_slquant,rsrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keyrs);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqrs);
    syncoff(&seqpassrs);

    for (rs_slice = 0; rs_slice < rfshim_slquant; rs_slice++)
    {
        tmp_DD_nCh = DD_nCh;

        if(PSdebugstate && (rs_slice >= 0))
        {
            printf("\n RFShim Sls = %i FOV = %f  slthick = %f\n", rfshim_slquant, rfshim_fov, rfshim_slthick);
            printf("\n RFShim Offsets: Tx = %f Rx = %f Phase = %f\n", rsrsp_info[rs_slice].rsptloc, 
                   rsrsp_info[rs_slice].rsprloc, rsrsp_info[rs_slice].rspphasoff);
            printf("%s\n"," RFShim Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][0], rsrsprot[0][1], rsrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][3], rsrsprot[0][4], rsrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", rsrsprot[0][6], rsrsprot[0][7], rsrsprot[0][8]);
            fflush(stdout);
        }

        dab_op = DABSTORE;

        setiamp((short)ia_rf1rs, &rf1rs, 0);

        for (DD_loop=0;DD_loop<tmp_DD_nCh;DD_loop++)
        {
            if ((B1Cal_mode) || (0!=DD_debug))
            {
                boffset(off_seqIQControl);

                if(B1Cal_mode)
                {
                    if (0==(DD_loop%2))
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }
                else
                {
                    if (1==DD_debug)
                    {   /* Turn off Q channel */
                        setwamp(SSPD|DDQOFF, &dDDIQ, 2);
                    }
                    else
                    {   /* Turn off I channel */
                        setwamp(SSPD|DDIOFF, &dDDIQ, 2);
                    }
                }

                settrigger((short)TRIG_INTERN, (short)0);

                startseq((SHORT)0,(SHORT)MAY_PAUSE);
            }

            boffset(off_seqrs);

            for (train_idx=(-(rs_dda+rfshim_baseline)+1); train_idx<= rs_trains; train_idx++)
            {
                if (train_idx > 0)
                {
                    rs_view = (train_idx-1)*rfshim_etl;
                    dab_view = viewtab[rs_view];

                    setiampt(-viewtable[dab_view], &gy1rs, 0);

                    if(rfshim_etl>=2)
                    {
                        for(tempi=0;tempi<rfshim_etl-1;tempi++)
                        {
                            setiampt(viewtable[viewtab[rs_view+tempi]]-viewtable[viewtab[rs_view+1+tempi]], &gy2rs, tempi);
                        }
                        setiampt(viewtable[viewtab[rs_view+rfshim_etl-1]], &gy1rrs, 0);
                    }
                    else
                    {
                        setiampt(viewtable[dab_view], &gy1rrs, 0);
                    }
                }
                else
                {
                    rs_view = 0;
                    dab_view = 0;
                }

                for (bls_idx = 0; bls_idx < 2; bls_idx++)
                {
                    dabechors = bls_idx;

                    if (0==bls_idx)
                    {
                        setiamp(ia_thetarfbrs, &thetarfbrs, 0);
                    }
                    else
                    {
                        setiamp(-ia_thetarfbrs, &thetarfbrs, 0);
                    }

                    dab_op = DABSTORE;


                    for (excitation=1; excitation <= 1; excitation++)
                    {
                        /* Scope Trigger */
                        if ((rspsct == rs_slice) || (rspsct == -1))
                        {
                            scopeon(&seqrs);
                        }
                        else
                        {
                            scopeoff(&seqrs);
                        }

                        if (train_idx > 0)
                        {
                            acq_echors = (int)DABON;
                        }
                        else
                        {
                            acq_echors = (int)DABOFF;
                        }

                        /* Load Transmit and Receive frequencies */
                        setfrequency(rf1rs_freq[rs_slice], &rf1rs, 0);
                        setfrequency(rec_freq1rs[rs_slice], &echo1rs, 0);

                        if (rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<(rfshim_etl-1);tempi++)
                            {
                                setfrequency(rec_freq1rs[rs_slice], &(rs_echo2toN[tempi]), 0);
                            }
                        }

                        if (train_idx > 0)
                        {
                            if (excitation == 1)
                            {
                                dab_op = 0;
                            }
                            else
                            {
                                dab_op = 3 - 2*(excitation % 2);
                            }

                            rs_yres_phase = phase_sign[rs_slice]*(((dab_view-1)*
                                                                   phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                        }
                        else
                        {
                            rs_yres_phase = 0;
                        }

                        if(rsspgr_flag)
                        {
                            rs_exphase = ((int)((float)rs_exphase + (float)rs_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            rs_seq_count++;
                        }
                        else
                        {
                            rs_exphase = 0;
                        }
                        setiphase(rs_exphase, &rf1rs, 0);

                        rs_rcphase = (rs_exphase + rs_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                        setiphase(rs_rcphase, &echo1rs, 0);

                        if(rfshim_etl>=2)
                        {
                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                rs_yres_phase2toN[tempi] = phase_sign[rs_slice]*
                                    (((viewtab[rs_view+tempi+1]-1)*phase_off[rs_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                                rs_yres_phase2toN[tempi] = (rs_exphase + rs_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                                if (PSdebugstate)
                                {
                                    sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,rs_yres_phase2toN[tempi]);
                                    printdbg(psddbgstr, PSdebugstate);
                                    sprintf(psddbgstr,"view=%d;  slice=%d\n",rs_view, rs_slice);
                                    printdbg(psddbgstr, PSdebugstate);
                                }

                                setiphase(rs_yres_phase2toN[tempi], &(rs_echo2toN[tempi]), 0);  /* yres phase */
                            }
                        }

                        /* Load up dab packet */
                        loaddab(&echo1rs,(short)0,dabechors+DD_loop*2,dab_op,dab_view,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                        if(rfshim_etl>=2)
                        {
                            INT temp_dabview;

                            for(tempi=0;tempi<rfshim_etl-1; tempi++)
                            {
                                temp_dabview = viewtab[rs_view+tempi+1];
                                loaddab(&rs_echo2toN[tempi],(short)0,dabechors+DD_loop*2,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echors, PSD_LOAD_DAB_ALL);
                            }
                        }

                        startseq((short)rs_slice, (short)MAY_PAUSE);

                        syncoff(&seqrs);

                    } /* excitation */
                } /* End of BLS cycling loop */

            }  /* End of Echo Train train_idx loop */

        }/* DD loop */

        boffset(off_seqpassrs);
        if (rs_slice == (rfshim_slquant-1)) /* Last pass */
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_rs, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (rs_slice >=0)
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD + DABPASS, &pass_rs, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            /* Set DAB pass packet to end of pass */
            setwamp(SSPD, &pass_rs, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqrs);

        if (B1Cal_mode && (rs_slice == (rfshim_slquant-1)))
        {
            boffset(off_seqIQControl);

            /* Enable I & Q channels again */
            setwamp(SSPD, &dDDIQ, 2);

            settrigger((short)TRIG_INTERN, (short)0);

            startseq((SHORT)0,(SHORT)MAY_PAUSE);
        }

    } /* End of slice loop */

    printdbg("Normal End of RFShim Map", PSdebugstate);

    return SUCCESS;
}   /* end PSrfshim() */


/*
 *  PSdyntg
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSdyntg( void )
{
    INT *rf1dtg_freq;
    INT *rec_freq1dtg;
    INT dtg_slice, dtg_trains;
    INT train_idx, bls_idx;
    INT tempi;
    long dtg_trigger[128];
    SHORT viewtable[128];
    SHORT viewtab[128];
    INT phase_off[128]; 
    INT phase_sign[128]; 
    INT dtg_yres_phase; 
    INT dtg_yres_phase2toN[16];
    INT dtg_view, dab_view, dab_op, dabechodtg;
    INT acq_echodtg;
    INT i, dtg_seq_count, dtg_exphase, dtg_rcphase, yoffs1;
    char psddbgstr[256] = "";

    printdbg("Greetings from dynTG B1Map", PSdebugstate);
    rspdda = dtg_dda;
    rspsct = 0;

    dtg_trains = dynTG_yres/dynTG_etl;

    boffset(off_seqdtg);

    dabechodtg = 0;
    dtg_seq_count = 1;
    dtg_exphase = 0;

    /* set up phase offset arrays */
    for (i = 0; i < dynTG_slquant; i++)
    {
        if (dtgrsp_info[i].rspphasoff >= 0.0)
            phase_sign[i] = -1;
        else
            phase_sign[i] = 1;
        /* phase offset increment */
        yoffs1 = (int)(.5 + fabs(FS_2PI*dtgrsp_info[i].rspphasoff/dynTG_fov));
        /* offset in range */
        phase_off[i] = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;
    }

    rf1dtg_freq = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));
    rec_freq1dtg = (int *)AllocNode((dynTG_slquant + 2)*sizeof(int));

    setupslices(rf1dtg_freq, dtgrsp_info, dynTG_slquant, a_gzrf1dtg,
                               (float)1, dynTG_fov, TYPTRANSMIT);

    setupslices(rec_freq1dtg, dtgrsp_info, dynTG_slquant, (float)0,
                echo1bwdtg, dynTG_fov, TYPREC);

    setupphasetable(viewtable, TYPNORM,(int)dynTG_yres);
    phase_ordering(viewtab, dtgphorder, dynTG_yres, dynTG_etl);  /* CENTRIC view ordering */

    setiampt(0, &gy1dtg, 0);
    setiampt(0, &gy1rdtg, 0);
    if(dynTG_etl>=2)
    {
        for(tempi=0;tempi<dynTG_etl-1;tempi++)
        {
            setiampt(0, &gy2dtg, tempi);
        }
    }

    setiamp((short)ia_rf1dtg, &rf1dtg, 0);
    setiphase(0, &rf1dtg, 0);

    setssitime((LONG)time_ssidtg/HW_GRAD_UPDATE_TIME);

    for ( dtg_slice = 0 ; dtg_slice < dynTG_slquant; dtg_slice++ )
    {
        dtg_trigger[dtg_slice] = (long)TRIG_INTERN;
    }
    settriggerarray((SHORT)dynTG_slquant, dtg_trigger);

    setrotatearray((short)dynTG_slquant,dtgrsprot[0]);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keydtg);
    scopeon(&seqdtg);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqdtg);
    syncoff(&seqpassdtg);

    boffset(off_seqdtg);

    for (dtg_slice = 0; dtg_slice < dynTG_slquant; dtg_slice++)
    {
        if(PSdebugstate && (dtg_slice >= 0))
        {
            printf("\n DynTG Sls = %i FOV = %f  slthick = %f\n", dynTG_slquant, dynTG_fov, dynTG_slthick);
            printf("\n DynTG Offsets: Tx = %f Rx = %f Phase = %f\n", dtgrsp_info[dtg_slice].rsptloc, 
                   dtgrsp_info[dtg_slice].rsprloc, dtgrsp_info[dtg_slice].rspphasoff);
            printf("%s\n"," DynTG Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][0], dtgrsprot[0][1], dtgrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][3], dtgrsprot[0][4], dtgrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", dtgrsprot[0][6], dtgrsprot[0][7], dtgrsprot[0][8]);
            fflush(stdout);
        }
        for (train_idx=-rspdda-dynTG_baseline; train_idx<= dtg_trains; train_idx++)
        {

            if (train_idx > 0)
            {
                dtg_view = (train_idx-1)*dynTG_etl;
                dab_view = viewtab[dtg_view];

                /* If after disdaqs, set phase encoding gradients. */
                setiampt(-viewtable[dab_view], &gy1dtg, 0);

                if(dynTG_etl>=2)
                {
                    for(tempi=0;tempi<dynTG_etl-1;tempi++)
                    {
                        setiampt(viewtable[viewtab[dtg_view+tempi]]-viewtable[viewtab[dtg_view+1+tempi]], &gy2dtg, tempi);
                    }
                    setiampt(viewtable[viewtab[dtg_view+dynTG_etl-1]], &gy1rdtg, 0);
                }
                else
                {
                    setiampt(viewtable[dab_view], &gy1rdtg, 0);
                }
            }
            else
            {
                dtg_view = 0;
                dab_view = 0;
            }

            /* BLS cycling loop */
            for (bls_idx = 0; bls_idx < 2; bls_idx++)
            {
                dabechodtg = bls_idx;

                if (0==bls_idx)
                {
                    setiamp(ia_thetarfbdtg, &thetarfbdtg, 0);
                }
                else
                {
                    setiamp(-ia_thetarfbdtg, &thetarfbdtg, 0);
                }

                dab_op = DABSTORE;


                for (excitation=1; excitation <= 1; excitation++)
                {
                    /* Scope Trigger */
                    if ((rspsct == dtg_slice) || (rspsct == -1))
                    {
                        scopeon(&seqdtg);
                    }
                    else
                    {
                        scopeoff(&seqdtg);
                    }

                    if (train_idx > 0)
                    {
                        acq_echodtg = (int)DABON;
                    }
                    else
                    {
                        acq_echodtg = (int)DABOFF;
                    }

                    /* Load Transmit and Receive frequencies */
                    setfrequency(rf1dtg_freq[dtg_slice], &rf1dtg, 0);
                    setfrequency(rec_freq1dtg[dtg_slice], &echo1dtg, 0);
                    if (dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<(dynTG_etl-1);tempi++)
                        {
                            setfrequency(rec_freq1dtg[dtg_slice], &(dtg_echo2toN[tempi]), 0);
                        } 
                    }

                    if (train_idx > 0)
                    {
                        if (excitation == 1)
                        {
                            dab_op = 0;
                        }
                        else
                        {
                            dab_op = 3 - 2*(excitation % 2);
                        }

                        dtg_yres_phase = phase_sign[dtg_slice]*(((dab_view-1)*
                                                                 phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);
                    }
                    else
                    {
                        dtg_yres_phase = 0;
                    }

                    if(dtgspgr_flag)
                    {
                        dtg_exphase = ((int)((float)dtg_exphase + (float)dtg_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                        dtg_seq_count++;
                    }
                    else
                    {
                        dtg_exphase = 0;
                    }
                    setiphase(dtg_exphase, &rf1dtg, 0);

                    dtg_rcphase = (dtg_exphase + dtg_yres_phase + 4L*FS_PI)%FS_2PI - FS_PI;
                    setiphase(dtg_rcphase, &echo1dtg, 0);
                    if(dynTG_etl>=2)
                    {
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            dtg_yres_phase2toN[tempi] = phase_sign[dtg_slice]*
                                (((viewtab[dtg_view+tempi+1]-1)*phase_off[dtg_slice] + 3L*FS_PI)%FS_2PI-FS_PI);

                            dtg_yres_phase2toN[tempi] = (dtg_exphase + dtg_yres_phase2toN[tempi]+ 4L*FS_PI)%FS_2PI - FS_PI;
                            setiphase(dtg_yres_phase2toN[tempi], &(dtg_echo2toN[tempi]), 0);  /* yres phase */
                            if (PSdebugstate)
                            {
                                sprintf(psddbgstr,"yres_phase2toN[%d]=%d\n",tempi,dtg_yres_phase2toN[tempi]);
                                printdbg(psddbgstr, PSdebugstate);
                            }

                        }
                    }

                    /* Load up dab packet */
                    loaddab(&echo1dtg,(short)0,dabechodtg,dab_op,dab_view,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);

                    if(dynTG_etl>=2)
                    {
                        INT temp_dabview;
                        for(tempi=0;tempi<dynTG_etl-1; tempi++)
                        {
                            temp_dabview = viewtab[dtg_view+tempi+1];
                            loaddab(&dtg_echo2toN[tempi],(short)0,dabechodtg,dab_op,temp_dabview,(TYPDAB_PACKETS)acq_echodtg, PSD_LOAD_DAB_ALL);
                        }
                    }

                    startseq((short)dtg_slice, (short)MAY_PAUSE);

                    syncoff(&seqdtg);

                } /* excitation */
            }  /* End of BLS cycling loop */
        } /* End of Echo Train train_idx loop */

        /* now it is one pass for all dtg slices */
        boffset(off_seqpassdtg);
        if (dtg_slice == (dynTG_slquant-1))
        {
            setwamp(SSPD + DABPASS + DABSCAN, &pass_dtg, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else if (dtg_slice >=0)
        {
            setwamp(SSPD + DABPASS, &pass_dtg, 2);
            printdbg("End of Pass", PSdebugstate);
        }
        else 
        {
            setwamp(SSPD, &pass_dtg, 2);
            printdbg("dummy slice", PSdebugstate);
        }

        startseq((short)0, (short)MAY_PAUSE);

        boffset(off_seqdtg);

    } /* End of Slice dtg_slice loop */

    printdbg("Normal End of dynTG B1Map", PSdebugstate);

    return SUCCESS;
}   /* end PSdyntg() */


/*
 *  PSextcal
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
STATUS
PSextcal( void )
{
    INT cal_sltab[CAL_SLTAB_MAX + 1];
    INT cal_slrtab[CAL_SLTAB_MAX + 1];
    SHORT cal_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long cal_trigger[CAL_SLTAB_MAX];
    INT caldabop;
    INT cal_acq;
    INT calsl_idx, calview_idx, calpass_idx, calcoil_idx, calnex_idx, longnex_idx;
    INT *calrf1_freq;
    INT *calrec_freq;
    INT cal_yphase;
    INT cal_zphase;
    INT cal_exphase;
    INT cal_rcphase;
    INT cal_seq_count;
    INT acq_passes;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT cal_superidx = 0;

    if(PSdebugstate)
    {

        {
            printf("\n AutoCal Sls = %i FOV = %f  slthick = %f\n", cal_slq, cal_fov, cal_slthick);
            printf("\n AutoCal: Tx = %f Rx = %f Phase = %f\n", calrsp_info[cal_slq/2].rsptloc,
                   calrsp_info[cal_slq/2].rsprloc, calrsp_info[cal_slq/2].rspphasoff);
            printf("%s\n"," AutoCal Rotation Matrix:");
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][0], calrsprot[0][1], calrsprot[0][2]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][3], calrsprot[0][4], calrsprot[0][5]);
            printf("\t %6ld %6ld %6ld \n", calrsprot[0][6], calrsprot[0][7], calrsprot[0][8]);
            fflush(stdout);
        }

    }

    cal_yphase = 0;
    cal_zphase = 0;
    cal_rcphase = 0;

    cal_exphase = 0;
    cal_seq_count = 1;

    acq_passes = cal_pass;
    acq_nexs = cal_nex;
    acq_longnexs = 1;
    
    /* Initialize cal_sltab  */
    memset(cal_sltab, 0, sizeof(cal_sltab));
    memset(cal_slrtab, 0, sizeof(cal_slrtab));

    if(CAL_NEX_INTERLEAVED == cal_interleave)
    {
        acq_longnexs = cal_pass*cal_nex;
        acq_nexs = 1;
    }

    if(cal_interleave > CAL_NONE_INTERLEAVED)
    {
        acq_passes = 1;
    }
    else
    {
        acq_passes = cal_pass;
    }

    /* calculate Slab Offset */
    zoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rsptloc/cal_vthick));
    if (calrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)cal_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (calrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (int)(.5 + fabs(FS_2PI*calrsp_info[0].rspphasoff/cal_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    calrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    calrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(calrf1_freq, calrsp_info, 1, a_gzrf1cal,
                (float)1, cal_fov, TYPTRANSMIT);

    /* setup rec freq for each slice, calc here so fov is not scaled by
     * fov_freq_scale */
    if(cal_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcal * 1000/ cal_xfov;
        calrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * calrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocal", 0);
    }


    if(PSdebugstate)
    {
        printf("\n AutoCal tx freq = %i calrec_freq = %i \n", calrf1_freq[0], calrec_freq[0]);
    }

    for(calsl_idx=0;calsl_idx<cal_slq;calsl_idx++)
    {
        cal_sltab[calsl_idx+1] = (short)((((float)calsl_idx*(a_combcal - a_endcal)/
                                           (float)(cal_slq-1) - a_combcal)/calloggrd.tz)*max_pg_iamp);

        cal_slrtab[calsl_idx+1] = (int)((((float)calsl_idx*(a_combcal2 - a_endcal2)/
                                    (float)(cal_slq-1) - a_combcal2)/calloggrd.tz)*max_pg_iamp);

        cal_trigger[calsl_idx] = (long)TRIG_INTERN;
    }

    setupphasetable(cal_viewtab, (INT)TYPNORM, cal_yres);

    setssitime((LONG)time_ssical/HW_GRAD_UPDATE_TIME);

    setiamp(-cal_viewtab[cal_zyindex[0].view+1],&gy1cal,0);
    setiamp(cal_viewtab[cal_zyindex[0].view+1],&gy1rcal,0);

    temp_short = cal_sltab[cal_zyindex[0].slice];
    setiamp(temp_short,&gzcombcal,0);
    temp_short = cal_slrtab[cal_zyindex[0].slice];
    setiamp(-temp_short,&gzprcal,0);

    setiamp((short)ia_rf1cal, &rf1cal, 0);
    setiphase(0, &rf1cal, 0);

    setfrequency(calrf1_freq[0],&rf1cal,0);
    setfrequency(calrec_freq[0],&echo1cal,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)cal_slq,cal_trigger);

    setrotatearray((SHORT)cal_slq,*calrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycal);
    scopeon(&seqcal);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcal);
    syncoff(&seqcalpass);

    boffset(off_seqcal);

    /* Turn off 3dpacket */
    load3d(&d3dcal,0,(TYPDAB_PACKETS)DABOFF);

    cal_acq = (INT)DABOFF;
    loaddab(&echo1cal, 0,0,0,0, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);


    for (calview_idx = -rspdda; calview_idx <= -1; calview_idx++)
    {
        if(calview_idx < -cal_dda)  /* delay time, set rf1cal to 0 amplitude */
        {
            setiamp(0, &rf1cal, 0);
        }
        else
        {
            setiamp((short)ia_rf1cal, &rf1cal, 0);
        }

        if(calspgr_flag)
        {
            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            cal_seq_count++;
        }
        else
        {
            cal_exphase = 0;
        }

        setiphase(cal_exphase, &rf1cal, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcal);
    }

    for (calpass_idx = 0; calpass_idx < acq_passes; calpass_idx++)
    {
        cal_acq = (INT)DABON;

        /* switch to body coil in 2nd pass for PURE Cal */
        if(calpass_idx > 0)
        {
            if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
            {
                if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                {
                    return FAILURE;
                }
                boffset(off_seqcal);
                printf("switch to body coil\n");
            }

        }

        for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
        {
            if(CAL_NEX_INTERLEAVED == cal_interleave)
            {
                /* switch coil in NEX loop PURE Cal */
                if(0 == longnex_idx %2)
                {
                    if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
                    {
                        if (FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], 1))
                        {
                            return FAILURE;
                        }
                        boffset(off_seqcal);
                        printf("switch to body coil\n");
                    }
                }
                else
                {
                    if (FAILURE == CoilSwitchSetCoil(coilInfo_tgt[0], 1))
                    {
                        return FAILURE;
                    }

                    boffset(off_seqcal);
                    printf("switch to surface coil\n");
                }
            }


            for (cal_superidx = 0; cal_superidx < cal_sampledPts; cal_superidx++)
            { 
                calview_idx = cal_zyindex[cal_superidx].view + 1;
                setiamp(-cal_viewtab[calview_idx],&gy1cal,0);
                setiamp(cal_viewtab[calview_idx],&gy1rcal,0);

                calsl_idx = cal_zyindex[cal_superidx].slice;
                cal_zphase =zsign*((calsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
                cal_yphase = phase_sign*(((calview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI - FS_PI);

                setiamp(cal_sltab[calsl_idx+1],&gzcombcal,0);
                setiamp(-cal_slrtab[calsl_idx+1],&gzprcal,0);

                /* Need this loaddab for coil switching in interleaved mode.
                 * The loaddab_hub_r1 is only set related ssp control bits related to rfhub for coil switching.
                 * Need to set other dab bits (slice, view, filter etc) for data acquisition by using loaddab().
                 */
                loaddab(&echo1cal,calsl_idx,0,0,calview_idx, (TYPDAB_PACKETS)cal_acq,PSD_LOAD_DAB_ALL);

                for (calcoil_idx = 0; calcoil_idx <= cal_tr_interleave; calcoil_idx++)
                {

                    for (calnex_idx = 1; calnex_idx <= acq_nexs; calnex_idx++)  /* EXCITATION LOOP */
                    {
                        if(calspgr_flag)
                        {
                            cal_exphase = ((int)((float)cal_exphase + (float)cal_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                            cal_seq_count++;
                        }
                        else
                        {
                            cal_exphase = 0;
                        }
                        setiphase(cal_exphase, &rf1cal, 0);

                        cal_rcphase = (cal_exphase + cal_zphase + cal_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                        setiphase(cal_rcphase, &echo1cal, 0); /* slab and offset phase */


                        if (cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else if (!cal_nex_interleave && (cal_zyindex[cal_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == calnex_idx))
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABON);
                        }
                        else
                        {
                            load3d(&d3dcal,calview_idx-1,(TYPDAB_PACKETS)DABOFF);
                        }


                        if(cal_nex > 1)
                        {
                            caldabop = DABADD;
                        }
                        else
                        {
                            caldabop = DABSTORE;
                        }

                        if(cal_tr_interleave)
                        {
                            if(calcoil_idx == 0)
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, coilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                            else   /* idx == 1, body coil rec */
                            {
                                loaddab_hub_r1(&echo1cal, calsl_idx, 0, caldabop, calview_idx, volRecCoilInfo_tgt[0].hubIndex, 0, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_HUB);
                            }
                        }
                        else
                        {
                            loaddab(&echo1cal,calsl_idx,0,caldabop,calview_idx, (TYPDAB_PACKETS)cal_acq, PSD_LOAD_DAB_ALL);
                        }

                        /* startseq should be after loaddab */
                        startseq((SHORT)calsl_idx,(SHORT)MAY_PAUSE);

                    }  /* End of Excitation */
                }  /* Coil switching for PURE cal */

            }  /* End of SuperIndex */
        }  /* End of Long Term Nex loop */

        /* pass packet logic */
        boffset(off_seqcalpass);

        if(calpass_idx == (acq_passes-1))
        {
            /* Set DAB pass packet to end of scan */
            setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecal, 2);
            printdbg("End of Scan and Pass", PSdebugstate);
        }
        else
        {
            setwamp(SSPD + DABPASS , &pass_pulsecal,2);
        }

        /* load last 3d packet */
        load3d(&d3dpasscal,cal_yres,(TYPDAB_PACKETS)DABON);

        startseq(0,(SHORT)AUTO_PAUSE);
        syncoff(&seqcal);

        boffset(off_seqcal);

        printdbg("Returning from Ext Cal core",PSdebugstate);

    } /* End of calpass */


    return SUCCESS;
}

/*
 *  PSautocoil
 *  
 *  Type: Public Function
 *  
 *  Description:
 *  
 */
    STATUS
PSautocoil( void )
{
    SHORT coil_sltab[CAL_SLTAB_MAX + 1];
    SHORT coil_slrtab[CAL_SLTAB_MAX + 1];
    SHORT coil_viewtab[CAL_SLTAB_MAX + 1];
    INT phase_off; 
    INT phase_sign; 
    INT zsign;
    INT zoffs1, zoffs;
    SHORT temp_short;
    long coil_trigger[CAL_SLTAB_MAX];
    INT coildabop;
    INT coil_acq;
    INT coilsl_idx, coilview_idx, coilnex_idx, longnex_idx;
    INT *coilrf1_freq;
    INT *coilrec_freq;
    INT coil_yphase;
    INT coil_zphase;
    INT coil_exphase;
    INT coil_rcphase;
    INT coil_seq_count;
    INT acq_nexs;
    INT acq_longnexs = 1;
    INT coil_superidx = 0;

    if(PSdebugstate)
    {
        printf("\n AutoCoil Sls = %i FOV = %f  slthick = %f\n", coil_slq, coil_fov, coil_slthick);
        printf("\n AutoCoil: Tx = %f Rx = %f Phase = %f\n", coilrsp_info[coil_slq/2].rsptloc,
               coilrsp_info[coil_slq/2].rsprloc, coilrsp_info[coil_slq/2].rspphasoff);
        printf("%s\n"," AutoCoil Rotation Matrix:");
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][0], coilrsprot[0][1], coilrsprot[0][2]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][3], coilrsprot[0][4], coilrsprot[0][5]);
        printf("\t %6ld %6ld %6ld \n", coilrsprot[0][6], coilrsprot[0][7], coilrsprot[0][8]);
        fflush(stdout);
    }

    /* Initialize coil_sltab  */    
    memset(coil_sltab, 0, sizeof(coil_sltab));
    memset(coil_slrtab, 0, sizeof(coil_slrtab));

    coil_yphase = 0;
    coil_zphase = 0;
    coil_rcphase = 0;

    coil_exphase = 0;
    coil_seq_count = 1;

    acq_nexs = coil_nex;
    acq_longnexs = 1;

    if(CAL_NEX_INTERLEAVED == coil_interleave)
    {
        acq_longnexs = coil_nex;
        acq_nexs = 1;
    }

    /* calculate Slab Offset */
    zoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rsptloc/coil_vthick));
    if (coilrsp_info[0].rsptloc >= 0.0)
        zsign = 1;
    else
        zsign = -1;

    /* offset in range 0 - 2pi */
    zoffs = (zoffs1 + FS_2PI +  (int)((float)FS_PI*(1.0 + ((float)zsign)/((float)coil_slq)))) %FS_2PI;


    /* calculate Y Phase offset */
    if (coilrsp_info[0].rspphasoff >= 0.0)
    {
        phase_sign = -1;
    }
    else
    {
        phase_sign = 1;
    }
    /* phase offset increment */
    yoffs1 = (INT)(.5 + fabs(FS_2PI*coilrsp_info[0].rspphasoff/coil_yfov));
    /* offset in range */
    phase_off = (yoffs1 + FS_2PI + FS_PI)%FS_2PI-FS_PI;

    /* set up T/R frequency */
    coilrf1_freq = (int *)AllocNode((1 + 2)*sizeof(int));
    coilrec_freq = (int *)AllocNode((1 + 2)*sizeof(int));

    setupslices(coilrf1_freq, coilrsp_info, 1, a_gzrf1coil,
                (float)1, coil_fov, TYPTRANSMIT);

    /* setup rec freq for each slice here so fov is not scaled
     * by fov_freq_scale */
    if(coil_xfov > 0.0)
    {
        FLOAT mmtoHz = 2 * echo1bwcoil * 1000/ coil_xfov;
        coilrec_freq[0] = (INT)((cfreceiveroffsetfreq + mmtoHz * coilrsp_info[0].rsprloc)/ TARDIS_FREQ_RES);
    }
    else
    {
        psdexit(EM_PSD_SUPPORT_FAILURE, (INT)0, "", "setup rec freq for autocoil", 0);
    }

    for(coilsl_idx=0;coilsl_idx<coil_slq;coilsl_idx++)
    {
        coil_sltab[coilsl_idx+1] = (SHORT)((((float)coilsl_idx*(a_combcoil - a_endcoil)/
                                     (float)(coil_slq-1) - a_combcoil)/coilloggrd.tz)*max_pg_iamp);

        coil_slrtab[coilsl_idx+1] =(SHORT)((((float)coilsl_idx*(a_combcoil2 - a_endcoil2)/
                                     (float)(coil_slq-1) - a_combcoil2)/coilloggrd.tz)*max_pg_iamp);

        coil_trigger[coilsl_idx] = (long)TRIG_INTERN;
    }

    if(PSdebugstate)
    {
        printf("\n Sls encode = %d, = %d,  = %d \n", coil_sltab[0], coil_sltab[3], coil_sltab[5]);
        fflush(stdout);
    }

    setupphasetable(coil_viewtab, (INT)TYPNORM, coil_yres);

    setssitime((LONG)time_ssicoil/HW_GRAD_UPDATE_TIME);


    temp_short = coil_sltab[1];
    setiamp(temp_short,&gzcombcoil,0);
    temp_short = coil_slrtab[1];
    setiamp(-temp_short,&gzprcoil,0);

    setiamp((short)ia_rf1coil, &rf1coil, 0);
    setiphase(0, &rf1coil, 0);

    setfrequency(coilrf1_freq[0],&rf1coil,0);
    setfrequency(coilrec_freq[0],&echo1coil,0);

    /* Inform the Tgt of the trigger array to be used */
    settriggerarray((SHORT)coil_slq,coil_trigger);

    setrotatearray((SHORT)coil_slq,*coilrsprot);

    /* Reset scope and attenuator lock*/
    attenlockon(&attenuator_keycoil);
    scopeon(&seqcoil);

    /* Reset all the synchronizations  - no need to use one in pass */
    syncon(&seqcoil);
    syncoff(&seqcoilpass);

    boffset(off_seqcoil);

    /* Turn off 3dpacket */
    load3d(&d3dcoil,0,(TYPDAB_PACKETS)DABOFF);

    coil_acq = (INT)DABOFF;
    loaddab(&echo1coil, 0,0,0,0, (TYPDAB_PACKETS)coil_acq,PSD_LOAD_DAB_ALL);

    for (coilview_idx = -rspdda; coilview_idx <= -1; coilview_idx++)
    {
        if(coilspgr_flag)
        {
            coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
            coil_seq_count++;
        }
        else
        {
            coil_exphase = 0;
        }

        setiphase(coil_exphase, &rf1coil, 0);

        startseq((SHORT)0,(SHORT)MAY_PAUSE);
        syncoff(&seqcoil);
    }

    for (longnex_idx = 1; longnex_idx <= acq_longnexs; longnex_idx++)
    {
        coil_acq = (INT)DABON;
        for (coil_superidx = 0; coil_superidx < coil_sampledPts; coil_superidx++)
        { 
            coilview_idx = coil_zyindex[coil_superidx].view + 1;
            setiamp(-coil_viewtab[coilview_idx],&gy1coil,0);
            setiamp(coil_viewtab[coilview_idx],&gy1rcoil,0);

            coilsl_idx = coil_zyindex[coil_superidx].slice;
            coil_zphase =zsign*((coilsl_idx*zoffs + 3L*FS_PI)%FS_2PI - FS_PI);
            coil_yphase = phase_sign*(((coilview_idx-1)*phase_off + 3L*FS_PI)%FS_2PI-FS_PI);


            setiamp(coil_sltab[coilsl_idx+1],&gzcombcoil,0);
            setiamp(-coil_slrtab[coilsl_idx+1],&gzprcoil,0);

            for (coilnex_idx = 1; coilnex_idx <= acq_nexs; coilnex_idx++)  /* EXCITATION LOOP */
            {
                if(coilspgr_flag)
                {
                    coil_exphase = ((int)((float)coil_exphase + (float)coil_seq_count*ps_seed + 3L*FS_PI) % FS_2PI)-FS_PI;
                    coil_seq_count++;
                }
                else
                {
                    coil_exphase = 0;
                }
                setiphase(coil_exphase, &rf1coil, 0);

                coil_rcphase = (coil_exphase + coil_zphase + coil_yphase + 3L*FS_PI)%FS_2PI-FS_PI;
                setiphase(coil_rcphase, &echo1coil, 0); /* slab and offset phase */

                if (coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_longnexs == longnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else if (!coil_nex_interleave && (coil_zyindex[coil_superidx].flags & ZY_XZ_PLANE_DONE) && (acq_nexs == coilnex_idx))
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABON);
                }
                else
                {
                    load3d(&d3dcoil,coilview_idx-1,(TYPDAB_PACKETS)DABOFF);
                }


                if(coil_nex > 1)
                {
                    coildabop = DABADD;
                }
                else
                {
                    coildabop = DABSTORE;
                }

                loaddab(&echo1coil,coilsl_idx,0,coildabop,coilview_idx, (TYPDAB_PACKETS)coil_acq, PSD_LOAD_DAB_ALL);

                /* startseq should be after loaddab */
                startseq((SHORT)coilsl_idx,(SHORT)MAY_PAUSE);

            }  /* End of Excitation */
        }  /* End of SuperIdx */
    }  /* End of Long Term Nex loop */

    /* pass packet logic */
    boffset(off_seqcoilpass);

    /* Set DAB pass packet to end of scan */
    setwamp(SSPD + DABPASS + DABSCAN, &pass_pulsecoil, 2);
    printdbg("End of Scan and Pass", PSdebugstate);

    /* load last 3d packet */
    load3d(&d3dpasscoil,coil_yres,(TYPDAB_PACKETS)DABON);

    startseq(0,(SHORT)AUTO_PAUSE);
    syncoff(&seqcoil);

    boffset(off_seqcoil);

    printdbg("Returning from AutoCOil core",PSdebugstate);


    return SUCCESS;
}



/* CoilSwitchSetCoil
 *
 *  Description: MRIhc15304
 *    This sets the RF HUB index for the coil by changing the data on an ssp
 *    pulse and/or with the sethubindeximm function.  Also calls
 *    setrcvportimm, if requested.
 *
 *  Parameters:
 *  (I: for input parameters, O: for output parameters)
 *  
 *  (O) STATUS return variable - Did function complete successfully.
 *  (I) const COIL_INFO - coil info structure of coil to switch to
 *  (I) const INT setRcvPortFlag - Flag indicating that setrcvportimm needs
 *        to be executed.  This needs to be set whenever switching to or
 *        from the BODY coil.
 *  
 *  Globals:
 *  (I) txCoilInfo
 *
 */

STATUS
CoilSwitchSetCoil( const COIL_INFO coil,
                   const INT setRcvPortFlag)
{
    SHORT device = 0;

    if( setRcvPortFlag || (COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod) )
    {
        int wait_rspimm = 0;

        /* MRIhc14300: When switching coils, play a delay sequence to
           wait for scan prep to complete and scanning to start before the
           first setrcvportimm() & sethubindeximm().  These functions may not
           be called until scanning starts and the first startseq will not
           return until scanning starts. After scanning has started this will
           merely add an additional short delay to the switch time */

        boffset(off_seqcswWaitBefore);
        startseq((short)0, (SHORT)MAY_PAUSE);

        /* Need additional delay for setrcvpowerimm & sethubindeximm
         * to take effect.  The delay time must be set to guarantee
         * the completion of both setrcvportimm and sethubindeximm */

        if( COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod )
        {
            wait_rspimm = csw_wait_sethubindeximm;
        }

        if( setRcvPortFlag )
        {
            wait_rspimm = IMax(2, wait_rspimm, csw_wait_setrcvportimm);
        }

        setperiod(wait_rspimm, &csw_wait, 0);
    }
    else
    {
        /* No additional delay needed when not calling setrcvportimm */
        setperiod(SSP_UPDATE_TIME, &csw_wait, 0);
    }

    /* Setup hub index switching packet */
    device = 0;
    if( COIL_SWITCH_SSP_HUB_INDEX & cfcoilswitchmethod )
    {
        device = RDC;
        /* Set hub index on SSP packet */
        setwamp( (SHORT)(SSPD | (HUBIND + coil.hubIndex)), &contrfhubsel, (LONG)2 );
    }
    setwamp( (SHORT)(SSPDS | device), &contrfhubsel, (LONG)0 );

    /* Set receiver port & receiver input */
    if( setRcvPortFlag || (COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod) )
    {
        SHORT coil_port = PSD_RP_BODY;
        SHORT rcv_input = RFBODYI;

        /* Calculate coil port & receiver input */
        switch (coil.rxCoilType) 
        {
        case RX_COIL_BODY:
        default:
            /* Transmit & receive with body coil */
            coil_port = PSD_RP_BODY;
            rcv_input = RFBODYI;
            break;
        case RX_COIL_LOCAL:
            {
                /* Assume there is only one transmit coil.  If two transmit
                   coils, the primary will be used */
                n32 txCoilType = TX_COIL_BODY;
                if (TX_INDEX_NONE != coil.txIndexPri)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexPri].txCoilType;
                }
                else if (TX_INDEX_NONE != coil.txIndexSec)
                {
                    txCoilType = txCoilInfo_tgt[coil.txIndexSec].txCoilType;
                }
                else
                {
                    printf("CoilSwitchSetCoil: No transmit coil defined!\n");
                    return FAILURE;
                }

                if (TX_COIL_LOCAL == txCoilType)
                {
                    /* Local transmit coil */
                    coil_port = PSD_RP_HEAD;
                    rcv_input = RHEADI;
                }
                else
                {
                    /* Surface coil */
                    coil_port = PSD_RP_SURFACE;
                    rcv_input = RFAUX;
                }
            }
            break;
        }

        /* Setup receiver input switching packet */
        device = 0;
        if( COIL_SWITCH_SSP_RECEIVER_INPUT & cfcoilswitchmethod )
        {
            device = RDC;
            setwamp( (SHORT)(SSPD | rcv_input), &contrfsel, (LONG)2 );
        }
        setwamp( (SHORT)(SSPDS | device), &contrfsel, (LONG)0 );

        /* Set receiver port using RSP function call when switching to/from 
         * body coil */
        if (setRcvPortFlag) 
        {
#ifdef PSD_HW
            setrcvportimm( (SHORT)coil_port );
#endif /* PSD_HW */
        }
    }

    /* Select coil using RSP function on MGD Rx chain */
    if(COIL_SWITCH_RSP_SETHUBINDEXIMM & cfcoilswitchmethod)
    {
        sethubindeximm( coil.hubIndex );
    }
   
    boffset( off_seqcsw );
    startseq( (short)0, (SHORT)MAY_PAUSE );
    return SUCCESS;
}

/* phase_ordering 
 *
 *  Description: function for different phase ordering
 *  (O) SHORT* view_tab : View table with view acquisition order.
 *  (I) INT phase_order : Phase order variable.  Phase order types are:
 *           SEQUENTIAL 0
 *           CENTRIC 1
 *  (I) INT yviews : Number of views acquired in the scan.
 *
 *
*******************************/
STATUS
phase_ordering( SHORT *view_tab,
                const INT phase_order,
                const INT yviews, const INT yetl)
{
    INT i, j, num_trains, center;
    STATUS status = SUCCESS;

    num_trains = yviews/yetl;


    if(yetl >= 2)
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL: 
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (i*2)*yetl+j+1;
                        view_tab[(i*2+1)*yetl+j] = (i*2+1)*yetl+j+1; 
                    }
                }
                break;
            case PH_CENTRIC_LOW:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = (yviews/2 - i - j*num_trains/2);
                        view_tab[(i*2+1)*yetl+j] = (yviews/2 + i + 1 + j*num_trains/2);
                    }
                }
                break;
            case PH_CENTRIC_HIGH:
                for(i=0; i<num_trains/2; i++)
                {
                    for(j=0; j<yetl; j++)
                    {
                        view_tab[(i*2)*yetl+j] = yviews/2 + i - j*num_trains/2 - num_trains/2 + 1;
                        view_tab[(i*2+1)*yetl+j] = yviews/2 - i + j*num_trains/2 + num_trains/2;
                    }
                }
                break;
        }
    }
    else
    {
        switch (phase_order)
        {
            case PH_SEQUENTIAL:
                {
                    for(i=0;i<yviews;i++)
                    {
                        view_tab[i]=i+1;
                    }
                }
                break;
            case PH_CENTRIC_LOW:
            case PH_CENTRIC_HIGH:
                center = yviews/2;

                for( i = 0, j = 0; i < yviews/ 2; ++i, j += 2 )
                {
                    view_tab[j % yviews] = center - i;
                    view_tab[(j + 1) % yviews] = center + i + 1;
                }
                break;
        }
    }
    return status;
}



/*****************************  PSDINIT  **************************/
STATUS
#ifdef __STDC__ 
psdinit( void )
#else /* !__STDC__ */
    psdinit() 
#endif /* __STDC__ */
{
    strcpy(psdexitarg.text_arg, "psdinit");  /* reset global error variable */
    diff_index = 0;
    nex_index = 0;
    frame_type = REF_FRAME;
    instance_index = 0;
    b_index = 0;
    dir_index = 0;
    vol_index = 0;
    skip_ir = 0;
    blankomega=0;
    deltaomega = 0;
    timedelta = 0;  
    dda_packe = dda_pack;

    /* BJM: initialize sign of freq offset to be positive */
    /*      variable declared in ss.e */
    freqSign = 1;
    freqSign_ex = 1;
    freqSign_rf2right = 1;
    freqSign_rf2left = 1;
    freqSign_rf2 = 1;

    setrfconfig((short)rfconf);

    /* Clear the SSI routine. */
    if (opsat == PSD_ON)
        ssivector(ssisat, (short) FALSE);
    else 
        ssivector(dummyssi, (short) FALSE);

    /* turn off dithering */
    setditherrsp(dither_control,dither_value);

    /* Set ssi time.  This is time from eos to start of sequence interrupt
       in internal triggering.  The minimum time is 50us plus 2us*(number of
       waveform and instruction words modified in the update queue).
       Needs to be done per entry point. */
    setssitime((LONG)time_ssi/GRAD_UPDATE_TIME);

    scopeon(&seqcore);    /* reset all scope triggers */

    if (epi_flair == PSD_ON)		/* IR scope triggers */
        scopeon(&seqinv);

    scopeoff(&seqblineacq);

    syncon(&seqcore);  /* reset all synchronizations, not needed in pass */

    /* Set trigger for cf and 1st pass prescan.
       Reset trigger the prescan slice to its scan trigger for 
       scan and second pass prescan entry points. */
    if ((rspent == L_CFL) || (rspent == L_CFH) || (rspent == L_MPS1)
        || (rspent == L_APS1)) {
        rsptrigger[acq_ptr[pre_pass] + pre_slice] = trig_prescan;

        if (ipg_trigtest == 0) 
            /* Remove next line when line gating supported */
            rsptrigger[acq_ptr[pre_pass] + pre_slice] = TRIG_INTERN;
        else 
            rsptrigger[acq_ptr[pre_pass] + pre_slice] = prescan_trigger;
    }
    /* Allow for manual trigger override for testing. */      
    if (((psd_mantrig == PSD_ON) || (opcgate == PSD_ON) || (oprtcgate == PSD_ON))
        && ((rspent == L_APS2) || (rspent == L_MPS2) || (rspent == L_SCAN) || (rspent == L_REF) ))
    {
        for (slice=0; slice < opslquant*opphases; slice++)
        {
            if (rsptrigger[slice] != TRIG_INTERN)
            {
                switch(rspent)
                {
                case L_MPS2:
                    rsptrigger[slice] = trig_mps2;
                    break;
                case L_APS2:
                    rsptrigger[slice] = trig_aps2;
                    break;
                case L_SCAN:
                case L_REF:
                    rsptrigger[slice] = trig_scan;
                    break;
                default:
                    break;
                }
            }
        }
    }

    /* Inform the Tgt of the location of the trigger arrays. */
    settriggerarray((SHORT)(opslquant*opphases), rsptrigger);

    /* Inform the Tgt of the rotation matrix array to be used */
    setrotatearray((SHORT)(opslquant*opphases), rsprot[0]);

    pass = 0;
    pass_index = 0;
    rspacqb = 0;
    rspacq = act_acqs;
    false_rspacqb = 0;
    false_rspacq = false_acqs;
    rspprp = pass_reps;

    /* DAB initialization */
    dabop = 0; /* Store data */
    dabview = 0; 
    dabecho = 0; /* first dab packet is for echo 0 */
    /* use the autoincrement echo feature for subsequent echos */
    dabecho_multi = -1;


    CsSatMod(cs_satindex);
    SpSatInitRsp((INT)1, sp_satcard_loc,0);

    if ( gyctrl == PSD_ON )
        gyb_amp = blippol[0];
    else
        gyb_amp = 0;

    rspgyc = gyctrl;
    rspgzc = rspgyc;
    /*multiband slice looping upto mux'ed number of slices*/
    rspslqb = 0;
    rspslq = mux_flag?mux_slquant:false_slquant1;

    rspilvb = 0;
    rspilv = intleaves;
    rspbasb = 1;

    if (gxctrl == PSD_OFF)                /* turn off the readout axis */
        setieos((SHORT)EOS_DEAD, &x_td0,0);
    else                                  /* turn it on */
        setieos((SHORT)EOS_PLAY, &x_td0, 0);

    if (gzctrl == PSD_OFF)                /* turn off slice select axis */
        setieos((SHORT)EOS_DEAD, &z_td0,0);
    else                                  /* turn it on */
        setieos((SHORT)EOS_PLAY, &z_td0, 0);

    /* Update the exciter freq/phase tables */
    if (rspent == L_REF)
        ref_switch = 1;
    else
        ref_switch = 0;

    xtr = 0.0;    /* This used to be the time between the XTR and RBA packet */
    /* but we are now using the Omega board to offset the freq. */
    /* instead of the offset freq register so this is now 0 */
    frt = frtime;
 
    /* BJM: refdattime is no longer used to prephase the echoes */
    /* keep it until the epiRecvFrqPhs() interface is modified. */
    {
        int slc;
        
        /* No need to calculate refdattime */
        for( slc = 0; slc < opslquant; slc++ ) {
            refdattime[slc] = 0.0;
        }
    }

    rsppepolar = pepolar; /* used in recv_phase_freq_init */

    recv_phase_freq_init();

    /** end of XJZ's addition  **/

    ref_switch = 0;

    if ((intleaves > 1) && (ep_alt > 0)) 
    {
        ileave = 0;
        setreadpolarity();  /* make sure readout gradient polarity is set
                               properly */
    }

    rspe1st = 0;
    rspetot = tot_etl;

    /* phase-encoding blip correction for oblique scan planes */
    blipcorr(rspia_gyboc,da_gyboc,debug_oblcorr,rsprot_unscaled,oc_fact,cvxfull,
             cvyfull,cvzfull,bc_delx,bc_dely,bc_delz,oblcorr_on,opslquant,
             &epiloggrd,pw_gyb,pw_gyba,a_gxw);

    /* set up tensor orientations from the AGP side */ 
    if ( FAILURE == set_tensor_orientationsAGP() ){
        return FAILURE;
    } 

#ifdef PSD_HW
    if (PSD_ON == navtrig_flag)
    {
        if (L_REF == rspent)
        {
            skip_navigator_prescan = 0;
            if (PSD_OFF == calc_rate)
            {
                NavigatorRspInit();
            }
        }
        if (L_SCAN == rspent)
        {
            NavigatorRspInit();
        }
    }
#endif /* PSD_HW */

    return SUCCESS;  
} /* End psdinit */	    


/* FOR MERGE */
#ifdef PSD_HW
#include "clockApi.h"
#endif

#if defined(MGD_TGT) && defined(PSD_HW)
void computeSprepTimingStats()
{
    char sprepfilepath[170] = "/export/home/service/log/SprepStat_";
    struct timespec nCurrTimeSprep;
    char timestampSprep[20];
    struct tm *SpreptimePtr;
    FILE *fp_sprepStat;
    long spreptimingidx = 0;

    mgd_clock_gettime (HOST_TIME_OF_DAY, &nCurrTimeSprep);
    SpreptimePtr  = localtime(&nCurrTimeSprep.tv_sec);

    strftime(timestampSprep,20,"_%m%d%Y%H_%M_%S",SpreptimePtr);

    strcat(sprepfilepath,timestampSprep);

    fp_sprepStat=fopen(sprepfilepath, "w");            
    if (fp_sprepStat == NULL) {
        printf("Failed to open %s\n", sprepfilepath);
        return;
    }

    /* Send Timing Stats to File */

    fprintf(fp_sprepStat, "Min SmartPrep roundtrip time: %ld \n", min_roundtrip_time);
    fprintf(fp_sprepStat, "Max SmartPrep roundtrip time: %ld \n", max_roundtrip_time);

    for( spreptimingidx = 0; spreptimingidx < sprep_roundtrip_index; spreptimingidx++)
    {
        fprintf(fp_sprepStat, "%ld\n", sprep_roundtrip_timing_array[spreptimingidx]);
    }

    fclose(fp_sprepStat);

    return;
}
#endif

STATUS Monitor_Download(void)
{
    if (navigator_flag)
    {
        setupslices(mon_receive_freq1, mon_rsp_info, tracker_quant, (float)0,
                    echo1monbw, mon_acqfov, TYPREC);  /* MRIge45734: changed bandwidth to echo1monbw */
        if(!navigatorCYL_flag)
        {
            if (nav_angle_adj)
            {
                rf1mon_freq[0] = (int)(GAM*(a_gzrf1mon*mon_rsp_info[0].rsptloc+a_gyrf1mon*mon_rsp_info2[0].rsptloc)/
                                       (10 * TARDIS_FREQ_RES));
            } else {
                setupslices(rf1mon_freq, mon_rsp_info, tracker_quant, a_gzrf1mon,
                            (float)1, mon_acqfov, TYPTRANSMIT);
            }
            setupslices(rf2mon_freq, mon_rsp_info2, tracker_quant, a_gyrf2mon,
                        (float)1, mon_acqfov, TYPTRANSMIT);
            setupslices(rfmontipup_freq, mon_rsp_info2, tracker_quant, a_gyrfmontipup,
                        (float)1, mon_acqfov, TYPTRANSMIT);
            /* FOR MERGE */
        }
    }

    if (smartprep_flag)
    {
        setupslices(mon_receive_freq1, mon_rsp_info, tracker_quant, (float)0,
                    echo1monbw, mon_acqfov, TYPREC);  /* MRIge45734: changed bandwidth to echo1monbw */
        setupslices(rf1mon_freq, mon_rsp_info, tracker_quant, a_gzrf1mon,
                    (float)1, mon_acqfov, TYPTRANSMIT);
        setupslices(rf2mon_freq, mon_rsp_info2, tracker_quant, a_gyrf2mon,
                    (float)1, mon_acqfov, TYPTRANSMIT);
    }

    if (debug_monrot)
    {
        printf("mon_receive_freq1 = %d\n",mon_receive_freq1[0]);
        printf("rf1mon_freq = %d\n",rf1mon_freq[0]);
        printf("rf2mon_freq = %d\n",rf2mon_freq[0]);
        printf("rfmontipup_freq = %d\n",rfmontipup_freq[0]);
    }  

    return SUCCESS;
}

/* FOR MERGE */
/* The functions sendvmsg( ) and turnoff_spu( ) have been deleted */

/* FOR MERGE */
/* The function load_spu_code( ) is not present in MGD */
/* The new function used in MGD is Monitor_load_SmartPrep_RTPtask( ) */

void 
Monitor_load_SmartPrep_RTPtask(void)
{
    RtpDataValuesPkt smartprepRtpPkt;
    int status;

#if defined(MGD_TGT) && defined(PSD_HW)
    status = rtp_register_opcode(RTP_RESULT_SMART_PREP, sizeof(SmartPrepResult), NULL);
    if (0 != status)
    {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "rtp_register_opcode failed",
            PSD_ARG_STRING, "rtp_register_opcode:SmartpPrep", 0);
    }
#endif

    /* DVMR: Now fill smartprepRtpPkt values */

    strncpy(smartprepRtpPkt.rtpDataVal.path, SMARTPREP_APS_OBJECT_PATH, sizeof(smartprepRtpPkt.rtpDataVal.path));
    strncpy(smartprepRtpPkt.rtpDataVal.func, "smartprepRTP", sizeof(smartprepRtpPkt.rtpDataVal.func));

    /* BAM Allocations */
    smartprepRtpPkt.rtpDataVal.frameSize = xres2use;

    /**
     * Legacy implementation used NonEDR always for SmartPrep while application
     * can have EDR on. (MRIhc22295)
     *
     * To get good noise characterization of raw data on DPP system, design was changed
     * to use scan prescription's EDR setting for SmartPrep acquisition. Details are
     * captured in Kizuna R1/R2 TDR (DOC1438598)
     */

    smartprepRtpPkt.rtpDataVal.dacqType = dacq_data_type;
    smartprepRtpPkt.rtpDataVal.numRtpReceivers = 0; 
    smartprepRtpPkt.rtpDataVal.hubIndex = volRecCoilInfo_tgt[0].hubIndex; /* vol Rec coil HubIndex */ 
    smartprepRtpPkt.rtpDataVal.bodyCoilCombine = rtp_bodyCoilCombine;
    smartprepRtpPkt.rtpDataVal.acquiredIndex = 0;
    smartprepRtpPkt.rtpDataVal.processedIndex = 0;

    /* navgs: Number of averages */
    smartprepRtpPkt.rtpDataVal.intVar_1 = navgs;

    /* maxiter: max number of interations */
    smartprepRtpPkt.rtpDataVal.intVar_2 = (int)max_avg_time/(int) (navgs*mon_tr)  + (int)(num_baseline_pts);

    /* discards: Number of discarded acquisitions */
    smartprepRtpPkt.rtpDataVal.intVar_3 = 5;

    /* baselines: Number of averages for baselines */
    smartprepRtpPkt.rtpDataVal.intVar_4 = num_avg_bline;

    /* fov_factor */
    smartprepRtpPkt.rtpDataVal.floatVar_1 = fov_factor;

    /* sigma1 */
    smartprepRtpPkt.rtpDataVal.floatVar_2 = sigma1;

    /* sigma2 */
    smartprepRtpPkt.rtpDataVal.floatVar_3 = sigma2;

    /* Debug: RTP App Debug flag */
    smartprepRtpPkt.rtpDataVal.longVar_1 = debug_sp_rtp;

    /* detected */
    smartprepRtpPkt.rtpDataVal.longVar_2 = 0;

    /* stopbit */
    smartprepRtpPkt.rtpDataVal.longVar_3 = 0;

    /* signal */
    smartprepRtpPkt.rtpDataVal.floatVar_4= 0.0;

    smartprepRtpPkt.rtpDataVal.writeRawData = sprep_save_raw_data;
    smartprepRtpPkt.rtpDataVal.vreDebug = sprep_debug_flag;

#ifdef PSD_HW
    if(sprep_timing_flag == 1)
    {
#if defined(MGD_TGT) && defined(PSD_HW)
        int sprepinitindex = 0;

    roundtrip_time = 0;
    max_roundtrip_time = 0;
    min_roundtrip_time = 9999;
    sprep_roundtrip_index = 0;
    for(sprepinitindex = 0; sprepinitindex < SPREP_NUM_TIMING_POINTS; sprepinitindex++)
    {
        sprep_roundtrip_timing_array[sprepinitindex] = 0;
    }
#endif
    }
#endif

    /* send buffer address to APS */
    status = RtpInit(&smartprepRtpPkt);

    if (status != SUCCESS)
    {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpInit failed",PSD_ARG_STRING,"RtpInit",0);
    }
    isrtplaunched = 1;
    return;
}


STATUS  write_data_file(void)
{
    FILE *fidman; /* output file handle */
    CHAR filename[255];

    /* FOR MERGE */
#ifdef PSD_HW
    struct timespec host_clock; 
#endif
    LONG seconds=0;

    num_items = 0;

    if (savedata == 1) 
    {
        boffset(off_seqloopdelay);
#ifdef PSD_HW
        /* FOR MERGE */
        mgd_clock_gettime (HOST_TIME_OF_DAY, &host_clock);
        seconds = host_clock.tv_sec ;
#endif
        sprintf(filename,"/usr/g/caldir/sp.%d",seconds);

        /* startseq(0, (SHORT)MAY_PAUSE); */

        /* write out the scan parameters */

        if (write_spinfo == PSD_ON)
        {
            datamax[total_points] = (float)sigma1;
            datamax[total_points + 1] = (float)sigma2;
            datamax[total_points + 2] = (float)max_avg_time;
            datamax[total_points + 3] = (float)mon_trigger_delay;
            datamax[total_points + 4] = (float)navgs;
            datamax[total_points + 5] = (float)mon_fov;
            datamax[total_points + 6] = (float)mon_vthickz;
            datamax[total_points + 7] = (float)mon_vthicky;
            datamax[total_points + 8] = (float)data_type;
            datamax[total_points + 9] = -1.0;
            total_points += 10;
        }

        /* FOR MERGE */
        if ( (fidman = fopen(filename,"wb")) )
        {
            num_items = fwrite(datamax,sizeof(float),total_points,fidman); 
            fclose(fidman);
        } else {
            num_items = -999;
        }
    }

    if (detector_mode == 1) 
    {
        boffset(off_seqloopdelay);

        /* FOR MERGE */
        sprintf(filename,"/usr/g/caldir/smrtp.%d",seconds);

#ifdef DEBUG
        /* FOR MERGE */
        if ( (fidman = fopen(filename,"wb")) )
        {
            num_items = fwrite(last_buff,sizeof(float),128,fidman); 
            fclose(fidman);
        } else
#endif
        num_items = -998;
    }
   
    return SUCCESS;
} /* end write_data_file */


/*
 * acquire_data : turns on/off data acquisition
 * slice_index   : index into acquisition table
 * standalone   : plays out a startseq if enabled
 */
STATUS
monitor_core( INT acquire_data,
              INT slice_index,
              INT standalone )
{
    TYPDAB_PACKETS acq_echo;
    boffset(off_seqmon);

    setfrequency( mon_receive_freq1[slice_index], &echo1mon, 0);
    setfrequency( rf1mon_freq[slice_index],&rf1mon, 0);
    setfrequency( rf2mon_freq[slice_index],&rf2mon, 0);

    setrotatearray((short)1,rsprot_monitor[0]);

    if (acquire_data)
        acq_echo = DABON;
    else
        acq_echo = DABOFF;

    /* loaddab(&echo1mon,0,0,0,0,acq_echo,PSD_LOAD_DAB_ALL); */

    loaddab(&echo1mon,0,0,0,0,acq_echo,PSD_LOAD_DAB_ACQON_RBA); 

    /* Lx/MGD - turn off DAB packet and route data to RTP */ 
    /* MRIge85438 */ 
    routeDataFrameDab(&echo1mon, ROUTE_TO_RTP, cfcoilswitchmethod);

    if (standalone)
    {
        printdbg("  Before disdaq", debugstate);
        startseq(0, (SHORT)MAY_PAUSE); /* 3d oblique - changed sliceindex to 0 - latha@mr */
        printdbg("  After disdaq", debugstate);
    }

    return SUCCESS;
}

#ifdef NAV_EFGRE3D
#ifndef SPIRAL
STATUS 
monitor_signal( void )
{
    FLOAT *datamaxptr; /* pointer to datamax */
    FLOAT  *lastbuffptr; /* pointer to last buffer */
    INT av; /* number of pts before averaging */
    INT found = 0; /* flag to see if spu found a maximum*/
    INT maxiters; /* maximum # of monitor segments */
    INT ndelays,ndelay0, data_counter,start_clock;
    INT stopbit; /* bit to stop the spu */

#ifdef PSD_HW
    DOUBLE point;
    int status;
    /* DVMR: Need RtpSimplePkt to send updated stopbit value to SmartPrep RTP via RTP Server */
    RtpSimplePkt rtpSimplePkt;
#endif /* PSD_HW */

    INT coilSwitched = 0;

    test_flag = 0;
    total_points = 0;
    points = 0;
    /* collect monitor views */
    av  = 0;
    /* determine the maximum number of monitor sequences */
    maxiters = (int)max_avg_time/(int)mon_tr  + (int)(navgs*num_baseline_pts);

    start_clock = num_baseline_pts*navgs;
    datamaxptr = datamax;
    lastbuffptr = last_buff;

    total_points = 0;
    stopbit = 0;

    data_counter = 0;
    smartprep_detected = 0;

    ndelay0 = opslquant;

    /* calculate the number of delay sequences after trigger less the
       audible delays*/
    ndelays = delay_dda - ((num_audibles*audible_loop) + ndelay0);

    if (ndelays <= 0)
    {
        ndelays = 1;   /* error trap */
    }


#ifdef PSD_HW
    setscantimeimm(PSD_CLOCK_NORM,scanclocktime,piviews,pitslice,opslicecnt); 
#endif /* PSD_HW */
    setscantimemanual();
    setscantimestop();

    /* MRIhc14300: The coil switching RSP functions setmcswitchselectimm(),
       setmcbiasenableimm(), and setrcvportimm() may not be called until
       after the SCP has finished applying the settings from the current
       entry point.  The SCP will block the first startseq() until it is
       finished preparing to scan.  Therefore, do not call the coil
       switching RSP functions until after the first startseq().  For
       SmartPrep, either play the dummyrfseq or a delay pulse of the same
       duration. */
    if((PSD_ON == minimize_RFunblank_time) ) 
    {
        /* FOR MERGE */
        setssitime((LONG)dummyrf_ssitime/HW_GRAD_UPDATE_TIME);
        boffset(off_dummyrfseq);
        startseq((short)0,(SHORT)MAY_PAUSE);
        /* Switch back to the core sequence */
        setssitime((LONG)rsptimessi/HW_GRAD_UPDATE_TIME);
    } else {
        boffset(off_seqsmartprepdelay);
        startseq((short)0, (SHORT)MAY_PAUSE);
    }
    
    /* MRIhc15304: calling CoilSwitchSetCoil funcion. This
     * function sets the RF HUB index as the data for the ssp command
     * and also send setrcvportimm command if needed.
     * Set the 'coilSwitched' variable, so that we can switch back to
     * the imaging coil later.
     */
    /* Change receive coil to volRec coil for  Tracker if this is a 
       coil which has a different volRec coil than the scanning coil */

    if (coilInfo_tgt[0].hubIndex != volRecCoilInfo_tgt[0].hubIndex)
    {
        if(FAILURE == CoilSwitchSetCoil(volRecCoilInfo_tgt[0], mon_run_setrcvportimm))
        {
            return FAILURE;
        }
        
        coilSwitched = PSD_ON;
    }

    monitor_core(1,0,0);

    for (view = -maxiters; (view <= 0) && (found == 0); view++)
    {
        if (data_counter == start_clock)
        {
            setscantimeauto();       /* HCSDM00425949 */
            setscantimestart();      /* start up the clock */
        }

        if(sprep_timing_flag == 1)
        {
            if( av == 0 )
            {
#if defined(MGD_TGT) && defined(PSD_HW)
                rspstarttimer();
#endif
            }
        }

        startseq(0, (SHORT)MAY_PAUSE); /* 3d oblique - changed slab to 0 - latha@mr */

        av++;
        data_counter++; 
        points++;

#ifdef PSD_HW
        if (av == navgs)
        {
#if defined(MGD_TGT) && defined(PSD_HW)
            if ( 1 == getSmartPrepFeedback(&smartprep_detected, &smartprep_signal) )
            {
                if(sprep_debug_flag == 1)
                {
                    printf("Signal = %f \n", smartprep_signal);
                }
             
                if(sprep_timing_flag == 1)
                {
                    roundtrip_time = rspreadtimer();
                    if( sprep_roundtrip_index < SPREP_NUM_TIMING_POINTS )
                    {
                        sprep_roundtrip_timing_array[sprep_roundtrip_index] = roundtrip_time;
                        sprep_roundtrip_index++;
                    }

                    if(max_roundtrip_time < roundtrip_time)
                    {
                        max_roundtrip_time = roundtrip_time;
                    }

                    if(min_roundtrip_time > roundtrip_time)
                    {
                        min_roundtrip_time = roundtrip_time;
                    }
                }
            }
#endif
            /* FOR MERGE */
            *datamaxptr = smartprep_signal;

            point = *datamaxptr;

            /* FOR MERGE */
            if (debug_sp_agp) printf("%7.3f\n",point);

            datamaxptr += numpts2pass;  
            total_points += numpts2pass;

            /* FOR MERGE */
            if (acq_data_only == 0)
            {
                found = smartprep_detected;
            }

            av = 0;
        }

        /* FOR MERGE */
        if (view == 0)
        {
            stopbit = 1;
        }

        /* rtpSimplePkt.rtpData.l is the subOpcode which will be read by the RTP App */
        rtpSimplePkt.rtpData.l = OP_SPREP_STOPBIT_VALUE;
        rtpSimplePkt.rtpData.f = (float)stopbit;

        status = RtpPsdForward(&rtpSimplePkt);

        if (status!=SUCCESS) {
            psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpPsdForward for stopbit failed",PSD_ARG_STRING,"Monitor:SmartPrep",0);
        }

#endif
    }   /* End monitor */

    setscantimestop();  /* stop the clock */

    test_flag = 1;

    /* MRIhc15304: If 'coilSwitched' is set then change the coil back to
     * imaging coil. 
     */ 

    if (PSD_ON == coilSwitched) {

        if(FAILURE == CoilSwitchSetCoil(coilInfo_tgt[0], mon_run_setrcvportimm))
        {
            return FAILURE;
        }

        coilSwitched = PSD_OFF;

        /* Change back to seq core after the coil switch */
        monitor_core(0,0,0);
    }

    /* Play out extra sequence to make sure that their is sufficient
       time after bolus detection */
    startseq(0, (SHORT)MAY_PAUSE);

    test_flag = 2;
    reset_for_scan();

    test_flag = 3;

    /* ATV - Quiet count down after bolus detection or time-out */

    /* Tell the scp about Autovoice Timing */
#ifdef PSD_HW
    broadcast_autovoice_timing(0, delay_quiet_time/1000, FALSE, TRUE);
#endif

    if (total_quiet_dda > 0)
    {
        /* FOR MERGE */
#ifdef PSD_HW
        setscantimeimm(PSD_CLOCK_NORM,mon_trigger_delay,piviews,pitslice,opslicecnt);
#endif
        setscantimestart();
        setscantimeauto();   /* return clock to auto */

        boffset(off_seqloopdelay2);
        for (j=0; j< total_quiet_dda; j++)
        {
            startseq((short)0,(SHORT)MAY_PAUSE);
            /*MRIhc05287*/
            if (j == 1) 
            {
                RtpEnd();
                isrtplaunched = 0;
            }
        }
        boffset(off_seqcore); 
    }

    execute_slice_loop((num_audibles*audible_loop),0);  /* flag to update slice */
    execute_slice_loop(ndelay0,1);  /* don't update slice */
    execute_slice_loop(ndelays,0);  /* update slice */

    /* FOR MERGE */
#ifdef PSD_HW
    setscantimeimm(pidmode,pitscan,piviews,pitslice,opslicecnt); /* reinit the clock time */
#endif
    setscantimestart();  /* restart the clock */
    setscantimeauto();   /* return clock to auto */

    return SUCCESS;
}
#endif /* !SPIRAL */
#endif /* NAV_EFGRE3D */
/**
 * gets Smartprep detected and signal from RTP App.  Detected and signal are 
 * unchanged if there is no new data available.
 *
 * @param[out] *detected - Pointer to the detected
 * @param[out] *signal - pointer to the signal 
 * @return 1 if new data available.  0 otherwise
 *
 */
int getSmartPrepFeedback(int * detected, float * signal)
{
    int nBytes = 0;
    SmartPrepResult rtpResult;
    n32 packed = 0;

#if defined(MGD_TGT) && defined(PSD_HW)
    nBytes = rtp_get_feedback_data(&rtpResult, sizeof(rtpResult), &packed, RTP_RESULT_SMART_PREP, RTP_QUEUE_OLDEST);
#endif

        if (nBytes > 0)        
        {
            if( packed == 1 )
            {
                n32 * packedResult = (n32*)(&rtpResult);
                /* Unpack feedback results */
                if((*packedResult & 0x08000000))
                {
                    *detected = 1;
                }
                else
                {
                    *detected = 0;
                }
                *signal = (float) (*packedResult & 0x07ffffff)/1000.0;

            }
            else
            {
                if(nBytes != sizeof(rtpResult) )
                {
                    RtpEnd(); 
                    psdexit(EM_PSD_ROUTINE_FAILURE,0,"","Failure in reading results",PSD_ARG_STRING,"monitor_signal:Monitor",0);
                }
                *detected = rtpResult.detected;
                *signal = rtpResult.signal;
            }
            return 1;
        }
        else
        {
            /* No new feedback data */
            return 0;
        }
}

/**
 * Entry point that allows the PSD to cleanup any unhandled items before
 * stopping acquisition.  MCT task performs a symbol lookup on this
 * function and calls it once the scan stops due an abort, crash, etc.
 *
 * @return the status after executing the cleanup:
 *         <ol>
 *         <li><code>EM_PSD_NO_ERROR</code> if the cleanup is successful</li>
 *         <li><code>EM_PSD_RTP_CLEANUP_FAILED</code> if there is an error
 *         ending the RTP application</li>
 *         </ol>
 */
n32 psdcleanup(n32 abort)
{
    n32 rv = EM_PSD_NO_ERROR;
    int rtpendstatus = 0;
    int rtpEndCalled = 0;

    /* Add the following code to clean the SmartPrep related
     * message when the user press the scan stop button.
     */
    if(smartprep_flag && sprep_monit)
    {
        if(isrtplaunched)
        {
            rsp_psd_err_clear(EM_SPCOPROC_SPU_ACQUIRE);
            rsp_psd_err_clear(EM_SPCOPROC_SPU_INJECT);
        }

        if(smartprep_detected != 1)
        {
            rsp_psd_err_clear(EM_SPCOPROC_SPU_NO_DETECT);
        }
        else
        {
            rsp_psd_err_clear(EM_SPCOPROC_SPU_DETECT);
        }
    }

    if(isrtplaunched)
    {
#ifdef NAV_EFGRE3D
        if((PSD_ON == opdynaplan) && (PSD_ON == opnav))
        {
            if(!phaseCompleted || abort || !rtp_mode_for_nav_dynaplan)
            {
                rtpendstatus = RtpEnd();
                rtpEndCalled = 1;
            }
            else
            {
                rtpendstatus = SUCCESS;
                rtpEndCalled = 0;
            }
        }
        else
        {
            rtpendstatus = RtpEnd();
            rtpEndCalled = 1;
        }
#else
        abort = 1; /* Dummy to avoid compilation failures in non EFGRE3D PSDs*/
        rtpendstatus = RtpEnd();
        rtpEndCalled = 1;
#endif

        if(rtpendstatus == SUCCESS)
        {
            if(rtpEndCalled)
            {
                isrtplaunched = 0;
            }
            rv = EM_PSD_NO_ERROR;
        }
        else
        {
            rv = EM_PSD_RTP_CLEANUP_FAILED;
        }
    }
    return rv;
}

/* *******************************************************************
   CardInit
   RSP Subroutine

   Purpose:
   To create an array of deadtimes for each slice/phase of the first
   pass in a cardiac scan.  For multi-phase scans, this same array can be
   used as the slices are shuffled in each pass to obtain new phases.

   Description: The logic for creating the deadtime array for
   multiphase scans is rather simple.  All of the slices except the last
   slice have the same deadtime.  This deadtime will assure that the
   repetition time between slices equals the inter-sequence delay time.
   The last slice has a deadtime that will run the logic board until the
   beginning of the cardiac trigger window.

   The logic for creating the deadtime for single phase, or cross R-R
   scans, is much more complicated.  In these scans, the operator
   prescribes over how many R-R intervals (1-4) the slices should be
   interleaved over.  The deadtimes for the last slice in each R-R
   interval will be different depending on whether the R-R interval is
   filled, unfilled, or the last R-R interval. For example, lets say 14
   slices are to be interleaved among 4 R-R intervals.  4 slices will be
   placed in the first R-R, 4 in the second, 3 in the third, and 3 in the
   fourth.  This prescription has 2 filled R-R intervals, 1 unfilled R-R
   interval, and a final R-R interval.  The deadtimes for slices which
   are not the last slice in a R-R interval is the same deadtime that
   assures that the inter-sequence delay time is met.

   Parameters:
   (O) int ctlend_tab[]  table of deadtimes
   (I) int ctlend_intern deadtime needed to maintain intersequence delay time.
   Delay when next slice will be internally gated.
   (I) int ctlend_last   Delay time for last slice in ophrep beats.  Deadtime needed
   to get proper trigger delay for next heart beat. 
   (I) int ctlend_fill   Dead time for filled R-R interval.  Not used in multi-phase
   scans. 
   (I) int ctlend_unfill Deadtime of last slice in an unfilled R-R interval.  Not used in
   multi-phase scans.
   *********************************************************************** */


/**************************  CardInit  *********************************/

#ifdef __STDC__
STATUS CardInit( INT ctlend_tab[], INT ctlend_intern, INT ctlend_last[], INT ctlend_fill[], INT ctlend_unfill[], INT subhacq,  INT subhrep, INT subphases)
#else /* !__STDC__ */
    STATUS CardInit(ctlend_tab, ctlend_intern, ctlend_last, ctlend_fill, ctlend_unfill)
    INT ctlend_tab[];   /* output table of deadtimes */
    INT ctlend_intern;  /* dead time for a slice when next slice will be
                           internally gated */
    INT ctlend_last[];    /* dead time of last temporal cardiac slice */
    INT ctlend_fill[];    /* dead time of last slice in a filled R-R interval */
    INT ctlend_unfill[];  /* dead time of a last slice in an unfilled R-R interval */
    INT subhrep;
    INT subhacq;
    INT subphases;

#endif /* __STDC__ */
{
    int rr = 0;  /* index for current R-R interval - 1 */
    int rr_end = 0; /* index for last slice in a R-R interval */
    int acq_cnt = 0; /* counter */
    int slice_cnt = 0; /* counter */
    int slice_quant = 0; /* number of slices */
    int prev_sum_slices_acq = 0; /* sum of slices till previous acq */
    int current_sum_slices_acq = 0; /* sum of slices till current acq */
    int current_acq = 0; /* index for current pass */
    int current_slices_acq = 0; /* current slices in current acq */
    int current_slices_rep = 0; /* current slices in current RR */
    int slices_rep_offset = 0; /* offset slices for current slice in current RR */

    /* Check for negative deadtimes and deadtimes that don't fall
       on GRAD_UPDATE_TIME boundaries */
    for (acq_cnt = 0; acq_cnt < subhacq; acq_cnt++)
    {
        if ((ctlend_intern < 0) || (ctlend_last[acq_cnt] < 0) || (ctlend_fill[acq_cnt] < 0) || (ctlend_unfill[acq_cnt] < 0)) 
        {
            psdexit( EM_PSD_SUPPORT_FAILURE, 0, "", "CardInit", 0 );
        }
    }

    ctlend_intern = RUP_GRD(ctlend_intern);

    for (acq_cnt = 0; acq_cnt < subhacq; acq_cnt++) 
    {
        ctlend_fill[acq_cnt] = RUP_GRD(ctlend_fill[acq_cnt]);
        ctlend_unfill[acq_cnt] = RUP_GRD(ctlend_unfill[acq_cnt]);
        ctlend_last[acq_cnt] = RUP_GRD(ctlend_last[acq_cnt]);
    }

    if (subphases > 1)
    {
        slice_quant = subphases;
    }
    else
    {
        slice_quant = opslquant;
    }

    for (slice_cnt=0; slice_cnt < slice_quant; slice_cnt++) 
    {
        if (subphases > 1) 
        { /* Multiphase */
            current_acq = 1; /* NOT support multi acq */
            if (slice_cnt == (slice_quant - 1))
            { /* next slice will be cardiac gated */
                ctlend_tab[slice_cnt] = ctlend_last[current_acq - 1];
            } 
            else
            { /* next slice will be internally gated */
                ctlend_tab[slice_cnt] = ctlend_intern;
            }
        } 
        else 
        {   /* Single phase, cross R-R */
            /* Initialize as if slice is NOT the last in a R-R */
            ctlend_tab[slice_cnt] = ctlend_intern; 

            if (slice_cnt  == current_sum_slices_acq)
            {
                current_acq += 1;
                /* Calculate # of slices in current acq */
                prev_sum_slices_acq = current_sum_slices_acq;
                if (current_acq <= slice_quant % subhacq)
                {
                    current_slices_acq = slice_quant/ subhacq + 1;
                }
                else
                {
                    current_slices_acq = slice_quant/ subhacq;
                }
                current_sum_slices_acq = prev_sum_slices_acq + current_slices_acq;

                slices_rep_offset = (current_slices_acq/ subhrep) * 
                    (current_slices_acq % subhrep) +
                    (current_slices_acq % subhrep);

                /* Calculate # of slices in current rep */
                if ( (current_slices_acq % subhrep != 0) && (0 < slices_rep_offset) )
                {
                    current_slices_rep = current_slices_acq/ subhrep + 1;
                }
                else
                {
                    current_slices_rep = current_slices_acq/ subhrep;
                }

                rr_end = current_slices_rep - 1;
            }

            if (slice_cnt == (slice_quant - 1)) 
            { /* last slice */
                ctlend_tab[slice_cnt] = ctlend_last[current_acq - 1];
            }
            else if ((current_slices_acq <= subhrep) && (slice_quant >= subhacq * subhrep))
            {  /* At most 1 slice in each R-R. Each
                  slice is the first and last in an R-R in single acq case*/
                ctlend_tab[slice_cnt] = ctlend_fill[current_acq - 1];
            }
            else 
            {
                if ((slice_cnt - prev_sum_slices_acq) == rr_end) 
                { /* This is the last slice in an R-R */
                    rr += 1; /* up the rr counter */
                    if ((rr > subhrep) ||
                            ((current_slices_acq < subhrep) && (rr > current_slices_acq)))
                    {
                        rr = 1;
                    } 

                    /* Decide whether to use filled deadtime or
                       unfilled deadtime. Also recalculate rr_end,
                       the index of last slice of the next R-R interval */
                    if (rr < current_slices_acq % subhrep) 
                    { /* This is a filled R-R interval and the next
                         will be filled also. */
                        ctlend_tab[slice_cnt] = ctlend_fill[current_acq - 1];
                        rr_end += (int)(current_slices_acq/ subhrep) + 1;
                    }
                    else if (rr == current_slices_acq % subhrep) 
                    { /* This R-R is filled but the next is not */
                        if ((current_slices_acq <= subhrep) && (slice_quant < subhacq * subhrep))
                        { /* Cross R-R with multi acq case. This is last slice in current acq */
                            ctlend_tab[slice_cnt] = ctlend_last[current_acq - 1];
                        }
                        else
                        {
                            ctlend_tab[slice_cnt] = ctlend_fill[current_acq - 1];
                            rr_end += (int)(current_slices_acq/ subhrep);
                        }
                    }
                    else
                    { /* rr > current_slices_acq % subhrep, 
                         This is an unfilled R-R interval */
                        ctlend_tab[slice_cnt] = ctlend_unfill[current_acq - 1];
                        rr_end += (int)(current_slices_acq/ subhrep);
                    }
                } 
            } 
        } 
    } 
    return SUCCESS;
}

/*******************************  MPS2  ***************************/
#ifdef __STDC__ 
STATUS mps2( void)
#else /* !__STDC__ */
    STATUS mps2() 
#endif /* __STDC__ */
{
    printdbg("Greetings from MPS2", debugstate);
    boffset(off_seqcore);
    rspent = L_MPS2;  
    rspdda = ps2_dda;

    if (cs_sat ==1)	/* Turn on Chemsat Y crusher */
        cstun=1;
    psdinit();
    strcpy(psdexitarg.text_arg, "mps2");
  
    rspent = L_MPS2;
    rspbas = 0;
    rspvus = 1;
    rspasl = pre_slice;
    rsprep = 30000;
    rspilv = 1;
    rspgy1 = 0;
    rspnex = 2;
    rspsct = 0;
    rspesl = -1;
    rspslqb = 0;
    rspslq = mux_flag?mux_slquant:false_slquant1;
    rspe1st = e1st;
    rspetot = etot;
    pass = pre_pass;

    if (ir_on == PSD_ON)  /* IR..MHN */
        setiamp(ia_rf0, &rf0, 0);


    rspgyc = 0;
    rspgzc = rspgyc;
    gyb_amp = 0;
    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    scanloop();
    printdbg("Normal End of MPS2", debugstate);
    rspexit();

    return SUCCESS;
} /* End MPS2 */

/*******************************  APS2  **************************/
#ifdef __STDC__ 
STATUS aps2( void )
#else /* !__STDC__ */
    STATUS aps2() 
#endif /* __STDC__ */
{
    printdbg("Greetings from APS2", debugstate);
    boffset(off_seqcore);
  
    rspent = L_APS2;
    rspdda = ps2_dda;
    if (cs_sat ==1)	/* Turn on ChemSat Y crusher */
	cstun = 1;
    psdinit();
 
    strcpy(psdexitarg.text_arg, "aps2");
  
    rspent = L_APS2;
    rspbas = 0;
    rspvus = 1;
    rspasl = -1;
    rsprep = 30000;
    rspilv = 1;
    rspgy1 = 0;
    rspnex = 2;
    rspsct = 0;
    rspesl = -1;
    rspslqb = aps2_rspslqb;
    rspslq = aps2_rspslq;
    rspe1st = e1st;
    rspetot = etot;
  
    rspacqb = pre_pass;
    rspacq  = pre_pass + 1;
    false_rspacqb = 0;
    false_rspacq = 1;
    rspprp = 1;

  
    if (ir_on == PSD_ON)
        setiamp(ia_rf0, &rf0, 0);

    rspgyc = 0;
    rspgzc = rspgyc;
    gyb_amp = 0;
    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    scanloop();
    printdbg("Normal End of APS2", debugstate);
    rspexit();
    return SUCCESS;
  
} /* End APS2 */

/***************************  SCAN  *******************************/
#ifdef __STDC__ 
STATUS scan( void )
#else /* !__STDC__ */
    STATUS scan() 
#endif /* __STDC__ */
{
    printdbg("Greetings from SCAN", debugstate);
    rspent = L_SCAN;
    rspdda = scan_dda;
    if (cs_sat == 1)	/* Turn on ChemSat Y crusher */
	cstun =1;
    psdinit();

    NoiseCalrcvn();

    /*RTB0 correction*/
    rtb0_initialized =0;

    rspbas = rhbline;   /* used on blineacq only */
    rspvus = rhnframes + rhhnover + rhoscans;
    rspasl = -1;
    rsprep = reps;
    rspgy1 = 1;
    rspnex = nex;
    rspsct = 0;
    rspesl = -1;
    rspslqb = 0;
    rspslq = rspslqb + (mux_flag?mux_slquant:false_slquant1);
    rspilv = intleaves;
    rspgyc = 0;
    rspgzc = rspgyc;

    if (ir_on == PSD_ON)
        setiamp(ia_rf0, &rf0, 0);


    if (rawdata == PSD_ON && baseline > 0) {  /* collect reference scan for rawdata */
	ygradctrl(rspgyc, gyb_amp, etl);
	scanloop();
    }
    if (gyctrl == PSD_ON)
	rspgyc = 1;
    else
	rspgyc = 0;
    rspgzc = rspgyc;
    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    if (PSD_ON == navtrig_flag)
    {
        if(!skip_navigator_prescan)
        {
            nav_rrmeas_end_flag = 0;
            navigator_baseline_prescan(&nav_rrmeas_end_flag);

            if(nav_rrmeas_end_flag)
            {
                int i;
                boffset(off_seqcore);
                setwamp(SSPDS + DABDC, &pass_pulse, 0);
                setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                setwamp(SSPDS + DABDC, &pass_pulse, 4);
                for (i=0; i<num_passdelay; i++) {
                    setperiod(1, &ssp_pass_delay, i);
                }
                startseq((short)0, (SHORT)MAY_PAUSE);
                rspexit();
            }
        }

        skip_navigator_prescan = 0;

#ifndef SIM
        setscantimestop();
        setscantimeimm(PSD_CLOCK_CARDIAC, pitscan, nreps*oprtrep, pitslice, opslicecnt);
        setscantimestart();
#endif

        num_slice_rr = (int)ceil((float)(rspslq)/oprtrep);

#ifndef SIM
        hbs_total = nreps*oprtrep;
        hbs_left = hbs_total;

        view_accepted = 0;
        view_rejected = 0;
#endif

        /* reset trigger status */
        nav_active = 0;
    }

    scanloop();

#ifdef PSD_HW
    if (PSD_ON == navtrig_flag || rtb0_flag) { /*RTB0 correction*/
        RtpEnd();
        isrtplaunched = 0;
        rtb0_initialized =0;
    }
#endif

    rspexit();
    return SUCCESS;
}

/***************************  REF  *******************************/
#ifdef __STDC__ 
STATUS ref( void )
#else /* !__STDC__ */
    STATUS ref() 
#endif /* __STDC__ */
{
    printdbg("Greetings from REF", debugstate);
    rspent = L_REF;
    rspdda = ref_dda; /* Refless EPI */
    if (cs_sat ==1)	/* Turn on ChemSat Y crusher */
	cstun=1;

    psdinit();

    rspbas = rhbline;   /* used on blineacq only */
    rspvus = rhnframes + rhhnover + rhoscans;
    rspasl = -1;
    rspgy1 = 1;
    rspnex = 1;
    rspsct = 0;
    rspesl = -1;
    rspgyc = 0;
    rspgzc = rspgyc;
    rspacqb = pre_pass;
    rspacq = pre_pass + 1;
    false_rspacqb = 0;
    false_rspacq = 1;
    rspslqb = pre_slice;
    rspslq = pre_slice + 1;
    rspprp = 1;
    rsprep = 1;

    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    if (ref_mode == 0 && rhpctemporal == 0) {
        rspacqb = 0;
        rspacq = act_acqs;
        false_rspacqb = 0;
        false_rspacq = false_acqs;
        rspslqb = 0;
        rspslq =  rspslqb + (mux_flag?mux_slquant:false_slquant1);
        if ( (mph_flag==1) && (acqmode==0) )
            rspprp = pass_reps;
        if ( (mph_flag==1) && (acqmode==1) )
            rsprep =  reps;
        rsprep = reps;
    } else if (ref_mode == 1 && rhpctemporal == 0) {
        rspacqb = pre_pass;
        rspacq = pre_pass + 1;
        false_rspacqb = 0;
        false_rspacq = 1;
        rspslqb = 0;
        rspslq = pre_slice+1;
        if ( (mph_flag==1) && (acqmode==0) )
            rspprp = pass_reps;
        if ( (mph_flag==1) && (acqmode==1) )
            rsprep =  reps;
        rsprep = reps;
    } else if (ref_mode == 2 && rhpctemporal == 0) {
        rspacqb = pre_pass;
        rspacq = pre_pass + 1;
        false_rspacqb = 0;
        false_rspacq = 1;
        rspslqb = pre_slice;
        rspslq = pre_slice+1;
        if ( (mph_flag==1) && (acqmode==0) )
            rspprp = pass_reps;
        if ( (mph_flag==1) && (acqmode==1) )
            rsprep =  reps;
        rsprep = reps;
    } else if (ref_mode == 0 && rhpctemporal != 0) {
        rspacqb = 0;
        rspacq = act_acqs;
        false_rspacqb = 0;
        false_rspacq = false_acqs;
        rspslqb =  0;
        rspslq = rspslqb + (mux_flag?mux_slquant:false_slquant1);
        rsprep = rhpctemporal;
    } else if (ref_mode == 1 && rhpctemporal != 0) {
	rsprep = rhpctemporal;
        rspacqb = pre_pass;
        rspacq = pre_pass + 1;
        false_rspacqb = 0;
        false_rspacq = 1;
        rspslqb = 0;
        rspslq = pre_slice+1;
    } else if (ref_mode == 2 && rhpctemporal != 0) {
        rspacqb = pre_pass;
        rspacq = pre_pass + 1;
        false_rspacqb = 0;
        false_rspacq = 1;
        rspslqb = pre_slice;
        rspslq = pre_slice+1;
    } else {
        return FAILURE;
    }

    if (rhpcileave == 0)
  	rspilv = intleaves;
    else
	rspilv = 1;

    if (PSD_ON == navtrig_flag)
    {
        if((!skip_navigator_prescan) && (PSD_OFF == calc_rate))
        {
            navigator_baseline_prescan(&nav_rrmeas_end_flag);
        }
        num_slice_rr = (int)ceil((float)(rspslq)/oprtrep);
    }

    /* HCSDM00153103 */
    if (PSD_OFF == calc_rate)
    {
        scanloop();
    }

    /* load current nav threshold and nav window in the next scan, when navigator prescan is skipped */
    /* HCSDM00176499 */
    if ((PSD_ON == navtrig_flag) && (PSD_OFF == calc_rate))
    {
        if(3 == nav_alg)
        {
            skip_navigator_prescan = 1;
            nav_prev_thresh = nav_currthresh;
            nav_prev_window = nav_currwindow;
        }

#ifdef PSD_HW
        RtpEnd();
        isrtplaunched = 0;
#endif
    }

    rspexit();
    return SUCCESS;
}

/* recv_phase_freq_init: Set receiver frequence and phase, including Maxwell correction */
STATUS recv_phase_freq_init(void)
{
    int ii, jj, kk;
    
    /* MRIge89403: added one more argument for EPI internal ref scan but set to 0 */
    /* RTB0 correction add 2 argument. slice_cfoffset_filtered[] is initialized to 0 at beginning of scanloop and updated when RTB0 is performed*/
    /* Distortion correction changes pepolar to rsp variable rsppepolar */
    epiRecvFrqPhs( opslquant, intleaves, etl, xtr-timedelta, refdattime, frt,
                   opfov, fullk_nframes,
                   opphasefov, b0ditherval, rf_phase_spgr, dro, dpo, rsp_info,
                   view1st, viewskip, gradpol, ref_switch, ky_dir, dc_chop,
                   rsppepolar, recv_freq, recv_phase_angle, recv_phase,
                   gldelayfval, a_gxw, debugepc, ref_with_xoffset,
                   asset_factor, iref_etl,
				   slice_cfoffset_filtered,eesp); /* MUSE use eesp instead of esp*/

    /* Call MaxwellCorrection Function (see epiMaxwellCorrection.e) */
    if (epiMaxwellCorrection() == FAILURE) return FAILURE;  /* this Maxwell correction only takes care of the      
                                                               parabolic shift due to maxwell related z2 B0 offset 
                                                               for axial plane */                                  
    
    /** save the nominal receiver phase angles to avoid the accumulative
        addition effect in the DWI B0-correction. The nominal phase is
        also used in HOEC Correction. **/
    for (ii=0; ii<opslquant; ii++)
    {
        for (jj=0; jj<intleaves; jj++)
        {
            for (kk=0; kk<tot_etl; kk++)
            {
                recv_phase_ang_nom[ii][jj][kk] = recv_phase_angle[ii][jj][kk];
            }
        }
    }

    return SUCCESS;
}

/* Refless EPI: scan_init() called in scan_loop() to switch back to scan with PE */
STATUS scan_init(void)
{
    rspent = L_SCAN;
    ref_switch = 0;

    recv_phase_freq_init();

    rspnex = nex;

    if (ir_on == PSD_ON) setiamp(ia_rf0, &rf0, 0);

    if (gyctrl == PSD_ON)
    {
        rspgyc = 1;
    }
    else
    {
        rspgyc = 0;
    }
    rspgzc = rspgyc;

    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    if (epi_flair == PSD_OFF)
    {
        dda_packe = dda_pack - 1;
    }

    return SUCCESS;
}

/* Refless EPI: ref_init() called in scan_loop() to switch the first pass of scan to ref without PE */
STATUS ref_init(void)
{
    rspent = L_REF;
    ref_switch = 1;

    recv_phase_freq_init();

    ref_switch = 0;

    rspnex = 1;
    
    rspgyc = 0;
    rspgzc = rspgyc;

    ygradctrl(rspgyc, gyb_amp, etl);

    if ( use_slice_fov_shift_blips && (PSD_ON == mux_flag) && (mux_slices_rf1 > 1) )
    {
        zgradctrl(0, 0, 0, etl, 0);
    }

    if (epi_flair == PSD_OFF)
    {
        dda_packe = dda_pack - 1;
    }

    return SUCCESS;
}

/*************************** SCANLOOP *******************************/
#ifdef __STDC__ 
STATUS scanloop( void )
#else /* !__STDC__ */
    STATUS scanloop() 
#endif /* __STDC__ */
{
    int pause; /* pause attribute storage loc */
    int i;
    char fname_coreinfo[255];
    char fname_diff_order[255];
#ifdef PSD_HW
    const char *dir_coreinfo = "/usr/g/service/log";
#else
    const char *dir_coreinfo = "./";
#endif

#ifdef DEBUG_CORE
    if (debug_core == PSD_ON)
    {
        sprintf(fname_coreinfo, "%s/EPI_coreinfo.log", dir_coreinfo);
        fp_coreinfo = fopen(fname_coreinfo, "w");
        if (fp_coreinfo == NULL)
        {
            return FAILURE;
        }
    }
#endif

    if (diff_order_debug == PSD_ON)
    {
        if(rspent == L_REF)
        {
            sprintf(fname_diff_order, "%s/EPI2_diff_order_ref.log", dir_coreinfo);
        }
        else if(rspent == L_SCAN)
        {
            sprintf(fname_diff_order, "%s/EPI2_diff_order_scan.log", dir_coreinfo);
        }
        else
        {
            sprintf(fname_diff_order, "%s/EPI2_diff_order_other.log", dir_coreinfo);
        }
        fp_diff_order = fopen(fname_diff_order,"w");
        if(fp_diff_order == NULL)
        {
            return FAILURE;
        }
    }

    /*RTB0 correction*/
    if (debug_unitTest == PSD_ON)
    {
        sprintf(fname_coreinfo, "%s/EPI2_LoopOrderUnitTest.log", dir_coreinfo);
        fp_utloopinfo = fopen(fname_coreinfo, "w");
        if (fp_utloopinfo == NULL)
        {
            return FAILURE;
        }
        else
        {
            fprintf(fp_utloopinfo,"Loop\t pass_rep\t pass\t dda_ind\t dda_fl_sl\t dda_sl\t core_rep\t ileave\t nex\t false_pass\t fl_sl\t sl\t \n");
        }
    }

    /*RTB0 correction*/
    if(rtb0_flag && rspent == L_SCAN && rtb0_debug)
    {
        time_t now_epoch = time(NULL);
        struct tm now; 
        int uid;
    
        localtime_r(&now_epoch, &now);
        uid = now.tm_sec +
              now.tm_min  * 100 +
              now.tm_hour * 10000 +
              now.tm_mday * 1000000 +
              (now.tm_mon +1) * 100000000;
        sprintf(fname_coreinfo, "%s/EPI2_sliceCF_data.%d", dir_coreinfo, uid);
        fp_cfdata = fopen(fname_coreinfo, "w");
        if (fp_cfdata == NULL)
        {
            return FAILURE;
        }

        fprintf(fp_cfdata, "slloc -> sltime\n");
        for(i=0; i<opslquant; i++)
            fprintf(fp_cfdata, "%d %d\n", i, slloc2sltime[i]);
        fprintf(fp_cfdata, "sltime -> slloc\n");
        for(i=0; i<opslquant; i++)
            fprintf(fp_cfdata, "%d %d\n", i, sltime2slloc[i]);
    }

    printdbg("Greetings from scanloop", debugstate);
    
    /*RTB0 correction*/
    for(i=0; i<DATA_ACQ_MAX; i++)
    {
        slice_cfoffset_TARDIS[i] = 0;
        slice_cfoffset[i] = 0.0;
        slice_cfoffset_filtered[i] = 0.0;
    }
    
    if (cs_sat == PSD_ON) 
	cstun = 1;
    
    setiamp(ia_rf1, &rf1, 0);   /* Reset amplitudes */
    if (oppseq == PSD_SE) {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
            setiamp(ia_rf2, &rf2, 0);
        } else {
            setiamp(ia_rf2, &rf2right, 0);
            setiamp(ia_rf2, &rf2left, 0);
        }
    }
    
    /* turning spatial & chem SAT on */ 
    SpSat_Saton(0);
    
    if (cs_sat > 0)  
	setiamp(ia_rfcssat, &rfcssat, 0);
    
    strcpy(psdexitarg.text_arg, "scan");
    
    if (opcgate==PSD_ON) {
#ifndef PSD_HW
	/* Don't check ecg rate in simulator mode. */
#else /* PSD_HW */
	if (test_getecg == PSD_ON) {
            getecgrate(&rsp_hrate);
            if (rsp_hrate == 0)
		psdexit(EM_PSD_NO_HRATE,0,"","psd scan entry point",0);
	}
#endif /* !PSD_HW */
	rsp_card_intern = ctlend + scan_deadtime;
    int acq_cnt = 0;
    for (acq_cnt = 0; acq_cnt < acqs; acq_cnt++)
    {
        rsp_card_last[acq_cnt]   = ctlend_last[acq_cnt] + scan_deadtime;
        rsp_card_fill[acq_cnt]   = ctlend_fill[acq_cnt] + scan_deadtime;
        rsp_card_unfill[acq_cnt] = ctlend_unfill[acq_cnt] + scan_deadtime;
    }

	CardInit(ctlend_tab, rsp_card_intern, rsp_card_last,
                 rsp_card_fill, rsp_card_unfill, act_acqs, ophrep, opphases);
    } else if (oprtcgate==PSD_ON){
#ifndef PSD_HW
	    /* Don't check ecg rate in simulator mode. */
#else /* PSD_HW */
        if (test_getecg == PSD_ON) {
            getresprate(&rsp_hrate);
            if (rsp_hrate == 0) {
                psdexit(EM_PSD_NO_RESP_RATE,0,"","psd scan entry point",0);
            }
        }
#endif /* !PSD_HW */
        rsp_card_intern = ctlend + scan_deadtime;
        int acq_cnt = 0;
        for (acq_cnt = 0; acq_cnt < acqs; acq_cnt++)
        {
            rsp_card_last[acq_cnt]   = ctlend_last[acq_cnt] + scan_deadtime;
            rsp_card_fill[acq_cnt]   = ctlend_fill[acq_cnt] + scan_deadtime;
            rsp_card_unfill[acq_cnt] = ctlend_unfill[acq_cnt] + scan_deadtime;
        }

        CardInit(ctlend_tab, rsp_card_intern, rsp_card_last,
                 rsp_card_fill, rsp_card_unfill, act_acqs, oprtrep, rt_opphases);
 
    } else
	setperiod(scan_deadtime, &seqcore, 0);
 
    inversRspRot(inversRR, rsprot_unscaled[0]); 

    /* DTI */    
    if (opdiffuse == PSD_ON || tensor_flag == PSD_ON) {

        /* DTI BJM: (dsp) set the instruction amplitude */
        if (PSD_OFF == dualspinecho_flag)
        {
/* granty changed setiampt to setiamp for custom waveforms */
            setiamp(0, &gxdl, 0);
            setiamp(0, &gxdr, 0);
            setiamp(0, &gydl, 0);
            setiamp(0, &gydr, 0);
            setiamp(0, &gzdl, 0);
            setiamp(0, &gzdr, 0);
        } else {
            setiampt(0, &gxdl1, 0);
            setiampt(0, &gxdr1, 0);
            setiampt(0, &gxdl2, 0);
            setiampt(0, &gxdr2, 0);
            
            setiampt(0, &gydl1, 0);
            setiampt(0, &gydr1, 0);
            setiampt(0, &gydl2, 0);
            setiampt(0, &gydr2, 0);

            setiampt(0, &gzdl1, 0);
            setiampt(0, &gzdr1, 0); 
            setiampt(0, &gzdl2, 0);
            setiampt(0, &gzdr2, 0);
        }
    }
    diff_pass_counter = 0;
    diff_pass_counter_save = 0;

    /* BJM: passreps control diffusion gradients */
    for (pass_rep = 0; pass_rep < rspprp; pass_rep++) 
    {
#ifdef DEBUG_CORE
        if (debug_core == PSD_ON)
        {
            fprintf(fp_coreinfo,"scanloop:pass_rep %d/%d\n", pass_rep, rspprp-1);
        }
#endif
        
        /* Refless EPI: make the first pass of scan as ref */
        if ((opdiffuse==PSD_ON || tensor_flag==PSD_ON) && (rspent != L_MPS2 && rspent != L_APS2))
        {
            /* for no ref 2 and 1 cases, first pass is initialized as ref scan without PE */
            if (ref_in_scan_flag)
            {
                if (pass_rep == 0)
                {
                    ref_init();
                }
                else if (pass_rep == 1)
                {
                    /* scan_init() only needs to be done once after the ref scan
                       because all remaining passes are scan passes */
                    scan_init();
                }
            }
	    
            /* RTB0 Correction*/
            /* Initialize RTB0 RTP communication*/
            /* dummy seq is played to avoid timeout error because sometimes */
            /* it takes time to load RTP variables for the first time*/ 
            /* RTP Init should happen after ref_init() or scan_init() depending*/
            /* on whether refless is ON & rtb0 mode*/
            if (rtb0_flag && !rtb0_initialized)
            {
                if ((ref_in_scan_flag && rtb0_flag && pass_rep == 0) ||
                   (!ref_in_scan_flag && pass_rep == 0))
                {	
                    play_rtb0dummyseq(1);
                    reset_to_epi2scan();

                    rtB0ComRspInit();
#ifdef PSD_HW
                    routeDataFrameDab(&rtb0echo, ROUTE_TO_RTP, cfcoilswitchmethod);
#endif
                    rtb0_initialized = 1;
                 }
            }
	
        }
        
        /* Distortion Correction. Note that ref scan or pass is defined rspent==L_REF.
           Therefore, invertGy1=-1 state will only happen for expected RPG pass.
           All other passes will have invertGy1=1. */
        if ((rpg_flag > 0) && (L_SCAN == rspent))
        {
            if (pass_rep > (ref_in_scan_flag?1:0)) 
            {   /* Not the first volume nor REF entry point */
                rsppepolar = (rpg_flag == RPG_FWD_THEN_REV) ? 1 : 0;
                invertGy1 = 1;
            }
            else 
            {   /* First volume. Do RPG here. */
                rsppepolar = (rpg_flag == RPG_FWD_THEN_REV) ? 0 : 1;
                invertGy1 = -1;
            }
            recv_phase_freq_init();
        }
        else
        {
            rsppepolar = pepolar;
            invertGy1 = 1;
        }

        /* Distortion Correction Unit Test */
        if ( (rpgUnitTestPtrSize > -1) && (pass_rep < rpgUnitTestPtrSize) && (NULL != rpgUnitTestPtr) )
        {
            rpgUnitTestPtr[pass_rep] = rsppepolar;
        }

        if ((opdiffuse == 1 && incr == 1) || (tensor_flag == PSD_ON)) 
        {
            /* BJM: increment diffusion gradients */ 
            /* RPG change setting dshot here */
            diffstep(pass_rep - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
        }

        diff_pass_counter_save = diff_pass_counter;

        for (pass = rspacqb; pass < rspacq; pass++) 
        {
#ifdef DEBUG_CORE
            if (debug_core == PSD_ON)
            {
                fprintf(fp_coreinfo,"scanloop:acq %d/%d\n", pass, rspacq-1);
            }
#endif
 
            pass_index = pass + pass_rep*rspacq;
            
            if (pass_index < rspacq)  {   /* MRIge57446: acquire baselines for the 1st rep of first pass */
                if (baseline > 0) {                     /* acquire the baseline */
                    if (baseline > 1)  /* play first n-1 baselines at fast rate */
                        setperiod(bl_acq_tr1, &seqblineacq, 0);
                    else
                        setperiod(bl_acq_tr2, &seqblineacq, 0);
                    blineacq();
                }
            }

            if (PSD_ON == oprtcgate)
            {
                rspslq = slc_in_acq[pass];
            }
            else if (PSD_ON == navtrig_flag)
            {
                rspslq = slc_in_acq[pass];
                num_slice_rr = (int)ceil((float)(rspslq)/oprtrep);
            }
            
            boffset(off_seqcore);
            
            setperiod(scan_deadtime, &seqcore, 0);
            
            /* initialize wait time and pass packet for disdacqs, etc. */
            setwamp(SSPDS, &pass_pulse, 0);
            setwamp(SSPD, &pass_pulse, 2);
            setwamp(SSPDS, &pass_pulse, 4);
            for (i=0; i<num_passdelay; i++) 
                setperiod(1, &ssp_pass_delay, i);
            pause = MAY_PAUSE;
            printdbg("Null ssp pass packet", debugstate);
            diff_pass_counter = diff_pass_counter_save;
            core();                                 /* acquire the data */
            
            settriggerarray((SHORT)1, rsptrigger_temp);
            
            /* Return to standard trigger array and core offset */
            settriggerarray((SHORT)(opslquant*opphases), rsptrigger);
            
            /* If this isn't the last pass and we are */
            /* doing relaxers  */
            if ((SatRelaxers)&&( (pass!=(rspacq-1)) && (pass_rep!=(rspprp-1)) ) )
                SpSatPlayRelaxers();
            
        } /* End pass loop */    
    } /* End pass rep loop */
    
#ifdef DEBUG_CORE
    if (debug_core == PSD_ON)
    {
        fclose(fp_coreinfo);
    }
#endif
    if (debug_unitTest == PSD_ON)
    {
        fclose(fp_utloopinfo);
    }
    /*RTB0 correction*/
    if(rtb0_flag && rspent == L_SCAN && rtb0_debug)
    {
        fclose(fp_cfdata);
    }

    if (diff_order_debug == PSD_ON)
    {
        fclose(fp_diff_order);
    }
    printdbg("Normal End of SCAN", debugstate);
    return SUCCESS;
    
} /* End SCANLOOP */

/*****************************  CORE  *************************/
#ifdef __STDC__ 
STATUS core( void )
#else /* !__STDC__ */
    STATUS core() 
#endif /* __STDC__ */
{
    int pause = MAY_PAUSE;
    int InterPassDoneFlag = 0;
    int disdaq_index;
    int i; 
    int tmpi;

    /* t1flair_stir */
    int real_slice_IR;
    int slice_flag;

    /*RTB0 correction*/
    int first_rtb0_sliceindex;
    int last_rtb0_sliceindex;
    int cf_counter;
    int num_wait;

#if defined(MGD_TGT) && defined(PSD_HW)
    struct timespec tim;
    double t1, t2;
#endif


    /*RTB0 correction*/
    int dda_in_pass_rep; /*indicate which pass_rep should play the disdaq block if rspdda > 0*/
    int dda_rtb0 = 0; /*additional TR for RTB0*/
 
#ifdef PRINTRSP
    printdbg("Starting Core", debugstate);
#endif  

    /* t1flair_stir */ 
    if ( (PSD_ON == t1flair_flag) && (PSD_ON == act_edge_slice_enh_flag) )
    {
        T1flair_calc_edgeslice_freq_pha();
    }

    /* MRIge44963 - Check if there is two more slices in the first pack, Hou */
    /* MRIge48302 - because the number of slices in L_REF is not the same as */
    /* L_SCAN, so that the slq_to_shift could be 1 even there is no need to */
    /* shift a slice.  Exclude this case by adding L_SCAN to the if. */  
    
    slq_to_shift = 0;
    if ( (epi_flair) &&
         ((rspent == L_SCAN) || ((rspent == L_REF) && (ref_in_scan_flag == PSD_ON))) )
    {
        if ( (2*rspslq - slc_in_acq[pass_index]) == false_acqs )
            slq_to_shift = 1;
        else
            slq_to_shift = 0;
    }
    
    /******* disdaq block ***********************************/
    /* Refless EPI: Play dda in T2 loop (pass_rep = 1) for DW-EPI Flair */
    /*RTB0 correction: Clean up the code. Basically, if ref_in_scan_flag is ON, */
    /*then in L_REF, if rtb0 is ON, then go into dda loop so the first dda (-1) can be used for rtb0. */
    /*In L_SCAN, don't play dda except when epi_flair is ON*/
    /*and the dda (if played) should be played in pass_rep = 1 (L_SCAN). */
    /*If ref_in_scan_flag is OFF, then play dda as usual (ie. in pass_rep = 0). */
    /*-1 means don't play dda*/    
    if (ref_in_scan_flag == PSD_ON)
    {
        if (rspent == L_SCAN)
            dda_in_pass_rep = (epi_flair == PSD_ON)? 1:-1; 
        if (rspent == L_REF) 
            dda_in_pass_rep = (epi_flair == PSD_OFF || rtb0_flag == PSD_ON)? 0:-1; 
    } 
    else 
    {
        dda_in_pass_rep = 0;
    }

    if ((rspdda > 0 || rtb0_flag) && (pass_rep == dda_in_pass_rep)){

        acq_data = (int)DABOFF;
        dabrbaload(0, 0, 0, tot_etl, 0);

        setperiod((int)tf[0], &wgx, 0);
        setperiod((int)tf[0], &wgy, 0);
        setperiod((int)tf[0], &wgz, 0);
        setperiod((int)tf[0], &wssp, 0);
        setperiod((int)tf[0], &womega, 0);      /* ufi2_ypd */

        if (rspent == L_REF)
        {
            zgradctrl(0, 0, 0, etl, 0);
        }

        if (gyctrl == PSD_ON && rspent != L_REF &&
            rspent != L_MPS2 && rspent != L_APS2) {
            setiampt(invertGy1*gy1f[0], &gy1, 0);
            if (ygmn_type == CALC_GMN1) {
                setiampt(gymn[0], &gymn1, 0);
                setiampt(-gymn[0], &gymn2, 0);
            }
        }

        acq_sl = 0;
        attenlockon(&atten);

        use_sl = 0;


        cf_counter = 0; /*RTB0 correction*//*move this here for STIR cases, otherwise, the cf_counter would be reset to 0 after the first dda (1 slice only), and that will mess up the indexing relationship between cf_counter & processedIndex*/
        dda_rtb0 =0;
       
        /*RTB0 correction: add an extra dda for RTB0 data collection. This dda will be indexed as -1*/
        if (rtb0_flag && pass ==0)
        {
            if ((ref_in_scan_flag == PSD_ON && rspent == L_REF) ||
               (ref_in_scan_flag == PSD_OFF && rspent == L_SCAN))
            {
                dda_rtb0 = 1;
            }
        }
 
        for (disdaq_index = dda_packb-dda_rtb0; disdaq_index < dda_packe; disdaq_index++)
        {
#ifdef DEBUG_CORE
            if (debug_core == PSD_ON)
            {
                fprintf(fp_coreinfo,"core:dda:%d/%d\n", disdaq_index, dda_packe-1);
            }
#endif

	    /*RTB0 correction: determine whether to play rtb0 related things*/
	    if (dda_rtb0 != 0 && disdaq_index==(dda_packb-dda_rtb0))
	    {
                in_rtb0_loop = 1;
	    }
	    else
	    {
                in_rtb0_loop = 0;
	    }
	
	    /*RTB0 correction*/
	    if (rtb0_flag)
	    {
                if(in_rtb0_loop ==1)
                {	
                    attenlockoff(&atten);
                    if(pscR1-rtb0_r1_delta > 0)
                    {
                        set_dynr1(pscR1-rtb0_r1_delta); 
        	        /* this only works on DV. need to change on HD */
                    }
                    setiampt(freqSign*ia_gz1, &gz1, 0);
                }	
                else
                {
                    attenlockon(&atten);
                    setiampt(0, &gz1, 0);
                }	
            }	

            if (epi_flair && rspent == L_SCAN) 
            {
                /* MRIge81039  NU */
                setrotatearray((SHORT)(opslquant*opphases),rsprot_orig[0]);

                /* MRIge44963 - need to subtract slq_to_shift from rspslq, HOU */
                for (false_slice = rspslqb; false_slice < rspslq-slq_to_shift; false_slice++) 
                {
#ifdef DEBUG_CORE
                    if (debug_core == PSD_ON)
                    {
                        fprintf(fp_coreinfo,"core:dda_inv:slice:%d/%d\n", false_slice, rspslq-slq_to_shift-1);
                    }
#endif
                    printdbg("Starting Interleaved Inversion", debugstate);
                    boffset(off_seqinv);
                    
                    slice_tmp = false_slice + (rspslq-slq_to_shift);
                    if (slice_tmp<slc_in_acq[pass_index]) {
                        slice = slice_tmp;
                        setiamp(ia_rf0, &rf0, false_slice);
                    }
                    else    
                    {
                        slice = 0;
                        setiamp(0, &rf0, false_slice);
                    } 

                    if (rspesl == -1)
                    {    
                        if (acqmode==0) /* interleaved */
                            sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                        if (acqmode==1) /* sequential */
                            sliceindex = acq_ptr[pass_index];
                    }
                    else
                        sliceindex = acq_ptr[pass_index] + rspesl;
                    
                    /* Load Transmit Frequencies */
                    setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, false_slice);
                    /* setfrequency(rf0_freq[sliceindex], &rf0, 0); */
                    /*	setiphase(rf0_pha[sliceindex], &rf0, 0); */
                      
                    /* MRIge81039  NU */
                    if ((rspent== L_CFH) || (rspent == L_CFL))
                        setrotatearray((SHORT)(opslquant*opphases),rsprot_orig[0]);
                    else
                        setrotatearray((SHORT)(opslquant*opphases),rsprot[0]);

                } /*IR prep */
                
                startseq((short)sliceindex, (SHORT)MAY_PAUSE);
                
                if (debug_unitTest)
                    fprintf(fp_utloopinfo,"%s\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t \n", "dda_flair:", pass_rep, pass, disdaq_index, false_slice, -1, -1,-1, -1,-1,-1,-1);
            } /*epi_flair*/
            
            boffset(off_seqcore); /* switch back to core seq */

            /* t1flair_stir */
            if (PSD_ON == t1flair_flag)
            {
                if ((disdaq_index == dda_packb) && dda_t1flair)
                {
                    rspslq = slquant_in_ti;
                }
                else
                {
                    rspslq = false_slquant1;
                }
            }
            
            /* MRIge44963 - need to subtract slq_to_shift from rspslq, HOU */
            for (false_slice = rspslqb; false_slice < rspslq-slq_to_shift; false_slice++) 
            { 
#ifdef DEBUG_CORE
                if (debug_core == PSD_ON)
                {
                    fprintf(fp_coreinfo,"core:dda_img:slice:%d/%d\n", false_slice, rspslq-slq_to_shift-1);
                }
#endif               

                if ((PSD_ON == navtrig_flag) && (PSD_OFF == calc_rate) && ((L_REF == rspent) || (L_SCAN == rspent)) &&
                    (false_slice % num_slice_rr == 0))
                {
                    NavigatorPlayTrig();
#ifndef SIM
                    if ((rspent == L_REF) && (ref_in_scan_flag == PSD_ON))
                    {
                        scantime = (60000000/ (float)oprtrate) * (float)hbs_left;
                        setscantimestop();
                        setscantimeimm(PSD_CLOCK_CARDIAC, scantime, hbs_left,pitslice,opslicecnt);
                        setscantimestart();
                    }
#endif
                }

                if(epi_flair)
                {  
                    slice_tmp = false_slice + (rspslq-slq_to_shift);
                }
                else
                {
                    slice_tmp = false_slice;
                }
                if (slice_tmp<slc_in_acq[pass_index]) 
                    slice = slice_tmp;
                else
                    slice = 0;   


                slice1 = slice;

                if (rspesl == -1)
                {
                    if (acqmode==0) /* interleaved */
                        sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                    if (acqmode==1) /* sequential */
                        sliceindex = acq_ptr[pass_index];
                }
                else
                    sliceindex = acq_ptr[pass_index] + rspesl;

                /* Set cardiac delays and end times */
                if (opcgate || oprtcgate) {

                    /* Build the trigger for multi-slice, multi-phase cardiac */
                    msmpTrig();

                    if ((rspent == L_SCAN)||(rspent == L_MPS2) 
                        ||(rspent == L_APS2)||(rspent == L_REF))
                        setperiod(ctlend_tab[sliceindex],&seqcore ,0);

                    /*  first slice in RR */
                    if (rsptrigger[sliceindex] != TRIG_INTERN) {	
                        if ((rspent == L_SCAN)||(rspent == L_MPS2)
                            ||(rspent == L_APS2)) {
                            /* Use cardiac trigger delay */
                            setperiod(td0, &x_td0, 0);
                            setperiod(td0, &y_td0, 0);
                            setperiod(td0, &z_td0, 0);
                            setperiod(td0, &rho_td0, 0);
                            setperiod(td0, &theta_td0, 0);
                            setperiod(td0, &omega_td0, 0);
                            setperiod(td0, &ssp_td0, 0);
                        }
                    } else {
                        /* Bypass cardiac trigger delay */
                        setperiod((int)GRAD_UPDATE_TIME, &x_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &y_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &z_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &rho_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &theta_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &omega_td0, 0);
                        setperiod((int)GRAD_UPDATE_TIME, &ssp_td0, 0);
                    }
                } /* if opcgate */

                /* t1flair_stir */
                if (PSD_ON == t1flair_flag)
                {
                    real_slice_IR = 0;
                    slice_flag = IMGSLICE;
                    sliceindex = (false_slice + slquant_in_ti)%rspslq + acq_ptr[pass_index];
                    if ( (dummyslices >= 0) || (act_edge_slice_enh_flag == PSD_ON) )
                    {
                        real_slice_IR =  real_slice_acq_seq[pass][(false_slice + slquant_in_ti)%rspslq];
                        sliceindex = acq_ptr[pass_index] + real_slice_IR;
                        slice_flag = T1flair_slice_flag[pass][(false_slice + slquant_in_ti)%rspslq];
                    }
                    sliceindex %= opslquant; 

                    if (slice_flag == EDGESLICE)
                    {
                        if (real_slice_IR == edgeslice1)
                        {
                            setfrequency(freqSign*edgeslice1freq+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                            setiphase(edgeslice1pha, &rf0, 0);
                        }
                        else
                        {
                            setfrequency(freqSign*edgeslice2freq+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                            setiphase(edgeslice2pha, &rf0, 0);
                        }
                        setiamp(ia_rf0, &rf0, 0);
                    }
                    else if (slice_flag == IMGSLICE)
                    {
                        setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                        setiphase(rf0_pha[sliceindex], &rf0, 0);
                        setiamp(ia_rf0,&rf0,0);
                    }
                    else
                    {
                        setiamp(0,&rf0,0);
                    }

                    /* t1flair_stir: the imaging sequence's sliceindex,
                     * slice_flag, etc.
                     */
                    slice = real_slice_acq_seq[pass][false_slice];
                    sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                    sliceindex1 = sliceindex; 
                    slice_flag = T1flair_slice_flag[pass][false_slice];

                    /*RTB0 correction*/
                    if(rtb0_flag && dda_t1flair)
                    {
                        if (in_rtb0_loop == 1 && false_slice < rspslq)  
                        {
                            if (ss_rf1 == PSD_ON)
                            {
                                /* need to turn off rf0 to have enough signal for CF offset measurement */
                                setiamp(0,&rf0,0);
                                if (rtb0_gzrf0_off)
                                {
                                    setiampt(0, &gzrf0, INSTRALL); 
                                }
                            }
                        }
                    }
                }
                else if (slice_tmp<slc_in_acq[pass_index])
                {   /* live slice */
                    if (!aspir_flag)
                    {
                        /* turn on RHO BOARD */
                        setieos((SHORT)EOS_PLAY, &rho_td0, 0);
                    }
                    else
                    {
                        /* turn on RHO BOARD */
                        setieos((SHORT)EOS_PLAY, &rf1, 0);
                    }
                    use_sl = 1;
                }
                else {
                    /* Dummy slice */
                    /* turn off RHO BOARD */
                    if (!aspir_flag)
                    {
                        setieos((SHORT)EOS_DEAD, &rho_td0,0);
                    }
                    else
                    {
                        /* play ASPIR rf only */
                        setieos((SHORT)EOS_DEAD, &rf1,0);
                    }
                    use_sl = 0;
                    if (rspesl == -1) {
                        sliceindex = (acq_ptr[0])%opslquant;
                        sliceindex1 = (acq_ptr[0])%opslquant;
                    }
                }

                if (epi_flair) {
                    /* MRIge44963 - need to subtract slq_to_shift so that the last slice in a pack */
                    /* can have longer deadtime (scan_deadlast) to prevent cross talk from IR pulse, HOU */
                    if (false_slice == rspslq-1-slq_to_shift)
                        setperiod(scan_deadlast,&seqcore,0); 
                    else
                        setperiod(scan_deadtime,&seqcore,0);
                }

                SpSatUpdateRsp(1, pass_index, opccsat);

                if( (PSD_ON == irprep_flag) && (t1flair_flag != PSD_ON) )
                {
    { /* Start of code inlined from Inversion.e InversionRSPcore */
        if (ir_on == PSD_ON)
        {
            /* Load Transmit Frequency */
	    /* MF B0 correction */
	    setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
            setiphase(rf0_pha[sliceindex], &rf0, 0);
        }
    } /* End of code inlined from Inversion.e InversionRSPcore */
                }    

                /* t1flair_stir */
                /* Play the IR rf pulses for the 1st excitation if T1FLAIR is on,
                   and turn off the rf1 and rf2 rf pulses. The data acquisition has
                   been  turn off. */
                if( (PSD_ON == t1flair_flag) &&
                    ( (slice_flag != IMGSLICE) ||
                      ( (disdaq_index == dda_packb) && (dda_t1flair) )
                    )
                  )
                {
                    setiamp(0, &rf1, 0);
                    if (oppseq == PSD_SE) /* DTI */
                    {
                        if (PSD_OFF == dualspinecho_flag)
                        {
                            setiamp(0, &rf2, 0);
                        }
                        else
                        {
                            setiamp(0, &rf2right, 0);
                            setiamp(0, &rf2left, 0);
                        }
                    }
                }
                else
                {
                    if (ssRsp() == FAILURE) return FAILURE;

                    setiamp(ia_rf1, &rf1, 0);

                    if (rfov_flag)
                    {
                        /* SVBranch: HCSDM00259122  - FOCUS walk sat */
                        if (walk_sat_flag) setrfwk();
                        
                        setfrequency(0, &rf1, 0);
                        setthetarf1(sliceindex); /* control frequency through theta wave */
                    }
                    else
                    {
                        setfrequency(freqSign*rf1_freq[sliceindex] + d_cf+slice_cfoffset_TARDIS[sliceindex], &rf1, 0);
                    }

                    if (sliceindex == 0) {
#ifdef DEBUG_CORE
                        if (debug_core == PSD_ON)
                        {
                            fprintf(fp_coreinfo,"DDA: Phase cycle number %d\n",(core_rep+reps*pass_rep));
                        }
#endif
                        if (mux_flag && mux_slices_rf1 > 1) {
                            if (phase_cycle_rf2) {
                                setwave( ptr_rf1[0], &rf1, 0);
                                if( opdualspinecho == PSD_OFF) {
                                    setwave( ptr_rf2[0], &rf2, 0);
                                } else {
                                    setwave( ptr_rf2[0], &rf2left,  0);
                                    setwave( ptr_rf2[0], &rf2right, 0);
                                }
                            }
                        }
                    }

                    if (oppseq == PSD_SE) /* DTI */
                    {
                        if (PSD_OFF == dualspinecho_flag)
                        {
                            if (mux_flag && verse_rf2) {
                                if (use_omegatheta) {
                                    setfrequency(0, &rf2, 0);
                                    setiamp(freqSign*max_pg_iamp, &th_omthrf2, 0);
                                    setiamp(freqSign*om_iamp_omthrf2[sliceindex], &om_omthrf2, 0);
                                    setwave(om_wave_omthrf2[sliceindex], &om_omthrf2, 0);
                                    setwave(th_wave_omthrf2[sliceindex], &th_omthrf2, 0);
                                } else if (thetarf2_flag == PSD_OFF) {
                                    setfrequency(freqSign*rf2_freq[sliceindex], &rf2, 0);
                                    setiamp(0, &thetarf2, 0);
                                } else {
                                    setiamp(freqSign*thetarf2_freq[sliceindex],&thetarf2,0);
                                    setfrequency(0, &rf2, 0);
#ifdef DEBUG_CORE
                                    if (debug_core == PSD_ON)
                                    {
                                        fprintf(fp_coreinfo,"FM: thetarf2_freq[%d]=%d\n",sliceindex,freqSign*thetarf2_freq[sliceindex]);
                                    }
#endif
                                }
                            } else {
                                setfrequency(freqSign_rf2*rf2_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf2, 0);
                            }
                            setiphase(rf2_pha[sliceindex], &rf2, 0);
                            setiamp(ia_rf2, &rf2, 0);
                        } else {
                            if (mux_flag && verse_rf2) {
                                if (use_omegatheta) {
                                    setfrequency(0, &rf2left, 0);
                                    setfrequency(0, &rf2right, 0);
                                    setiamp(freqSign_rf2left*max_pg_iamp, &th_omthrf2left, 0);
                                    setiamp(freqSign_rf2right*max_pg_iamp, &th_omthrf2right, 0);
                                    setiamp(freqSign_rf2left*om_iamp_omthrf2left[sliceindex], &om_omthrf2left, 0);
                                    setiamp(freqSign_rf2right*om_iamp_omthrf2right[sliceindex], &om_omthrf2right, 0);
                                    setwave(om_wave_omthrf2left[sliceindex], &om_omthrf2left, 0);
                                    setwave(om_wave_omthrf2right[sliceindex], &om_omthrf2right, 0);
                                    setwave(th_wave_omthrf2left[sliceindex], &th_omthrf2left, 0);
                                    setwave(th_wave_omthrf2right[sliceindex], &th_omthrf2right, 0);
                                } else if (thetarf2_flag == PSD_OFF) {
                                    setfrequency(freqSign_rf2left*rf2_freq[sliceindex], &rf2left, 0);
                                    setiamp(0, &thetarf2left, 0);
                                    setfrequency(freqSign_rf2right*rf2_freq[sliceindex], &rf2right, 0);
                                    setiamp(0, &thetarf2right, 0);
                                } else {
                                    setiamp(freqSign_rf2right*thetarf2_freq[sliceindex],&thetarf2right,0);
                                    setiamp(freqSign_rf2left*thetarf2_freq[sliceindex],&thetarf2left,0);
                                    setfrequency(0, &rf2right, 0);
                                    setfrequency(0, &rf2left, 0);
                                }
                            } else {
                                setfrequency(freqSign_rf2right*rf2_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf2right, 0);
                                setfrequency(freqSign_rf2left*rf2_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf2left, 0);
                            }
                            setiphase(rf2right_pha[sliceindex1], &rf2right , 0);
                            setiphase(rf2left_pha[sliceindex1],&rf2left , 0);
                            setiamp(ia_rf2, &rf2right, 0);
                            setiamp(ia_rf2, &rf2left, 0);
                        }
                    }
                } 

                /*RTB0 correction*/
                if (rtb0_flag)
                {
                    if (in_rtb0_loop == 1 && slice_tmp < slc_in_acq[pass_index])
                    {
                        loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ACQON);
                        loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABON, PSD_LOAD_DAB_ACQON_RBA);
                    }
                    else
                    {
                        loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ALL);
                    }
                }

                printdbg("D", debugstate);
                sp_sat_index = sliceindex;

		startseq((short)sliceindex, (SHORT)MAY_PAUSE);
		
                if (debug_unitTest)
                    fprintf(fp_utloopinfo,"%s\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t \n", "dda:", pass_rep, pass, disdaq_index, -1, false_slice, -1,-1, -1,-1,-1,-1);

                /*RTB0 correction*/
                /*Acquired FID and RTP will return cfoffset & fidmean*/
                if (in_rtb0_loop == 1 && (slice_tmp < slc_in_acq[pass_index] || (t1flair_flag == PSD_OFF && use_sl == 1)))
                {
                    if (rtb0_debug)
                    { 
                        fprintf(fp_cfdata, "core: cf_counter%d, rtb0_processed_index %d\n", cf_counter, rtb0_processed_index);
                    }

                    num_wait =1;

#if defined(MGD_TGT) && defined(PSD_HW)
    if (PSD_ON == rtb0_timing_flag)
    {
        rspstarttimer();
    }
#endif

                    play_rtb0resultwaitseq(1);


#if defined(MGD_TGT) && defined(PSD_HW)
                    while(cf_counter == rtb0_processed_index)	
                    {							
                        if (0==getRTB0Feedback(&rtb0_processed_index, &rtb0_cfoffset, &rtb0_fidmean, &rtb0_cfstddev, &rtb0_cfresidual))
                        {
                            /* No feedback available.  Play dummy pulse to 
                            prevent EOS errors while waiting for result */
                            num_wait++;
                            startseq((SHORT)0, (SHORT)MAY_PAUSE);
                        }/*end if*/

                        if( (PSD_OFF == rtb0_debug) && (0 == rtb0DebugFlag) && (0 == rtb0SaveRaw) && (1500 < num_wait * rtb0resultwaittime) ) 
                        {
                            printdbg("Warning: Could not receive Feedback from RTP within 1.5ms in getRTB0Feedback", 1);
                            rtb0_cfoffset = 0;
                            rtb0_fidmean = 0;
                            rtb0_cfstddev = rtb0_cfstddev_threshold*2; /*ensure this data point is not used*/
                            rtb0_cfresidual = rtb0_cfresidual_threshold*2; /*ensure this data point is not used*/
                            printf("getRTB0Feedback Timeout, rtb0_cfoffset %f\n", rtb0_cfoffset);
                            break; /*If timeout, break from the while loop*/
                        }
                    }                					

                    /*Forcing CF offset to be a user defined value*/
                    /*for debugging/formal verification purpose*/
                    if (rtb0_debug && !floatsAlmostEqualEpsilons(rtb0_cfoffset_debug, 0.0, 2))
                    {
                        rtb0_cfoffset = rtb0_cfoffset_debug;
                    }

#else

                    rtb0_cfoffset = 10;
                    rtb0_fidmean = 100;
                    rtb0_cfstddev = 50;
                    rtb0_cfresidual = 10;
#endif

#if defined(MGD_TGT) && defined(PSD_HW)
    if (PSD_ON == rtb0_timing_flag)
    {
        rtb0_feedback_time = rspreadtimer();
        printf("feedback time =%ld\n", rtb0_feedback_time);

        if(rtb0_roundtrip_index < RTB0_NUM_TIMING_POINTS)
        {
            rtb0_roundtrip_timing_array[rtb0_roundtrip_index] = rtb0_feedback_time;
            rtb0_roundtrip_index++;
        }

        if (max_rtb0_feedback_time < rtb0_feedback_time)
        {
            max_rtb0_feedback_time = rtb0_feedback_time;
        }

        if (min_rtb0_feedback_time > rtb0_feedback_time)
        {
            min_rtb0_feedback_time = rtb0_feedback_time;
        }

        rtb0_num_frames_processed = rtb0_processed_index;
        sum_rtb0_feedback_times = sum_rtb0_feedback_times + rtb0_feedback_time;
     }
#endif


                    slice_cfoffset[sliceindex] = rtb0_cfoffset;
                    slice_fidmean[sliceindex] = rtb0_fidmean;
                    slice_cfstddev[sliceindex] = rtb0_cfstddev;
                    slice_cfresidual[sliceindex] = rtb0_cfresidual;
			 
                    if (rtb0_debug)
                    {
                        fprintf(fp_cfdata,"core: While loop: pass_rep=%d,pass=%d,dda=%d/%d, false_slice=%d, num_wait=%d\n",pass_rep, pass, disdaq_index, dda_packe-1, false_slice, num_wait);
                        fprintf(fp_cfdata,"core: While loop: slice_cfoffset[%d]=%7.2f, slice_fidmean = %f, slice_cfstddev=%f, slice_cfresidual=%f\n", sliceindex, slice_cfoffset[sliceindex], slice_fidmean[sliceindex], slice_cfstddev[sliceindex], slice_cfresidual[sliceindex]);
                    }

                    reset_to_epi2scan();

                    /*RTB0 correction*/
                    /*Reject noise if CF offset is greater than pre-defined threshold*//*Remove this or move to RTB0.e and activate only when polyfit is used*/
                    switch (rtb0_rejectnoise)
                    {
                        case 1: /*set Mag to 0 if cfoffset> rtb0_max_range*/
                            slice_fidmean[sliceindex] = (fabs(rtb0_cfoffset) > rtb0_max_range)? 0:rtb0_fidmean;
                            break;
                        case 2: /*set cfoffset to rtb0_max_range if cfoffset > rtb0_max_range*/
                            if (rtb0_cfoffset > rtb0_max_range)
                                slice_cfoffset[sliceindex] = rtb0_max_range;
                            if (rtb0_cfoffset < rtb0_max_range*-1)
                                slice_cfoffset[sliceindex] = -1*rtb0_max_range;
                            break;
                        default: /*original: do nothing*/
                            break;
                    }

                    if(cf_counter == 0)
                    {
                        first_rtb0_sliceindex = sliceindex;
                    }
                    last_rtb0_sliceindex = sliceindex;
                    cf_counter++;
                }
            } /* false_slice= 0 */

            /*RTB0 correction: reset things & do interslice fitting before going into actual disdacqs*/
            /*do fitting & comp only after RTB0 loop is completed*/
            if (rtb0_flag && in_rtb0_loop)
            {	
                set_dynr1(pscR1); /*reset R1*/

                if (rtb0_gzrf0_off && t1flair_flag==PSD_ON) /*reset gzrf0*/
                {
                    setiampt(freqSign*ia_gzrf0, &gzrf0, INSTRALL);
                }

                /*Play dummy sequence to avoid EOS timing error*/
                play_rtb0fitwaitseq(rtb0fittingwaittimeLoop);
                reset_to_epi2scan();

#if defined(MGD_TGT) && defined(PSD_HW)
    if (PSD_ON == rtb0_timing_flag)
    {
        mgd_clock_gettime(HOST_TIME_OF_DAY, &tim);  
        t1 = tim.tv_sec+(tim.tv_nsec/1000000000.0);
    }
#endif


    int slcindex = 0;

    int rtb0_num_slice = last_rtb0_sliceindex - first_rtb0_sliceindex + 1;

    /* Number of slices should never exceed GE limits or be negative */
    if ((rtb0_num_slice > DATA_ACQ_MAX) || (rtb0_num_slice < 0))
    {
        return FAILURE; 
    }

    /* Switch between confidence methods */
    switch (rtb0_confidence_method)
    {
    case 1: /* Linear fit residual */
        rtb0_confidence_thresh_val = rtb0_cfresidual_threshold;
        for (slcindex = 0; slcindex < rtb0_num_slice; slcindex++)
        {
            slice_cfconfidence[slcindex] = slice_cfresidual[slcindex];
        }
        break;
    case 2: /* Standard deviation across channels */
        rtb0_confidence_thresh_val = rtb0_cfstddev_threshold;
        for (slcindex = 0; slcindex < rtb0_num_slice; slcindex++)
        {
            slice_cfconfidence[slcindex] = slice_cfstddev[slcindex];
        }
        break;
    case 0: /* Do not threshold */
    default:
        /* Turn off confidence thresholding (i.e. all slices are valid) */
        rtb0_confidence_thresh_val  = 0.0;
        for (slcindex = 0; slcindex < rtb0_num_slice; slcindex++)
        {
            slice_cfconfidence[slcindex] = -1.0; /* To ensure all pts are below threshold (i.e. valid) */
        }
    }

    switch (cf_interpolation)
    {
        case 0: /*Median filter*/
            cf_medianfilter_acqinterpolation(rtb0_num_slice, rtb0_median_kernel_size, rtb0_confidence_method, slice_cfconfidence, rtb0_confidence_thresh_val);
            break;
        case 1: /*Weighted 1st order (linear) fit*/
            weighted_polyfit(slice_cfoffset_filtered, cf_coeff, slice_cfoffset,f_sltime2slloc, slice_fidmean, 1, rtb0_num_slice);
            break;
        case 2: /*Weighted 2nd order (quadratic) fit */
            weighted_polyfit(slice_cfoffset_filtered, cf_coeff, slice_cfoffset,f_sltime2slloc, slice_fidmean, 2, rtb0_num_slice);
            break;
        case 3: /*Weighted 3rd order (quadratic) fit */
            weighted_polyfit(slice_cfoffset_filtered, cf_coeff, slice_cfoffset,f_sltime2slloc, slice_fidmean, 3, rtb0_num_slice);
            break;
        case 4: /*Smooth with keep edge*/
            /*Compute maximum kernel size as percent of slice coverage*/
            rtb0_max_kernel_keep_edge = (int)(rtb0_max_kernel_percent/ 100.0 * rtb0_num_slice);
            if (rtb0_max_kernel_keep_edge % 2)
            {
                rtb0_max_kernel_keep_edge = rtb0_max_kernel_keep_edge + 1;
            }
            cf_smooth_with_keep_edge(rtb0_num_slice, rtb0_min_kernel_keep_edge, rtb0_max_kernel_keep_edge, rtb0_confidence_method, slice_cfconfidence, rtb0_confidence_thresh_val);
            break;
    }
    /*MF B0 correction*/
    /*Interpolate for pass>1 only if polynomial fit method is used*/
    if (cf_interpolation >=1 && cf_interpolation < 4)
    {
        int pass2 = 0;
        int the_slcindex = 0;

        for (pass2 = 1; pass2 < rspacq; pass2++)
        {
            the_slcindex = acq_ptr[pass2]%opslquant;

            generate_polycurve(&slice_cfoffset_filtered[the_slcindex],&f_sltime2slloc[the_slcindex], cf_coeff, cf_interpolation/*order*/,slc_in_acq[pass2]);
        }
			
        if (rtb0_debug)
            printCFResult(rtb0_num_slice);

    }

    /*MF B0 correction: add manual baseline offset - for testing only*/
    int i = 0;
    for (i=0;i<opslquant;i++)
    {
        slice_cfoffset_filtered[i]=slice_cfoffset_filtered[i];
    }

    /*MF B0 correction: cap the max rtb0 offset*/
    for (i=0;i<opslquant;i++)
    {
        if (fabs(slice_cfoffset_filtered[i])>rtb0_max_range)
        {
            slice_cfoffset_filtered[i]=(slice_cfoffset_filtered[i]>0? 1:-1)*rtb0_max_range;
        }
    }

    /*MF B0 correction: apply smoothing*/
    /*reorder cfoffset so it is sort by slice location when it goes into the generic smooth function*/
    if (rtb0_smooth_cf_flag)
    {
        /*convert sort by time to sort by loc*/
        reorder_cfoffset(slice_cfoffset_bySlice, slice_cfoffset_filtered, opslquant, slloc2sltime, 0); 

        smooth(slice_cfoffset_bySlice, opslquant, rtb0_smooth_kernel_size, 0);

        /*convert sort by loc to sort by slice*/
        reorder_cfoffset(slice_cfoffset_filtered, slice_cfoffset_bySlice, opslquant, slloc2sltime, 1);
    }		

    /*Print out CF offset after smoothing*/
    if (rtb0_debug)
    {
        int i = 0;
        for (i=0; i<opslquant; i++)
        {
            fprintf(fp_cfdata, "%d %8.2f\n", i, slice_cfoffset_filtered[i]);
        }
    }

    if(rtb0_comp_flag)
    {
        int i = 0;
        for (i = 0; i < opslquant; i++)
        {
            slice_cfoffset_TARDIS[i] = (int)(slice_cfoffset_filtered[i]/TARDIS_FREQ_RES);
        }
		    	
        if (rtb0_recvphase_comp_flag && rspent == L_SCAN)/*no need to recalculate phase if it's in ref scan since phase_y_incr is set to 0.0 if ref_mode == 1 */
        {
            /* PWW: Integrated-RPG */
            recv_phase_freq_init();

            if (hoecc_flag == PSD_ON)
            {
                /* update recv_phase array that is used in dabrbaload() call later in core() */
                HoecCalcReceiverPhase();  /* in core(), dabrbaload() actually applies recv_phase that is calculated here */

            } /* end hoecc_flag*/
        }/* end rtb0_recvphase_comp_flag*/
    }/* end rtb0_comp_flag*/

#if defined(MGD_TGT) && defined(PSD_HW)
    if (PSD_ON == rtb0_timing_flag)
    {
        mgd_clock_gettime(HOST_TIME_OF_DAY, &tim);  
        t2 = tim.tv_sec+(tim.tv_nsec/1000000000.0);
        rtb0_fitting_time = (t2-t1)*10000; /*0.1ms*/
        printf("fitting time =%.6f [0.1ms]\n", rtb0_fitting_time);
    }
#endif

#if defined(MGD_TGT) && defined(PSD_HW)
    if (rtb0_timing_flag)
    {
        computeRTB0TimingStats();
    }
#endif


                loaddab(&(rtb0echo), 0, 0, DABSTORE, 1, DABOFF, PSD_LOAD_DAB_ALL);
                in_rtb0_loop = 0;
            }

        }  /* disdaq */
	
    }	/* if rspdda > 0 */
    
    /******* end disdaq block ***********************************/
    /*RTB0 correction*/
    if(rtb0_flag)
    {
        setiampt(0, &gz1, 0);
    }

    /* Refless EPI: when T1 Flair is on, the original logic is that first dda sets rspslq to slquant_in_ti and second dda sets it back
       to false_slquant1. In refless EPI, we skip the 2nd dda, so here we need to manually set rspslq back after the dda loop */
    if (t1flair_flag && ref_in_scan_flag)
    {
        rspslq = false_slquant1;
    }

    if (rspent != L_SCAN)
	attenlockoff(&atten);
    else
	attenlockon(&atten);

    for (core_rep = 0; core_rep <= rsprep-1; core_rep++) 
    {
        /* baselines are done seperately in blineacq routine */
        for (ileave = rspilvb; ileave < rspilv; ileave++) 
        {
            if (ileave>0) 
            {
                if ( (ep_alt > 0) && (gradpol[ileave] != gradpol[ileave-1] ))
                    setreadpolarity();
            }

            if ((cs_sat == PSD_ON) && (rspent == L_MPS2))
                CsSatMod(cs_satindex);

            /* set sliding ssp/readout/phase/slice */

            setperiod((int)tf[ileave], &wgx, 0);
            setperiod((int)tf[ileave], &wgy, 0);
            setperiod((int)tf[ileave], &wgz, 0);
            setperiod((int)tf[ileave], &wssp, 0);
            setperiod((int)tf[ileave], &womega, 0);       /* ufi2_ypd */


            /* Set blip and gy1 pulse amplitudes */
            ygradctrl(rspgyc, blippol[ileave], etl);
            if (gyctrl == PSD_ON && rspent != L_REF &&
                rspent != L_MPS2 && rspent != L_APS2) {
                setiampt(invertGy1*gy1f[ileave], &gy1, 0);
                if (ygmn_type == CALC_GMN1) {
                    setiampt(gymn[ileave], &gymn1, 0);
                    setiampt(-gymn[ileave], &gymn2, 0);
                }
            }

            /* SWL pick the right nex for current pass rep */
            /* Refless EPI: for ref-in-scan mode, first pass is labeled as L_REF where rspnex is preset to 1 */
            /* rspnex_temp of the ref pass for DWI and DTI is set here */
            if((rspent==L_MPS2)||(rspent==L_APS2)||(rspent==L_REF))
            {
                rspnex_temp = rspnex;
            }
            else if( (PSD_ON == rpg_in_scan_flag) && ((pass_rep-(ref_in_scan_flag?1:0)) < rpg_in_scan_num) )
            {   
                /* Distortion Correction: Set 1NEX for rpg_in_scan_flag and rpg_in_scan_num passes */
                rspnex_temp = 1;
            }
            else if(tensor_flag == PSD_ON)
            {
                rspnex_temp = difnextab_rsp[0];
            }
            else if(opdiffuse == PSD_ON)
            {
                int pass_rep_tmp = pass_rep-(ref_in_scan_flag ? 1:0)-(rpg_in_scan_flag ? rpg_in_scan_num:0);
                if (pass_rep_tmp < 0) /* Only with RPG on */
                {
                    rspnex_temp = 1;
                }
                else if (opdifnumt2 == 0)
                {
                    rspnex_temp = difnextab_rsp[(pass_rep_tmp)/opdifnumdirs];
                }
                else
                {
                    if(pass_rep_tmp == 0)
                    {
                        rspnex_temp = (short)opdifnext2;
                    }
                    else
                    {
                        rspnex_temp = difnextab_rsp[(pass_rep_tmp-1)/opdifnumdirs];
                    }
                }
            }
            else
            {
                rspnex_temp = rspnex;
            }

            for (excitation=1-rspdex; excitation <= rspnex_temp; excitation++) 
            {
                if (rf_chop == PSD_ON && excitation % 2 == 0)
                {
                    setiamp(-rfpol[ileave], &rf1, 0);  /* even excitation */
                }
                else
                {
                    setiamp(rfpol[ileave], &rf1, 0);   /* odd excitation */
                }
	               
#ifdef UNDEF
		if (debugstate==PSD_ON)
                    sprintf(psddbgstr,"  Excitation=%6d",excitation);
		printdbg(psddbgstr, debugstate);
#endif		
                
		if (epi_flair) {
                    setiamp(ia_rf0, &rf0, 0);
                    setiamp(freqSign*ia_gzrf0, &gzrf0, 0);
                    setiamp(freqSign*ia_gzrf0, &gzrf0a, 0);
                    setiamp(freqSign*ia_gzrf0, &gzrf0d, 0);
                    setiamp(ia_gyk0, &gyk0, 0);
                    setiamp(ia_gyk0, &gyk0a, 0);
                    setiamp(ia_gyk0, &gyk0d, 0);
		}
                
                for (false_pass = false_rspacqb; false_pass < false_rspacq; false_pass++) 
                {
                    /* Refless EPI: Play IR in REF for DW-EPI Flair with 1 acq */
                    if (epi_flair && flair_flag &&
                        ((rspent == L_SCAN) ||
                         ((rspent == L_REF) && (ref_in_scan_flag == PSD_ON) && (rspacq == 1))))
                    {

                        /* MRIge81039  NU */
                        setrotatearray((SHORT)(opslquant*opphases),rsprot_orig[0]);

                        /* MRIge44963 - need to subtract slq_to_shift from rspslq, HOU */
                        for (false_slice = rspslqb; false_slice < rspslq-slq_to_shift; false_slice++) 
                        { 
                            printdbg("Starting Interleaved Inversion", debugstate);
#ifdef DEBUG_CORE
                            if (debug_core == PSD_ON)
                            {
                                fprintf(fp_coreinfo,"core:inv:core_rep%d/%d:int%d/%d:nex%d/%d:false_acq%d/%d:slice%d/%d\n", 
                                        core_rep,rsprep-1,ileave, rspilv-1,excitation,rspnex_temp-1,false_pass,false_rspacq-1,
                                        false_slice,rspslq-slq_to_shift-1); 
                            }
#endif
                            boffset(off_seqinv);   
                            slice_tmp = false_slice + false_pass*(rspslq-slq_to_shift);
                            if (slice_tmp<slc_in_acq[pass_index]) {
                                slice = slice_tmp;
                                setiamp(ia_rf0, &rf0, false_slice);
                                /* setiamp(ia_rf0, &rf0, 0); */

                            }
                            else    {
                                slice = 0;
                                setiamp(0, &rf0, false_slice);
                                /* setiamp(0, &rf0, 0); */
                            } 

                            /* Determine which slice(s) to excite (find spot in
                               rspinfo table) */
                            /* Remember slices & passes start at 0 */
                            if (rspesl == -1)
                            {
                                if (acqmode==0) /* interleaved */
                                    sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                                if (acqmode==1)  /* sequential */
                                    sliceindex = acq_ptr[pass_index];
                            }
                            else 
                                sliceindex = acq_ptr[pass_index] + rspesl;

                            /* SW: Setup Diff Gradient Dir */
                            if (diff_order_flag && (rspent == L_SCAN))
                            {
                                int pass_index;

                                if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                                {
                                    pass_index = pass_rep;
                                }
                                else
                                {
                                    pass_index = diff_pass_counter;
                                }

                                tmpi = get_diff_order(pass_index, false_slice + false_pass * rspslq + slquant1 * pass);

                                if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                                {
                                    diff_index = tmpi;
                                }
                                else
                                {
                                    diff_index = diff_order_pass[tmpi-ref_in_scan_flag-(rpg_in_scan_flag?rpg_in_scan_num:0)];
                                }

                                if ((opdiffuse == 1 && incr == 1) || tensor_flag)
                                {
                                    /* BJM: increment diffusion gradients */
                                    skip_ir = PSD_ON;
                                    diffstep(diff_index - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
                                    if(rtb0_flag)
                                    {
                                        setiampt(0, &gz1, 0);
                                    }
                                    skip_ir = PSD_OFF;
                                }

                                /* Load Transmit Frequencies */
                                setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, false_slice);
                                setiamp(freqSign*ia_gzrf0, &gzrf0, false_slice);
                                setiamp(freqSign*ia_gzrf0, &gzrf0a, false_slice);
                                setiamp(freqSign*ia_gzrf0, &gzrf0d, false_slice);
                            }
                            else
                            {
                                /* Load Transmit Frequencies */
                                setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, false_slice);
                                /* setfrequency(rf0_freq[sliceindex], &rf0, 0); */
                                /* setiphase(rf0_pha[sliceindex], &rf0, 0); */
                            }
                        } /*IR prep */

                        startseq((short)sliceindex, (SHORT)MAY_PAUSE);

			if (debug_unitTest)
				fprintf(fp_utloopinfo,"%s\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t \n", "core_flair:", pass_rep, pass, -1, -1, -1, core_rep, ileave, excitation, false_pass, false_slice, -1);

                        /* MRIge81039  NU */
                        if ((rspent== L_CFH) || (rspent == L_CFL))
                            setrotatearray((SHORT)(opslquant*opphases),rsprot_orig[0]);
                        else
                            setrotatearray((SHORT)(opslquant*opphases),rsprot[0]);

                    } /*epi_flair*/

                    boffset(off_seqcore); /* switch back to core seq */
                    
                    /* MRIge44963 - need to subtract slq_to_shift from rspslq, HOU */
                    for (false_slice = rspslqb; false_slice < rspslq-slq_to_shift; false_slice++) 
                    { 
#ifdef DEBUG_CORE
                        if (debug_core == PSD_ON)
                        {
                            fprintf(fp_coreinfo,"core:img:core_rep%d/%d:int%d/%d:nex%d/%d:false_acq%d/%d:slice%d/%d\n",
                                    core_rep,rsprep-1,ileave,rspilv-1, excitation,rspnex_temp-1,false_pass,false_rspacq-1,
                                    false_slice,rspslq-slq_to_shift-1);
                        }
#endif                            

                        if ((PSD_ON == navtrig_flag) && (PSD_OFF == calc_rate) && ((L_REF == rspent) || (L_SCAN == rspent)) &&
                            (false_slice % num_slice_rr == 0))
                        {
                            NavigatorPlayTrig();

#ifndef SIM
                            if ((rspent == L_REF) && (ref_in_scan_flag == PSD_ON))
                            {
                                scantime = (60000000/ (float)oprtrate) * (float)hbs_left;
                                setscantimestop();
                                setscantimeimm(PSD_CLOCK_CARDIAC, scantime, hbs_left,pitslice,opslicecnt);
                                setscantimestart();
                            }
#endif
                        }

                        slice_tmp = false_slice + false_pass*(rspslq-slq_to_shift);

                        if (slice_tmp<slc_in_acq[pass_index]) { 
                            slice = slice_tmp;
                        } else {
                            slice = 0;   
                        }
                        slice1 = slice; 
                        
#ifdef UNDEF
                        sprintf(psddbgstr,"    slice=%6d",slice);
                        printdbg(psddbgstr,debugstate);
#endif
                        
                        if ((slice == rspasl) || (rspasl == -1)) {
                            acq_sl = 1;
                        } else { 
                            acq_sl = 0;
                        }

                        /* Determine which slice(s) to excite (find spot in 
                           rspinfo table) */
                        /* Remember slices & passes start at 0 */
                        if (rspesl == -1)
                        {
                            if (acqmode==0) {/* interleaved */
                                sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                                sliceindex1 = (acq_ptr[pass_index] + slice1)%opslquant;

                                /* t1flair_stir */
                                if (PSD_ON == t1flair_flag )
                                {
                                    slice = real_slice_acq_seq[pass][false_slice];
                                    slice1 = slice;
                                    sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                                    sliceindex1 = (acq_ptr[pass_index] + slice1)%opslquant;
                                }
                            }
                            if (acqmode==1) { /* sequential */
                                sliceindex = acq_ptr[pass_index];
                                sliceindex1 = acq_ptr[pass_index];
                            }
                        }
                        else 
                        {
                            sliceindex = acq_ptr[pass_index] + rspesl;
                            sliceindex1 = acq_ptr[pass_index] + rspesl;
                        }

                        if ((rspent == L_MPS1) || (rspent == L_MPS2)) {
                            if ((excitation == rspnex_temp) && (acq_sl == 1))
                                attenlockoff(&atten);
                            else
                                attenlockon(&atten);
                        }

                        /* Set cardiac delays and end times */
                        if (opcgate || oprtcgate) {

                            /* Build the trigger for multi-slice, multi-phase cardiac */
                            msmpTrig();

                            if ((rspent == L_SCAN)||(rspent == L_MPS2) 
                                ||(rspent == L_APS2) ||(rspent == L_REF))
                                setperiod(ctlend_tab[sliceindex],&seqcore ,0);

                            /*  first slice in RR */
                            if (rsptrigger[sliceindex] != TRIG_INTERN) {	
                                if ((rspent == L_SCAN)||(rspent == L_MPS2)||(rspent == L_APS2)) {
                                    /* Use cardiac trigger delay */
                                    setperiod(td0, &x_td0, 0);
                                    setperiod(td0, &y_td0, 0);
                                    setperiod(td0, &z_td0, 0);
                                    setperiod(td0, &rho_td0, 0);
                                    setperiod(td0, &theta_td0, 0);
                                    setperiod(td0, &omega_td0, 0);
                                    setperiod(td0, &ssp_td0, 0);
                                }
                            } else {
                                /* Bypass cardiac trigger delay */
                                setperiod((int)GRAD_UPDATE_TIME, &x_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &y_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &z_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &rho_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &theta_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &omega_td0, 0);
                                setperiod((int)GRAD_UPDATE_TIME, &ssp_td0, 0);
                            }
                        }
                         
                        /* t1flair_stir */
                        if (PSD_ON != t1flair_flag)
                        {
                            if (slice_tmp<slc_in_acq[pass_index]) { /* live slice */
                                if (!aspir_flag)
                                {
                                    /* turn on RHO BOARD */
                                    setieos((SHORT)EOS_PLAY, &rho_td0, 0);
                                }
                                else
                                {
                                    /* turn on RHO BOARD */
                                    setieos((SHORT)EOS_PLAY, &rf1, 0);
                                }

                                use_sl = 1;
                                if ((acq_sl == PSD_ON)&&(excitation > 0)) {
                                    acq_data = (int)DABON;
                                } else { 
                                    acq_data = (int)DABOFF;
                                }
                            }
                            else 
                            {
                                /* Dummy slice */
                                acq_data = (int)DABOFF;
                                if (!aspir_flag)
                                {
                                    /* turn off RHO BOARD */
                                    setieos((SHORT)EOS_DEAD, &rho_td0, 0);
                                }
                                else
                                {
                                    /* turn off RHO BOARD */
                                    setieos((SHORT)EOS_DEAD, &rf1, 0);
                                }
                                use_sl = 0;
                                if (rspesl == -1) {
                                    sliceindex = (acq_ptr[0])%opslquant;
                                    sliceindex1 = (acq_ptr[0])%opslquant;
                                }
                            }
                        }
                        
                        /* update Sat Move CATSAT Pulse */
                        SpSatUpdateRsp(1, pass_index, opccsat);
                        
                        /* SW: Setup Diff Gradient Dir */
                        if (diff_order_flag && (rspent == L_SCAN))
                        {
                            int pass_index;

                            if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                            {
                                pass_index = pass_rep;
                            }
                            else
                            {
                                pass_index = diff_pass_counter;
                            }

                            tmpi = get_diff_order(pass_index, false_slice + false_pass * rspslq + slquant1 * pass);

                            if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                            {
                                diff_index = tmpi;
                            }
                            else
                            {
                                diff_index = diff_order_pass[tmpi-ref_in_scan_flag-(rpg_in_scan_flag?rpg_in_scan_num:0)];
                                nex_index = diff_order_nex[tmpi-ref_in_scan_flag-(rpg_in_scan_flag?rpg_in_scan_num:0)];
                            }

                            if ((opdiffuse == 1 && incr == 1) || tensor_flag)
                            {
                                /* BJM: increment diffusion gradients */
                                diffstep(diff_index - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
                                if(rtb0_flag)
                                {
                                    setiampt(0, &gz1, 0);
                                }
                            }
                        }
                        else
                        {
                            diff_index = pass_rep;
                        }

                        if( (PSD_ON == irprep_flag) && (t1flair_flag != PSD_ON) )
                        {
    { /* Start of code inlined from Inversion.e InversionRSPcore */
        if (ir_on == PSD_ON)
        {
            /* Load Transmit Frequency */
	    /* MF B0 correction */
	    setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
            setiphase(rf0_pha[sliceindex], &rf0, 0);
        }
    } /* End of code inlined from Inversion.e InversionRSPcore */
                        }    

#ifdef UNDEF
    { /* Start of code inlined from Inversion.e InversionRSPcore */
#if defined(IPG_TGT) || defined(MGD_TGT) /* MRIhc13008 */
        if (ir_on == PSD_ON)
        {
            /* Load Transmit Frequency */
            setfrequency(rf0_freq[sliceindex], &rf0, 0);
            setiphase(rf0_pha[sliceindex], &rf0, 0);
        }
#endif
    } /* End of code inlined from Inversion.e InversionRSPcore */

#endif
                        /* t1flair_stir */
                        if( PSD_ON == t1flair_flag )
                        {
                            int temp_pass_index = pass_index;
                            int freqSign_org = freqSign;

                            /* Play IR Prep for next pass at the end of pass.
                               1st pass_rep is excluded as IR is applied during disdaq. */
                            if ((slquant_in_ti > 0) && !((pass_rep == 0) && (pass < rspacq -1)) &&
                                (false_slice > rspslq-1-slq_to_shift-slquant_in_ti) &&
                                (false_pass == false_rspacq-1) && (excitation == rspnex_temp) &&
                                (ileave == rspilv-1) && (core_rep == rsprep-1))
                            {
                                temp_pass_index++;

                                if ((pass == rspacq - 1) && (diff_order_flag == PSD_OFF) &&
                                    !((rspent==L_MPS2)||(rspent==L_APS2)))
                                {
                                    /* set freqSign of IR prep for next pass */
                                    if (pass_rep < rspprp - 1)
                                    {
                                        diffamp(pass_rep + 1 - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
                                    }

                                    freqSign = 1;

                                    if (PSD_OFF == dualspinecho_flag)
                                    {
                                        if(invertSliceSelectZ == PSD_ON || invertSliceSelectZ2 == PSD_ON)
                                        {
                                            if((invertSliceSelectZ==PSD_ON && ((ia_incdifz<0 && ia_gzrf2r1>0) || (ia_incdifz>0 && ia_gzrf2r1<0))) ||
                                               (invertSliceSelectZ2==PSD_ON && ia_gzrf2r1<0))
                                            {
                                                freqSign = -1;
                                            }
                                            else
                                            {
                                                freqSign = 1;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if(PSD_ON == invertSliceSelectZ || PSD_ON == invertSliceSelectZ2)
                                        {
                                            if((invertSliceSelectZ==PSD_ON && ((ia_incdifz>0 && ia_gzrf2leftr1>0) || (ia_incdifz<0 && ia_gzrf2leftr1<0))) ||
                                               (invertSliceSelectZ2==PSD_ON && ia_gzrf2leftr1>0))
                                            {
                                                freqSign = -1;
                                            }
                                            else
                                            {
                                                freqSign = 1;
                                            }
                                        }
                                    }
                                    if(ssgr_flag)
                                    {
                                        freqSign *= -1;
                                    }

                                    if(ir_on) setiampt(freqSign*ia_gzrf0, &gzrf0, INSTRALL);

                                    diffamp(pass_rep - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0)); /* restore */
                                }
                            }

                            if ((diff_order_flag) &&
                                !((rspent==L_MPS2)||(rspent==L_APS2)))
                            {
                                /* SW: Setup Diff Gradient Dir */
                                if (rspent == L_SCAN)
                                {
                                    int pass_index;
                                    int diff_index_orig = diff_index;
                                    int slice_index = 0;

                                    if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                                    {
                                        pass_index = temp_pass_index/rspacq; /* pass_rep; */

                                        if (pass_index > rspprp - 1)
                                        {
                                            pass_index = 0;
                                        }
                                    }
                                    else
                                    {
                                        pass_index = diff_pass_counter;
                                    }

                                    if (excitation == rspnex_temp)
                                    {
                                        slice_index = (slquant_in_ti + false_slice + false_pass * rspslq + slquant1 * pass) % (slquant1*rspacq);

                                        if ((diff_order_flag == 2) &&
                                            ((int)((slquant_in_ti + false_slice + false_pass * rspslq + slquant1 * pass)/ (slquant1*rspacq))) > 0)
                                        {
                                            pass_index++;
                                            if (pass_index > rspprp - 1)
                                            {
                                                pass_index = 0;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        slice_index = (slquant_in_ti + false_slice + false_pass * rspslq + slquant1 * pass) % slquant1 + slquant1 * pass;

                                        if ((diff_order_flag == 2) &&
                                            ((int)((slquant_in_ti + false_slice + false_pass * rspslq)/ (slquant1))) > 0)
                                        {
                                            pass_index++;
                                            if (pass_index > rspprp - 1)
                                            {
                                                pass_index = 0;
                                            }
                                        }
                                    }

                                    tmpi = get_diff_order(pass_index, slice_index);

                                    if (diff_order_flag == 1 || (diff_order_flag == 2 && tensor_flag == PSD_ON))
                                    {
                                        diff_index = tmpi;
                                    }
                                    else
                                    {
                                        diff_index = diff_order_pass[tmpi-1];
                                    }

                                    if ((opdiffuse == 1 && incr == 1) || tensor_flag)
                                    {
                                        /* BJM: increment diffusion gradients */
                                        diffamp(diff_index - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0));
                                    }

                                    freqSign = 1;

                                    if (PSD_OFF == dualspinecho_flag)
                                    {
                                        if(invertSliceSelectZ == PSD_ON || invertSliceSelectZ2 == PSD_ON)
                                        {
                                            if((invertSliceSelectZ==PSD_ON && ((ia_incdifz<0 && ia_gzrf2r1>0) || (ia_incdifz>0 && ia_gzrf2r1<0))) ||
                                               (invertSliceSelectZ2==PSD_ON && ia_gzrf2r1<0))
                                            {
                                                freqSign = -1;
                                            }
                                            else
                                            {
                                                freqSign = 1;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if(PSD_ON == invertSliceSelectZ || PSD_ON == invertSliceSelectZ2)
                                        {
                                            if((invertSliceSelectZ==PSD_ON && ((ia_incdifz>0 && ia_gzrf2leftr1>0) || (ia_incdifz<0 && ia_gzrf2leftr1<0))) ||
                                               (invertSliceSelectZ2==PSD_ON && ia_gzrf2leftr1>0))
                                            {
                                                freqSign = -1;
                                            }
                                            else
                                            {
                                                freqSign = 1;
                                            }
                                        }
                                    }

                                    if(ssgr_flag)
                                    {
                                        freqSign *= -1;
                                    }

                                    if(ir_on) setiampt(freqSign*ia_gzrf0, &gzrf0, INSTRALL);

                                    diff_index = diff_index_orig;
                                    diffamp(diff_index - (ref_in_scan_flag?1:0) - (rpg_in_scan_flag?rpg_in_scan_num:0)); /* restore */
                                }
                            }

                            real_slice_IR = 0;
                            slice_flag = IMGSLICE;
                            sliceindex = (false_slice + slquant_in_ti)%rspslq + acq_ptr[temp_pass_index];

                            if (dummyslices >= 0 || PSD_ON == act_edge_slice_enh_flag)
                            {
                                real_slice_IR =  real_slice_acq_seq[pass][(false_slice + slquant_in_ti)%rspslq];
                                sliceindex = acq_ptr[temp_pass_index] + real_slice_IR;
                                slice_flag = T1flair_slice_flag[pass][(false_slice + slquant_in_ti)%rspslq];
                            }

                            sliceindex = sliceindex % opslquant;

                            if (slice_flag == EDGESLICE)
                            {
                                if (real_slice_IR == edgeslice1)
                                {
                                    /* RTB0 correction*/
                                    setfrequency(freqSign*edgeslice1freq+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                                    setiphase(edgeslice1pha, &rf0, 0);
                                }
                                else
                                {
                                    /* RTB0 correction*/
                                    setfrequency(freqSign*edgeslice2freq+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                                    setiphase(edgeslice2pha, &rf0, 0);
                                }
                                setiamp(ia_rf0, &rf0, 0);
                            }
                            else if (slice_flag == IMGSLICE)
                            {
                                /* RTB0 correction*/
                                setfrequency(freqSign*rf0_freq[sliceindex]+slice_cfoffset_TARDIS[sliceindex], &rf0, 0);
                                setiphase(rf0_pha[sliceindex], &rf0, 0);
                                setiamp(ia_rf0,&rf0,0);

                                /* Not play IR Prep at the end of 1st pass_rep,
                                   as IR is applied during disdaq in next pass */
                                if ((slquant_in_ti > 0) && (pass_rep == 0) && (pass < rspacq -1) &&
                                    (false_slice > rspslq-1-slq_to_shift-slquant_in_ti) && (false_pass == false_rspacq-1) &&
                                    (excitation == rspnex_temp) && (ileave == rspilv-1) && (core_rep == rsprep-1))
                                {
                                    setiamp(0,&rf0,0);
                                }
                            }
                            else
                            {
                                setiamp(0,&rf0,0);
                            }

                            /* t1flair_stir: the imaging sequence's sliceindex,
                             * slice_flag, etc.
                             */
                            slice = real_slice_acq_seq[pass][false_slice];
                            sliceindex = (acq_ptr[pass_index] + slice)%opslquant;
                            sliceindex1 = sliceindex;
                            slice_flag = T1flair_slice_flag[pass][false_slice];

                            if ((slice_flag == IMGSLICE) && (acq_sl == PSD_ON) && (excitation > 0))
                            {
                                acq_data = (int)DABON;
                            }
                            else
                            {
                                acq_data = (int)DABOFF;
                            }

                            freqSign = freqSign_org;
                        }

                    /* t1flair_stir */
                    /* Play the IR rf pulses for the 1st excitation if T1FLAIR is on, 
                       and turn off the rf1 and rf2 rf pulses. The data acquisition has 
                       been  turn off. */
                    if ((PSD_ON == t1flair_flag) && (slice_flag != IMGSLICE))
                    {
                        setiamp(0, &rf1, 0);
                        if (oppseq == PSD_SE) /* DTI */
                        {
                            if (PSD_OFF == dualspinecho_flag)
                            {
                                setiamp(0, &rf2, 0);
                            }
                            else
                            {
                                setiamp(0, &rf2right, 0);
                                setiamp(0, &rf2left, 0);
                            }
                        }
                    }
                    else
                    {
                        /* Set the rf pulse transmit frequencies */
                        if (ssRsp() == FAILURE) return FAILURE;
                        if (slice1 < 0) {
                            
                            setiamp(0, &rf1, 0);   /* zero amplitudes */
                            
                            if (oppseq == PSD_SE)
                            {
                                if (PSD_OFF == dualspinecho_flag)
                                {
                                    setiamp(0, &rf2, 0);
                                }
                                else
                                {
                                    setiamp(0, &rf2right, 0);
                                    setiamp(0, &rf2left, 0);
                                }
                            }

                        } else {

                            if (rf_chop == PSD_ON && excitation % 2 == 0)
                            {
                                setiamp(-rfpol[ileave], &rf1, 0);  /* even excitation */
                            }
                            else
                            {
                                setiamp(rfpol[ileave], &rf1, 0);   /* odd excitation */
                            }

                            if (rfov_flag)
                            {
                                /* SVBranch: HCSDM00259122  - FOCUS walk sat */
                                if (walk_sat_flag) setrfwk();                            
                            
                                setfrequency(0, &rf1, 0);
                                setthetarf1(sliceindex1); /* control frequency through theta wave */
                            }
                            else /* RTB0 correction*/
                            {
                                setfrequency(freqSign*rf1_freq[sliceindex1] + d_cf + slice_cfoffset_TARDIS[sliceindex1], &rf1, 0);
                            }

                            if (sliceindex1 == 0) {
#ifdef DEBUG_CORE
                                if (debug_core == PSD_ON)
                                {
                                    fprintf(fp_coreinfo,"Phase cycle number %d\n",(core_rep+reps*pass_rep));
                                }
#endif
                                if (mux_flag && mux_slices_rf1 >1) {
                                    setwave( ptr_rf1[0], &rf1, 0);
                                    if (phase_cycle_rf2) {
                                        if( opdualspinecho == PSD_OFF) {
                                            setwave( ptr_rf2[0], &rf2, 0);
                                        } else {
                                            setwave( ptr_rf2[0], &rf2left,  0);
                                            setwave( ptr_rf2[0], &rf2right, 0);
                                        }
                                    }
                                    if (use_slice_fov_shift_blips && mux_flag && (mux_slices_rf1 > 1)) { /* Use Gz blips */
                                        zgradctrl(rspgzc, slice_fov_shift_blip_start, slice_fov_shift_blip_inc, etl, slice_fov_shift);
                                    } else { /* No Gz blips */
                                        zgradctrl(0, 0, 0, etl, 0);
                                    }
                                } else {
                                    zgradctrl(0, 0, 0, etl, 0);
                                } /* mux_slices_rf1 > 1 */
                            } /* sliceindex == 1 */

                            if (oppseq == PSD_SE)
                            {
                                if (PSD_OFF == dualspinecho_flag)
                                {
                                    if (mux_flag && verse_rf2) {
                                        if (use_omegatheta) {
                                            setfrequency(0, &rf2, 0);
                                            setiamp(freqSign*max_pg_iamp, &th_omthrf2, 0);
                                            setiamp(freqSign*om_iamp_omthrf2[sliceindex], &om_omthrf2, 0);
                                            setwave(om_wave_omthrf2[sliceindex], &om_omthrf2, 0);
                                            setwave(th_wave_omthrf2[sliceindex], &th_omthrf2, 0);
                                        } else if (thetarf2_flag == PSD_OFF) {
                                            setfrequency(freqSign*rf2_freq[sliceindex], &rf2, 0);
                                            setiamp(0, &thetarf2, 0);
                                        } else {
                                            setiamp(freqSign*thetarf2_freq[sliceindex1],&thetarf2,0);
                                            setfrequency(0, &rf2, 0);
#ifdef DEBUG_CORE
                                            if (debug_core == PSD_ON)
                                            {
                                                fprintf(fp_coreinfo,"FM: thetarf2_freq[%d]=%d\n",sliceindex1,freqSign*thetarf2_freq[sliceindex1]);
                                            }
#endif
                                        }
                                    } else {
                                        setfrequency(freqSign_rf2*rf2_freq[sliceindex1]+slice_cfoffset_TARDIS[sliceindex1], &rf2, 0);
                                    }
                                    setiphase(rf2_pha[sliceindex1], &rf2, 0);
#ifdef DEBUG_CORE
                                    if (debug_core == PSD_ON)
                                    {
                                         fprintf(fp_coreinfo,"rf2_pha[%d] = %d\n",sliceindex1, rf2_pha[sliceindex1]);
                                    }
#endif
                                    setiamp(ia_rf2, &rf2, 0);
                                } else {
                                    if (mux_flag && verse_rf2) {
                                        if (use_omegatheta) {
                                            setfrequency(0, &rf2left, 0);
                                            setfrequency(0, &rf2right, 0);
                                            setiamp(freqSign_rf2left*max_pg_iamp, &th_omthrf2left, 0);
                                            setiamp(freqSign_rf2right*max_pg_iamp, &th_omthrf2right, 0);
                                            setiamp(freqSign_rf2left*om_iamp_omthrf2left[sliceindex], &om_omthrf2left, 0);
                                            setiamp(freqSign_rf2right*om_iamp_omthrf2right[sliceindex], &om_omthrf2right, 0);
                                            setwave(om_wave_omthrf2left[sliceindex], &om_omthrf2left, 0);
                                            setwave(om_wave_omthrf2right[sliceindex], &om_omthrf2right, 0);
                                            setwave(th_wave_omthrf2left[sliceindex], &th_omthrf2left, 0);
                                            setwave(th_wave_omthrf2right[sliceindex], &th_omthrf2right, 0);
                                        }	else if (thetarf2_flag == PSD_OFF) {
                                            setfrequency(freqSign_rf2left*rf2_freq[sliceindex], &rf2left, 0);
                                            setiamp(0, &thetarf2left, 0);
                                            setfrequency(freqSign_rf2right*rf2_freq[sliceindex], &rf2right, 0);
                                            setiamp(0, &thetarf2right, 0);
                                        } else {
                                            setiamp(freqSign_rf2right*thetarf2_freq[sliceindex1], &thetarf2right, 0);
                                            setiamp(freqSign_rf2left*thetarf2_freq[sliceindex1], &thetarf2left, 0);
                                            setfrequency(0, &rf2right, 0);
                                            setfrequency(0, &rf2left,  0);
                                        }
                                    } else {
                                        setfrequency(freqSign_rf2right*rf2_freq[sliceindex1]+slice_cfoffset_TARDIS[sliceindex1], &rf2right, 0);
                                        setfrequency(freqSign_rf2left*rf2_freq[sliceindex1]+slice_cfoffset_TARDIS[sliceindex1], &rf2left, 0);
                                    }
                                    setiphase(rf2right_pha[sliceindex1], &rf2right , 0);
                                    setiphase(rf2left_pha[sliceindex1], &rf2left  , 0);
                                    setiamp(ia_rf2, &rf2right, 0);
                                    setiamp(ia_rf2, &rf2left,  0);

                                }
                            }
                        }
                    }
                    dabview = ileave;

                    /* BJM: always store (dabop = 0) for multi-nex DW-EPI */
                    if ((excitation == 1) || (opdiffuse == PSD_ON) || (tensor_flag == PSD_ON))
                    {
                        dabop = 0;
                    }
                    else if (rf_chop == PSD_OFF)
                    {
                        dabop = 1;
                    }
                    else
                    {
                        dabop = 3 - 2*(excitation % 2);
                    }

                    if (slice1 >= 0) {
                        slicerep = slice1 + core_rep*rspslq;
                    } else {
                        slicerep = 0 + core_rep*rspslq;
                    }

                    if (PSD_ON == t1flair_flag)
                    {
                        slicerep = slice + core_rep*(rspslq - dummyslices);
                    }

                    if (slice1 >= 0 &&  setDataAcqDelays == PSD_ON ) {
                        /* Set the delay for the proper dacq/gradient alignment */

                        /* Coorected group delay. ufi2_ypd */

                        setperiod((int)((float)gldelaycval[sliceindex] + pw_sspdelay),
                                  &sspdelay, 0);
                        setperiod(RUP_RF((int)((float)gldelaycval[sliceindex] +
                            pw_omegadelay + deltaomega)), &omegadelay, 0);

                        setperiod((int)((float)(pw_sspshift - gldelaycval[sliceindex])),
                                  &sspshift, 0);

                    } /*slice1 >0 */

                    if (use_slice_fov_shift_blips && mux_flag && (mux_slices_rf1 > 1)) {
                        dabrbaload(rspgzc, slice_fov_shift_blip_start, slice_fov_shift_blip_inc, tot_etl, slice_fov_shift);
                    } else {
                        dabrbaload(0, 0, 0, tot_etl, 0);
                    }

                    /* Note in diffstep(), recv_phase is adjusted for HOEC B0 compensation,
                                         but the actual phase is set in dabrbaload here */

                    /* play out pass delay and send proper pass packet within seqcore.  We do
                           this to avoid having to play out a seperate pass sequence as is usually
                           done */
                    if ( (pass == (rspacq - 1)) && (pass_rep == (rspprp - 1)) &&
                        (false_pass == false_rspacq-1) && (false_slice == rspslq-1-slq_to_shift) &&
                        (excitation == rspnex_temp) && (ileave == rspilv-1) &&
                        (core_rep == rsprep-1) ) {
                        /* Set DAB pass packet to end of scan */
                        setwamp(SSPDS + DABDC, &pass_pulse, 0);
                        setwamp(SSPD + DABPASS + DABSCAN, &pass_pulse, 2);
                        setwamp(SSPDS + DABDC, &pass_pulse, 4);
                        /*MRIhc09116 end of scan, no opsldelay is
                         * needed*/
                        for (i=0; i<num_passdelay; i++) {
                            setperiod(1, &ssp_pass_delay, i);
                        }
                        pause = MAY_PAUSE;
                        printdbg("End of Scan and Pass", debugstate);
                        InterPassDoneFlag = 0;
                    } else if ( (false_slice == rspslq-1-slq_to_shift) && (false_pass == false_rspacq-1) &&
                        (excitation == rspnex_temp) && (ileave == rspilv-1) && (core_rep == rsprep-1) ) {
                        /* Set DAB pass packet to end of pass */
                        setwamp(SSPDS + DABDC, &pass_pulse, 0);
                        setwamp(SSPD + DABPASS, &pass_pulse, 2);
                        setwamp(SSPDS + DABDC, &pass_pulse, 4);
                        for (i=0; i<num_passdelay; i++) {
                            if ((rspent == L_REF) &&
                                !((mph_flag == PSD_ON) && (avminsldelay > 0)))
                            {
                                setperiod(1, &ssp_pass_delay, i);
                            }
                            else
                            {
                                setperiod(pass_delay, &ssp_pass_delay, i);
                            }
                        }
                        pause = AUTO_PAUSE;
                        printdbg("End of Pass", debugstate);
                        InterPassDoneFlag = 1;
                    } else if (slice1 >= 0) {
                        /* send null pass packet and use the minimum delay for pass_delay */
                        setwamp(SSPDS, &pass_pulse, 0);
                        setwamp(SSPD, &pass_pulse, 2);
                        setwamp(SSPDS, &pass_pulse, 4);
                        for (i=0; i<num_passdelay; i++) {
                            setperiod(1, &ssp_pass_delay, i);
                        }
                        pause = MAY_PAUSE;
                        printdbg("Null ssp pass packet", debugstate);
                        InterPassDoneFlag = 0;
                    }

                    /* MRIge44963 - need to subtract slq_to_shift so that the last slice in a pack */
                    /* can have longer deadtime (scan_deadlast) to prevent cross talk from IR pulse, HOU */
                    if (epi_flair) {
                        if (false_slice == rspslq-1-slq_to_shift)
                            setperiod(scan_deadlast,&seqcore,0);
                        else
                            setperiod(scan_deadtime,&seqcore,0);
                    }

                    sp_sat_index = sliceindex1;

                    /* Update per slice instruction amplitude of echo train readout and phase blips */
{ /* Start of code inlined from HoecCorr.e HoecUpdateReadoutBlipAmpRsp */

    if (hoecc_psd_flag == PSD_ON)  /* note b0 compensation is done through earlier in slice loop of core() */
    {
        HoecSetEchoTrainAmp();
        HoecSetBlipAmp(rspgyc); /* in ref scan mode (rspgyc = 0), this function sets
                                   phase blips and prephaser to 0; in scan mode, it compensates
                                   HOEC by changing phase blip amplitude */
    }
} /* End of code inlined from HoecCorr.e HoecUpdateReadoutBlipAmpRsp */
                        
                    startseq((short)sliceindex1, (SHORT)pause);

                    if (debug_unitTest)
                        fprintf(fp_utloopinfo,"%s\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t \n", "core:", pass_rep, pass, -1, -1, -1, core_rep, ileave, excitation, false_pass, -1, false_slice);
                    

#ifdef PSD_HW       /* Auto Voice  08/08/2005 KK */
                    if (mph_flag && InterPassDoneFlag) {
                        broadcast_autovoice_timing((int)(act_tr/slquant1)/1000, pass_delay*num_passdelay/1000, TRUE, TRUE);
                    }   
#endif        
                        
                        syncoff(&seqcore);

#ifdef UNDEF                        
     
                        /* Load Transmit and Receive Frequencies */
                        printf("Tf1= %d, Tf2 = %d, ->rsp_info[%d].rsploc= %f,pass_index =%d,slc_in_acq=%d\n",rf1_freq[sliceindex1],rf2_freq[sliceindex1],sliceindex1,rsp_info[sliceindex1].rsprloc,pass_index, slc_in_acq[pass_index]);
                        
                        printf("excitation = %d out of %d NEX\n", excitation,rspnex_temp);
                        printf("Slice = %d && Slice1 = %d\n",slice,slice1);
                        printf("Slice Index = %d && Slice Index 1 = %d\n",sliceindex, sliceindex1);
                        printf("false_slice = %d && rspslqb = %d\n",false_slice,rspslqb);
                        printf("rspslq = %d && slq_to_shift = %d\n",rspslq,slq_to_shift);
                        fflush(stdout);
#endif 
                    }  /* slice */                    
                   
                }  /* false_pass */
                
                if (rspchp == CHOP_NONE) SpSatChop();
		
#ifdef UNDEF
		if (debugstate==1)
                    sprintf(psddbgstr,"Ileave=%6d",ileave);
		printdbg(psddbgstr,debugstate);
#endif
        if ((diff_order_flag == 2) &&
            (ileave == rspilv-1) &&
                (core_rep == rsprep-1))
        {
            diff_pass_counter++;
        }
		
            } /* excitation */

	} /* ileave */
    } /* core_rep */	

    printdbg("Returning from CORE", debugstate);
    return SUCCESS;
    
} /* End Core */


STATUS reset_for_scan(void)
{
    int i;

    /* RF1, echo1 and trigger array are already set */
    boffset(off_seqcore);

    if ((rspent == L_SCAN) || (rspent == L_REF) || (rspent == L_APS2) || (rspent == L_MPS2))
    {
        for (i=0;i<etl;i++)
            setrfltrs((int)scanslot, &(echotrain[i]));
    }

    setrotatearray((SHORT)(opslquant*opphases),rsprot[0]);

    return SUCCESS;
}

/* RTB0 correction*/
void reset_to_epi2scan(void){
    boffset(off_seqcore);
    settriggerarray((SHORT)(opslquant*opphases), rsptrigger); /*reset trigger to original*/
}

/***************************** blineacq  *************************/
#ifdef __STDC__ 
STATUS blineacq( void )
#else /* !__STDC__ */
    STATUS blineacq()
#endif /* __STDC__ */
{
    int bcnt, nslice, rcnt, slindex;
    int bl_slice_end;

    if (rspent == L_REF) /* for ref entry point, play baselines for all slices */
        bl_slice_end = rspslq;
    else /* otherwise, play baselines for first slice only */
        bl_slice_end = rspslqb + 1;
  
    printdbg("Entering blineacq", (SHORT)debugstate);
    boffset(off_seqblineacq);
  
    settriggerarray((SHORT)1, rsptrigger_temp);
    if (baseline > 0 && rawdata == PSD_ON) {    /* collect single frame */
        sp_sat_index = 0;
	startseq((short)0, (SHORT)MAY_PAUSE);
	printdbg("B", (SHORT)debugstate);
    } else {
	dabop = 0; /* Store data */
	for (bcnt = rspbasb; bcnt <= rspbas; bcnt++) {
            for (rcnt = 0;rcnt < rsprep; rcnt++) {
                for (nslice = rspslqb;nslice < bl_slice_end; nslice++) {

                    /* play last baseline at longer TR */
                    if ( (rspbas > 1) && (bcnt == rspbas) && (nslice == bl_slice_end - 1) && (rcnt == rsprep - 1)  )
                        setperiod(bl_acq_tr2, &seqblineacq, 0);

                    if (nslice < slc_in_acq[pass_index]) {
			slindex = nslice + rcnt*rspslq;
                        /* Load the HSDAB or DIFFDAB packet. */

                        if(hsdab == 2)
                        {
                            loaddiffdab( &diffdabbl,
                                         (LONG) 0,
                                         (LONG) dabop,
                                         (LONG) 1,
                                         (LONG) 0,
                                         (LONG) slindex,
                                         (LONG) 1,
                                         (LONG) 1,
                                         (LONG) 1,
                                         (LONG) 0,
                                         (LONG) 0,
                                         (LONG) 0,
                                         (LONG) 0,
                                         (TYPDAB_PACKETS) DABON,
                                         (LONG) diffdabmask );
                        }
                        else
                        {
		  	    loadhsdab(&hyperdabbl,
                                      (LONG)slindex,
                                      (LONG)0,
                                      (LONG)dabop,
                                      (LONG)0,
                                      (LONG)1,
                                      (LONG)1,
                                      (LONG)1,
                                      (LONG)1,
                                      (TYPDAB_PACKETS)DABON,
                                      (LONG)hsdabmask);
                        }

                        sp_sat_index = 0;
                        startseq((short)0, (SHORT)MAY_PAUSE);
                        printdbg("B", (SHORT)debugstate);
                    }		  
		
                } /* for (nslice = rspslqb;nslice <= rspslq; nslice++) */
            } /* reps loop */
            dabop = 1;       /* add baseviews */
        } /* for (bcnt = 1; bcnt <= rspbas; bcnt++) */
    } /* if (baseline > 0 && rawdata == PSD_ON) */
  
    /* Return to standard trigger array and core offset */
    settriggerarray((SHORT)(opslquant*opphases), rsptrigger);

    return SUCCESS;
  
} /* end blineacq */


/***************************** dabrbaload *************************/
#ifdef __STDC__

STATUS dabrbaload(INT blipsw,
                  INT blipstart,
                  INT blipinc,
                  INT etl,
                  INT fovshift)

#else /* !__STDC__ */
    STATUS dabrbaload(blipsw, blipstart, blipinc, etl, fovshift)
    INT blipsw;
    INT blipstart;
    INT blipinc;
    INT etl;
    INT fovshift;
#endif /* __STDC__ */
{
    TYPDAB_PACKETS dabacqctrl;
    int echo;                 /* loop counter */
    int echo_nex;
    int freq_ctrl = 0;
    int phase_ctrl = 0;

    int kz_idx;
    float kz_off, kz_to_phase;
    float slice_fov_shift_phase;
    float slice_fov_shift_area_to_use;

    /* BJM: pass nex to echo slot for mag. avg'd multi-nex diffusion */
    if((opdiffuse == PSD_ON || tensor_flag == PSD_ON) && (rspent == L_SCAN)) {
        echo_nex = excitation-1;
    } else {
        echo_nex = 0;
    }

    dabacqctrl = (TYPDAB_PACKETS)acq_data;
    if (hsdab == 1)
    {
	loadhsdab(&hyperdab,        /* load hyperdab */
		  (LONG)slicerep,
	          (LONG)echo_nex,        /* note, this is the echonum slot */
		  (LONG)dabop,
		  (LONG)view1st[ileave],
		  (LONG)viewskip[ileave],
		  (LONG)etl,
                  (LONG)1, /* card_rpt */
                  (LONG)1, /* k_read */
	          dabacqctrl,
	          (LONG)hsdabmask);
    }
    else if (hsdab == 2)
    {
        int ioffset = ref_in_scan_flag + (rpg_in_scan_flag?rpg_in_scan_num:0);

        /* Note: For diffusion hyper DAB, indices below can be determined with diff_index */
        instance_index = 0;
        dir_index = 0;
        b_index = 0;
        vol_index = pass;
        frame_type = REF_FRAME;

        if ( (ref_in_scan_flag && (diff_index == 0)) || (rspent == L_REF) )
        { /*ref*/
            frame_type = REF_FRAME;
        }
        else if ( rpg_flag && rpg_in_scan_flag && (diff_index < ioffset))
        {   /* RPG TODO */
            frame_type = T2_FRAME;
            instance_index = diff_index - ref_in_scan_flag;
        }
        else if ( ((diff_index > (ioffset-1) ) && (diff_index < opdifnumt2 + ioffset)) && (rspent == L_SCAN))
        {  /*T2, if ref_in_scan_flag is off, it starts from 0, otherwise, starts from 1*/
            frame_type = T2_FRAME;
            instance_index = diff_index - ref_in_scan_flag; /*T2 instance index starting from 0*/
        }
        else if (rspent == L_SCAN)
        {
            frame_type = DIFF_FRAME;
            dir_index = (diff_index - opdifnumt2 - ioffset) % opdifnumdirs; /*diff dir_index starts from 0 */
            b_index = (diff_index - opdifnumt2 - ioffset)/ opdifnumdirs;
        }

        if(diff_order_debug == PSD_ON)
        {
            sprintf(psddbgstr,"pass: %d, diff_index:%d, echo_nex:%d, dabop:%d, frame_type:%d, instance_index:%d, slicerep:%d, b_index:%d, dir_index:%d, vol_index:%d \n",
                    pass, diff_index, echo_nex, dabop, (int)frame_type, instance_index, slicerep,  b_index, dir_index, vol_index);
            printdbg(psddbgstr, diff_order_debug);

            fprintf(fp_diff_order, "%s", psddbgstr);
        }

        loaddiffdab( &diffdab,
                     (LONG) echo_nex,
                     (LONG) dabop,
                     (LONG) frame_type,
                     (LONG) instance_index,
                     (LONG) slicerep,
                     (LONG) view1st[ileave],
                     (LONG) viewskip[ileave],
                     (LONG) etl,
                     (LONG) b_index,
                     (LONG) dir_index,
                     (LONG) vol_index,
                     (LONG) gradpol_dab,
                     dabacqctrl,
                     (LONG) diffdabmask );
    }

    if (mux_flag)
    {
        if (fovshift == 0) {
            fovshift = slice_fov_shift;
        }
        slice_fov_shift_area_to_use = slice_fov_shift_area;

        kz_idx = blipstart;
        kz_to_phase = 2.0 * PI * GAM * (slice_fov_shift_area_to_use/1e6)/ (fovshift-1);    /* phase/cm / kz_offset */
    }
    else
    {
        fovshift = 0;
        slice_fov_shift_area_to_use = 0.0;
        kz_idx = 0;
        kz_to_phase = 0.0;
    }

    /* Load the receive frequency/phase and dab packets */
    for (echo=0; echo<etl; echo++) {
      
        /* MRIge56894 - only set this stuff during real data acq */
        if(acq_data != DABOFF) { 
            /* BJM: we set the demod freq (sl_rcvcf) in the freq offset */
            /* register and then use omega to offset the slice along */
            /* the read axis.  For non-ramp sampled cases, the offset */
            /* waveform is a constant pulse.  For ramp sampled waveforms */
            /* the offset freq wavefrom is a trapezoid (freq mod on ramps */
            /* This simplifies the phase accumulation across the echo since */
            /* we no longer have to worry about the time it takes to latch */
            /* a freq. offset which leads to an uncertainty in how long we */
            /* accumulate phase across each echo in the train */
          
            freq_ctrl = sl_rcvcf;

            if ((blipsw == 0) || (PSD_OFF== mux_flag) || (echo < iref_etl)) {
                phase_ctrl = recv_phase[sliceindex][ileave][echo];
            } else {
                /* Calculate phase correction for center slice to remove effect of Kz encoding */
                kz_off = -1 * (kz_idx - (fovshift-1)/2.0);
                if (mux_flag && ((mux_slices_rf1 & 1) == 1))
                    slice_fov_shift_phase =  (rsp_info[sliceindex].rsptloc/10.0) * kz_off * kz_to_phase;
                else
                    slice_fov_shift_phase =  ((rsp_info[sliceindex].rsptloc + mux_slice_shift_mm_rf1/2.0)/10.0) * kz_off * kz_to_phase;
                phase_ctrl = calciphase(recv_phase_angle[sliceindex][ileave][echo] + slice_fov_shift_phase);

                kz_idx = (kz_idx + blipinc) % (fovshift);
            }
            
            setfreqphase(freq_ctrl,
                         phase_ctrl,
                         echotrainxtr[echo]);
          
            /* frequency offset */ 
            tempamp=(short)((recv_freq[sliceindex][ileave][echo]-sl_rcvcf)/omega_scale);
          
            if (vrgfsamp){
              
                setiampt(tempamp, &omega_flat, echo);
              
            } else {
              
                setiamp(tempamp, &omega_flat, echo);
              
            }

        } /* end acq_data condition */
      
        if ((echo >= rspe1st) && (echo < rspe1st + rspetot))
            dabacqctrl = (TYPDAB_PACKETS)acq_data;
        else
            dabacqctrl = DABOFF;
      
        acqctrl(dabacqctrl, fast_rec, echotrainrba[echo]);
      
    } /* end echo loop for setting op xtr packets */ 

    return SUCCESS;

} /* End dabrbaload */

/***************************** diffamp *************************/
STATUS diffamp( INT dshot )
{
    if((dshot < 0)||(rspent == L_MPS2)||(rspent == L_APS2)||(rspent == L_REF))
    {
        ia_incdifx = 0;
        ia_incdify = 0;
        ia_incdifz = 0;
    }
    else
    {
        /* DWI */
        if(opdiffuse == PSD_ON && tensor_flag == PSD_OFF)
        {
            getDiffGradAmp(&incdifx, &incdify, &incdifz, dshot);
            ia_incdifx = (int)(incdifx*(float)max_pg_iamp/loggrd.tx);
            ia_incdify = (int)(incdify*(float)max_pg_iamp/loggrd.ty);
            ia_incdifz = (int)(incdifz*(float)max_pg_iamp/loggrd.tz);
        }
        /* DTI BJM: do the tensor acq. */
        else if(tensor_flag == PSD_ON)
        {
	    if(ide_max_bval < max_bval){ 
		max_bval =  ide_max_bval;
	    }
	    if(sde_max_bval < max_bval){ 
		max_bval =  sde_max_bval;
	    }
	    waveform_type = (int)WAVE_AGP[dshot];/* granty edit to read in waveform type */
	    if(waveform_type == 3){ /* isotropic diffusion */
                 ia_incdifx = (int)(incdifx*TENSOR_AGP[0][dshot]*(float)max_pg_iamp/loggrd.tx*(float)sqrt(max_bval/ide_max_bval));
                 ia_incdify = (int)(incdify*TENSOR_AGP[1][dshot]*(float)max_pg_iamp/loggrd.ty*(float)sqrt(max_bval/ide_max_bval));
                 ia_incdifz = (int)(incdifz*TENSOR_AGP[2][dshot]*(float)max_pg_iamp/loggrd.tz*(float)sqrt(max_bval/ide_max_bval));
	    }else{ /* waveform type == 1 */
                 ia_incdifx = (int)(incdifx*TENSOR_AGP[0][dshot]*(float)max_pg_iamp/loggrd.tx*(float)sqrt(max_bval/sde_max_bval));
                 ia_incdify = (int)(incdify*TENSOR_AGP[1][dshot]*(float)max_pg_iamp/loggrd.ty*(float)sqrt(max_bval/sde_max_bval));
                 ia_incdifz = (int)(incdifz*TENSOR_AGP[2][dshot]*(float)max_pg_iamp/loggrd.tz*(float)sqrt(max_bval/sde_max_bval));
	    }


            if (debugTensor == PSD_ON)
            {
                printf("Shot # = %d\n", dshot);
		printf("Waveform type: %d \n", waveform_type);
                printf("TENSOR_AGP[0] = %f\n", TENSOR_AGP[0][dshot]);
                printf("TENSOR_AGP[1] = %f\n", TENSOR_AGP[1][dshot]);
                printf("TENSOR_AGP[2] = %f\n\n",TENSOR_AGP[2][dshot]);
                printf("incdifx=%d,incdify=%d,incdifz=%d,dshot=%d\n",ia_incdifx,ia_incdify,ia_incdifz,dshot);
                fflush(stdout);
            }
        }
    }
        
    return SUCCESS;
}

/***************************** diffstep *************************/
STATUS diffstep( INT dshot )
{
    int i;
    /* granty edit for swapping waveforms */
    LONG bufferedwave;
    diffamp(dshot);

#ifdef UNDEF

    if (hoecc_flag == PSD_OFF)  /* only turn on linear correction if HOECC is off */
    {
        /*************************************************************/
        /* compute cross term correction values                      */
        /*************************************************************/
        
        /* B0 calculation */
        
        freq_dwi = (float)ia_incdifx/(float)max_pg_iamp*loggrd.tx*dwibcor[0];
        freq_dwi += (float)ia_incdify/(float)max_pg_iamp*loggrd.ty*dwibcor[1];
        freq_dwi += (float)ia_incdifz/(float)max_pg_iamp*loggrd.tz*dwibcor[2];
        
        freq_dwi = freq_dwi*GAM; /* convert frequency from Gauss to Herz */
        phase_dwi = freq_dwi*TWO_PI*(float)esp/(1.0e6);  /* convert freq to phase */
        
        
        /* gradient calculation */
        
        ia_gx_dwi=ia_incdifx*dwigcor[0];
        ia_gx_dwi=ia_gx_dwi+ia_incdify*dwigcor[3];
        ia_gx_dwi=ia_gx_dwi+ia_incdifz*dwigcor[6];
        
        ia_gy_dwi=ia_incdifx*dwigcor[1];
        ia_gy_dwi=ia_gy_dwi+ia_incdify*dwigcor[4];
        ia_gy_dwi=ia_gy_dwi+ia_incdifz*dwigcor[7];
        
        /*  now convert the phase-encoding correctin values to the
            blip correction amplitudes  */
        
        ia_gy_dwi = ia_gy_dwi*esp/(pw_gyb + pw_gyba);
        
        /* the conversion is based on area conservation */
        /* This calculation does not account for the    */
        /* change in the slew rate of gyba as a result  */
        /* of adding ia_gy_dwi to gyb                   */
        
        
        /******************************************************************************/
        /*      ia_gz_dwi not used at this time                                       */
        /******************************************************************************/
        ia_gz_dwi=ia_incdifx*dwigcor[2];
        ia_gz_dwi=ia_gz_dwi+ia_incdify*dwigcor[5];
        ia_gz_dwi=ia_gz_dwi+ia_incdifz*dwigcor[8];
        
        tmp_ileave=ileave;
        ileave=0;
        setreadpolarity();
        ileave=tmp_ileave;
        
        tmp_ygrad_sw=1;
        ygradctrl(tmp_ygrad_sw,gyb_amp,etl);
       
        /** added by XJZ for B0-eddy current DWI correction  **/
        
        if (dwicntrl==1)
            for (ii=0; ii<opslquant; ii++)
                for(jj=0; jj<intleaves; jj++)
                    for(kk=0; kk<tot_etl; kk++)
                    {
                        recv_phase_angle[ii][jj][kk] = recv_phase_ang_nom[ii][jj][kk];
                        recv_phase_angle[ii][jj][kk] += (phase_dwi/2.0+phase_dwi*(float)kk);
                        recv_phase[ii][jj][kk] = calciphase(recv_phase_angle[ii][jj][kk]);
                    }
        
        /* end cross term correction  and B0 computation */
    }
#endif  /* UNDEF */

    /* Calculate read, blip grad and receiver freq compensation; update receiver phase in diffstep() */
{ /* Start of code inlined from HoecCorr.e HoecCalcAmpUpdateReceiverPhaseRsp */
    if (hoecc_psd_flag == PSD_ON)
    {
        int ii, jj, pp;

        /* per-slice per-echo gradient instruction amplitude and receiver phase needed for HOEC compensation */
        for (pp=0; pp<intleaves; pp++)
        {
            for (ii=0; ii<opslquant; ii++)
            {
                for (jj=0; jj<tot_etl; jj++)
                {
                    if(jj < iref_etl) /* interref echoes played out before diffusion gradients */
                    {
                        ia_gx_hoec_comp[pp][ii][jj] = 0;
                        ia_gy_hoec_comp[pp][ii][jj] = 0;
                        recv_phase_b0_hoec_comp[pp][ii][jj] = 0;
                        continue;
                    }
                    
                    /* X grad */
                    ia_gx_hoec_comp[pp][ii][jj] = (int)((double)(ia_incdifx)*dwi_hoec_gcor_XonX[pp][ii][jj] +
                                                (double)(ia_incdify)*dwi_hoec_gcor_YonX[pp][ii][jj] +
                                                (double)(ia_incdifz)*dwi_hoec_gcor_ZonX[pp][ii][jj]);
                    if (read_corr_option == 1)
                    {
                        /* pw_gxwl and pw_gxwd are wait time at the beginning and end of the plateau (typically zero) */
                        ia_gx_hoec_comp[pp][ii][jj] = ia_gx_hoec_comp[pp][ii][jj]*esp/(pw_gxwl+pw_gxw+pw_gxwr+pw_gxwad);
                    }
                    else if (read_corr_option == 2)
                    {
                        ia_gx_hoec_comp[pp][ii][jj] = ia_gx_hoec_comp[pp][ii][jj]*esp/(pw_gxwl+pw_gxw+pw_gxwr);
                    }

                    /* Y grad */
                    ia_gy_hoec_comp[pp][ii][jj] = (int)((double)(ia_incdifx)*dwi_hoec_gcor_XonY[pp][ii][jj] +
                                                (double)(ia_incdify)*dwi_hoec_gcor_YonY[pp][ii][jj] +
                                                (double)(ia_incdifz)*dwi_hoec_gcor_ZonY[pp][ii][jj]);
                    ia_gy_hoec_comp[pp][ii][jj] = ia_gy_hoec_comp[pp][ii][jj]*esp/(pw_gyb + pw_gyba);

                    /* B0 (through adjustment of receiver phase where the adjusted phase at a given echo is the
                       integration of recv_phase_b0_hoec_comp from begining of echo train to center of the given echo) */
                    recv_phase_b0_hoec_comp[pp][ii][jj] = (TWO_PI*GAM*(double)esp/(1.0e6))*
                                                          ((double)ia_incdifx/
                                                           (double)max_pg_iamp*loggrd.tx*dwi_hoec_bcor_XonB0[pp][ii][jj] +
                                                           (double)ia_incdify/(double)max_pg_iamp*loggrd.ty*dwi_hoec_bcor_YonB0[pp][ii][jj] +
                                                           (double)ia_incdifz/(double)max_pg_iamp*loggrd.tz*dwi_hoec_bcor_ZonB0[pp][ii][jj]);
                }
            }
        }

        /* save intermediate results */
        if (hoecc_debug == PSD_ON)
        {
            printf("HOEC realtime correction: pass_rep=%d ileave=%d slice=%d echo=%d\n",
                    dshot, psd_ileave_for_debug, psd_slice_for_debug, psd_echo_for_debug);
            printf("gx=%6d gy=%6d recv_phase=%12.3e\n",
                    ia_gx_hoec_comp[psd_ileave_for_debug][psd_slice_for_debug][psd_echo_for_debug],
                    ia_gy_hoec_comp[psd_ileave_for_debug][psd_slice_for_debug][psd_echo_for_debug],
                    recv_phase_b0_hoec_comp[psd_ileave_for_debug][psd_slice_for_debug][psd_echo_for_debug]);
        }

        /* update recv_phase array that is used in dabrbaload() call later in core() */
        HoecCalcReceiverPhase();  /* in core(), dabrbaload() actually applies recv_phase that is calculated here */
    }
} /* End of code inlined from HoecCorr.e HoecCalcAmpUpdateReceiverPhaseRsp */

/* Update read and blip instruction amplitudes in core() */

    /*	turn off diffusion during prescan	*/

    if((rspent==L_MPS2)||(rspent==L_APS2)||(rspent==L_REF)) 
    {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
/* granty edit from setiampt to setiamp for custom waveforms */
            setiamp(0, &gxdl, 0);
            setiamp(0, &gxdr, 0);
            setiamp(0, &gydl, 0);
            setiamp(0, &gydr, 0);
            setiamp(0, &gzdl, 0);
            setiamp(0, &gzdr, 0);
        } else {
            setiampt(0, &gxdl1, 0);
            setiampt(0, &gxdr1, 0);
            setiampt(0, &gxdl2, 0);
            setiampt(0, &gxdr2, 0);
          
            setiampt(0, &gydl1, 0);
            setiampt(0, &gydr1, 0);
            setiampt(0, &gydl2, 0);
            setiampt(0, &gydr2, 0);
          
            setiampt(0, &gzdl1, 0);
            setiampt(0, &gzdr1, 0); 
            setiampt(0, &gzdl2, 0);
            setiampt(0, &gzdr2, 0);
        }
  
    }
    else
    {
        /* DTI */
        if (PSD_OFF == dualspinecho_flag)
        {
/* granty edit swap out waveforms between TRs */
	    if(waveform_type == 3){/*qti*/
	     	getwave(&bufferedwave, &gxiso1);
	     	setwave(bufferedwave,&gxdl,0);
	     	getwave(&bufferedwave, &gxiso2);
	     	setwave(bufferedwave,&gxdr,0);

	     	getwave(&bufferedwave, &gyiso1);
	     	setwave(bufferedwave,&gydl,0);
	     	getwave(&bufferedwave, &gyiso2);
	     	setwave(bufferedwave,&gydr,0);

	     	getwave(&bufferedwave, &gziso1);
	     	setwave(bufferedwave,&gzdl,0);
	     	getwave(&bufferedwave, &gziso2);
	     	setwave(bufferedwave,&gzdr,0);


		/* granty edit setiampt to setiamp for custom waveforms */
            	setiamp(ia_incdifx, &gxdl, 0);
            	setiamp(ia_incdifx, &gxdr, 0);
            	setiamp(ia_incdify, &gydl, 0);
            	setiamp(ia_incdify, &gydr, 0);
            	setiamp(ia_incdifz, &gzdl, 0);
           	setiamp(ia_incdifz, &gzdr, 0);
	    }else{/*sde*/
	     	getwave(&bufferedwave, &gxdlbuff);
	     	setwave(bufferedwave,&gxdl,0);
	     	getwave(&bufferedwave, &gxdrbuff);
	     	setwave(bufferedwave,&gxdr,0);

	     	getwave(&bufferedwave, &gydlbuff);
	     	setwave(bufferedwave,&gydl,0);
	     	getwave(&bufferedwave, &gydrbuff);
	     	setwave(bufferedwave,&gydr,0);

	     	getwave(&bufferedwave, &gzdlbuff);
	     	setwave(bufferedwave,&gzdl,0);
	     	getwave(&bufferedwave, &gzdrbuff);
	     	setwave(bufferedwave,&gzdr,0);

		/* granty edit setiampt to setiamp for custom waveforms */
            	setiamp(ia_incdifx, &gxdl, 0);
            	setiamp(ia_incdifx, &gxdr, 0);
            	setiamp(ia_incdify, &gydl, 0);
            	setiamp(ia_incdify, &gydr, 0);
            	setiamp(ia_incdifz, &gzdl, 0);
           	setiamp(ia_incdifz, &gzdr, 0);
	    }
        } 
        else 
        {
            setiampt(ia_incdifx, &gxdl1, 0);
            setiampt(-ia_incdifx, &gxdr1, 0);
            setiampt(ia_incdifx, &gxdl2, 0);
            setiampt(-ia_incdifx, &gxdr2, 0);

            setiampt(ia_incdify, &gydl1, 0);
            setiampt(-ia_incdify, &gydr1, 0);
            setiampt(ia_incdify, &gydl2, 0);
            setiampt(-ia_incdify, &gydr2, 0);

            setiampt(ia_incdifz, &gzdl1, 0);
            setiampt(-ia_incdifz, &gzdr1, 0); 
            setiampt(ia_incdifz, &gzdl2, 0);
            setiampt(-ia_incdifz, &gzdr2, 0);
        }
    }       

    freqSign = 1;
    freqSign_ex = 1;
    freqSign_rf2 = 1;
    freqSign_rf2right = 1;
    freqSign_rf2left = 1;

    if (PSD_OFF == dualspinecho_flag)
    {
            /* Keep the polarity of rf1 and rf2 slice select grad and crusher same as diff grad */
            if(invertSliceSelectZ == PSD_ON || invertSliceSelectZ2 == PSD_ON)
            {
                if((invertSliceSelectZ==PSD_ON && ((ia_incdifz<0 && ia_gzrf2r1>0) || (ia_incdifz>0 && ia_gzrf2r1<0))) ||
                    (invertSliceSelectZ2==PSD_ON && ia_gzrf2r1<0))
            {
                freqSign = -1;
                freqSign_ex = -1;
                freqSign_rf2 = -1;
            }
            else
            {
                freqSign = 1;
                freqSign_ex = 1;
                freqSign_rf2 = 1;
            }
        }
        if(ssgr_flag)
        {
            freqSign *= -1;
            freqSign_ex *= -1;
        }

        /* 90 */
        if (ss_rf1 || rfov_flag) setiamp(freqSign*ia_gzrf1, &gzrf1, 0);
        else 
        {
            setiamp(freqSign*ia_gzrf1, &gzrf1a, 0);
            setiamp(freqSign*ia_gzrf1, &gzrf1, 0);
            setiamp(freqSign*ia_gzrf1, &gzrf1d, 0);
        }   
        /* RTB0 correction*/
        if(rtb0_flag || (dpc_flag && (!mux_flag)))
        {
            setiampt(freqSign*ia_gz1, &gz1, 0);
        }

        if (rfov_flag)
        {
            setiamp(freqSign*ia_gyrf1, &gyrf1, 0);
            if (ia_gyex1 != 0)
            {
                setiamp(freqSign*ia_gyex1, &gyex1a, 0);
                setiamp(freqSign*ia_gyex1, &gyex1, 0);
                setiamp(freqSign*ia_gyex1, &gyex1d, 0);
            }
        }

        /* 180 + crushers */
        setiamp(freqSign_rf2*ia_gzrf2l1, &gzrf2l1a, 0);
        setiamp(freqSign_rf2*ia_gzrf2l1, &gzrf2l1, 0);
        setiamp(freqSign_rf2*max_pg_iamp, &gzrf2l1d, 0);
        setiamp(freqSign_rf2*ia_gzrf2, &gzrf2, 0);
        setiamp(freqSign_rf2*max_pg_iamp, &gzrf2r1a, 0);
        setiamp(freqSign_rf2*ia_gzrf2r1, &gzrf2r1, 0);
        setiamp(freqSign_rf2*ia_gzrf2r1, &gzrf2r1d, 0);

        /* Inversion pulse */
        if(ir_on && (skip_ir == PSD_OFF)) setiampt(freqSign*ia_gzrf0, &gzrf0, INSTRALL);

            /* Keep the polarity of XY crusher same as diff grad */
            if(invertCrusherXY == PSD_ON)
            {
                if((ia_incdifx < 0 && ia_xgradCrusherR >0) || (ia_incdifx > 0 && ia_xgradCrusherR <0)) {
                    if(xygradCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_xgradCrusherL, &xgradCrusherL, 0);
                        setiampt(-ia_xgradCrusherR, &xgradCrusherR, 0);
                    }
                } else {
                    if(xygradCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_xgradCrusherL, &xgradCrusherL, 0);
                        setiampt(ia_xgradCrusherR, &xgradCrusherR, 0);
                    }
                } 
                if((ia_incdify < 0 && ia_ygradCrusherR >0) || (ia_incdify > 0 && ia_ygradCrusherR <0)) {
                    if(xygradCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_ygradCrusherL, &ygradCrusherL, 0);
                        setiampt(-ia_ygradCrusherR, &ygradCrusherR, 0);
                    }
                } else {
                    if(xygradCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_ygradCrusherL, &ygradCrusherL, 0);
                        setiampt(ia_ygradCrusherR, &ygradCrusherR, 0);
                    }
                } 
            }
    }
    else 
    {
            /* Need to flip sign of SlicSel gradients to */
            /* prevent STE formation due to balancing    */
            /* of diffusion lobes on Z and slice select  */
            /* crushers....                             */
            /* keep the polarity of slice select grad and crusher same as the last diff grad lobe */
            if(PSD_ON == invertSliceSelectZ || PSD_ON == invertSliceSelectZ2) {

                if((invertSliceSelectZ==PSD_ON && ((ia_incdifz>0 && ia_gzrf2leftr1>0) || (ia_incdifz<0 && ia_gzrf2leftr1<0))) || 
                   (invertSliceSelectZ2==PSD_ON && ia_gzrf2leftr1>0)) {
                freqSign = -1;
                freqSign_ex = -1;
                    freqSign_rf2left = -1;
                freqSign_rf2right = -1;
            } 
            else
            {
                freqSign = 1;
                freqSign_ex = 1;
                freqSign_rf2left = 1;
                freqSign_rf2right = 1;
            }
        }
        if(ssgr_flag)
        {
            freqSign *= -1;
            freqSign_ex *= -1;
            freqSign_rf2left *= -1;
        }

        /* 90 */
        if (ss_rf1 || rfov_flag) setiamp(freqSign*ia_gzrf1, &gzrf1, 0);
        else 
        {
            setiamp(freqSign*ia_gzrf1, &gzrf1a, 0);
            setiamp(freqSign*ia_gzrf1, &gzrf1, 0);
            setiamp(freqSign*ia_gzrf1, &gzrf1d, 0);
        }
        /* RTB0 correction*/
        if(rtb0_flag || (dpc_flag && (!mux_flag)))
        {
            setiampt(freqSign*ia_gz1, &gz1, 0);
        }

        if (rfov_flag)
        {
            setiamp(freqSign*ia_gyrf1, &gyrf1, 0);
            if (ia_gyex1 != 0)
            {
                setiamp(freqSign*ia_gyex1, &gyex1a, 0);
                setiamp(freqSign*ia_gyex1, &gyex1, 0);
                setiamp(freqSign*ia_gyex1, &gyex1d, 0);
            }
        }

        /* left 180 + crushers */
        setiamp(freqSign_rf2left*ia_gzrf2leftl1, &gzrf2leftl1a, 0);
        setiamp(freqSign_rf2left*ia_gzrf2leftl1, &gzrf2leftl1, 0);
        setiamp(freqSign_rf2left*max_pg_iamp, &gzrf2leftl1d, 0);
        setiamp(freqSign_rf2left*ia_gzrf2left, &gzrf2left, 0);
        setiamp(freqSign_rf2left*max_pg_iamp, &gzrf2leftr1a, 0);
        setiamp(freqSign_rf2left*ia_gzrf2leftr1, &gzrf2leftr1, 0);
        setiamp(freqSign_rf2left*ia_gzrf2leftr1, &gzrf2leftr1d, 0);

        /* right 180 + crushers */
        setiamp(freqSign_rf2right*ia_gzrf2rightl1, &gzrf2rightl1a, 0);
        setiamp(freqSign_rf2right*ia_gzrf2rightl1, &gzrf2rightl1, 0);
        setiamp(freqSign_rf2right*max_pg_iamp, &gzrf2rightl1d, 0);
        setiamp(freqSign_rf2right*ia_gzrf2right, &gzrf2right, 0);
        setiamp(freqSign_rf2right*max_pg_iamp, &gzrf2rightr1a, 0);
        setiamp(freqSign_rf2right*ia_gzrf2rightr1, &gzrf2rightr1, 0);
        setiamp(freqSign_rf2right*ia_gzrf2rightr1, &gzrf2rightr1d, 0);

        /* Inversion pulse */
        if(ir_on && (skip_ir == PSD_OFF)) setiampt(freqSign*ia_gzrf0, &gzrf0, INSTRALL);

            /* Keep the polarity of left XY crusher same as 1st diff grad lobe,
               and right XY crusher as the last diff grad lobe */
            if(invertCrusherXY == PSD_ON)
            {
                if((ia_incdifx < 0 && ia_xgradLeftCrusherR >0) || (ia_incdifx > 0 && ia_xgradLeftCrusherR <0)) {
                    if(xygradLeftCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_xgradLeftCrusherL, &xgradLeftCrusherL, 0);
                        setiampt(-ia_xgradLeftCrusherR, &xgradLeftCrusherR, 0);
                    }
                    if(xygradRightCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_xgradRightCrusherL, &xgradRightCrusherL, 0);
                        setiampt(ia_xgradRightCrusherR, &xgradRightCrusherR, 0);
                    }
                } else {
                    if(xygradLeftCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_xgradLeftCrusherL, &xgradLeftCrusherL, 0);
                        setiampt(ia_xgradLeftCrusherR, &xgradLeftCrusherR, 0);
                    }
                    if(xygradRightCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_xgradRightCrusherL, &xgradRightCrusherL, 0);
                        setiampt(-ia_xgradRightCrusherR, &xgradRightCrusherR, 0);
                    }
                } 
                if((ia_incdify < 0 && ia_ygradLeftCrusherR >0) || (ia_incdify > 0 && ia_ygradLeftCrusherR <0)) {
                    if(xygradLeftCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_ygradLeftCrusherL, &ygradLeftCrusherL, 0);
                        setiampt(-ia_ygradLeftCrusherR, &ygradLeftCrusherR, 0);
                    }
                    if(xygradRightCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_ygradRightCrusherL, &ygradRightCrusherL, 0);
                        setiampt(ia_ygradRightCrusherR, &ygradRightCrusherR, 0);
                    }
                } else {
                    if(xygradLeftCrusherFlag == PSD_ON)
                    {
                        setiampt(ia_ygradLeftCrusherL, &ygradLeftCrusherL, 0);
                        setiampt(ia_ygradLeftCrusherR, &ygradLeftCrusherR, 0);
                    }
                    if(xygradRightCrusherFlag == PSD_ON)
                    {
                        setiampt(-ia_ygradRightCrusherL, &ygradRightCrusherL, 0);
                        setiampt(-ia_ygradRightCrusherR, &ygradRightCrusherR, 0);
                    }
                } 
            }
    }

    for (i=0; i<opslquant; i++) 
    {
        if (ss_rf1 == PSD_ON) 
        {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, 0, freqSign);
        } 
        else 
        {
            setupphases(rf1_pha, rf1_freq, i, rf1_phase, t_rf1_phase, freqSign);
        }

        if(ir_on)
        {
            setupphases(rf0_pha, rf0_freq, i, rf0_phase, 0, freqSign);
        }

        if(PSD_OFF == dualspinecho_flag)
        {
            setupphases(rf2_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2);
        }
        else
        {
            setupphases(rf2left_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2left);
            setupphases(rf2right_pha, rf2_freq, i, rf2_phase, t_rf2_phase, freqSign_rf2right);
        }
    }		

    return SUCCESS;

}

/***************************** msmpTrig *************************/
/* Build the trigger for multi-slice, multi-phase cardiac */
#ifdef __STDC__ 
STATUS msmpTrig(void )
#else /* !__STDC__ */
    STATUS msmpTrig()
#endif /* __STDC__ */
{
    if ((opcgate == PSD_ON) && (opphases > 1) &&
        ((rspent == L_MPS2)||(rspent == L_APS2)||
         (rspent == L_SCAN)||(rspent == L_REF))) 
    {
        if (slice == 0) {
            switch(rspent) {
            case L_MPS2:
                settrigger((short)trig_mps2, (short)sliceindex);
                break;
            case L_APS2:
                settrigger((short)trig_aps2, (short)sliceindex);
                break;
            case L_SCAN:
            case L_REF:
                settrigger((short)trig_scan, (short)sliceindex);
                break;
            default:
                break;
            }
        }
        else
            settrigger((short)TRIG_INTERN, (short)sliceindex);
    }
    return SUCCESS;
}

/***************************** phaseReset*************************/
STATUS
#ifdef __STDC__
phaseReset( WF_PULSE_ADDR pulse,
            INT control )
#else /* !__STDC__ */
    phaseReset(pulse, control)
    WF_PULSE_ADDR pulse;
    INT control;
#endif /* __STDC__ */
{
    SHORT loadbits;

    if (control == 0)
        loadbits = 0;
    else
        loadbits = EDC;

    sspload((SHORT *)&loadbits,
            (WF_PULSE_ADDR)pulse,
            (LONG)0,
            (SHORT)1,
            (HW_DIRECTION)TOHARDWARE,
            (SSP_S_ATTRIB)SSPS1);

    return SUCCESS;
}

/***************************** ygradctrl  *************************/
#ifdef __STDC__
STATUS ygradctrl( INT blipsw,
                  INT blipwamp,
                  INT numblips )
#else /* !__STDC__ */
    int ygradctrl(blipsw, blipwamp, numblips)
    INT blipsw;
    INT blipwamp;
    INT numblips;
#endif /* __STDC__ */
{
    int bcnt;
    int dephaser_amp;
    int gmn_amp;
    int parity;

    parity = gradpol[ileave];

    if (blipsw == 0) {
        dephaser_amp = 0;
        gmn_amp = 0;
        for (bcnt=0;bcnt<numblips-1;bcnt++)
            setiampt((short)0, &gyb, bcnt);
    } else {
        gmn_amp = ia_gymn2;
        if (rsppepolar == PSD_OFF)
        {
            dephaser_amp = -gy1f[0];
            for (bcnt=0;bcnt<numblips-1;bcnt++) {
                if (oblcorr_perslice == 1)
                    setiampt((short)(-blipwamp + parity*rspia_gyboc[slice]-ia_gy_dwi), &gyb, bcnt);
                else
                    setiampt((short)(-blipwamp + parity*rspia_gyboc[0]-ia_gy_dwi), &gyb, bcnt);
                parity *= -1;
            }
        } 
        else 
        {
            dephaser_amp = gy1f[0];
            for (bcnt=0;bcnt<numblips-1;bcnt++) {
                if (oblcorr_perslice == 1)
                    setiampt((short)(blipwamp + parity*rspia_gyboc[slice]-ia_gy_dwi), &gyb, bcnt);
                else
                    setiampt((short)(blipwamp + parity*rspia_gyboc[0]-ia_gy_dwi), &gyb, bcnt);
                parity *= -1;
            }
        }
    }	 

    setiampt((short)dephaser_amp, &gy1, 0);
    if (ygmn_type == CALC_GMN1) {
        setiampt((short)-gmn_amp, &gymn1, 0);
        setiampt((short)gmn_amp, &gymn2, 0);
    }

    return SUCCESS;

} /* End ygradctrl */
/* functions that set blip amplitude and receiver phase */
STATUS zgradctrl( INT blipsw,
                  INT blipstart,
                  INT blipinc,
                  INT etl,
                  INT fovshift)
{
    int bcnt;
    int kz_last, kz_new;
    float kz_off;
    float gz1_single_blip_scale;
    float gz1_scale;
    float gzb_scale;
    float slice_fov_shift_cycles_to_use;
    float factor_gz1_to_use;

    if (blipsw == 0) {
        /* Set all blips to 0 amplitude */
        if (oppseq == PSD_GE)
            setiampt((short)(a_gz1/ loggrd.tz * MAX_PG_IAMP), &gz1, 0);
        if (oppseq == PSD_SE && use_slice_fov_shift_blips)
        {
            if(dpc_flag)
            {
                gz1_scale = area_gz1/(fabs(slice_fov_shift_area/2) + fabs(area_gz1));
                setiampt((short)(gz1_scale*a_gz1/ loggrd.tz * MAX_PG_IAMP), &gz1, 0);
            }
            else
            {
                setiampt((short)0, &gz1, 0);
            }
        }
        if ( use_slice_fov_shift_blips > 0 ) {
            for (bcnt=0;bcnt<etl-1;bcnt++) {
                setiampt((short)0, &gzb, bcnt);
            }
        }
    } else {
        /* Normal blipped slice_fov_shift */
        if (fovshift == 0) {
            fovshift = slice_fov_shift;
        }

        /* Find gz1 scaling so that we are acquiring Kz = blipstart, with Kz going from [0..fovshift-1] */
        slice_fov_shift_cycles_to_use = slice_fov_shift_cycles;
        factor_gz1_to_use = factor_gz1;

        kz_off = -1 * (blipstart - ((fovshift-1)/2.0));
        if (oppseq == PSD_GE) {
            gz1_single_blip_scale = 2*(factor_gz1_to_use-1.0)/ (slice_fov_shift_cycles_to_use * fovshift); /* gz1 multiple equivalent to single Kz blip */
            gz1_scale = 1.0 - gz1_single_blip_scale * kz_off;
            setiampt((short)(a_gz1 * gz1_scale/ loggrd.tz * MAX_PG_IAMP), &gz1, 0);
        }
        if (oppseq == PSD_SE && use_slice_fov_shift_blips) {
            gz1_single_blip_scale = 2 * factor_gz1_to_use/ (slice_fov_shift_cycles_to_use * fovshift);
            if(dpc_flag)
            {
                gz1_scale = ((kz_off * gz1_single_blip_scale)*slice_fov_shift_area/2+area_gz1)/(fabs(slice_fov_shift_area/2) + fabs(area_gz1));  
            }    
            else
            {   
                gz1_scale = kz_off * gz1_single_blip_scale;
            }
            setiampt((short)(a_gz1 * gz1_scale/ loggrd.tz * MAX_PG_IAMP), &gz1, 0);
        }

        kz_last = blipstart;
        for (bcnt=0; bcnt<etl-1; bcnt++) {
            kz_new = (kz_last + blipinc) % (fovshift);
            kz_off = -1 * (kz_new - kz_last);
            kz_last = kz_new;

            gzb_scale = kz_off/ (slice_fov_shift_cycles * fovshift); /* Always use max blip area in accelerated time points to set up gzb amplitude and width, because calibration time points never use gzb */
            setiampt((short)(gzb_amp * gzb_scale/ epiloggrd.tz * MAX_PG_IAMP), &gzb, bcnt);
        }
    }

    return SUCCESS;
} /* End zgradctrl */


/* calculate per slice receiver phase adjustment needed for B0 compensation (called in
   diffstep(), and then dabrbaload in core() actually applies recv_phase) */
STATUS HoecCalcReceiverPhase(void)
{
    int ii,jj,kk;
    /* accumulated phase from start of echo train to the center of current echo (allowing echo dependent phase) */
    double accumulated_recv_phase_b0_hoec_comp;

    for (ii=0; ii<opslquant; ii++)
        for (jj=0; jj<intleaves; jj++)
            for (kk=0; kk<tot_etl; kk++)
            {
                recv_phase_angle[ii][jj][kk] = recv_phase_ang_nom[ii][jj][kk];

                if(kk < iref_etl) continue;

                if (kk == iref_etl)
                {
                    /* 1/2.0 is because we assume the phase accumulation happens at center of echo */
                    accumulated_recv_phase_b0_hoec_comp= recv_phase_b0_hoec_comp[jj][ii][0]/2.0;
                }
                else
                {
                    /* add phase from half of current and half of last echoes*/
                    accumulated_recv_phase_b0_hoec_comp += recv_phase_b0_hoec_comp[jj][ii][kk-1]/2.0 + recv_phase_b0_hoec_comp[jj][ii][kk]/2.0;
                }

                recv_phase_angle[ii][jj][kk] += accumulated_recv_phase_b0_hoec_comp;

                recv_phase[ii][jj][kk] = calciphase(recv_phase_angle[ii][jj][kk]);
            }

    return SUCCESS;
}


/* per slice per echo instruction amplitude update for echo train readout gradients */
STATUS HoecSetEchoTrainAmp(void)
{
    int polarity;

    if (iref_etl%2 == 1) {
        polarity = -1;
    }
    else {
        polarity = 1;
    }

    tia_gx1 = gradpol[ileave]*ia_gx1;  /* temporary x dephaser amp */
    tia_gxw = polarity*gradpol[ileave]*ia_gxw;  /* temporary x readout amp  */
    tia_gxk = polarity*gradpol[ileave]*ia_gxk;  /* temporary x killer amp   */
    
    setiamp(tia_gx1, &gx1a, 0);        /* x dephaser attack */
    setiamp(tia_gx1, &gx1, 0);         /* x dephaser middle */
    setiamp(tia_gx1, &gx1d, 0);        /* x dephaser decay  */

    if(iref_etl > 0)
    {
        tia_gxiref1 = polarity*gradpol[ileave]*ia_gxiref1; /* temporary interref x dephaser amp */ 
        tia_gxirefr = (iref_etl%2 ? 1 : -1)*polarity*gradpol[ileave]*ia_gxirefr; /* temporary interref x rephaser amp */
        setiampt(tia_gxiref1, &gxiref1, 0);  /* interref x dephaser */
        setiampt(tia_gxirefr, &gxirefr, 0);  /* interref x rephaser */
    }

    setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][0],&gxwa, tot_etl-1);   /* attack, beginning of echo
                                                                        train (but the last pulse index) */
    setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][0], &gxw, 0); /* index 0 of gxw (begining of echo train */
 
    for (echo=1; echo < tot_etl; echo++)
    {
        if ((echo % 2) == 1)
        {  /* Even echo within interleave */
            setiamp(-tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo], &gxwa, echo-1); /* sliceindex1 is an rsp variable used in core
                                                                                    and HoecSetEchoTrainAmp is called in core */
            setiamp(-tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo-1], &gxwd, echo-1);
            setiamp(-tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo], &gxw, echo);
        }
        else
        {  /* Odd echo within interleave */
            setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo], &gxwa, echo-1); /* (echo-1)th gxwa and echo-th gxw belong to
                                                                                   the echo-th view, while (echo-1)th gxwd
                                                                                   belongs to the (echo-1)th view */
            setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo-1], &gxwd, echo-1);
            setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][echo], &gxw, echo);
        }
    }
 
    if ((tot_etl % 2) == 1)
    {
        setiamp(-tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][tot_etl-1],&gxwde, 0);  /* decay,end */
        if (eosxkiller == 1)
        {
            setiamp(-tia_gxk,&gxka, 0); /* killer attack */
            setiamp(-tia_gxk,&gxk, 0);  /* killer flattop */
            setiamp(-tia_gxk,&gxkd, 0); /* killer decay  */
        }
    }
    else
    {
        setiamp(tia_gxw-ia_gx_hoec_comp[ileave][sliceindex1][tot_etl-1],&gxwde, 0);   /* decay,end */
        if (eosxkiller == 1)
        {
            setiamp(tia_gxk,&gxka, 0);  /* killer attack */
            setiamp(tia_gxk,&gxk, 0);   /* killer flattop */
            setiamp(tia_gxk,&gxkd, 0);  /* killer decay  */
        }
    }

    return SUCCESS;
} /* end HoecSetEchoTrainAmp */

/* per slice phase blip compensation */
STATUS HoecSetBlipAmp(int blipsw)  /* blipsw = 0 means ref scan where all phase blips and prephaser
                                      are set to 0, 1 means normal scan */
{
    int bcnt;
    int dephaser_amp;
    int gmn_amp;
    int parity;

    parity = gradpol[ileave];
  
    if (blipsw == 0)
    {
        dephaser_amp = 0;
        gmn_amp = 0;
        for (bcnt=0;bcnt<etl-1;bcnt++)
            setiampt((short)0, &gyb, bcnt);
    }
    else
    {
        gmn_amp = ia_gymn2;
        if (rsppepolar == PSD_OFF)
        {
            dephaser_amp = -gy1f[0];
            for (bcnt=0;bcnt<etl-1;bcnt++) /* there are no blips for interref echoes */
            {
                if (oblcorr_perslice == 1)  /* HOEC correction is per sliceindex1 in either case */
                    setiampt((short)(-blippol[ileave] + parity*rspia_gyboc[sliceindex1]-
                                ia_gy_hoec_comp[ileave][sliceindex1][bcnt+iref_etl]), &gyb, bcnt);
                else
                    setiampt((short)(-blippol[ileave] + parity*rspia_gyboc[0]-
                                ia_gy_hoec_comp[ileave][sliceindex1][bcnt+iref_etl]), &gyb, bcnt);
                parity *= -1;
            }
        }
        else
        {
            dephaser_amp = gy1f[0];
            for (bcnt=0;bcnt<etl-1;bcnt++)
            {
                if (oblcorr_perslice == 1)
                    setiampt((short)(blippol[ileave] + parity*rspia_gyboc[sliceindex1]-
                                ia_gy_hoec_comp[ileave][sliceindex1][bcnt+iref_etl]), &gyb, bcnt);
                else
                    setiampt((short)(blippol[ileave] + parity*rspia_gyboc[0]-
                                ia_gy_hoec_comp[ileave][sliceindex1][bcnt+iref_etl]), &gyb, bcnt);
                parity *= -1;
            }
        }
    }
  
    setiampt((short)dephaser_amp, &gy1, 0);
    if (ygmn_type == CALC_GMN1)
    {
        setiampt((short)-gmn_amp, &gymn1, 0);
        setiampt((short)gmn_amp, &gymn2, 0);
    }

    if (blipsw == 1 && rspent != L_REF && rspent != L_MPS2 && rspent != L_APS2)
    {
        setiampt(invertGy1*gy1f[ileave], &gy1, 0);
        if (ygmn_type == CALC_GMN1)
        {
            setiampt(gymn[ileave], &gymn1, 0);
            setiampt(-gymn[ileave], &gymn2, 0);
        }
    }

    return SUCCESS;

} /* End HoecSetBlipAmp */

/* Calculate read, blip grad and receiver freq compensation; update receiver phase in diffstep() */

void dummylinks( void )
{
    epic_loadcvs("thefile");            /* for downloading CVs */
}



STATUS
SpSatChop( void )
{
    extern short rspchp;
    INT skip_next_sat;
    SHORT satamp;
  
    /* If SAT is on in the slice direction, we need to chop if the scan
       does not. The slice gradient always comes from the Z 
       generator; any rotation gets handled by WARP afterwards.*/    
  
    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return SUCCESS;
  
    if (rspchp == CHOP_NONE) 
    {
        if (opsatz !=  PSD_OFF) 
        {
            if ((opplane == PSD_AXIAL) || 
                ((opplane == PSD_OBL) && (opobplane == PSD_AXIAL )) ) 
            {
                getiamp(&satamp, &rfsz1, 0);
                setiamp(-satamp, &rfsz1, 0);
	      
                if (opsatz == PSD_SATPARA)
                {
                    getiamp(&satamp, &rfsz2, 0);
                    setiamp(-satamp, &rfsz2, 0);
                }
            }
	}
      
        /* Chop all the explicit sat pulses. The psd does not know which
           explicit sat bands are in the select direction unless you 
           perform some matrix magic on the rotation matrix. So, we
           are chopping all explicit sat pulses. It should not hurt. */
      
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_1) != 0)
        {
            getiamp(&satamp, &rfse1, 0);
            setiamp(-satamp, &rfse1, 0);
	  
            if ((opexsatparal & PSD_1_PARALLEL) != 0)
                skip_next_sat = 1;
        }
      
        if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse2, 0);
            setiamp(-satamp, &rfse2, 0);
        }
      
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_3) != 0)
        {
            getiamp(&satamp, &rfse3, 0);
            setiamp(-satamp, &rfse3, 0);
	  
            if ((opexsatparal & PSD_2_PARALLEL) != 0)
                skip_next_sat = 1;
        }
        if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse4, 0);
            setiamp(-satamp, &rfse4, 0);
        }
        skip_next_sat = 0;
        if ((opexsatmask & PSD_EXPLICIT_5) != 0)
        {
            getiamp(&satamp, &rfse5, 0);
            setiamp(-satamp, &rfse5, 0);
	  
            if ((opexsatparal & PSD_3_PARALLEL) != 0)
                skip_next_sat = 1;
        }
        if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
        {
            getiamp(&satamp, &rfse6, 0);
            setiamp(-satamp, &rfse6, 0);
        }
    }
    return SUCCESS;
}

STATUS
SpSatChopKiller( void )
{
    INT skip_next_sat;
  
    if (opsat == PSD_OFF) 
        return SUCCESS;
  
    if (opsatx !=  PSD_OFF) 
    {
        setiampt(-amp_gyksx1, &gyksx1, 0);
      
        if (opsatx == PSD_SATPARA)
        {
            setiampt(-amp_gyksx2, &gyksx2, 0);
        }
    }
  
    if (opsaty !=  PSD_OFF) 
    {
        setiampt(-amp_gyksy1, &gyksy1, 0);
      
        if (opsaty == PSD_SATPARA)
	{
            setiampt(-amp_gyksy2, &gyksy2, 0);
	}
    }
  
    if (opsatz !=  PSD_OFF) 
    {
        setiampt(-amp_gyksz1, &gyksz1, 0);
      
        if (opsatz == PSD_SATPARA)
	{
            setiampt(-amp_gyksz2, &gyksz2, 0);
	}
    }
  
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) != 0)
    {
        setiampt(-amp_gykse1, &gykse1, 0);
      
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
  
    if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse2, &gykse2, 0);
    }
  
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) != 0)
    {
        setiampt(-amp_gykse3, &gykse3, 0);
      
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse4, &gykse4, 0);
    }
    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) != 0)
    {
        setiampt(-amp_gykse5, &gykse5, 0);
      
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
    {
        setiampt(-amp_gykse6, &gykse6, 0);
    }
  
    return SUCCESS;
}

STATUS
CsSatMod( INT num_chemsats )
{
    SHORT ampcssat;
    INT i; /* counter */
  
    /* MRIge51368 */
    if ( csa > max_csa ) 
        csa = max_csa;

    csflip = flip_rfcssat * (csa/1000.0)/a_rfcssat;
    if (cs_sat == 1) {
        /* ensure that inferior slabs have a positive offset frequency
         * */ 
        if (selectiveChemsat)
        {
             ia_gzrfcs = -1 * abs(ia_gzrfcs); /* Superior SAT */
        }
    
        if (cstun == 1) {
            /* Activate ChemSat and update parameters to current rspvars */
            for (i=0; i<num_chemsats; i++) {
                setfrequency((int)(csf/TARDIS_FREQ_RES), &rfcssat, i);
                ampcssat = (SHORT)(csa/1000*max_pg_iamp);
                if (rspent == L_CFH)
                    ampcssat = (SHORT)(ampcssat * a_rfcssatcfh/a_rfcssat);
                rfon(&rfcssat,i);
                setiamp(ampcssat, &rfcssat, i);
                /* adjust bandwidth to minimize IQ issue with
                 * off-resonant excitation */ 
                if (selectiveChemsat)  
                  setiampt((int)(selectiveChemsatBWscaler*ia_gzrfcs), &gzrfcs, i);
                setiampt(amp_gykcs, &gykcs, i);
#ifdef CSXKILLER
                setiampt(amp_gxkcs, &gxkcs, i);
#endif

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
                if(duo_cs_flag)
                {
                    setiampt(amp_gzkcs, &gzkcs, i);
                }
#else
                setiampt(amp_gzkcs, &gzkcs, i);
#endif
#endif
            }
        } else {
            for (i=0; i<num_chemsats; i++) {
                rfoff(&rfcssat,i);
                setiampt(0, &gykcs, i);
#ifdef CSXKILLER
                setiampt(0, &gxkcs, i);
#endif
#ifdef CSZKILLER
#ifdef DCS_ZKILLER_ENH
                if(duo_cs_flag)
                {
                    setiampt(0, &gzkcs, i);
                }
#else

                setiampt(0, &gzkcs, i);
#endif
#endif
            }
        }
    }
    return SUCCESS;
}

/* SVBranch HCSDM00091804: Duo Chemical Saturation */
/* CsSatMod_duo gets called when duo chem sat is selected. *
 * When duo chem Sat is not selected, CsSatMod will be called */
int rspsatx1, 
    rspsatx2,
    rspsaty1, 
    rspsaty2,
    rspsatz1, 
    rspsatz2,
    rspsate1, 
    rspsate2,
    rspsate3,
    rspsate4,
    rspsate5,
    rspsate6;

int rsp_sat_rindex;
int rsp_max_rindex;


void
sp_dump_rsp_rot( INT ir_mode )
{
    INT  i ;
    printf("\nPSD-> Dump of RSP \t\t\tRotation Matrix\n");

    for (i=0;i<opslquant*opphases; ++i) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][0], rsprot[i][1], rsprot[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][3], rsprot[i][4], rsprot[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot[i][6], rsprot[i][7], rsprot[i][8]);
    }

    if (ir_mode == 1)
    {
        for (i=opslquant*opphases; i <(opslquant*opphases *2); i++) 
        {
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][0], rsprot[i][1], rsprot[i][2]);
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][3], rsprot[i][4], rsprot[i][5]);
            printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
                   i, rsprot[i][6], rsprot[i][7], rsprot[i][8]);
        }
    }
   
    for (i=0; i< opslquant*opphases; ++i)
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][0], rsprot_orig[i][1], rsprot_orig[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][3], rsprot_orig[i][4], rsprot_orig[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, rsprot_orig[i][6], rsprot_orig[i][7], rsprot_orig[i][8]);
    }
    return;
}


void
sp_dump_sat_rot( void )
{
    INT i ;
    printf("\nPSD-> Dump of Explicit Sat rotation info\t\t\tRotation Matrix\n");

    for (i=0;i<sat_rot_ex_num*2; i=i+2) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
               sat_rot_matrices[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
               sat_rot_matrices[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
               sat_rot_matrices[i][8]);

        printf("\n Slice rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1], 
               sat_rot_matrices[i+1][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4], 
               sat_rot_matrices[i+1][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7], 
               sat_rot_matrices[i+1][8]);
    }

    printf("\nPSD-> Dump of Default Sat rotation info\t\t\tRotation Matrix\n");
    for (i=sat_rot_ex_num*2;i<(sat_rot_df_num +sat_rot_ex_num)*2; i= i+2) 
    {
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
               sat_rot_matrices[i][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
               sat_rot_matrices[i][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
               sat_rot_matrices[i][8]);

        printf("\n Slice rotation matrix\n");
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][0], sat_rot_matrices[i+1][1], 
               sat_rot_matrices[i+1][2]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][3], sat_rot_matrices[i+1][4], 
               sat_rot_matrices[i+1][5]);
        printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
               i+1, sat_rot_matrices[i+1][6], sat_rot_matrices[i+1][7], 
               sat_rot_matrices[i+1][8]);
    }
   
    printf("\nPSD-> Dump of Slice Sat rotation info\t\t\tRotation Matrix\n");
    i = (sat_rot_ex_num + sat_rot_df_num)*2;
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][0], sat_rot_matrices[i][1], 
           sat_rot_matrices[i][2]);
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][3], sat_rot_matrices[i][4], 
           sat_rot_matrices[i][5]);
    printf("PSD->\nPSD->Index %d\t\t\t\t%+6ld, %+6ld, %+6ld\n",
           i, sat_rot_matrices[i][6], sat_rot_matrices[i][7], 
           sat_rot_matrices[i][8]);
    return;
}


/* THIS IS USED AS AN ISI SUBROUTINE VECTOR */

/* This assumes that the first SAT rotation matrix has
   been loaded by the psd; so the index is incremented first to
   bypass the first matrix.  */
void
sp_set_rot_matrix( void )
{
    sp_array_index = sp_array_index + 1;

    ++isi_vector_count;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        sp_array_index = 0;


    return;
}

/* For cardiac scans if the sat pulses are not at the beginning then
   the following ISI interrupt is used. The difference between the two
   interrupts is that the first entry in the sat_rot_matrices is used
   for the cardiac case. It is skipped in the case where the sat appear
   at the beginning of the sequence. (The psd loads first matrix in this
   case. ) */
void
sp_set_rot_matrix_card( void )
{

    ++isi_vector_count_card;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);
    sp_array_index = sp_array_index + 1;

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        sp_array_index = 0;

    return;
}


/* Inversion recovery description:
   sat 1 == a whole sat sequence that occurs before inversion pulse
   sat 2 == a whole sat sequence that occurs before the 90 pulse
   sat 3 == a whole sat sequence that occurs after inversion pulse

   sat 1 and sat 3 belong to the same boffset
   sat 2 belongs to a differenct boffset
*/

/* ISI vector for sequential inversion recovery sequences with sat 1, sat 2
   and sat 3 on. During  sat 1 and sat 3, the slice is never updated. 
   The first rotation matrix of sat 1 is loaded via the psd startseq. 
   The remainder sats in sat 1 use a preincrement to index through 
   the sat_rot_matrices array. Sat3 uses an ISI to load the first sat 
   rotation matrix. A postincrement is needed to index through the 
   sat_rot_matrices array. In addition, between sat 1 execution and 
   sat 2 execution the sat index must be reset to the top of the array.

   Sat 2 uses the psd to load the first rotation matrix and a preincrement 
   to index through the sat_rot_matrices array. */
void
sp_set_rot_matrix_seqir123( void )
{
    ++isi_vector_count_seqir123;

    /* If in the inversion sequence, the first sequence of sat (sat1)
       use preincrement since the psd loaded the first sat rotation matrix
       it must be bypass by the preincrement. The second sequence of
       sat (sat2) is in the same sequence so it has an ISI vector to
       load the first sat2 rotation matrix. A postincrement is needed here.
       Order of incrementing and resetting indices & counter is very
       important--don't skrew with it!!! */

    switch (sp_sat_seq_count)
    {
        /* Sat sequence 1 */
    case 0:
        sp_array_index = sp_array_index + 1;

        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_sat_seq_count = sp_sat_seq_count + 1;
            sp_array_index = 0;
        }
        break;

        /* Sat 2 sequence */
    case 1:
        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        sp_array_index = sp_array_index + 1;

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        {
            sp_sat_seq_count = sp_sat_seq_count + 1;
            sp_array_index = 0;
        }
        break;
 
        /* 90-180 sequence in IR */

    case 2:
        sp_array_index = sp_array_index + 1; 

        setrotateimm(sat_rot_matrices[sp_array_index],
                     WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_sat_seq_count = 0;
            sp_array_index = 0;
        }
        break;
    }

    return;
}

/* ISI for inversion recovery with sat 1 and sat 2.  For both sat 1 and 
   sat 2, the psd loads first rotation matrix for the first sat. So
   a preincrement is needed to index through the sat_rot_matrices array. */
void
sp_set_rot_matrix_seqir12( void )
{
    sp_array_index = sp_array_index + 1;

    ++isi_vector_count_seqir12;
    setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

    if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
    {
        sp_array_index = 0;
    }

    return;
}


/* ISI vector for inversion recovery with sat 1 and sat 3. 
   The sat 1 sequence requires a preincrement to index through the
   sat_rot_matrices array since the psd loaded the first rotation matrix.
   The sat 3 sequence requires a postincrement since an ISI is used
   to update the first rotation matrix.  */
void
sp_set_rot_matrix_seqir13( void )
{
    ++isi_vector_count_seqir13;

    /* If in the inversion sequence, the first sequence of sat (sat1)
       use preincrement since the psd loaded the first sat rotation matrix
       it must be bypass by the preincrement. The second sequence of
       sat (sat2) is in the same sequence so it has an ISI vector to
       load the first sat2 rotation matrix. A postincrement is needed here.
       Order of incrementing and resetting indices & counter is very
       important--don't screw with it!!! */

    if (sp_sat_seq_count == 0)                /* sat 1 sequence */
    {
        sp_array_index = sp_array_index + 1;

        setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2)
        {
            sp_array_index = 0;
            sp_sat_seq_count = sp_sat_seq_count + 1;
        }
    }
    else                 /* sat 2 sequence */
    {
        setrotateimm(sat_rot_matrices[sp_array_index],WARP_UPDATE_ON_SSP_INT);
    
        sp_array_index = sp_array_index + 1;

        if (sp_array_index == (sat_rot_ex_num+sat_rot_df_num)*2 + 1)
        {
            sp_array_index = 0;
            sp_sat_seq_count = 0;
        }
    }

    return;
}

/* vmx 4/17/95  YI  changed data type of slice_rot_matrix and sat_rot_array */
STATUS
sp_update_rot_matrix( long *slice_rot_matrix,
                      long (*sat_rot_array)[9],
                      const INT num_explicit_sats,
                      const INT num_default_sats )
{
    INT i, j;
    INT slice_rot_index;

    /* SAT rotation matrix contains the following
       |--------------------|
       |  SAT 1 rot matrix  |    Explicit SATs
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 2 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 3 rot matrix  |
       |--------------------|    
       |  Slice rot matix   |
       |--------------------|
       |  SAT 4 rot matrix  |   Default Sats
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 5 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  SAT 6 rot matrix  |
       |--------------------|
       |  Slice rot matix   |
       |--------------------|
       |  slice rot matrix  |
       |--------------------|

       sat_rot_ex_num = point where explicit sat change to default sats

       Default sat follow slice rotation matrix. When the slice changes
       the default sat rotations matrices and the slice rotation matrix
       slots must be updated with the new slice rotation matrix. */

    /* Updates default sat & slice rotation matrices */
    slice_rot_index = 1;
    for (i=0; i < num_explicit_sats; ++i)
    {
        for (j=0; j < 9; ++j)
            *( ((long *) sat_rot_array)+(slice_rot_index*9+j))= 
                *(slice_rot_matrix+j);
        slice_rot_index +=2;
    }

    slice_rot_index = num_explicit_sats*2;
    for (i=0; i< num_default_sats*2+1; ++i)
    {
        for (j=0; j < 9; ++j)
            *( ((long *) sat_rot_array)+(slice_rot_index*9+j))= 
                *(slice_rot_matrix+j);
        ++slice_rot_index;
    }

    return SUCCESS;
}


/*
  The theory here is that the rsprot array needs to contain the rotation
  matrix for the first pulse being played out. In the case of explicit
  sats, this is the first explicit sat rotation matrix. In the case of
  no explicit sats but defaults sats, this is the slice rotation matrix.
  To accomplish this the rsprot array needs to be modified. The rsprot
  matrix will only be used for the first pulse--ISI vector will update
  the rotation matrices for the remaining sat pulses and the slice pulses.
  The rsprot array only handles the first pulse in the sequence.

  If Explicit Sats are used the rsprot array looks as follows.
  Note that there will be nslices entries all filled in with
  the first explicit sat rotation matrix.
      
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
    |   Explicit Sat1 rotation matrix    |
    |------------------------------------|
         ...

    If there are no explicit SATs, only default SAT, the rsprot is not
    changed. It contains the original slices.
  
    |-------------------------------|
    |   slice 1 rotation matrix     |
    |-------------------------------|
    |   slice 2 rotation matrix     |
    |-------------------------------|
    |   slice 3 rotation matrix     |
    |-------------------------------|

    This routine also places the slice rotation matrices into the 
    sat_rot_matrices. The sat_rot_matrices are the working version
    of what rotation matrices need to be played during the current
    sequence. They are updated for every sequence. The explicit sat
    rotation matrices which appear first in the array are filled out
    during cveval. 

    The slice rotation matrix appears after every sat pulse. The slice
    rotation matrix is played out for the killer for the sat. Killers
    are played out after each sat, hence a slice rotation matrix appears
    after each sat rotation matrix (explicit or default).
   
    The slice rotation matrices are provided by scan. The
    default sat rotation matrices are the same as the slice. They
    are filled out now.

               |--------------------|
               |  SAT 1 rot matrix  |    Explicit SATs
               |--------------------|      filled out in cveval
               |  Slice rot matrix  |    Killer for Sat 1
               |--------------------|
               |  SAT 2 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 2
               |--------------------|
               |  SAT 3 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 3
               |--------------------|    Default SATs
               |  SAT 4 rot matrix  |      filled out now
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 4
               |--------------------|
               |  SAT 5 rot matrix  |
               |--------------------|
               |  Slice rot matrix  |    Killer for Sat 5
               |--------------------|
               |  SAT 6 rot matrix  |
               |--------------------|
               |  slice rot matrix  |    Killer for Sat 6
               |--------------------|
               |  slice rot matrix  |    For Slice
               |--------------------|
*/ 
void
SpSat_set_sat1_matrix( long (*orig_rot_matrix)[9],
                       long (* new_rot_matrix)[9],
                       int entries,
                       long (*sat_array)[9],
                       int num_explicit_sats,
                       int num_default_sats,
                       int cardiacsat_pos,
                       int sequence_flag )
{
    int i, j;
    int slice_rot_index;

    /* Saves original slice rotation matrix array if this is the first
       scan since download. Otherwise, the rotation matrices have
       already been copied over and this code is not repeated. */
    if ( (sp_first_scan == 1) || (opfluorotrigger==1) )
    {
        for (i=0; i < entries; ++i)
        {
            for (j=0; j<9; ++j)
                *( ((int *) orig_rot_matrix)+i*9 + j) 
                    = *( ((int *) new_rot_matrix) +i*9+j);
        }
    }
    sp_first_scan = 0;

    /* Changes slice rotation matrix if explicit sat are used.
       The slice rotation matrix will be filled with the rotation
       matrix for the first explicit SAT band. All entries are
       filled with this same matrix because explicit sat bands
       keep the same matrix throughout the scan.  

       In the case of cardiac where the sat pulses are not at the
       beginning of the sequence, the new rotation matrices are 
       not changed. */

    if ((num_explicit_sats != 0) && (cardiacsat_pos == 0) && 
        (sequence_flag == 0))
    {
        for (i=0; i<entries; ++i)
            for(j=0; j<9; ++j)
                *( ((int *) new_rot_matrix) +i*9+ j) = 
                    *( ((int *) sat_array)+j);
    }
   
    slice_rot_index = 1;
    for (i = 0; i < num_explicit_sats; ++i)
    {
        for (j=0; j<9; ++j)
            *( ((int *) sat_array )+slice_rot_index*9+j) = 
                *( ((int *) orig_rot_matrix)+j);

        slice_rot_index += 2;
    }

    for (i= num_explicit_sats*2; i<(num_explicit_sats + num_default_sats)*2 +1;
         i++)
    {
        for (j=0; j<9; ++j)
            *( ((int *) sat_array )+i*9+j) = 
                *( ((int *) orig_rot_matrix)+j);
    }

    /* If sat is played as a separate sequence as in fgre or mpir (the case
       where sat is only in the inversion sequence), the original slice 
       rotation matrix is maintained. The first sat rotation matrix is
       appended at the end. The sequences switch between the top and 
       bottom of the rotation matrix array to determine what to load. */
    if (sequence_flag == 1)
    {
        for (i=entries; i< entries*2; ++i)
            for(j=0; j<9; ++j)
                *( ((int *) new_rot_matrix) +i*9+ j) = 
                    *( ((int *) sat_array)+j);
    }

    sp_array_index = 0;
    return;
}

STATUS
SpSatInitRsp( INT num_sat_grps,
              INT cardiacsat_pos,
              INT ir_sattype )
{
    INT i = 0; /* counters */
    INT skip_next_sat;

    if ( (opsat != PSD_OFF) && ((opsatx != PSD_OFF)
                                || (opsaty != PSD_OFF)
                                || (opsatz != PSD_OFF)
                                || (opexsatmask != PSD_OFF)) )
    {
        switch (sat_debug)
        {
            /* Set the rotation matrices with 27 rsp variables for AutoShim. */
            case 4:
                for (i=0; i<sat_rot_ex_num; i++)
                {
                    switch (sat_rot_ex_indices[i])
                    {
                        case 1:  /* explicit I Sat Band */
                        case 2:  /* explicit S Sat Band */
                            sat_rot_matrices[i*2][0] = hostToRspRotMat( asrot0 );
                            sat_rot_matrices[i*2][1] = hostToRspRotMat( asrot1 );
                            sat_rot_matrices[i*2][2] = hostToRspRotMat( asrot2 );
                            sat_rot_matrices[i*2][3] = hostToRspRotMat( asrot3 );
                            sat_rot_matrices[i*2][4] = hostToRspRotMat( asrot4 );
                            sat_rot_matrices[i*2][5] = hostToRspRotMat( asrot5 );
                            sat_rot_matrices[i*2][6] = hostToRspRotMat( asrot6 );
                            sat_rot_matrices[i*2][7] = hostToRspRotMat( asrot7 );
                            sat_rot_matrices[i*2][8] = hostToRspRotMat( asrot8 );
                            break;
                        case 3:  /* explicit P Sat Band */
                        case 4:  /* explicit A Sat Band */
                            sat_rot_matrices[i*2][0] = hostToRspRotMat( asrot9 );
                            sat_rot_matrices[i*2][1] = hostToRspRotMat( asrot10 );
                            sat_rot_matrices[i*2][2] = hostToRspRotMat( asrot11 );
                            sat_rot_matrices[i*2][3] = hostToRspRotMat( asrot12 );
                            sat_rot_matrices[i*2][4] = hostToRspRotMat( asrot13 );
                            sat_rot_matrices[i*2][5] = hostToRspRotMat( asrot14 );
                            sat_rot_matrices[i*2][6] = hostToRspRotMat( asrot15 );
                            sat_rot_matrices[i*2][7] = hostToRspRotMat( asrot16 );
                            sat_rot_matrices[i*2][8] = hostToRspRotMat( asrot17 );
                            break;
                        case 5:  /* explicit L Sat Band */
                        case 6:  /* explicit R Sat Band */
                            sat_rot_matrices[i*2][0] = hostToRspRotMat( asrot18 );
                            sat_rot_matrices[i*2][1] = hostToRspRotMat( asrot19 );
                            sat_rot_matrices[i*2][2] = hostToRspRotMat( asrot20 );
                            sat_rot_matrices[i*2][3] = hostToRspRotMat( asrot21 );
                            sat_rot_matrices[i*2][4] = hostToRspRotMat( asrot22 );
                            sat_rot_matrices[i*2][5] = hostToRspRotMat( asrot23 );
                            sat_rot_matrices[i*2][6] = hostToRspRotMat( asrot24 );
                            sat_rot_matrices[i*2][7] = hostToRspRotMat( asrot25 );
                            sat_rot_matrices[i*2][8] = hostToRspRotMat( asrot26 );
                            break;
                        default:
                            break;
                    }
                }
                scalerotmats(sat_rot_matrices, &satloggrd, &phygrd, 2*sat_rot_ex_num, sat_obl_debug);
                SpSat_set_sat1_matrix(rsprot_orig, rsprot, opslquant*opphases,
                                      sat_rot_matrices, sat_rot_ex_num, sat_rot_df_num,
                                      sp_satcard_loc, 0);
                setrotatearray((SHORT)(opslquant*opphases),rsprot[0]);
                break;
            default:
                break;
        }

        if (cardiacsat_pos == 0)
            isivector((short) 1, sp_set_rot_matrix, (short) FALSE);
        else
            isivector ((short) 1, sp_set_rot_matrix_card, (short) FALSE);

        switch (ir_sattype)
        {
        case 1:
            isivector ((short) 1, sp_set_rot_matrix_seqir13, (short) FALSE);
            break;

        case 2:
            isivector ((short) 1, sp_set_rot_matrix_seqir12, (short) FALSE);
            break;

        case 3:
            isivector ((short) 1, sp_set_rot_matrix_seqir123, (short) FALSE);
            break;

        case 4:
            isivector ((short) 1, sp_set_rot_matrix, (short) FALSE);
            break;

        case 5:
            isivector ((short) 1, sp_set_rot_matrix_card, (short) FALSE);
            break;
        }

        isi_vector_count = 0;
        isi_vector_count_card = 0;
        isi_vector_count_seqir123 = 0;
        isi_vector_count_seqir12 = 0;
        isi_vector_count_seqir13 = 0;
        sp_sat_seq_count = 0;
        rsp_max_rindex = sat_rot_index;	
        /* Turn off SAT in first pass prescan */
        if ((rspent == L_APS1) || (rspent == L_MPS1))
        {
            if (opsatx != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsx1,i);
            }
            if (opsatx == PSD_SATPARA)
            {
                for (i=0; i < num_sat_grps; i++)
                    rfoff(&rfsx2, i);
            }

            if (opsaty != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsy1,i);
            }
            if (opsaty == PSD_SATPARA)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsy2, i);
            }

            if (opsatz != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsz1,i);
            }
            if (opsatz == PSD_SATPARA)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfsz2, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_1) != 0)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse1, i);
            }

            if ((opexsatparal & PSD_1_PARALLEL) == PSD_1_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_2) == PSD_EXPLICIT_2) && 
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse2, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_3) != 0)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse3, i);
            }


            if ((opexsatparal & PSD_2_PARALLEL) == PSD_2_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_4) == PSD_EXPLICIT_4) &&
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse4, i);
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_5) == PSD_EXPLICIT_5)
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse5, i);
            }

            if ((opexsatparal & PSD_3_PARALLEL) == PSD_3_PARALLEL)
                skip_next_sat = 1;
            if (((opexsatmask & PSD_EXPLICIT_6) == PSD_EXPLICIT_6) &&
                (skip_next_sat == 0))
            {
                for (i=0; i<num_sat_grps; i++)
                    rfoff(&rfse6, i);
            }
       	} /* APS1 or MPS1 */
        else
        {
            /* Turn RF on and load frequencies in other entry points */
            if (opsatx != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsatx1 = (int)(off_rfsx1/TARDIS_FREQ_RES);
                    rfon(&rfsx1,i);
                    setfrequency(rspsatx1,&rfsx1,i);
                    amp_gyksx1 = ia_gyksx1;
                    setiampt(amp_gyksx1, &gyksx1, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxksx1, 0.0, 2))
                    {
                        amp_gxksx1 = ia_gxksx1;
                        setiampt(amp_gxksx1, &gxksx1, 0);
                    }

                    if (opsatx == PSD_SATPARA)
                    {
                        rspsatx2 = (int)(off_rfsx2/TARDIS_FREQ_RES);
                        rfon(&rfsx2, i);
                        setfrequency(rspsatx2, &rfsx2, i);
                        amp_gyksx2 = ia_gyksx2;
                        setiampt(amp_gyksx2, &gyksx2, 0);
                        if (!floatsAlmostEqualEpsilons(area_gxksx2, 0.0, 2))
                        {
                            amp_gxksx2 = ia_gxksx2;
                            setiampt(amp_gxksx2, &gxksx2, 0);
                        }
                    }
                }
            }
            if (opsaty != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsaty1 = (int)(off_rfsy1/TARDIS_FREQ_RES);
                    rfon(&rfsy1,i);
                    setfrequency(rspsaty1,&rfsy1,i);
                    amp_gyksy1 = ia_gyksy1;
                    setiampt(amp_gyksy1, &gyksy1, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxksy1, 0.0, 2))
                    {
                        amp_gxksy1 = ia_gxksy1;
                        setiampt(amp_gxksy1, &gxksy1, 0);
                    }

                    if (opsaty == PSD_SATPARA)
                    {
                        rspsaty2 = (int)(off_rfsy2/TARDIS_FREQ_RES);
                        rfon(&rfsy2,i);
                        setfrequency(rspsaty2,&rfsy2,i);
                        amp_gyksy2 = ia_gyksy2;
                        setiampt(amp_gyksy2, &gyksy2, 0);
                        if (!floatsAlmostEqualEpsilons(area_gxksy2, 0.0, 2))
                        {
                            amp_gxksy2 = ia_gxksy2;
                            setiampt(amp_gxksy2, &gxksy2, 0);
                        }
                    }
                }
            }
            if (opsatz != PSD_OFF)
            {
                for (i=0; i<num_sat_grps; i++)
                {
                    rspsatz1 = (int)(off_rfsz1/TARDIS_FREQ_RES);
                    rfon(&rfsz1,i);
                    setfrequency(rspsatz1,&rfsz1,i);
                    amp_gyksz1 = ia_gyksz1;
                    setiampt(amp_gyksz1, &gyksz1, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxksz1, 0.0, 2))
                    {
                        amp_gxksz1 = ia_gxksz1;
                        setiampt(amp_gxksz1, &gxksz1, 0);
                    }

                    if (opsatz == PSD_SATPARA)
                    {
                        rspsatz2 = (int)(off_rfsz2/TARDIS_FREQ_RES);
                        rfon(&rfsz2,i);
                        setfrequency(rspsatz2,&rfsz2,i);
                        amp_gyksz2 = ia_gyksz2;
                        setiampt(amp_gyksz2, &gyksz2, 0);
                        if (!floatsAlmostEqualEpsilons(area_gxksz2, 0.0, 2))
                        {
                            amp_gxksz2 = ia_gxksz2;
                            setiampt(amp_gxksz2, &gxksz2, 0);
                        }
                    }
                }
            }

            switch (sat_debug)
            {
                case 4:
                    off_rfse1 = (int)(GAM * a_gzrfse1 * astloc1/10);
                    off_rfse2 = (int)(GAM * a_gzrfse2 * astloc1/10);
                    off_rfse3 = (int)(GAM * a_gzrfse3 * astloc2/10);
                    off_rfse4 = (int)(GAM * a_gzrfse4 * astloc2/10);
                    off_rfse5 = (int)(GAM * a_gzrfse5 * astloc3/10);
                    off_rfse6 = (int)(GAM * a_gzrfse6 * astloc3/10);
                    break;
                default:
                    break;
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_1) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate1 = (int)(off_rfse1/TARDIS_FREQ_RES);
                    rfon(&rfse1,i);
                    setfrequency(rspsate1, &rfse1, i);
                    amp_gykse1 = ia_gykse1;
                    setiampt(amp_gykse1, &gykse1, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse1, 0.0, 2))
                    {
                        amp_gxkse1 = ia_gxkse1;
                        setiampt(amp_gxkse1, &gxkse1, 0);
                    }
                }
                if ((opexsatparal & PSD_1_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_2) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate2 = (int)(off_rfse2/TARDIS_FREQ_RES);
                    rfon(&rfse2,i);
                    setfrequency(rspsate2, &rfse2, i);
                    amp_gykse2 = ia_gykse2;
                    setiampt(amp_gykse2, &gykse2, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse2, 0.0, 2))
                    {
                        amp_gxkse2 = ia_gxkse2;
                        setiampt(amp_gxkse2, &gxkse2, 0);
                    }
                }
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_3) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate3 = (int)(off_rfse3/TARDIS_FREQ_RES);
                    rfon(&rfse3,i);
                    setfrequency(rspsate3, &rfse3, i);
                    amp_gykse3 = ia_gykse3;
                    setiampt(amp_gykse3, &gykse3, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse3, 0.0, 2))
                    {
                        amp_gxkse3 = ia_gxkse3;
                        setiampt(amp_gxkse3, &gxkse3, 0);
                    }
                }
                if ((opexsatparal & PSD_2_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_4) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate4 = (int)(off_rfse4/TARDIS_FREQ_RES);
                    rfon(&rfse4,i);
                    setfrequency(rspsate4, &rfse4, i);
                    amp_gykse4 = ia_gykse4;
                    setiampt(amp_gykse4, &gykse4, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse4, 0.0, 2))
                    {
                        amp_gxkse4 = ia_gxkse4;
                        setiampt(amp_gxkse4, &gxkse4, 0);
                    }
                }
            }

            skip_next_sat = 0;
            if ((opexsatmask & PSD_EXPLICIT_5) != 0)
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate5 = (int)(off_rfse5/TARDIS_FREQ_RES);
                    rfon(&rfse5,i);
                    setfrequency(rspsate5, &rfse5, i);
                    amp_gykse5 = ia_gykse5;
                    setiampt(amp_gykse5, &gykse5, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse5, 0.0, 2))
                    {
                        amp_gxkse5 = ia_gxkse5;
                        setiampt(amp_gxkse5, &gxkse5, 0);
                    }
                }
                if ((opexsatparal & PSD_3_PARALLEL))
                    skip_next_sat = 1;
            }

            if (((opexsatmask & PSD_EXPLICIT_6) != 0) && (skip_next_sat == 0))
            {
                for (i = 0; i<num_sat_grps; i++)
                {
                    rspsate6 = (int)(off_rfse6/TARDIS_FREQ_RES);
                    rfon(&rfse6,i);
                    setfrequency(rspsate6, &rfse6, i);
                    amp_gykse6 = ia_gykse6;
                    setiampt(amp_gykse6, &gykse6, 0);
                    if (!floatsAlmostEqualEpsilons(area_gxkse6, 0.0, 2))
        	    {
                        amp_gxkse6 = ia_gxkse6;
                        setiampt(amp_gxkse6, &gxkse6, 0);
                    }
                }
            }

        } /* else not APS1 or MPS1 */
    } /* SAT on */
    return SUCCESS;
}

STATUS
SpSatUpdateRsp( INT num_sat_grps,
                INT  pass,
                INT cat_seq_type )
{
    INT grp;
    
    if ((opsatx != PSD_OFF) || (opsaty != PSD_OFF) || (opsatz != PSD_OFF)
        || (opexsatmask != PSD_OFF))
    {
        if ((opsatz != PSD_OFF) && (cat_seq_type ==  PSD_ON)) 
        {
            for (grp=0; grp<num_sat_grps; grp++) 
            {
                rspsatz1 = (int)(off_rfcsz[pass]/TARDIS_FREQ_RES);
	        setfrequency(rspsatz1,&rfsz1,grp);
            }
        }
    }
    return SUCCESS;
}

STATUS
SpSatPlayRelaxers( void )
{
    INT i;

    boffset(off_cat_seq);	   /* Switch to Cat Sat relaxer sequence */
  
    for (i=0; i<ccs_relaxers; i++) /* Play the sequence */
        startseq(0,(SHORT)MAY_PAUSE);

    /* Should switch back boffset in scan core */
    return SUCCESS;
}

void
SpSat_Satoff( INT sat_index )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != 0)
    {
        setiamp(0, &rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            setiamp(0, &rfsx2, sat_index);
    }
    if (opsaty != 0)
    {
        setiamp(0, &rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            setiamp(0, &rfsy2, sat_index);
    }
    if (opsatz != 0)
    {
        setiamp(0, &rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            setiamp(0, &rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        setiamp(0, &rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        setiamp(0, &rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        setiamp(0, &rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        setiamp(0, &rfse6, sat_index);
    return;
}


void
SpSat_Saton( INT sat_index )
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != 0)
    {
        setiamp(ia_rfsx1, &rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            setiamp(ia_rfsx2, &rfsx2, sat_index);
    }
    if (opsaty != 0)
    {
        setiamp(ia_rfsy1, &rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            setiamp(ia_rfsy2, &rfsy2, sat_index);
    }
    if (opsatz != 0)
    {
        setiamp(ia_rfsz1, &rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            setiamp(ia_rfsz2, &rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        setiamp(ia_rfse1, &rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse2, &rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        setiamp(ia_rfse3, &rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse4, &rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        setiamp(ia_rfse5, &rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        setiamp(ia_rfse6, &rfse6, sat_index);
    return;
}

void
SpSat_Satrfoff(INT sat_index)
{
    INT  skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != PSD_SATOFF)
    {
        rfoff(&rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            rfoff(&rfsx2, sat_index);
    }
    if (opsaty != PSD_SATOFF)
    {
        rfoff(&rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            rfoff(&rfsy2, sat_index);
    }
    if (opsatz != PSD_SATOFF)
    {
        rfoff(&rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            rfoff(&rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        rfoff(&rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        rfoff(&rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        rfoff(&rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        rfoff(&rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        rfoff(&rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        rfoff(&rfse6, sat_index);
    return;
}


void
SpSat_Satrfon(INT sat_index)
{
    INT skip_next_sat;

    if ((opsat == PSD_OFF) || ((opsatx==PSD_OFF)&&(opsaty==PSD_OFF)&&
                               (opsatz==PSD_OFF)&&(opexsatmask==PSD_OFF)))
        return;

    if (opsatx != PSD_SATOFF)
    {
        rfon(&rfsx1, sat_index);
        if (opsatx == PSD_SATPARA)
            rfon(&rfsx2, sat_index);
    }
    if (opsaty != PSD_SATOFF)
    {
        rfon(&rfsy1, sat_index);
        if (opsaty == PSD_SATPARA)
            rfon(&rfsy2, sat_index);
    }
    if (opsatz != PSD_SATOFF)
    {
        rfon(&rfsz1, sat_index);
        if (opsatz == PSD_SATPARA)
            rfon(&rfsz2, sat_index);
    }

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_1) !=0)
    {
        rfon(&rfse1, sat_index);
        if ((opexsatparal & PSD_1_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_2) !=0) && (skip_next_sat ==0))
        rfon(&rfse2, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_3) !=0)
    {
        rfon(&rfse3, sat_index);
        if ((opexsatparal & PSD_2_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_4) !=0) && (skip_next_sat ==0))
        rfon(&rfse4, sat_index);

    skip_next_sat = 0;
    if ((opexsatmask & PSD_EXPLICIT_5) !=0)
    {
        rfon(&rfse5, sat_index);
        if ((opexsatparal & PSD_3_PARALLEL) != 0)
            skip_next_sat = 1;
    }
    if (((opexsatmask & PSD_EXPLICIT_6) !=0) && (skip_next_sat ==0))
        rfon(&rfse6, sat_index);
    return;
}


STATUS ssRsp(void)
{
    INT temp_freq;  /* for debugging */
    if (ss_rf1 == PSD_ON) {
        if (fat_flag == PSD_ON) {
            rf1_freq[sliceindex] = fat_offset;
        } else {
            rf1_freq[sliceindex] = 0;
        }
        temp_freq = theta_freq[sliceindex];

        setiampall((int)(freqSign*theta_freq[sliceindex]), &thetarf1, 0);
    }
    return(SUCCESS);
}


/*GE Medical Systems
 * Copyright (C) 2003  The General Electric Company.
 *       $Source: Navigator.e $
 *       $Revision: 1.0 $  $Date: 03/26/2003
 *       Language : EPIC / ANSI C
 *       Developer: M. Saranathan, N. Gai, R. Francis 
 *
 */
/* do not edit anything above this line */

/*************************************************************/

/*
        @Synopsis

        EPIC inline module to support Navigator Echo Gated Acquisitions.
        This module depends on Monitor.e for navigator sequence generation. 
        Supports navigator data processing and manages communication with the
        Navigator task running on the APS. 

*/


/*

  Date        Author               Comments
  -----------------------------------------------------------------

              NDG       MRIge65952 : Scan time and clock countdown related changes 

              NDG       MRIge66342 : Merge source files for different Nav PSDs.

              NDG       MRIge66349 : Changes for input part of Nav host UI to PSD chain 

              NDG       MRIge67150 : Introduce the new common header file 

              NDG       MRIge67565 : Remove miscellaneous warning messages

  03/26/2003  RJF       MRIge82182 : Excite-II implementation, general code clean up
              PL                     Integrated VAST mode into Navigator prescan.

  04/22/2003  RJF       MRIge82537 : RTP type is now default, RTP_NAV not needed.

  05/30/2003  RJF       MRIge82507 : New Fat SAT User Interface Support.

  06/20/2003  PL        MRIge85438 : Additional arg to routedataFrame

  06/23/2003  RJF       MRIge85079 : Removed unused CVs from old Navigator implementation.

  10/21/2003  PL        MRIge89462 : Added arrhythmia check logic for 3D FIESTA Gated.

  04/02/2004  ZL        MRIge91361 : add RtpCoilSwitch function call to send the scanSetup
                                     Packet needed for RTP calls, although coilswitch is 
                                     not really performed.

              NDG       MRIhc05612 : Turn rotation of tracker off by default. Tracker is played
                                     at the end of r-r interval and magnetization has 
                                     sufficient time to recover during typical cardiac delays
 
  04/26/2005  ARI       MRIhc07115 : Navigator enhancements:
              MF                     implementing new LSQ algorithm for NAV

  05/05/2005  ARI       MRIhc07063 : Navigator enhancements:
                                     writing NAV data into file

  06/03/2005  ARI       MRIhc07226 : Navigator enhancements:
              MF                     slice tracking & cylindrical NAV

  07-19-2005  ARI/MF    MRIhc08626 & MRIhc08609 & MRIhc10392:
                                     wrap around sections with navigatorCYL_flag.

  01/11/2006  MF        MRIhc12741 : Fix nav direction reversal problem
  01/09/2007  NB        MRIhc30846 : RTP stays in scanning state even after failure error message
  05/28/2008  NB        MRIhc36908 : RtpServer fails to unregister as an AcqDataClient

  11-06-2009  SW        MRIhc46122 : 1. Merge NavigatorCYL.e into Navigator.e and Monitor.e for simplification.
                                     2. Redesign the 2D rf file based on the hardware performance. 
                                     3. Cleanup the code. 
                                     4. Add the tipup sequence for IRPREP based on Maggie Fung's prototype.

  12-07-2009  JX        MRIhc46552 : Adjust navscale and flip_rfcylrtipup ranges. Also 
                                     correct the frequency setup for 90-180 nav tipup rf.

  12-16-2009  SW        MRIhc46713 : 1. Add edge detection algorithm for Navigator.
                                     2. Add signal normalization algorithm for Navigator.
                                     3. Exclude nav_ss from nav_dda.

  02-21-2011  JX        MRIhc55201 : NavSat for 3dHeart FS FIESTA with cylin nav on 1.5T.

  08-19-2011  NB        HCSDM00092825 : Code cleanup and changes related to RTP on VRE for HD23

  08-23-2012  YT        HCSDM00153386 : CV range should not be limited by cvmin/cvmax if avmin/avmax exist to show proper warning

  08-23-2012  YT        HCSDM00153381 : scan time calculation was modified in Body Navigator

  09-11-2012  YT        HCSDM00157187 : Navigator related parameters should be properly set for non-navigator sequence

  01-18-2013  YT        HCSDM00174825 : scantime refresh timing was changed for navigator gating

  01-29-2013  YT        HCSDM00181166 : max navigator interval should not be displayed in PSD with pfkz_segments fixed to 1

  02-07-2013  YT        HCSDM00174828 : ensure sequence calc time and fix some bugs to prevent EOS error

  03-08-2013  YT        HCSDM00182858 : For navigator signal stability in body navigator,
                                        - changed coil selection algorithm from 2ch selection to All Good Channel Combination
                                        - changed position detection algorithm from Edge Detection to LSQ except for dynaplan
                                        - changed navigator prescan time from 200ms to mon_tr in navigator triggering
                                          to make the same steady state between navigator prescan and imaging scan

  03-15-2013  YT        HCSDM00191233 : corrected endexpindex calculation to avoid flat navigator waveform

  06-28-2013  YT        HCSDM00220650 : corrected max_navphase and min_navphase calculation in navigator triggering

  10-31-2013  YT        HCSDM00250942 : hided slab tracking selection from UI for body navigator gating.
  
  10-12-2014  KM        HCSDM00324194 : Use SCM (Suboptimal Channel Masking) method as default from AGCC.
                                        Set LSQ as default for DISCO.

  Nov-10-2015 YT        HCSDM00381524 : Apply LSQ with SCM to all cases for body navigator.

  Aug-01-2016 ZWW       HCSDM00417156 : Added waiting time between Navigator sequence and imaging sequence to
                                        remove the saturation artifact from Navigator.

  Jul-10-2017 WHB       HCSDM00455295 : Promote code for feature PRICE which remove R2 function, oversample and downsample data. Data type
                                        is changed to float from int.
                                        
****************************************************************************************************************************/


#ifdef PSD_HW
#include "RtpPsd.h"
#endif
#include "rtp_feedback_task.h"

int nav_acquired_index = 0;
int nav_processed_index = 0;

/* DVMR: Variables to measure VRF and Ethernet feedback pathway times */
#if defined(MGD_TGT) && defined(PSD_HW)
long feedback_time = 0;
long max_feedback_time = 0;
long min_feedback_time = 999;
long sum_feedback_times = 0;
long num_frames_processed = 0;
#define NAV_NUM_TIMING_POINTS 200 
long roundtrip_timing_array[NAV_NUM_TIMING_POINTS];
long roundtrip_index = 0;
# endif

#ifdef PSD_HW
/* Needed for printdbg(). To see output, agpTraceOptions must be invoked
   from the AGP window. To enable screen output, the options listed via
   agpTraceStats() must not include 0x20. Subtract 0x20 (32) from the
   current options and use as the input to agpTraceOptions. */
#include <pgen_tmpl.h>
#endif /* PSD_HW */

float error_width;

#ifdef PSD_HW
#include "clockApi.h"
#endif

/**
 * This is the callback function to update Navigator related parameters. 
 * It's called when navigator baseline prescan finishes.
 *
 * @param[in]  *receivedBuffer
 */
void updateNavigatorBuffer( void* receivedBuffer )
{
    int i, j, channel;
    long bit;
    RtpDataToPsdTaskPkt* pRtpDataToPsdTaskPkt = (RtpDataToPsdTaskPkt *) receivedBuffer;

    if (NULL == pRtpDataToPsdTaskPkt)
    {
        return;
    }

    switch(pRtpDataToPsdTaskPkt->data.subOpcode)
    {
        case  OP_NAV_THRESHOLD_VALUE:
            nav_currthresh = pRtpDataToPsdTaskPkt->data.f32vals[0];
            if (PSD_ON == nav_debug_flag)
            {
                printf("Threshold = %f\n", pRtpDataToPsdTaskPkt->data.f32vals[0]);
            }
            break;

        case OP_NAV_ACCEPTANCE_VALUE:
            nav_currwindow = pRtpDataToPsdTaskPkt->data.f32vals[0];
            if (PSD_ON == nav_debug_flag)
            {
                printf("Acceptance value = %f\n", pRtpDataToPsdTaskPkt->data.f32vals[0]);
            }
            break;

        case OP_NAV_COIL_VALUE:
            nav_currcoil = pRtpDataToPsdTaskPkt->data.f32vals[0];
            if (PSD_ON == nav_debug_flag)
            {
                printf("Coil = %f\n", pRtpDataToPsdTaskPkt->data.f32vals[0]);
            }
            break;

        case OP_NAV_BASELINE_PRESCAN_INFO:
            nav_stable_flag = pRtpDataToPsdTaskPkt->data.n32vals[0];
            if (PSD_ON == nav_debug_flag)
            {
                printf("stableFlag = %d\n", (int) pRtpDataToPsdTaskPkt->data.n32vals[0]);
            }

            channel = 0;
            for(i = 0; i < MAX_CH_GRP; i++)
            {
                nav_channel_bit[i] = pRtpDataToPsdTaskPkt->data.n32vals[i+1];
                navscm_channel_bit[i] = pRtpDataToPsdTaskPkt->data.n32vals[i+5];
                bit = 0x1;
                for(j = 0; j < 32; j++)
                {
                    if(PSD_ON == nav_debug_flag && !(bit & nav_channel_bit[i]))
                    {
                        printf("non-selected channel#: %d\n", channel);
                    }

                    if(PSD_ON == nav_debug_flag && (bit & navscm_channel_bit[i]))
                    {
                        printf("filtered channel#: %d\n", channel);
                    }

                    bit = bit << 1;
                    channel = channel + 1;

                    if(channel > rhdab0e)
                    {
                        break;
                    }
                }
                if(channel > rhdab0e)
                {
                    break;
                }
            }
            break;

        default:        
            break;
    }

    return;
}


#if defined(MGD_TGT) && defined(PSD_HW)

/**
 * This function is not used in product, but is useful function for debug
 * Min and Max Navigator roundtrip time will be logged
 */
void computeNavigatorTimingStats()
{
    char navfilepath[170] = "/export/home/service/log/NavStat_";
    struct timespec nCurrTimeNav;
    char timestampNav[20];
    struct tm *NavtimePtr;
    FILE *fp_navStat;
    long navtimingidx = 0;

    mgd_clock_gettime (HOST_TIME_OF_DAY, &nCurrTimeNav);
    NavtimePtr  = localtime(&nCurrTimeNav.tv_sec);

    strftime(timestampNav,20,"_%m%d%Y%H_%M_%S",NavtimePtr);

    strcat(navfilepath,timestampNav);

    fp_navStat=fopen(navfilepath, "w");
    if (fp_navStat == NULL) {
        printf("Failed to open %s\n", navfilepath);
        return;
    }

    /* Send Timing Stats to File */

    fprintf(fp_navStat, "Min Navigator roundtrip time: %ld \n", min_feedback_time);
    fprintf(fp_navStat, "Max Navigator roundtrip time: %ld \n", max_feedback_time);

    for( navtimingidx = 0; navtimingidx < roundtrip_index; navtimingidx++)
    {
        fprintf(fp_navStat, "%ld\n", roundtrip_timing_array[navtimingidx]);
    }

    fclose(fp_navStat);

    return;
}
#endif

/*
 * The NavigatorSat segments are using the same pulse segment as the
 * NavigatorTipUp segment.
 * This func setup the frequency, flip angle and length for the NavigatorSat
 * segment,
 * then playout this segment.
 */
STATUS NavigatorSat()
{
    if(PSD_OFF == navigatorCYL_flag)
    {
        setfrequency( rfmontipup_freq[0],&rfmontipup, 0);
        /* set FA */
        setiamp((SHORT)(ia_rfmontipup*flip_rfmon_navsat/flip_rfmontipup), &rfmontipup, 0);
    } else {
        setfrequency( 0,&rfcylrtipup, 0);
        setiamp((SHORT)(end_gycylratipup*gycylrtipup0_scale/monloggrd.ty*MAX_PG_IAMP),
                &gycylratipup, 0);
        setiamp((SHORT)(end_gzcylratipup*gzcylrtipup0_scale/monloggrd.tz*MAX_PG_IAMP),
                &gzcylratipup, 0);
        /* set FA */
        setiamp((SHORT)(ia_rfcylrtipup*flip_rfcylr_navsat/flip_rfcylrtipup), &rfcylrtipup, 0);
    }
    /* set period to min length */
    setperiod(RUP_GRD(tmin_montipup), &seqmontipup, 0);
    setrotatearray( (short)1, rsprot_monitor[0]);
    boffset(off_seqmontipup);
#ifndef SIM
    startseq((SHORT)0, (SHORT)MAY_PAUSE);
#endif
    reset_for_scan();
    return SUCCESS;
}

STATUS NavigatorTipUp()
{
    if(PSD_OFF == navigatorCYL_flag)
    {
        setfrequency( rfmontipup_freq[0],&rfmontipup, 0);
        /* set fa */
        setiamp((SHORT)(ia_rfmontipup), &rfmontipup, 0);
    } else {
        setfrequency( 0,&rfcylrtipup, 0);
        setiamp((SHORT)(end_gycylratipup*gycylrtipup0_scale/monloggrd.ty*MAX_PG_IAMP),
                &gycylratipup, 0);
        setiamp((SHORT)(end_gzcylratipup*gzcylrtipup0_scale/monloggrd.tz*MAX_PG_IAMP),
                &gzcylratipup, 0);
        /* set fa */
        setiamp((SHORT)(ia_rfcylrtipup), &rfcylrtipup, 0);
    }
    /* set period to include IR time */
    setperiod(RUP_GRD(tmin_montipup + nav_tseq_irprep - nav_min_tseq_irprep), &seqmontipup, 0);
    setrotatearray( (short)1, rsprot_monitor[0]);
    boffset(off_seqmontipup);
#ifndef SIM
    startseq((SHORT)0, (SHORT)MAY_PAUSE);
#endif
    reset_for_scan();
    return SUCCESS;
}

#ifdef NAV_EFGRE3D

/**
 * This function is used for navigator baseline prescan of navigator gating with cardiac gating.
 *
 * @param[in]  NumDisdaqs
 * @param[in]  StartIndex
 */
STATUS
NavigatorPlayContRf(INT NumDisdaqs,INT StartIndex)
{
    int trigger_ecg;
    int i;
    int navdda_index;

    int npe;
    int specir_time=0;

    min_navphase = 1.0E9;
    max_navphase = -1.0E9;

    triggerState = gettrigoccur();
    trigger_detected = FALSE;
    look_for_trig    = TRUE;
    num_trig = 0;

    for (navdda_index = StartIndex; navdda_index < NumDisdaqs+StartIndex; navdda_index++) 
    {
        if (debug_card_sim || (trigger_detected == TRUE)) {
            trigger_ecg = TRIG_INTERN;
            trigger_detected = TRUE;
        } else {
            trigger_ecg = TRIG_ECG;
            trigger_detected = FALSE;
        }

        /* Initialize exphase for each RR (MRIhc07115) */
        exphase =0;

        if (ssfp_flag) 
        {
            /* Trigger Delay Block */
            if( arr_check ) 
            {
                ncard_delay = dda_delay - num_trig;
                if( ncard_delay < 0 ) 
                {
                    ncard_delay = dda_delay;
                    trigger_ecg = TRIG_ECG;
                }
                num_trig = 0; /* reset arr trig count */
                settrigger((short)trigger_ecg, (short)slabindex);
	    
                boffset(off_seqcarddelay);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                settrigger((short)TRIG_INTERN, (short)slabindex);

                /* reinitialize trigger */
                triggerState = gettrigoccur();
                trigger_detected = FALSE; /* reset trigger */

                for( i = 1; i < ncard_delay; ++i ) {
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                }
            } else {
                trigger_detected = FALSE; /* reset trigger */
                settrigger((short)trigger_ecg, (short)slabindex);
	    
                boffset(off_seqcarddelay);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                settrigger((short)TRIG_INTERN, (short)slabindex);

                for( i = 1; i < dda_delay; ++i ) 
                {
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                }
            }
            /* End Trigger Delay Block */

            if ( t2prep_flag && !t2prep_nav_order )
            {
                boffset(off_seqt2prep);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                boffset(off_seqcore);
            }

            /* Move navigator to the front if slice tracking is ON (MRIhc07226) */
            if (slabtracking_flag) 
            {
                
                /* Prolong navigator time up to the 2nd sequence to carry out coil selection */
                if (navdda_index < StartIndex+2) {
                    get_navigator_phase(0, mon_tr, &ref_phase0);
                } else {
                    get_navigator_phase(0, mon_tr, &ref_phase0);
                }
                reset_for_scan();
            }

            if ( t2prep_flag && t2prep_nav_order )
            {
                boffset(off_seqt2prep);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                boffset(off_seqcore);
            }

            if (specir_flag)
            {
                SpecIRChemPrep();
            }
            
            settrigger((short)TRIG_INTERN, (short)slabindex);
            scopeoff(&seqcore);
            boffset(off_seqcore);

            if (enable_alpha) 
            {
                scopeoff(&seqhtrcore);
                boffset(off_seqhtrcore);
                exphase ^= 0x8000;
                setiphase(exphase, &rf1htr, scanrf1_inst);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                boffset(off_seqcore);
            }

            for (i=1;i<=fiesta_gated_dda;i++) 
            {
                int temp_rf1_amp;
                if (fiesta_rampup_type > 0)
                {
                    if(value_system_flag)
                    {
                        if(i<=fiesta_gated_ramp_dda)
                        { /* ramp up */
                            temp_rf1_amp = (int)((float)ia_rf1/(float)fiesta_gated_ramp_dda) * i;
                        } else { /* flat dda */
                            temp_rf1_amp = ia_rf1;
                        }
                    } else {
                        if (1==fiesta_rampup_type)
                        {
                            temp_rf1_amp = (int)((float)(ia_rf1*i)/(float)fiesta_gated_dda);
                        }
                        else if (2==fiesta_rampup_type)
                        {
                            temp_rf1_amp = (int)((float)ia_rf1/
                                            (1+exp((fiesta_gated_dda/2.0-(float)i)/(0.1*fiesta_gated_dda))));
                        }
                        else if (3==fiesta_rampup_type)
                        {
                            temp_rf1_amp = (int)(0.5*(float)ia_rf1*
                                            (1.0-cos((float)(M_PI*i)/(float)fiesta_gated_dda)));
                        } 
                        else 
                        {
                            temp_rf1_amp = ia_rf1;
                        }
                    }
                } else {
                    temp_rf1_amp = ia_rf1;
                }
                setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                exphase ^= 0x8000;
                setiphase(exphase, &rf1, 0);
                startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                scopeoff(&seqcore);
            }
            view = 0;
        }
	    else 
        {   /* GRE */
            if (vast_mode) {
/* Trigger delay block */
if( arr_check ) 
{
    ncard_delay = dda_delay - num_trig;
    if( ncard_delay < 0 ) 
    {
        ncard_delay = dda_delay;
        trigger_ecg = TRIG_ECG;
    }
    num_trig = 0; /* reset arr trig count */
    settrigger((short)trigger_ecg, (short)slabindex);

    boffset(off_seqcarddelay);
    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
    settrigger((short)TRIG_INTERN, (short)slabindex);

    /* reinitialize trigger */
    triggerState = gettrigoccur();
    trigger_detected = FALSE; /* reset trigger */

    for( i = 1; i < ncard_delay; ++i ) 
    {
        startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
    }
}  /* END if(arr_check) */
else
{
    trigger_detected = FALSE; /* reset trigger */
    settrigger((short)trigger_ecg, (short)slabindex);

    boffset(off_seqcarddelay);
    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
    settrigger((short)TRIG_INTERN, (short)slabindex);

    for( i = 1; i < dda_delay; ++i ) 
    {
        startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
    }
} /*  END else!(arr_check) */

            }

            if ((PSD_ON == opcgate) || (PSD_OFF == pfkz_flag)) {
                if ( t2prep_flag && !t2prep_nav_order )
                {
                    boffset(off_seqt2prep);
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                    settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    boffset(off_seqcore);
                }

                if (irprep_flag)
                {
                    IRPrep();
                    settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    scopeoff(&seqcore);

                }

                if (slabtracking_flag) 
                {
                    if (irprep_flag)
                    {
                        NavigatorTipUp();
                    }
                    /* Move navigator pulse to the front if slabtracking is ON (MRIhc07226) */
                    if (navdda_index < StartIndex+2) {
                        get_navigator_phase(0, mon_tr, &ref_phase0);
                    } else {
                        get_navigator_phase(0, mon_tr, &ref_phase0);
                    }
                    reset_for_scan();
                }

                if ( t2prep_flag && t2prep_nav_order )
                {
                    boffset(off_seqt2prep);
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                    settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    boffset(off_seqcore);
                }

                /* Chem Prep Play this after IR Prep since TIs are shorter */
                if (specir_flag) 
                {   
                    SpecIRChemPrep();
                    settrigger((short)TRIG_INTERN, (short)0);
                    scopeoff(&seqcore);
                }
            }	

            boffset(off_seqcore);
            exphase = 0;
            view = -gated_dda;
        }

        /* set amp of gzcomb and gzp for dummy rf */
        setiamp(volumetab[0], &gzcomb, 0);
        if(zrewind_flag) {
            setiamp(volumetab2[0], &gzp, 0);
        }

        /* do the central views  for all z-encodes */

        /* Don't reset phase for FIESTA here, (MRIhc07115)
         * and this has already been done for GRE in section above
         * exphase = 0; */

        if ((PSD_OFF == opcgate) && (PSD_ON == navgate_flag)) {
            /* Reduce pe_acq2 for nav baseline to match navgate_tr */
            if (PSD_ON == pfkz_flag) {
                if (navky_views_per_segment == 0)
                    npe = navkz_views_per_segment;
                else
                    npe = navky_views_per_segment * pfkz_total;
            } else {
                specir_time= (specir_flag * (cs_sattime + cs_satstart + time_ssi));
                npe = (INT)(((act_navgate_tr-mon_tr-specir_time)/act_tr)/2)*2;
            }

            view = 0;
            pe_acq2 = npe;
        }

        for( ; view < pe_acq2; view++ ) 
        { /* view is initialized above */

            if ((PSD_OFF == opcgate) && (PSD_ON == pfkz_flag) &&
                (view%pfkz_views_per_segment == 0))
            {
                if (t2prep_flag)
                {
                    boffset(off_seqt2prep);
                    startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
                    settrigger((SHORT)TRIG_INTERN, (SHORT)slabindex);
                    boffset(off_seqcore);
                }

                /* from vast_gre_scancore() */
                if (irprep_flag)
                {
                    IRPrep();
                    settrigger((short)TRIG_INTERN, (short)0);
                }

                /* Chem Prep Play this after IR Prep since TIs are shorter */
                if (specir_flag) {
                    if (ssfp_flag)
                        SpecIRChemPrep();
                    else
                        ChemPrep();
                    settrigger((short)TRIG_INTERN, (short)0);
                    scopeoff(&seqcore);
                }
                reset_for_scan();
            } /* pfkz_flag */

            if (view < 0)
            {
                dabview = viewtab[0];
            } else {
                dabview = viewtab[view];
            }

            setiamp(-viewtable[dabview], &gy1, 0);
            if(rewinder_flag) {
                setiamp(-viewtable[dabview], &gy1r, 0);
            }

            /* Separate out FIESTA and GRE acquisitions to match 
             * those in vast_X_scancore sections (MRIhc07115) */
            if (ssfp_flag == PSD_ON) 
            {   /*FIESTA*/
                exphase ^= 0x8000;
                setiphase(exphase, &rf1, 0);
                rcphase = (yres_phase + slab_phase + exphase ) & 0xFFF0;
                setiphase(rcphase, &echo1, 0);
            } else {   /*GRE*/	
                spoil();
            }

            setiamp((short)ia_rf1, &rf1, scanrf1_inst);

            startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
            settrigger((short)TRIG_INTERN, (short)slabindex);

            if( arr_check ) 
            {
                triggerState = gettrigoccur();
                if( triggerState == TRUE ) 
                {
                    trigger_detected = TRUE;
                }
                if( trigger_detected ) 
                {
                    ++num_trig;
                }
            }
        }

        /* If slice tracking is ON then navigator will be played in the front 
         * and not here, therefore bypass this section (MRIhc07226) */	
        if (!slabtracking_flag)
        {
            if (navdda_index < StartIndex+2) {
                get_navigator_phase(0, mon_tr, &ref_phase0);
            } else {
                get_navigator_phase(0, mon_tr, &ref_phase0);
            }
        }

        if ( navdda_index >= nav_ss)
        {
            if (min_navphase > ref_phase0) min_navphase = ref_phase0;
            
            if (max_navphase < ref_phase0) max_navphase = ref_phase0;

        }

        reset_for_scan();

        if (fiesta_killer_flag)
        {
            boffset(off_seqgzk);
            scopeoff(&seqgzk);
            startseq((SHORT)slabindex, (SHORT)MAY_PAUSE);
        }

        if(navsat_flag && navigator_flag && slabtracking_flag)
        {
            NavigatorSat();
        }
    } /* navdda loop */

    return SUCCESS;
}

/**
 * This function is used for navigator baseline prescan of navigator gating without cardiac gating.
 *
 * @param[in]  NumDisdaqs
 * @param[in]  navg_calc
 */
STATUS
NavigatorPlaySPGR( INT NumDisdaqs,
            INT navg_calc )
{
    int nseg;
    int nv;

    /* variable flip */
    int temp_rf1_amp, cnt_ramp;
    float temp_rf1_float, rf1_base;
    temp_rf1_amp = ia_rf1;
    temp_rf1_float = (float)ia_rf1;

    min_navphase = 1.0E9;
    max_navphase = -1.0E9;

    setscantimestop();
    setscantimeimm(PSD_CLOCK_NORM,(float)(opnavpsctime*1000000),piviews,pitslice,opslicecnt);
    setscantimestart();

    /* separable */
    if ((PSD_OFF == ellipt_flag) && (PSD_OFF == reverse_ellipt_flag) &&
        (PSD_OFF == radfb_flag) && (PSD_OFF == pfkr_flag) &&
        !((ELLIPTICAL_CAL == cal_shape) || (BOX_CAL == cal_shape)))
    {
        if (PSD_ON == pfkz_flag)
            nv = pfkz_views_per_segment;
        else
            nv = num_views_per_nav_tr;
    } else { /* non-separable */
        if (PSD_ON == segmented_flag) {
            nv = views_per_segment;
        } else {
            if (PSD_ON == pfkz_flag)
                nv = pfkz_views_per_segment;
            else
                nv = num_views_per_nav_tr;
        }
    }

    exphase = 0;

    /* disdaq */
    PlayDisdaq(dda);

    for (slice = 0; slice < NumDisdaqs; slice++) {

        for (nseg=0; nseg < nseg_per_nav_tr; nseg++) {

            if (PSD_ON == specir_flag) {
                ChemPrep(); /* play SPECIR at start of every nav TR */
            }
            if( (chemsat_dda != 0) && (PSD_ON == specir_flag) ) {
                PlayDisdaq(chemsat_dda);
            }

            for (view=0; view < nv; view++) {

                dabview = viewtab[view];

                /* set amp of gzcomb and gzp for dummy rf */
                setiamp(volumetab[0], &gzcomb, 0);
                if(zrewind_flag) {
                    setiamp(volumetab2[0], &gzp, 0);
                }

                setiamp(-viewtable[dabview], &gy1, 0);
                if(rewinder_flag) {
                    setiamp(-viewtable[dabview], &gy1r, 0);
                }
                spoil();

                /* variable flip */
                if ((navseg_weight < 1.0) || (nav_linear_ramp_up > 0) || (nav_linear_ramp_down > 0))
                {
                    temp_rf1_float = (float)ia_rf1;

                    if (nav_linear_ramp_up > 0)
                    {
                        cnt_ramp = view;
                        if (cnt_ramp < nav_linear_ramp_up)
                        {
                            rf1_base = temp_rf1_float*nav_1st_factor;
                            temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_up;
                        }
                    }
    
                    if (nav_linear_ramp_down > 0)
                    {
                        cnt_ramp = nv - view - 1;
                        if (cnt_ramp < nav_linear_ramp_down)
                        {
                            rf1_base = temp_rf1_float*nav_last_factor;
                            temp_rf1_float = rf1_base + (temp_rf1_float-rf1_base)*cnt_ramp/(float)nav_linear_ramp_down;
                        }
                    }

                    if ((navseg_weight < 1.0) && (0 == nseg))
                    {
                        temp_rf1_float *= navseg_weight;
                    }

                    temp_rf1_amp = (int)temp_rf1_float;
                    setiamp(temp_rf1_amp, &rf1, scanrf1_inst);
                }
                else
                {
                    setiamp((short)ia_rf1, &rf1, scanrf1_inst);
                }

                startseq((SHORT)0, (SHORT)MAY_PAUSE);
                settrigger((short)TRIG_INTERN, (short)0);

            } /* end view */

        } /* end nseg */

        if (PSD_ON == nav_wait_flag) {
            settrigger((short)TRIG_INTERN, (short)0);
            scopeoff(&seqnavend);
            boffset(off_seqnavend);
#ifndef SIM
            startseq((short)0, (SHORT)MAY_PAUSE);
#endif
        }

        /* Prolong navigator time up to the coilselection frame
           to carry out coil selection computation */
        if (slice <= nav_coilsel_index) {
            get_navigator_phase(0, nav_coilsel_tr, &ref_phase0);
        } else {
            get_navigator_phase(0, mon_tr, &ref_phase0);
        }

        if (0 != navsegment_dda) {
            PlayDisdaq(navsegment_dda);
        }

        if (navg_calc)
        {
            if ( slice >= nav_ss)
            {
                if (min_navphase > ref_phase0)
                    min_navphase = ref_phase0;
                if (max_navphase < ref_phase0)
                    max_navphase = ref_phase0;
            }
        } /* end if navg_calc */

        reset_for_scan();

    } /* slice loop */

    return SUCCESS;
}

#endif

/**
 * This function is used for navigator baseline prescan of navigator triggering.
 *
 * @param[in]  NumNavs
 * @param[in]  navTR
 * @param[out] *nav_rrmeas_end
 */
STATUS
NavigatorPlayAlone(INT NumNavs, INT navTR, INT *nav_rrmeas_end)
{
    int counter;

    min_navphase = 1.0E9;
    max_navphase = -1.0E9;

    /* HCSDM00153381 */
    if(PSD_ON == opnavrrmeas)
    {
        setscantimestop();
        setscantimeimm(PSD_CLOCK_NORM,(float)(opnavrrmeastime*1000000),piviews,pitslice,opslicecnt);
        setscantimestart();
    } else {
        setscantimestop();
        setscantimeimm(PSD_CLOCK_NORM,(float)(opnavpsctime*1000000),piviews,pitslice,opslicecnt);
        setscantimestart();
    }

    for (counter = 0; counter < NumNavs; counter++){

        /* Prolong navigator time up to the coil selection frame
           to carry out coil selection computation */
        if (counter <= nav_coilsel_index) {
            get_navigator_phase(0, nav_coilsel_tr, &ref_phase0);
        } else {
            get_navigator_phase(0, navTR, &ref_phase0);
        }

        if ( counter >= nav_ss)
        {
            if (min_navphase > ref_phase0) min_navphase = ref_phase0;
            if (max_navphase < ref_phase0) max_navphase = ref_phase0;
        }

        if((PSD_ON == calc_rate) && (NumNavs - 1 == counter))
        {
            *nav_rrmeas_end = 1;
#ifdef PSD_HW
            RtpEnd();
            isrtplaunched = 0;
#endif
            break;
        }
    }

    reset_for_scan();

    return SUCCESS;

}

/**
 * Calculate if the detected position is within acceptance window or not
 * and if the point is accepted or not
 *
 * @param[out] *result
 * @param[out] *in_limit
 */
STATUS
navigator_calculate(INT *result, INT *in_limit)
{

/*MF Parameters*/
/* [o] result:      The point is accepted (1)   */
/* [o] in_limit:    The point is within limit (1)   */

    static int refresh_counter = 0; /* counter for scantime refresh */

    test_rtpoint = nav_currthresh;
    test_rtwin = nav_currwindow * dnav_win_factor;

    low_limit = test_rtpoint - test_rtwin;
    high_limit = test_rtpoint + test_rtwin;

    if ((ref_phase0 > low_limit) && (ref_phase0 < high_limit)) {
        *in_limit = 1;

        if (nav_active){
            *result = 1;
            hbs_left--;
            view_accepted++;
        }else {
            *result=0;
            view_rejected++;
        }
    } else {
#ifndef SIM
        *in_limit = 0;
        *result=0;
        view_rejected++;
#else /*simulator*/
        *in_limit = 1;
        if (nav_active){
            *result = 1;
            hbs_left--;
            view_accepted++;
        }else{
            *result=0;
            view_rejected++;
        }
#endif
    }

    if(PSD_ON == navgate_flag)
    {
        /* calculate scantime every nav_scantime_refresh_pts times */
        refresh_counter = refresh_counter + 1;

        if(refresh_counter >= nav_scantime_refresh_pts)
        {
            refresh_counter = 0;

            curr_eff = (float)(view_accepted)/ (view_accepted+view_rejected);

#ifdef NAV_EFGRE3D
            scantime = act_navgate_tr * hbs_left;
#else
            scantime = (act_tr + mon_tr) * hbs_left;
#endif

            if (curr_eff > 0) {
                scantime/= curr_eff;
            } else {
                /* assume 30% efficiency */
                scantime/= 0.3;
            }

            setscantimestop();
            setscantimeimm(PSD_CLOCK_CARDIAC, scantime, hbs_left,pitslice,opslicecnt);
            setscantimestart();
        }
    }

    return SUCCESS;
}

/**
 * load rotation matrix, filter, and route data
 * slnumber might be used for multiple tracker in the future.
 *
 * @param[in] slnumber
 */
STATUS NavigatorCore(INT slnumber)
{ 
    /* Set frequency */
    setfrequency( mon_receive_freq1[slnumber], &echo1mon, 0);

    if (PSD_OFF == navigatorCYL_flag)
    {
        setfrequency( rf1mon_freq[slnumber],&rf1mon, 0);
        setfrequency( rf2mon_freq[slnumber],&rf2mon, 0);
    } else {
        setfrequency( 0,&rfcylr, 0);
        /* set the ramp gradient amplitude based on the first point of
         * 2D rf gradients 
         */
        setiamp((SHORT)(end_gycylra*gycylr0_scale/monloggrd.ty*MAX_PG_IAMP), &gycylra, 0);
        setiamp((SHORT)(end_gzcylra*gzcylr0_scale/monloggrd.tz*MAX_PG_IAMP), &gzcylra, 0);
    }

    /* install our rotation matrix */
    setrotatearray((short)1,rsprot_monitor[0]);

    /* select our filter */
    setrfltrs((int)filter_echo1mon, &echo1mon);

    /* Turn off regular DAB for RTP preparation, and set the
       destination bit in the dab packet to route the data for  
       APS processing - RJF, MGD2 */

    /* MRIge85438 */ 
    routeDataFrameDab(&echo1mon, ROUTE_TO_RTP, cfcoilswitchmethod);

    /* to beginning of our sequence */
    boffset(off_seqmon);
    scopeoff(&seqmon);

    return SUCCESS;
}

/**
 * prepare for callback function, initialize navigator related parameters,
 * and start RTP apps with those parameters
 */
STATUS NavigatorRspInit( void )
{
    RtpDataValuesPkt navRtpPkt;

#ifdef PSD_HW
    int status;
#endif /* PSD_HW */

#if defined(MGD_TGT) && defined(PSD_HW)
    int initindex = 0;
#endif /* MGD_TGT || PSD_HW */

#if defined(MGD_TGT) && defined(PSD_HW)
    rtp_register_callback(&updateNavigatorBuffer);

    status = rtp_register_opcode(RTP_RESULT_NAVIGATOR, sizeof(NavigatorResult), NULL);
    if (0 != status)
    {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "rtp_register_opcode failed", 
            PSD_ARG_STRING, "rtp_register_opcode:Navigator", 0);
    }
    
    if(isrtplaunched && (PSD_ON == opdynaplan) && rtp_mode_for_nav_dynaplan)
    {
        return SUCCESS;
    }

    if (PSD_ON == nav_timing_flag)
    {
        feedback_time = 0;
        max_feedback_time = 0;
        min_feedback_time = 999;
        sum_feedback_times = 0;
        num_frames_processed = 0;
        roundtrip_index = 0;
        for(initindex = 0; initindex < NAV_NUM_TIMING_POINTS; initindex++)
        {
            roundtrip_timing_array[initindex] = 0;
        }
    }
#endif
    
    /* Now fill navRtpPkt values */

    /* NDG  Changed to new object file and new app type */
    strncpy(navRtpPkt.rtpDataVal.path, "/usr/g/bin", sizeof(navRtpPkt.rtpDataVal.path));
    strncpy(navRtpPkt.rtpDataVal.func, "navigatorRTP", sizeof(navRtpPkt.rtpDataVal.func));

    /* BAM Allocations */
    navRtpPkt.rtpDataVal.dacqType = dacq_data_type;
    navRtpPkt.rtpDataVal.frameSize = mon_xres;
    navRtpPkt.rtpDataVal.hubIndex = coilInfo_tgt[0].hubIndex; 
    navRtpPkt.rtpDataVal.numRtpReceivers = 0; 
    navRtpPkt.rtpDataVal.bodyCoilCombine = rtp_bodyCoilCombine;
    
    nav_acquired_index = 0;
    navRtpPkt.rtpDataVal.acquiredIndex = 0;

    nav_processed_index = 0;
    navRtpPkt.rtpDataVal.processedIndex = 0;

    /* fov_factor */
    navRtpPkt.rtpDataVal.floatVar_1 = fov_factor;
    
    /* mon_acqfov */
    navRtpPkt.rtpDataVal.floatVar_2 = mon_acqfov;
    
    /* phase */
    navRtpPkt.rtpDataVal.floatVar_3 = 0.0;

    /* currthresh */
    nav_currthresh = 0.0;
    navRtpPkt.rtpDataVal.floatVar_4 = nav_currthresh;
    
    /* currwindow */
    nav_currwindow = 0.0;
    navRtpPkt.rtpDataVal.floatVar_5 = nav_currwindow;

    /* currcoil */
    nav_currcoil = 0.0;
    navRtpPkt.rtpDataVal.floatVar_6 = nav_currcoil;

    if (0 == skip_navigator_prescan)
    {
        navRtpPkt.rtpDataVal.floatVar_7 = 0.0;             /* nav_thresh */
        navRtpPkt.rtpDataVal.floatVar_8 = nav_window;      /* nav_window */
    } else {
        navRtpPkt.rtpDataVal.floatVar_7 = nav_prev_thresh; /* nav_thresh */
        navRtpPkt.rtpDataVal.floatVar_8 = nav_prev_window; /* nav_window */
    }

    if ((PSD_ON == opcgate) && (PSD_ON == navgate_flag)) {
        navRtpPkt.rtpDataVal.floatVar_9 = (float)ophrate; /* Heart rate */
    } else {
        navRtpPkt.rtpDataVal.floatVar_9 = 60;
    }

    /* Hist time */
    navRtpPkt.rtpDataVal.floatVar_10 = hist_wait_time/ 1000.0;

    /* Baselines */
    if (0 == skip_navigator_prescan)
    {
        navRtpPkt.rtpDataVal.intVar_1 = nav_ss + nav_dda;
    } else {
        navRtpPkt.rtpDataVal.intVar_1 = 0;
    }

    /* expindex */
    navRtpPkt.rtpDataVal.intVar_2 = 0;

    /* deltapix */
    navRtpPkt.rtpDataVal.intVar_3 = 0;

    /* Navigator Data Dump Flag */
    navRtpPkt.rtpDataVal.intVar_4 = nav_test;
    
    /* Navigator Algorithm */
    navRtpPkt.rtpDataVal.intVar_5 = nav_alg;
    
    /* Navigator Direction */
    navRtpPkt.rtpDataVal.intVar_6 = nav_dir;
    
    /* Channel Select */
    navRtpPkt.rtpDataVal.intVar_7 = nav_channel;

    /* Reset iter flag */
    navRtpPkt.rtpDataVal.intVar_8 = 0;

    /* Navigator Normalization */
    navRtpPkt.rtpDataVal.intVar_9 = nav_normalization;

    /* Navigator Triggering or Navigator Gating */
    navRtpPkt.rtpDataVal.intVar_10 = navtrig_flag;

    /* Navigator Monitor UI mode */
    navRtpPkt.rtpDataVal.intVar_11 = opnavrrmeas;

    /* hrate_ctrl_mode */
    if ((PSD_ON == opcgate) && (PSD_ON == navgate_flag)) {
        navRtpPkt.rtpDataVal.intVar_12 = 1;
    } else {
        navRtpPkt.rtpDataVal.intVar_12 = 0;
    }

    navRtpPkt.rtpDataVal.intVar_13 = navmph_cnt; /* Multi Phase count */

    navRtpPkt.rtpDataVal.intVar_14 = nav_coilsel_index; /* Coil selection index */

    /* Number of steady state acquisitions */
    navRtpPkt.rtpDataVal.longVar_1 = nav_ss;
    
    /* Start Coil */
    navRtpPkt.rtpDataVal.longVar_2 = rhdab0s; 
    
    /* End Coil */
    navRtpPkt.rtpDataVal.longVar_3 = rhdab0e;

    /* same channel selections for dynaplan */
    if (0 == skip_navigator_prescan)
    {
        navRtpPkt.rtpDataVal.longVar_4 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_5 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_6 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_7 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_8 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_9 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_10 = 0x0; /* Dummy */
        navRtpPkt.rtpDataVal.longVar_11 = 0x0; /* Dummy */
    } else {
        navRtpPkt.rtpDataVal.longVar_4 = nav_channel_bit[0];
        navRtpPkt.rtpDataVal.longVar_5 = nav_channel_bit[1];
        navRtpPkt.rtpDataVal.longVar_6 = nav_channel_bit[2];
        navRtpPkt.rtpDataVal.longVar_7 = nav_channel_bit[3];
        navRtpPkt.rtpDataVal.longVar_8 = navscm_channel_bit[0];
        navRtpPkt.rtpDataVal.longVar_9 = navscm_channel_bit[1];
        navRtpPkt.rtpDataVal.longVar_10 = navscm_channel_bit[2];
        navRtpPkt.rtpDataVal.longVar_11 = navscm_channel_bit[3];
    }

    /* Flamesize for Raw Data Dump */
    navRtpPkt.rtpDataVal.writeRawData = nav_save_raw_data;

    /* Debug Flag */
    navRtpPkt.rtpDataVal.vreDebug = nav_debug_flag;
 
    total_points = 0;
 
#ifdef PSD_HW

    status = RtpInit(&navRtpPkt);
    if(SUCCESS != status) {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpInit failed",PSD_ARG_STRING,"RtpInit:Navigator",0);
    }
    isrtplaunched = 1;

#endif

    return SUCCESS;
}

/**
 * analyze the navigator baseline prescan data and send expiration position index to RTP
 *
 * @param[out] *trigger_point
 */
STATUS get_navigator_histogram(FLOAT *trigger_point)
{
    int i;
    int pos_offsets[NAVIGATOR_HISTOGRAM_BINS];
    int rel_pos;
    float ref_phase;
    int hist_pos, hist_freq;
    int endexpindex = -1;  /* MRIhc07115 - LSQ algorithm */
    float x;               /* MRIhc07115 - LSQ algorithm */

#ifdef PSD_HW
    int status;
#endif /* PSD_HW */
    RtpSimplePkt rtpSimplePkt;

    if (0 == nav_type)
    {
        ref_phase = max_navphase;
    } else {
        ref_phase = min_navphase;
    }

    /* Range in mm for histogram analysis (NDG) */
    navphase_range = max_navphase - min_navphase;

    for (i=0;i<NAVIGATOR_HISTOGRAM_BINS;i++) pos_offsets[i]=0;   /* initialize */

    for (i=nav_ss; i< total_points; i++) 
    {
        /* Divide into NAVIGATOR_HISTOGRAM_BINS for analysis. Fix best resolution as 0.01mm to avoid the division from blowing up (NDG) */
        if (navphase_range > 0.01) 
        {
            if (0 == nav_type) /* 0 = maxphase, 1 = minphase */
                rel_pos = (int)(((ref_phase - datamax[i])/navphase_range)*(float)(NAVIGATOR_HISTOGRAM_BINS-1));
            else
                rel_pos = (int)(((datamax[i] - ref_phase)/navphase_range)*(float)(NAVIGATOR_HISTOGRAM_BINS-1));
            pos_offsets[rel_pos]++;
        } else {
            /* If no excursion at all (NDG) */
            pos_offsets[0]++;
        }
    }

    /* find max frequency */
    hist_freq = 0;
    hist_pos = 0;
    for (i=0; i<=nav_sr;i++) /* search radius now a cv used to be 30 MS*/
    {
        if (pos_offsets[i] > hist_freq)
        {
            hist_pos = i;
            hist_freq = pos_offsets[i];  
        }
    }

    if (0 == nav_type) /* 0 = max phase, 1 = min phase */
        *trigger_point = (float)(ref_phase - (hist_pos*navphase_range)/(float)(NAVIGATOR_HISTOGRAM_BINS-1));
    else
        *trigger_point = (float)(ref_phase + (hist_pos*navphase_range)/(float)(NAVIGATOR_HISTOGRAM_BINS-1));
     
    /* Find the index that corresponds to the end-expiration reference (MRIhc07115) */
    for (i = nav_ss; i < nav_dda+nav_ss; i++) 
    {
        x = datamax[i] - *trigger_point;
        if ((x*x) <= (navphase_range*navphase_range)/((float)(NAVIGATOR_HISTOGRAM_BINS-1)*(float)(NAVIGATOR_HISTOGRAM_BINS-1)))
        {
            endexpindex = i;
            break; /* break when endexpindex is found to save time */
        }
    }

    /* rtpSimplePkt.rtpData.l is the subOpcode which will be read by the RTP App */
    rtpSimplePkt.rtpData.l = OP_NAV_EXPINDEX_VALUE;
    rtpSimplePkt.rtpData.f = endexpindex;
    rtpSimplePkt.rtpData.s = (short)((*trigger_point) * 100);

#ifdef PSD_HW

    status = RtpPsdForward(&rtpSimplePkt);

    if(SUCCESS != status) {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpPsdForward for expindex failed",PSD_ARG_STRING,"get_navigator_histogram:Navigator",0);
    }

#endif

#ifdef NAV_EFGRE3D
   if ((PSD_ON == opnavautoaccwin) && (PSD_ON == ifir_flag) && (PSD_ON == opirprep)) {
       error_width = navphase_range * navtrig_factor;
       if (error_width < 2.0)
           error_width = 2.0;
       test_rtwin = error_width;
       nav_window = error_width;
       navigator_set_accwindow(nav_window);
   }
#endif

    return SUCCESS;
}   /* END get_navigator_histogram */


/**
 * run navigator and wait sequence to get position from RTP
 *
 * @param[in]  psd_index
 * @param[in]  nav_tr
 * @param[out] *nav_phase
 */
STATUS get_navigator_phase (INT psd_index, INT nav_tr, FLOAT *nav_phase)
{
 
    int processedIndex; /* timeout = 22ms; */
    int av;
    int data_index;

#if defined(MGD_TGT) && defined(PSD_HW)
    int num_wait;
    int temp_mon_deadtime;
#endif
    
#ifdef PSD_HW
    struct timespec nav_clock;
#endif

    if (total_points > MAX_DATA_CLIPPED)
    {
        data_index = MAX_DATA_CLIPPED;
    }
    else
    {
        data_index = total_points;  /* trap if scan goes too long */
    }
 
    NavigatorCore(psd_index);   /* load rotation matrix, filter, and route data */

    processedIndex = nav_acquired_index + 1;

    for (av=0; av<mon_navgs; av++) 
    {
        startseq(psd_index, (SHORT)MAY_PAUSE);
    }

    if (av >= mon_navgs) 
    {
        nav_acquired_index++;
    }

#if defined(MGD_TGT) && defined(PSD_HW)
   
    if (PSD_ON == nav_timing_flag)
    {
        rspstarttimer();
    }

    /* Below is the wait loop forever, or until data is processed */
    num_wait = 1;
    boffset(off_seqrtpnav); /* offset to feedback wait pulse */
    startseq((SHORT)0, (SHORT)MAY_PAUSE);

    while (nav_processed_index < processedIndex)
    {
        /* Check if feedback results available */
        if ( 0 == getNavigatorFeedback(&nav_processed_index, nav_phase) )
        {
            /* No feedback available.  Play dummy pulse to prevent
               EOS errors while waiting for result */
            num_wait = num_wait + 1;
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        } 

        /* MRIhc30846 */
        feedback_time = rspreadtimer();
        if( (PSD_OFF == nav_debug_flag) && (0 == nav_save_raw_data) &&
            (50000 < num_wait * (rtpresultwait + mon_ssi_time)) ) {
            printdbg("Warning: Could not receive Feedback from RTP within 50ms in get_navigator_phase", 1);
        }
    }

    /* playout extra wait sequence */
    temp_mon_deadtime = RUP_GRD((nav_tr - mon_tr_nav) - num_wait * (rtpresultwait + mon_ssi_time));

    if(PSD_ON == navgate_flag)
    {
        if(temp_mon_deadtime > MAX_PGEN_TIME_GATE)
        {
            setperiod(temp_mon_deadtime, &seqmonwait, 0);
            boffset(off_seqmonwait); /* offset to dummy wait pulse */
            startseq((SHORT)0, (SHORT)MAY_PAUSE);
        }
    }

    if(PSD_ON == navtrig_flag)
    {
        if(temp_mon_deadtime < MAX_PGEN_TIME_TRIG)
        {
            temp_mon_deadtime = MAX_PGEN_TIME_TRIG;
        }

        setperiod(temp_mon_deadtime, &seqmonwait, 0);
        boffset(off_seqmonwait); /* offset to dummy wait pulse */
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    if(PSD_ON == nav_debug_flag)
    {
        if(temp_mon_deadtime > 0)
            act_nav_time = nav_tr;
        else
            act_nav_time = mon_tr_nav + num_wait * (rtpresultwait + mon_ssi_time);
    }

    if (PSD_ON == nav_timing_flag)
    {
        feedback_time = rspreadtimer();
        if( roundtrip_index < NAV_NUM_TIMING_POINTS )
        {
            roundtrip_timing_array[roundtrip_index] = feedback_time;
            roundtrip_index++;
        }

        if (max_feedback_time < feedback_time)
        {
            max_feedback_time = feedback_time;
        }

        if (min_feedback_time > feedback_time)
        {
            min_feedback_time = feedback_time;
        }

        num_frames_processed = nav_processed_index;
        sum_feedback_times = sum_feedback_times + feedback_time;

    }
#endif
  
    datamax[data_index] = *nav_phase;

#ifdef PSD_HW
    mgd_clock_gettime(0, &nav_clock); /* HOST_TIME_OF_DAY */
    nav_timing[data_index] = 1000000*nav_clock.tv_sec+nav_clock.tv_nsec/1000;
#endif

    total_points++;
  
    return SUCCESS;
} /* END get_navigator_phase */

/**
 * send pixel difference to RTP
 *
 * @param[in]  delta_mm
 */
STATUS navigator_set_deltapixel (FLOAT delta_mm)
{   /* MRIhc07115 - Update navigator threshold used for LSQ processing */
    /* MRIhc07115 - Update navigator threshold used for LSQ processing */
    float mm_to_pix;
    int deltapix;

#ifdef PSD_HW
    int status;
#endif /* PSD_HW */

    RtpSimplePkt rtpSimplePkt;

    mm_to_pix = (float)mon_xres/mon_acqfov;

    deltapix = (int)(mm_to_pix*delta_mm);

    /* rtpSimplePkt.rtpData.l is the subOpcode which will be read by the RTP App */
    rtpSimplePkt.rtpData.l = OP_NAV_DELTAPIX_VALUE;
    rtpSimplePkt.rtpData.f = deltapix;

#ifdef PSD_HW

    status = RtpPsdForward(&rtpSimplePkt);
    if(SUCCESS != status) {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpPsdForward for deltapix failed",PSD_ARG_STRING,"set_deltapixel:Navigator",0);
    }
#endif

    return SUCCESS;
}   /* END set_deltapixel */

/* navigator_reset_iter will enable the RTP side to redo the baseline collection.
 * It maybe useful for multi-slab in the future. Currently, only the
 * first slab will do the baseline collection.
 */
STATUS navigator_reset_iter (short reset_flag)
{   /* Reset iter value to 0 for 3D Heart */
#ifdef PSD_HW
    int status;
#endif
    RtpSimplePkt rtpSimplePkt;

    /* rtpSimplePkt.rtpData.l is the subOpcode which will be read by the RTP App */
    rtpSimplePkt.rtpData.l = OP_NAV_ITER_VALUE;
    rtpSimplePkt.rtpData.s = reset_flag;

#ifdef PSD_HW
    status = RtpPsdForward(&rtpSimplePkt);
    if(SUCCESS != status) {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpPsdForward for iter value failed",PSD_ARG_STRING,"set_iter:Navigator",0);
    }
#endif

    return SUCCESS;
}   /* END set_iter */

/**
 * send acceptance window value to RTP 
 * This function is used for auto acceptance window in IFIR
 *
 * @param[in]  auto_accwin
 */
STATUS navigator_set_accwindow (FLOAT auto_accwin)
{
#ifdef PSD_HW
    int status;
#endif
    RtpSimplePkt rtpSimplePkt;

    /* rtpSimplePkt.rtpData.l is the subOpcode which will be read by the RTP App */
    rtpSimplePkt.rtpData.l = OP_NAV_AUTO_ACCEPTANCE_VALUE;
    rtpSimplePkt.rtpData.f = auto_accwin;

#ifdef PSD_HW
    status = RtpPsdForward(&rtpSimplePkt);
    if(SUCCESS != status) {
        psdexit(EM_PSD_ROUTINE_FAILURE, 0,"", "RtpPsdForward for auto acceptance window failed",PSD_ARG_STRING,"set_accwindow:Navigator",0);
    }
#endif

    return SUCCESS;
}

/**
 * This function is used to dump navigator related parameters for debug purpose
 */
STATUS write_navigator_data_file( void )
{   /* MRIhc07063 - Write navigator parameters into file */

    FILE *fidman ; /* output file handle */
    char filename[255];

#ifdef PSD_HW
    struct timespec host_clock; 
#endif
    LONG seconds=0;
    int i;

    boffset(off_seqloopdelay);
#ifdef PSD_HW
    mgd_clock_gettime (HOST_TIME_OF_DAY, &host_clock);
    seconds = host_clock.tv_sec ;
#endif
    sprintf(filename,"/usr/g/service/log/navtest_config.%d", seconds);

    if (total_points > MAX_DATA_CLIPPED)
    {
        total_points = MAX_DATA_CLIPPED;
    }

    /* write out the scan parameters */
    if ( (fidman = fopen(filename,"w")) )
    {
        fprintf(fidman, "\n Navigator Flags: \n");
        fprintf(fidman, "navigator_flag    = %d\n", navigator_flag);
        fprintf(fidman, "navtrig_flag      = %d\n", navtrig_flag); 
        fprintf(fidman, "navgate_flag      = %d\n", navgate_flag); 
        fprintf(fidman, "slabtracking_flag = %d\n", slabtracking_flag);
        fprintf(fidman, "navigatorCYL_flag = %d\n", navigatorCYL_flag);

        fprintf(fidman, "\n Navigator Parameters sent to RTP: \n");
        fprintf(fidman, "framesize         = %d\n", mon_xres);
        fprintf(fidman, "pointSize         = %d\n", rhptsize);
        fprintf(fidman, "numRtpReceivers   = %d\n", rhdab0e - rhdab0s + 1);
        fprintf(fidman, "fov_factor        = %f\n", fov_factor);
        fprintf(fidman, "mon_acqfov        = %f\n", mon_acqfov);
        if (0 == skip_navigator_prescan) {
            fprintf(fidman, "nav_window        = %f\n", nav_window);
        } else {
            fprintf(fidman, "nav_thresh        = %f\n", nav_prev_thresh);
            fprintf(fidman, "nav_window        = %f\n", nav_prev_window);
        }
        if ((PSD_ON == opcgate) && (PSD_ON == navgate_flag)) {
            fprintf(fidman, "ophrate           = %f\n", (float)ophrate);
        } else {
            fprintf(fidman, "ophrate           = %f\n", 60.0);
        }
        fprintf(fidman, "hist_wait_time    = %f\n", hist_wait_time/ 1000.0);
        if (0 == skip_navigator_prescan) {
            fprintf(fidman, "baselines         = %d\n", nav_ss + nav_dda);
        } else {
            fprintf(fidman, "baselines         = %d\n", 0);
        }
        fprintf(fidman, "nav_test          = %d\n", nav_test);
        fprintf(fidman, "nav_alg           = %d\n", nav_alg);
        fprintf(fidman, "nav_dir           = %d\n", nav_dir);
        fprintf(fidman, "nav_channel       = %d\n", nav_channel);
        fprintf(fidman, "nav_normalization = %d\n", nav_normalization);
        fprintf(fidman, "navtrig_flag      = %d\n", navtrig_flag);
        fprintf(fidman, "opnavrrmeas       = %d\n", opnavrrmeas);
        if ((PSD_ON == opcgate) && (PSD_ON == navgate_flag)) {
            fprintf(fidman, "hrate_ctrl_mode   = %d\n", 1);
        } else {
            fprintf(fidman, "hrate_ctrl_mode   = %d\n", 0);
        }
        fprintf(fidman, "navmph_cnt        = %d\n", navmph_cnt);
        if (1 == skip_navigator_prescan) {
            for(i = 0; i < MAX_CH_GRP; i++) {
                fprintf(fidman, "nav_channel_bit[%d] = %ld\n", i, nav_channel_bit[i]);
                fprintf(fidman, "navscm_channel_bit[%d] = %ld\n", i, navscm_channel_bit[i]);
            }
        }
        fprintf(fidman, "nav_ss            = %d\n", nav_ss);
        fprintf(fidman, "rhdab0s           = %d\n", rhdab0s);
        fprintf(fidman, "rhdab0e           = %d\n", rhdab0e);
        fprintf(fidman, "nav_save_raw_data = %d\n", nav_save_raw_data);
        fprintf(fidman, "nav_debug_flag    = %d\n", nav_debug_flag);
    
        fprintf(fidman, "\n Other Navigator Parameters: \n");
        fprintf(fidman, "nav_type          = %d\n", nav_type);
        fprintf(fidman, "nav_sr            = %d\n", nav_sr);
        fprintf(fidman, "curr_eff          = %f\n", curr_eff);
        fprintf(fidman, "monrot_phi        = %f\n", monrot_phi);
        fprintf(fidman, "mon_navgs         = %d\n", mon_navgs);
        fprintf(fidman, "mon_fov           = %f\n", mon_fov);
        fprintf(fidman, "mon_vthickz       = %f\n", mon_vthickz);
        fprintf(fidman, "mon_vthicky       = %f\n", mon_vthicky);
        fprintf(fidman, "mon_vthick        = %f\n", mon_vthick);
        fprintf(fidman, "mon_tr            = %d\n", mon_tr);
        fclose(fidman);
    }

    return SUCCESS;
}   /* END write_navigator_data_file */

/**
 * This function is called from each PSD to run navigator baseline prescan
 *
 * @param[out] *nav_rrmeas_end
 */
STATUS navigator_baseline_prescan(INT *nav_rrmeas_end)
{
    short trig_org; /* original trigger */

    nav_stable_flag = -1;

    /* initialize deltapix to 0 at the beginning (MRIhc07115) */
    navigator_set_deltapixel(0.0);
    navigator_reset_iter(0);    

    /* get trigger info */
    gettrigger(&trig_org, (short) 0);

    /* Navigator Prescan */
#ifdef NAV_EFGRE3D
    if (PSD_ON == navtrig_flag) {
        NavigatorPlayAlone(nav_ss + nav_dda, nav_prescan_tr, nav_rrmeas_end);
    } else if (PSD_OFF == opcgate) {
        NavigatorPlaySPGR(nav_ss + nav_dda, 1);
    }
#else
    NavigatorPlayAlone(nav_ss + nav_dda, nav_prescan_tr, nav_rrmeas_end);
#endif

    settrigger((short)TRIG_INTERN, (short)0);
    scopeoff(&seqnavhistdelay);
    boffset(off_seqnavhistdelay);
#ifndef SIM
    startseq((short)0, (SHORT)MAY_PAUSE);
#endif /* PSD_HW */

    /* Navigator computations */
    /* nav_window, max_nav_phase and min_nav_phase
       are calculated from the Navigator Prescan. RJF */

    error_width = fabs(nav_window);
    test_rtwin = error_width;

    /* Range in mm for histogram analysis (NDG) */
    navphase_range = max_navphase - min_navphase;

    get_navigator_histogram(&trig_phase);

    test_rtpoint = trig_phase;
    tmpcurrthresh = trig_phase; /*MF 12/27/2004 SLICE TRACKING initialization*/

    if(PSD_ON == nav_debug_flag)
        printf("actual last navigator time was %dus\n", act_nav_time);

    while(nav_stable_flag < 0) /* wait for callback from RTP: updateNavigatorBuffer */
    {
        if(PSD_ON == nav_debug_flag)
            printf("wait for callback from RTP: updateNavigatorBuffer\n");
#ifndef SIM
        startseq((short)0, (SHORT)MAY_PAUSE);
#endif /* PSD_HW */
    }

    if ((PSD_ON == nav_pause_after_prescan) || (0 == nav_stable_flag)) {
        settrigger((short)TRIG_INTERN, (short)0);
        scopeoff(&seqloopdelay2);
        boffset(off_seqloopdelay2);
#ifndef SIM
        startseq((short)0,(SHORT)MUST_PAUSE);
#endif
    }

    scopeon(&seqcore);
    boffset(off_seqcore);

    reset_for_scan();
    result = 0;
    in_limit = 0;

    settrigger(trig_org, (short) 0); /* original trigger */

    return SUCCESS; 
} /* end nav_baseline_prescan() */ 

/**
 * This function is called from each PSD to run navigator for navigator triggering
 */
STATUS
NavigatorPlayTrig( void )
{
    int nav_counter = 0;
    int i = 0;      /*MF use for dummy wait time counter*/
    short trig_org = 0; /* original trigger */ 

#ifndef SIM
    /* auto-start */
    struct timespec nav_clock;
    long start_time = 0;
    long current_time = 0;
    int autostart_counter=0;
#endif

    /* get trigger info */
    gettrigger(&trig_org, (short) 0);
    settrigger((short)TRIG_INTERN, (short)0);

    nav_quiet_dda = (int)(ceil((float)navtrig_waittime/loopdelay2));

#ifdef NAV_2DFSE
    loaddab_hub_r1(&echo1mon,0,0,0,0,0,pscR1,DABON,PSD_LOAD_DAB_ALL | PSD_LOAD_DAB_R1);
#endif

    if (nav_quiet_dda > 0) {
        /* wait for T1 relaxation */
        scopeoff(&seqloopdelay2);
        boffset(off_seqloopdelay2);
        for (i=0;i<nav_quiet_dda;i++){
#ifndef SIM
            startseq((short)0, (SHORT)MAY_PAUSE);
#endif
        }
    }

    result = 0;
    while(!result){
        /*play navigator seq and get displacement*/
        get_navigator_phase(0, mon_tr, &ref_phase0);

        if (((0 == nav_type) && (ref_phase0 > nav_currthresh+nav_currwindow)) ||
            ((1 == nav_type) && (ref_phase0 < nav_currthresh-nav_currwindow)))
            nav_active = 0;

        /*turn on nav triggering if we are at a new resp cycle*/
        if (((0 == nav_type) && (ref_phase0 < nav_currthresh-nav_currwindow)) ||
            ((1 == nav_type) && (ref_phase0 > nav_currthresh+nav_currwindow)))
            nav_counter++;
        else if (0 == nav_active)
            nav_counter=0;

#ifndef SIM
        /* auto-start */
        mgd_clock_gettime(0, &nav_clock); /* HOST_TIME_OF_DAY */
        current_time = 1000000*nav_clock.tv_sec+nav_clock.tv_nsec/1000;
        if (0 == autostart_counter)
            start_time = current_time;
        autostart_counter++;
#endif

        if ((0 == nav_active) && (nav_counter >= wait_pts)){
            nav_active = 1;
        }

#ifndef SIM
        /* auto-start */
        if ((0 == nav_active) && (current_time - start_time >= opnavautotrigtime * 1000000))
            nav_active = 1;
#endif

        reset_for_scan();

        navigator_calculate(&result, &in_limit); /*decide whether to reject or accept and update scantime left accordingly*/

    }/*while loop*/

    /* Add a waiting pulse between Nav sequence and imaging sequence */
    if(navtrig_wait_before_imaging >= MIN_WAIT_TIME)
    {
        setperiod(navtrig_wait_before_imaging, &seqmonwait, 0);
        boffset(off_seqmonwait); /* offset to dummy wait pulse */
        startseq((SHORT)0, (SHORT)MAY_PAUSE);
    }

    settrigger(trig_org, (short) 0); /* original trigger */
    boffset(off_seqcore);

#ifndef SIM
    if (rspent == L_SCAN)
    {
        scantime = (60000000/ (float)oprtrate) * (float)hbs_left;
        setscantimestop();
        setscantimeimm(PSD_CLOCK_CARDIAC, scantime, hbs_left,pitslice,opslicecnt);
        setscantimestart();
    }
#endif

#ifndef SIM
    nav_active =0; /*reset nav trigger*/
#endif
    return SUCCESS;
} /* end PlayTrig() */

/**
 * This function is called from each PSD to run navigator for navigator gating without cardiac gating
 */
STATUS
NavigatorPlayGate( void )
{
    short trig_org; /* original trigger */

    /* set trigger to intern */
    gettrigger(&trig_org, (short)0);
    settrigger((short)TRIG_INTERN, (short)0);

    /*play navigator seq and get displacement*/
    get_navigator_phase(0, mon_tr, &ref_phase0);
    reset_for_scan();
    navigator_calculate(&result, &in_limit); /*decide whether to reject or accept and update scantime left accordingly*/

    settrigger(trig_org, (short)0); /* original trigger */

    return SUCCESS;
}


/**
 * gets navigator processedIndex and phase from RTP App.  ProcessedIndex and phase are 
 * unchanged if there is no new data available.
 *
 * @param[out] *processedIndex - Pointer to the processedIndex
 * @param[out] *phase - pointer to the phase 
 * @return 1 if new data available.  0 otherwise
 *
 */

int getNavigatorFeedback(int * processedIndex, float * phase)
{
    n32 packed = 0;
    NavigatorResult rtpResult;
    int nBytes = 0;
    
#if defined(MGD_TGT) && defined(PSD_HW)
    nBytes = rtp_get_feedback_data(&rtpResult, sizeof(rtpResult), &packed, RTP_RESULT_NAVIGATOR, RTP_QUEUE_OLDEST);
#endif    

    if( nBytes > 0 )
    {
        if( packed )
        {
            /* Unpack results packed into lower 28-bits of an n32 */
            n32 * packedResult = (n32 *)(&rtpResult);

            /* Bits 16-27 are the processed index */
            *processedIndex = (*packedResult & 0x0fff0000) >> 16;

            /*
             * Bit 15 is the sign of the phase 
             * Bits 14-0 are the phase * 100 
             */
            if ((*packedResult & 0x00008000))
            {
                *phase = (float) -1.0*(*packedResult & 0x00007fff)/100.0;
            }
            else
            {
                *phase = (float) (*packedResult & 0x00007fff)/100.0;
            }
        }
        else
        {
            /* Results are a NavigatorResult structure */
            if( nBytes != sizeof(rtpResult) )
            {
                RtpEnd();
                psdexit(EM_PSD_ROUTINE_FAILURE, 0, "", "Failure in reading results",
                        PSD_ARG_STRING, "get_navigator_phase:Navigator", 0);
            }

            *processedIndex = rtpResult.processedIndex;
            *phase = rtpResult.phase;
        }

        return 1;
    }
    else
    {
        /* No new feedback data */
        return 0;
    }
}

void getDiffGradAmp(float * difx, float * dify, float * difz, int dshot)
{
    int bindex, dirindex;

    if (opdifnumt2 > 0)
    {
        if (dshot <= 0 )  /* ref and T2 */
        {
            *difx = 0;
            *dify = 0;
            *difz = 0;
        }
        else
        {
            *difx = diff_ampx[(int)((dshot-1)/opdifnumdirs)];
            *dify = diff_ampy[(int)((dshot-1)/opdifnumdirs)];
            *difz = diff_ampz[(int)((dshot-1)/opdifnumdirs)];

            if(opdfaxtetra > PSD_OFF || opdfax3in1 > PSD_OFF || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
            {
                if (obl_3in1_opt) /* Obl 3in1 opt */
                {
                    bindex = (int)((dshot-1)/opdifnumdirs);
                    dirindex = (dshot-1)%opdifnumdirs;

                    *difx = diff_ampx2[bindex][dirindex];
                    *dify = diff_ampy2[bindex][dirindex];
                    *difz = diff_ampz2[bindex][dirindex];

                    if (obl_3in1_opt_debug)
                    {
                        printf(" \n");
                        printf("bindex= %d dirindex= %d\n", bindex, dirindex);
                        printf("MPG amplitude in each axis in G/cm.\n");
                        printf("*difx= %f *dify= %f *difz= %f\n", *difx, *dify, *difz);
                    }
                }
                else if (PSD_OFF == different_mpg_amp_flag)
                {
                    rotateToLogical(difx, dify, difz, (dshot-1)%opdifnumdirs);
                }
            }
            else
            {
                *difx *= D[(dshot-1)%opdifnumdirs][AXIS_X];
                *dify *= D[(dshot-1)%opdifnumdirs][AXIS_Y];
                *difz *= D[(dshot-1)%opdifnumdirs][AXIS_Z];
            }
        }
    }
    else
    {
        if (dshot<0)  /* ref */
        {
            *difx = 0;
            *dify = 0;
            *difz = 0;
        }
        else
        {
            *difx = diff_ampx[(int)(dshot/opdifnumdirs)];
            *dify = diff_ampy[(int)(dshot/opdifnumdirs)];
            *difz = diff_ampz[(int)(dshot/opdifnumdirs)];

            if(opdfaxtetra > PSD_OFF || opdfax3in1 > PSD_OFF || (opdfaxall > PSD_OFF && gradopt_diffall == PSD_ON))
            {
                if (obl_3in1_opt) /* Obl 3in1 opt */
                {
                    bindex = (int)(dshot/opdifnumdirs);
                    dirindex = dshot%opdifnumdirs;

                    *difx = diff_ampx2[bindex][dirindex];
                    *dify = diff_ampy2[bindex][dirindex];
                    *difz = diff_ampz2[bindex][dirindex];

                    if (obl_3in1_opt_debug)
                    {
                        printf(" \n");
                        printf("bindex= %d dirindex= %d\n", bindex, dirindex);
                        printf("MPG amplitude in each axis in G/cm.\n");
                        printf("*difx= %f *dify= %f *difz= %f\n", *difx, *dify, *difz);
                    }
                }
                else if (PSD_OFF == different_mpg_amp_flag)
                {
                    rotateToLogical(difx, dify, difz, dshot%opdifnumdirs);
                }
            }
            else
            {
                *difx *= D[dshot%opdifnumdirs][AXIS_X];
                *dify *= D[dshot%opdifnumdirs][AXIS_Y];
                *difz *= D[dshot%opdifnumdirs][AXIS_Z];
            }
        }
    }
}

void loadDiffVecMatrix(void)
{
    /* SWL: set the diffusion lobe amp scale for DWI
     * D[][] are 4by3 matrix. First dimension
     * indicates the axis to play the gradient lobe, the second
     * dimension indicates the TRs to be played. (Index 0 is the
     * T2 scan) */

    if (opdfaxall == PSD_ON)
    {
        if(gradopt_diffall == PSD_OFF)
        {
            D[DIR1][AXIS_X] = 0.0;
            D[DIR1][AXIS_Y] = 0.0;
            D[DIR1][AXIS_Z] = 1.0;

            D[DIR2][AXIS_X] = 1.0;
            D[DIR2][AXIS_Y] = 0.0;
            D[DIR2][AXIS_Z] = 0.0;

            D[DIR3][AXIS_X] = 0.0;
            D[DIR3][AXIS_Y] = 1.0;
            D[DIR3][AXIS_Z] = 0.0;
        }
        else
        {
            D[DIR1][AXIS_X] = 1.0;
            D[DIR1][AXIS_Y] = 1.0;
            D[DIR1][AXIS_Z] = 0.0;

            D[DIR2][AXIS_X] = 1.0/sqrt(2.0);
            D[DIR2][AXIS_Y] = -1.0/sqrt(2.0);
            D[DIR2][AXIS_Z] = 1.0;

            D[DIR3][AXIS_X] = -1.0/sqrt(2.0);
            D[DIR3][AXIS_Y] = 1.0/sqrt(2.0);
            D[DIR3][AXIS_Z] = 1.0;
        }
    }
    else if(opdfaxx > 0)
    {
        D[DIR1][AXIS_X] = 1.0;
        D[DIR1][AXIS_Y] = 0.0;
        D[DIR1][AXIS_Z] = 0.0;
    }
    else if(opdfaxy > 0)
    {
        D[DIR1][AXIS_X] = 0.0;
        D[DIR1][AXIS_Y] = 1.0;
        D[DIR1][AXIS_Z] = 0.0;
    }
    else if(opdfaxz > 0)
    {
        D[DIR1][AXIS_X] = 0.0;
        D[DIR1][AXIS_Y] = 0.0;
        D[DIR1][AXIS_Z] = 1.0;
    }
    else if (opdfax3in1 > PSD_OFF || opdfaxtetra > PSD_OFF)
    {
        D[DIR1][AXIS_X] = 1.0;
        D[DIR1][AXIS_Y] = 1.0;
        D[DIR1][AXIS_Z] = 1.0;

        D[DIR2][AXIS_X] = 1.0;
        D[DIR2][AXIS_Y] = -1.0;
        D[DIR2][AXIS_Z] = -1.0;

        D[DIR3][AXIS_X] = -1.0;
        D[DIR3][AXIS_Y] = -1.0;
        D[DIR3][AXIS_Z] = 1.0;

        D[DIR4][AXIS_X] = -1.0;
        D[DIR4][AXIS_Y] = 1.0;
        D[DIR4][AXIS_Z] = -1.0;
    }
}

STATUS rotateToLogical(float * idifx, float * idify, float * idifz, int dir)
{
    float ax, ay, az;

    ax = (*idifx)*D[dir][AXIS_X];
    ay = (*idify)*D[dir][AXIS_Y];
    az = (*idifz)*D[dir][AXIS_Z];

    *idifx = inversRR[0]*ax+inversRR[1]*ay+inversRR[2]*az;
    *idify = inversRR[3]*ax+inversRR[4]*ay+inversRR[5]*az;
    *idifz = inversRR[6]*ax+inversRR[7]*ay+inversRR[8]*az;

    return SUCCESS;
}

STATUS inversRspRot( float inversRot[9], long  origRot[9])
{
    /* given that the rotation matrix would always be real and
     * orthogonal, then the inverse of the rotation matrix would
     * be the same as its tranpose matrix ZL */
    float a[9];
    int i, j;

    for (i = 0; i<9; i++)
    {
        a[i] = (float)origRot[i]/(float)max_pg_iamp;
    }

    for (i=0; i<3 ; i++)
    {
        for (j=0; j<3; j++)
        {
            inversRot[i*3+j] = a[3*j+i];
        }
    }

    if (debugTensor == PSD_ON)
    {
        printf("orig rot is\n");
        for (i=0; i<3; i++)
        {
            for (j=0; j<3; j++)
            {
                printf( "%f        ",a[i*3+j]);
            }
            printf("\n");
        }
        printf("invers rot is\n");
        for (i=0; i<3; i++)
        {
            for (j=0; j<3; j++)
            {
                printf( "%f        ",inversRot[i*3+j]);
            }
            printf("\n");
        }
        fflush( stdout );
    }
    return SUCCESS;
}

STATUS set_diff_order( void )
{
    /* This function calculates the diffusion gradient cycling orders for each pass and
     * save the scheme into diff_order.txt
     * */
    int npass;
    int nslice;
    int ndirs = 0;
    int LCD;
    int thedir = 0;
    int count = 0;
    int noffset=0;
    int n = 0, nrep = 0;
    int var;
    int kk, ll, mm;
    int maxnex;

#ifndef IPG
    int sum_dir;
    FILE *fp_diff_order = NULL;

#ifdef PSD_HW
    const char *dir_difforder = "/usr/g/service/log";
#else
    const char *dir_difforder = "./";
#endif

    char fname_difforder[255];
    sprintf(fname_difforder, "%s/diff_order.txt", dir_difforder);
#endif

    int pass_offset = (ref_in_scan_flag ? 1:0) + (rpg_in_scan_flag?rpg_in_scan_num:0);

    if (tensor_flag == PSD_OFF)
    {
        if(diff_order_flag == 1)
        {
            ndirs = num_dif;
            nrep = opnumbvals;
        }
        else if (diff_order_flag == 2)
        {
            ndirs = (int)(opdifnext2 * opdifnumt2 + num_dif * total_difnex);
            nrep = 1;
        }
    }
    else
    {
        if(diff_order_flag == 1)
        {
#ifndef IPG
            ndirs = exist(opdifnumdirs);
#else
            ndirs = opdifnumdirs;
#endif
        }
        else if (diff_order_flag == 2)
        {
            ndirs = pass_reps - pass_offset; /* Don't cycle integrated ref nor RPG volume */
        }
        nrep = 1;
    }

    int counter = 0;
    if (diff_order_flag == 2 && tensor_flag == PSD_OFF)
    {
        for(kk=0; kk<opdifnumt2; kk++)
        {
            for (ll=0; ll<opdifnext2; ll++)
            {
                diff_order_pass[counter] = kk+pass_offset;
                diff_order_nex[counter]  = ll;
                diff_order_dif[counter]  = 0;
                counter++;
            }
        }

        for(kk=0; kk<opnumbvals; kk++)
        {
#ifdef IPG
            maxnex = difnextab_rsp[kk];
#else
            maxnex = (int)difnextab[kk];
#endif
            for (ll=0; ll< maxnex; ll++)
            {
                for (mm=0; mm<num_dif; mm++)
                {
                    diff_order_pass[counter] = (int)(opdifnext2 * opdifnumt2 + mm + num_dif * kk + pass_offset);
                    diff_order_nex[counter] = ll;
                    diff_order_dif[counter] = kk;
                    counter++;
                }
            }
        }
    }

    if (ndirs == 0)
    {
        return SKIP;
    }

    /* No change in order */
    for (npass = 0; npass < opdifnumt2 + pass_offset; npass++)
    {
        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            diff_order[npass][nslice] = npass;
        }
    }

    /* Assign diffusion direction */
    if (diff_order_flag == 1)
    {
        noffset = opdifnumt2 + pass_offset;
    }
    else if (diff_order_flag == 2)
    {
        noffset = pass_offset;
    }

    LCD = getLCD(diff_order_nslices, ndirs);

    if(LCD == 0)
    {
        return FAILURE;
    }

    var = 0;

    for (npass = 0; npass < ndirs; npass++)
    {
        if (diff_order_nslices > ndirs)
        {
            var = npass;
        }

        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            if ((diff_order_flag == 1) || (diff_order_flag == 2))
            {
                thedir = thedir%ndirs;
                diff_order[noffset + npass][nslice] = noffset + thedir;
                count++;
                thedir++;
            }
        }

        if ((diff_order_flag == 1) || (diff_order_flag == 2))
        {
            thedir = thedir%ndirs;
            if(count%LCD == 0)
            {
                thedir++;
            }
            thedir = thedir%ndirs;
        }
    }

    /* repeat for multi-b */
    if (nrep > 1)
    {
        for (n = 1; n < nrep; n++)
        {
            for (npass = 0; npass < ndirs; npass++)
            {
                for (nslice = 0; nslice < diff_order_nslices; nslice++)
                {
                    diff_order[noffset + n * ndirs + npass][nslice] = diff_order[noffset + npass + (n-1) * ndirs][nslice] + ndirs;
                }
            }
        }
    }

#ifndef IPG
    /* Debug info in diff_order.txt*/
    if(diff_order_debug)
    {
        if (NULL != (fp_diff_order = fopen(fname_difforder, "w")))
        {
            fprintf(fp_diff_order, "# ndirs, Slices\n");
            fprintf(fp_diff_order, "%d, %d\n", ndirs, diff_order_nslices);
            fprintf(fp_diff_order, "# opdfaxall, opdfax3in1, opdfaxtetra, optensor\n");
            fprintf(fp_diff_order, "%d, %d, %d, %d\n", opdfaxall, opdfax3in1, opdfaxtetra, optensor);

            for (npass = 0; npass < diff_order_size; npass++)
            {
                fprintf(fp_diff_order, "# Pass %d: \n", npass);
                for (nslice = 0; nslice < diff_order_nslices; nslice++)
                {
                    fprintf(fp_diff_order, "%d ", diff_order[npass][nslice]);
                }
                fprintf(fp_diff_order, "\n");

            }

            if (diff_order_flag == 2 && tensor_flag == PSD_OFF)
            {
                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_pass: ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_pass[npass]);
                }

                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_nex:  ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_nex[npass]);
                }

                fprintf(fp_diff_order, "\n");
                fprintf(fp_diff_order, "diff_dif:  ");

                for (npass = 0; npass < ndirs; npass++)
                {
                    fprintf(fp_diff_order, "%02d ", diff_order_dif[npass]);
                }
            }
            fclose(fp_diff_order);
        }
    }

    /* verify order */
    if (diff_order_verify == 1)
    {
        int *verify_diff = NULL;
        if((verify_diff = (int *) malloc(sizeof(int) * pass_reps)) == NULL)
        {
            return FAILURE;
        }

        for (nslice = 0; nslice < diff_order_nslices; nslice++)
        {
            memset(verify_diff, 0, sizeof(int) * pass_reps);

            sum_dir = 0;

            for (npass = 0; npass < pass_reps; npass++)
            {
                if(verify_diff[diff_order[npass][nslice]] == 1)
                {
                    return FAILURE;
                }
                else
                {
                    verify_diff[diff_order[npass][nslice]] = 1;
                }

                sum_dir += diff_order[npass][nslice];
            }

            if (sum_dir != pass_reps*(pass_reps - 1)/2)
            {
                return FAILURE;
            }
        }

        free(verify_diff);
    }

#endif
    return SUCCESS;
}

int getLCD(int a, int b)
{
    int x, y, r;

    x = a;
    y = b;
    r = a % b;

    while (r > 0)
    {
        x = y;
        y = r;
        r = x % y;
    }

    return a*b/y;
}

int get_diff_order(int pass, int slice)
{
    return diff_order[pass][slice];
}

/* Include special CV download code */
#include "epi2.cvcopy.cpp"

