/*
 *  epi2.allcv.h
 *
 *  Do not edit this file. It is automatically generated by EPIC.
 *
 *  Date : Jul 22 2018
 *  Time : 03:23:38
 */

#ifndef h_epi2_allcv_h
#define h_epi2_allcv_h

long _firstcv = 0;

/*
 * reqcv
 * cvs required for communication between host applications
 * (scn, ifcc, psc, etc.) and any and all PSDs. The content
 * is order-sensitive and name sensitive. If any changes are
 * made to CV names or the order of CVs including new additions
 * anywhere, the revision must be changed to prevent adverse
 * and unpredictable changes to the data communicated to and from
 * the PSD.
 */

int psd_annefact_level = 0 






;

int rhpsd_annefact_level = 0 






;

float psd_relative_excited_volume_freq = -1.0 






;

float psd_relative_excited_volume_phase = -1.0 






;

float psd_relative_excited_volume_slice = 1.0 






;


float psd_relative_encoded_volume_freq = -1.0 






;

float psd_relative_encoded_volume_phase = 1.0 






;

float psd_relative_encoded_volume_slice = 1.0 






;

int opresearch = 0 






;

/* ****************************
   Patient/Study Parameters 
   ************************** */
float opweight = 50 






;

/* ****************************
   Patient Position Parameters 
   ************************** */

int oplandmark = PSD_OFF 






;

int optabent = 0 






;

int opentry = 1 






;

int oppos = 1 






;

int opplane = PSD_AXIAL 






;

int opphysplane = PSD_AXIAL 






;

int opobplane = PSD_AXIAL 






;

int opimode = PSD_2D 






;

int oppseq = 1 






;

/* opgradmode says which coil is active in TRM_COIL (twin gradient) (Gili) */
int opgradmode = 0 






;

/* Anatomy */
int opanatomy = 0 





;

/* ************************** 
   Imaging Options CVs 
   *************************** */
int piimgoptlist = 0 






;

int opcgate = 0 






;

int opexor = 0 






;

int opcmon = 0 






;

int opfcomp = 0 






;

int opgrx = 0 






;

int opgrxroi = 0 






;

int opnopwrap = 0 






;

int opptsize = 2 






;

int oppomp = 0 






;

int opscic = 0 






;

int oprect = 0 






;

int opsquare = 0 






;

int opvbw = 0 






;

int opblim = 0 






;

int opfast = 0 






;

int opcs = 0 






;

int opdeprep = 0 






;

int opirprep = 0 






;

int opsrprep = 0 






;

int opmph = 0 






;

int opdynaplan = 0 






;

int opdynaplan_mask_phase = 0 





;

/*  Black Blood Suppression */
int opbsp = 0 






;

int oprealtime = 0 






;

int opfluorotrigger = 0 






;

int opET = 0 






;

int opmultistation = 0 






;

int opepi = 0 






;

int opflair = 0 






;

int opt1flair = 0 






;

int opt2flair = 0 






;

int opdoubleir = 0 






;

int optissuet1 = 0 






;

int opautotissuet1 = 0 






;

int optlrdrf = 0 






;

int opfulltrain = 0 






;

int opirmode = SIRMODE 






;

int opmt = 0 






;

int opzip512 = 0 






;

int opzip1024 = 0 






;

int opslzip2 = 0 






;

int opslzip4 = 0 






;

int opsmartprep = 0 






;

int opssrf = 0 






;

int opt2prep = 0 






;

int opspiral = 0 






;

int opnav = 0 






;

int opfmri = 0 






;

/* ECTRICKS CVS */
int opectricks = 0 






;

int optricksdel = 1000000 





;

int optrickspause = 1 





;

int opfr = 0 






;

int opcube = 0 






;

int ophydro = 0 






;

/* Added for enabling fiesta-c psd is selected.: HK */
int opphasecycle = 0 






;

int oplava = 0 






;

int op3dcine_fiesta = 0 






;

int op3dcine_spgr = 0 






;

int op4dflow = 0 






;

int opbrava = 0 






;

int opcosmic = 0 






;

int opvibrant = 0 






;


int opbravo = 0 






;

int opdisco = 0 






;

int opmprage = 0 






;

/* PROMO CV */
int oppromo = 0 






;

int opprop = 0 






;

int opdwprop = 0 






;

int opdwpropduo = 0 






;

int opmuse = PSD_OFF 






;

int opallowedrescantime = 0 






;

int opbreastmrs = 0 






;

int opjrmode = 0 






;

int opssfse = 0 






;

int t1flair_flag = 0 






;
                                                                        
/*
   AF 03/22/01 Add condition parameter for Phase Sensitivity
   Reconstruction function when Phase Sensitivity radio button is selected
   on the Imaging Option page
*/

int opphsen = 0 






;

int opbc = 0 






;

int opfatwater = 0 






;

int oprtbc = 0 






;

int opnseg = 1 






;

int opnnex = 0 






;

int opsilent = 0 






;

int opsilentlevel = 1 






;

int opmerge = 0 






;

int opswan = 0 






;

int opphaseimage = 0 






;

int opdixon = 0 






;

/*----------------------------------------------------------------
Bit pattern for opdixproc
-------------------------
bit 0 used for indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
----------------------------------------------------------------*/
int opdixproc = 0 






;

int opmedal = 0 






;

int opquickstep = 0 






;

int opidealiq = 0 






;

int opsilentmr = 0 






;

int opmagic = 0 






;

/* ************************************
   added for Zoom Gradient limitations
   ************************************ */
float opzoom_fov_xy = 440.0 






;

float opzoom_fov_z = 350.0 






;

float opzoom_dist_ax = 120.0 






;

float opzoom_dist_cor = 120.0 






;

float opzoom_dist_sag = 150.0 






;

int app_grad_type = 0 






;

int opzoom_coil_ind = 0 






;

int pizoom_index = 0 






;


/* *****************
   SAT CVs 
   **************** */
int opsat = 0 
;

int opsatx = 0 






;

int opsaty = 0 






;

int opsatz = 0 






;

float opsatxloc1 = 9999 






;

float opsatxloc2 = 9999 






;

float opsatyloc1 = 9999 






;

float opsatyloc2 = 9999 






;

float opsatzloc1 = 9999 






;

float opsatzloc2 = 9999 






;

float opsatxthick = 40.0 






;

float opsatythick = 40.0 






;

float opsatzthick = 40.0 






;

int opsatmask = 0 






;

int opfat = 0 






;

int opwater = 0 






;

int opccsat = 0 






;

int opfatcl = 0 





;


int opspecir = 0 





;

/* ***************************
   These are for graphic sats.
   *************************** */
int opexsatmask = 0 






;

float opexsathick1 = 40.0 






;

float opexsathick2 = 40.0 






;

float opexsathick3 = 40.0 






;

float opexsathick4 = 40.0 






;

float opexsathick5 = 40.0 






;

float opexsathick6 = 40.0 






;

float opexsatloc1 = 9999 






;

float opexsatloc2 = 9999 






;

float opexsatloc3 = 9999 






;

float opexsatloc4 = 9999 






;

float opexsatloc5 = 9999 






;

float opexsatloc6 = 9999 






;

int opexsatparal = 0 






;

/*
   The opexsatoff<> cvs are for future use when targeted sat pulses
   are implemented 
*/
int opexsatoff1 = 0 






;

int opexsatoff2 = 0 






;

int opexsatoff3 = 0 






;

int opexsatoff4 = 0 






;

int opexsatoff5 = 0 






;

int opexsatoff6 = 0 






;

int opexsatlen1 = 480 






;

int opexsatlen2 = 480 






;

int opexsatlen3 = 480 






;

int opexsatlen4 = 480 






;

int opexsatlen5 = 480 






;

int opexsatlen6 = 480 






;
/* end of unused targeted sat cvs */

/* default sat band thicknesses */
float opdfsathick1 = 40.0 






;

float opdfsathick2 = 40.0 






;

float opdfsathick3 = 40.0 






;

float opdfsathick4 = 40.0 






;

float opdfsathick5 = 40.0 






;

float opdfsathick6 = 40.0 






;

/* **********************************************************************
   Pseudo-header variables. These values keep the following
   information for manual inclusion in the header -- that is, the PSD
   needs to copy the information to someplace else, like opusers, in
   order for the data to be included in the header. These values are
   calculated by Scan and are not used internally. Not OP, IH, PI, or RH.

   Thickness = sqrt(normth_R^2 + normth_A^2 + normth_S^2)
   Normal vector = [normth_R, normth_A, normth_S]/Thickness
   Sat center = dist * Normal vector.
   ********************************************************************** */

float exsat1_normth_R = 0;
float exsat1_normth_A = 0;
float exsat1_normth_S = 0;
float exsat2_normth_R = 0;
float exsat2_normth_A = 0;
float exsat2_normth_S = 0;
float exsat3_normth_R = 0;
float exsat3_normth_A = 0;
float exsat3_normth_S = 0;
float exsat4_normth_R = 0;
float exsat4_normth_A = 0;
float exsat4_normth_S = 0;
float exsat5_normth_R = 0;
float exsat5_normth_A = 0;
float exsat5_normth_S = 0;
float exsat6_normth_R = 0;
float exsat6_normth_A = 0;
float exsat6_normth_S = 0;
float exsat1_dist = 0;
float exsat2_dist = 0;
float exsat3_dist = 0;
float exsat4_dist = 0;
float exsat5_dist = 0;
float exsat6_dist = 0;

/* Graphic IR Bands */
int pigirscrn = 0;      /* To control Graphic IR screen */
int piautoirbands = 0;  /* To control Auto IR Bands button */
float pigirdefthick = 200.0;    /* Graphic IR Bands default thickness in mm */

int pinumgir = MAX_NUM_GIR 





;

int opnumgir = 0 





;

int pigirmode = 3 





;

int opgirmode = 0 





;

/* Cardiac Tagging */
int optagging = 0 






;

int optagspc = 7 





;

/*
 * Allow Tagging angles of 0 and 90 degrees 
 * with default as 45 degrees. The CV taggingangle in 
 * Tagging.e has been replaced with optagangle and moved
 * to epic.h
 */
float optagangle = 45.0 





;


/* *****************
   Vascular CVs
   ***************** */
float opvenc = 50.0 





;

int opflaxx = 0 





;

int opflaxy = 0 





;

int opflaxz = 0 





;

int opflaxall = 0 





;

int opproject = 0 





;

int opcollapse = 1 





; 

int oprlflow = 0 





;

int opapflow = 0 





;

int opsiflow = 0 





;

int opmagc = 1 





;

int opflrecon = 0 





;

int oprampdir = 0 





;

int project = 0 





;

int vas_ovrhd = 0 





;

int slice_col = 1 





; 

int phase_col = 0 





;

int read_col = 0 





;

int mag_mask = 1 





;

int phase_cor = 1 





;

int extras = 0 





;

int mag_create = 1 





;

int rl_flow = 0 





;

int ap_flow = 0 





;

int si_flow = 0 





;

int imagenum = 1 





;

int motsa_ovrhd = 0 





;

int opslinky = 0 





;

int opinhance = 0 






;

int opmavric = 0 






;

int opinhsflow = 0 






;

int opmsde = 0 





;

float opvest = 50.0 





;

int opmsdeaxx = 0 





;

int opmsdeaxy = 0 





;

int opmsdeaxz = 0 





;

/* Auto Navigator Tracker */
int opbreathhold= 0 





;

/********************************************************/
/*      AUTO SUBTRACT                                   */
/********************************************************/

int opautosubtract = 0 






;

int opsepseries = 0 






;

/* **********************
   op user CVs
   ********************* */
int pititle = 0 ;
float opuser0  = 0 ;
float opuser1  = 0 ;
float opuser2  = 0 ;
float opuser3  = 0 ;
float opuser4  = 0 ;
float opuser5  = 0 ;
float opuser6  = 0 ;
float opuser7  = 0 ;
float opuser8  = 0 ;
float opuser9  = 0 ;
float opuser10 = 0 ;
float opuser11 = 0 ;
float opuser12 = 0 ;
float opuser13 = 0 ;
float opuser14 = 0 ;
float opuser15 = 0 ;
float opuser16 = 0 ;
float opuser17 = 0 ;
float opuser18 = 0 ;
float opuser19 = 0 ;
float opuser20 = 0 ;
float opuser21 = 0 ;
float opuser22 = 0 ;
float opuser23 = 0 ;
float opuser24 = 0 ;
float opuser25 = 0 ;
float opuser26 = 0 ;
float opuser27 = 0 ;
float opuser28 = 0 ;
float opuser29 = 0 ;
float opuser30 = 0 ;
float opuser31 = 0 ;
float opuser32 = 0 ;
float opuser33 = 0 ;
float opuser34 = 0 ;
float opuser35 = 0 ;
/* Do not use the following UserCVs. They are reserved for common purposes. */
float opuser36 = 0 ;
float opuser37 = 0 ;
float opuser38 = 0 ;
float opuser39 = 0 ;
float opuser40 = 0 ;
float opuser41 = 0 ;
float opuser42 = 0 ;
float opuser43 = 0 ;
float opuser44 = 0 ;
float opuser45 = 0 ;
float opuser46 = 0 ;
float opuser47 = 0 ;
float opuser48 = 0 ;

/********************************************************/
/*   Multi-Station cvs                                  */
/********************************************************/

int opnostations = 1 





;

int opstation = 1 





;

int oploadprotocol = 0 





;

int opmask = 0 





;

int opvenous = 0 





;

/* Added to indicate whether Procol/Scan mode -TAA */
int opprotRxMode = 0 





;

/********************************************************/
/*   Multi-Phase cvs				        */
/********************************************************/

int opacqo = 1 





;

int opfphases = PHASES_MIN 





;

int opsldelay = 50000 





;

int avminsldelay = 50000 





;

/* ECTRICKS CVS */
int optphases = PHASES_MIN 





;

int opdynaplan_nphases = 1 





;

int opvsphases = PHASES_MIN 





;

/********************************************************/
/*   EPI DWI/TENSOR cvs				        */
/********************************************************/

int opdiffuse = 0 






;

int opsavedf = 0 





;
	
int opmintedif = 1 





;

int opseparatesynb = 1 





;

int opdfaxx = 0;        /*   diffusion direction variables      */
int opdfaxy = 0;
int opdfaxz = 0;
int opdfaxall = 0;
int opdfaxtetra = 0;
int opdfax3in1 = 0;

int opbval = 0 





;

int opnumbvals = 1 





;

int opautonumbvals = 0 





;

int opnumsynbvals = MIN_NUM_SYNBVALS 





;

float opdifnext2 = 1 





;

int opautodifnext2 = 0 





;

int optensor = 0 





;

int opdifnumdirs = 1 





;

int opdifnumt2 = 1 





;

int opautodifnumt2 = 0 





;

int opdualspinecho = 0 





;

int opdifproctype = 0 





;

int opdifnumbvalues = 1 





;

int dti_plus_flag = 0 





;

/***********************************/
/*   MR-TOUCH CVs                  */
/***********************************/
int optouch = 0 






;

int optouchfreq = 60 





;

int optouchmegfreq = 60 





;

int optouchamp = 30 





;

int optouchtphases = 4 





;

int optouchcyc = 3 





;

int optouchax = 4 





;

/*********************
    Silenz-ASL CVs
 ********************/
int opaslprep = 0 






;
 
/* ********************
   3dASL CVs
   ********************/
int opasl = 0 






;
      
float oppostlabeldelay = 1525.0 






;

int rhchannel_combine_method = 0 






;

int rhasl_perf_weighted_scale = 32 






;

/* ****************************************
   Acoustic Reduction Technology (ART) CVs
   **************************************** */
float cfslew_artmedium = 2.0 





;

float cfgmax_artmedium = 3.3 





;

float cfslew_arthigh = 2.0 





;

float cfgmax_arthigh = 3.3 





;

int cfnumartlevels = 0 





;

int pinumartlevels = 0 





;

/*Two CV added for SV system*/
float cfslew_artmediumopt = 5.0 





;

float cfgmax_artmediumopt = 2.2 





;

/* *********************
   fMRI CVs
   ******************** */
int oprep_active = 1 





;

int oprep_rest = 1 





;

int opdda = 0 





;

int opinit_state = 0 





;

int opfMRIPDTYPE = SIMPLE_BLOCK 





;

int opview_order = 1 





;

int opslice_order = 0 





;

int oppsd_trig = 0 





;

int oppdgm_str = -1 





;

int opbwrt = 0 





;

int cont_flag = PSD_OFF 





;

/* *******************
   Scan Timing CVs 
   ******************* */

/* Show opnecho by default for all PSDs */
int opautonecho = 1 





;

int opnecho = 1 






;

int opnshots = 1 





;

int opautote = 0 





;

int opte = 25000 





;

int opte2 = 50000 





;

/* cv for Faster sequence TE selection */
int optefw = 0 





;

int opti = TI_MIN 





;

int opbspti = TI_MIN 






;

int opautoti = 0 





;

int opautobti = 0 





;

int optrecovery = TRECOVERY_MIN 





;

int optlabel = TLABEL_DEF 





;

int opt2prepte = 25000 





;

int opautotr = 0 





;

int opnspokes = 128 





;

float opoversamplingfactor = 1.0 





;

int opacs = 4 





;

int opharmonize = 0 






;

int pieffbladewidth = 1 





;

int opinrangetr = 0 





;

int opinrangetrmin = 160000 





;

int opinrangetrmax = 10000000 





;

int optr = 400000 





;

float opflip = 90 





;

int opautoflip = 0 





;

int opautoetl = 0 





;

int opetl = 8 





;

int opautorbw = 0 





;

/* oprbw is receive bw for echoes 2-4 for 1.5 T, receive bw for 1st echo
for 0.5 T */

float oprbw = 16.0 





;

float oprbw2 = 16.0 





;

/* *******************
   Scanning Range CVs 
   ******************* */		

float opfov = FOV_MAX 





;

float opphasefov = 1 





;

float opnpwfactor = 1.0 





;

float opfreqfov = 1 





;

int opautoslquant = 0 





;

int opslquant = 1 





;

int opsllocs = 1 





;

float opslthick = 5 





;

float opslspace = 10 





;

int opileave = 0 





;

/* 0 is non coaxial
   1 is coaxial through isocenter
   2 is coaxial not through isocenter */

int opcoax = 1 





;

float opvthick = 320 





;

int opvquant = 1 





;

int opovl = 0 





;

/* ***********************
   Graphic ROI CVs
   ********************** */

float oplenrl = 0 





;

float oplenap = 0 





;

float oplensi = 0 





;

float oplocrl = 0 





;

float oplocap = 0 





;

float oplocsi = 0 





;

float oprlcsiis = 1 





;

float opapcsiis = 2 





;

float opsicsiis = 3 





;

/* SmartPrep CVs */

float opmonfov = 200 





;

float opmonthick = 20 





;

float opinittrigdelay = 1000000 





;

/* ***********************
   Acquisition Time CVs 
   ********************** */

int opxres = 256 





;

int opyres = 128 





;

int opautonex = 0 





;

float opnex = 1 





;

int opslicecnt = 0 





;

int opnbh = 0 






;

int opspf = 0 





;

int opcfsel = 2 





;

int opfcaxis = 0 





;

int opphcor = 0 





;

float opdose = 0 





;

int opcontrast = 0 






;

/* ****************
   Regular CINE CVs 
   **************** */

int opchrate = 100 






;

int opcphases = 1 






;

int opaphases = 1 






;

int opclocs = 1 






;

/* **************
   Cardiac CVs 
   ************** */

int ophrate = 60 






;

int oparr = 10 





;

int ophrep = 1 





;

int opautotdel1 = 0 





;

int optdel1 = 20000 





;

int optseq = 1 





;

int opphases = 1 





;

int opcardseq = 0 





;

int opmphases = 0 





;

int oparrmon = 1 





;

int opvps = 8 





;

int opautovps = 0 





;

int opcgatetype = CARDIAC_GATE_TYPE_NONE 





;

int opadvgate = 0 





;

/* Fast CINE */
int opfcine = 0 






;

/* **************************
   CineIR CVs
   ************************** */
int opcineir = 0 





;

/* **************************
   STRESS/CREATIV Feature CVs
   ************************** */

/* CREATIV feature activation CV */
int opstress = 0 





;

/* Number of R-R Intervals */
int opnrr = 0 





;

/* DisDaqs for Monitor Mode */
int opnrr_dda = 8 





;

/* ********************
   Resp Trig CVs
   ******************** */

int oprtcgate = 0 






;

int oprtrate = 12 





;

int oprtrep = 1 





;

int oprttdel1 = 20000 





;

int oprttseq = 1 





;

int oprtcardseq = 0 





;

int oprtarr = 10 





;

int oprtpoint= 10 





;

/* ********************
 *    Navigator CVs
 * ******************** */

int opnavrrmeas = 0 





;

int opnavrrmeastime = 20 





;

int opnavrrmeasrr = 12 





;

int opnavsltrack = 0 





;

int opnavautoaccwin = 0 





;

float opnavaccwin = 2.0 





;

int opnavautotrigtime = 10 





;

int opnavpsctime = 10 





;

int opnavmaxinterval = 200 





;

int opnavtype = PSD_NAV_TYPE_90_180 





;

int opnavpscpause = 0 





;

int opnavsigenhance = 0 





;


int opasset = 0 





;

int opassetcal = 0 






;

int opassetscan = 0 






;

int rhcoilno = 0 





;

/* ******************************
   Bit patterns for rhcal_options
   ------------------------------
   bit 0 set for Ext 3D Cal;
   bit 1 set for Ext 2D Cal;
   bit 2 set for Int ACS Lines Cal;
   bit 3 set for Int 1st phase Cal;
   bit 4 set for Cache calibration;
   ********************************************* */
int rhcal_options = 0 





;

int rhasset = 0 





;

int rhasset_calthresh = 10000 





;

float rhasset_R = 0.5 





;

int rhasset_phases = PHASES_MIN 





;

float rhscancent = 0.0 





;

int rhasset_alt_cal = 0 






;

int rhasset_torso = 0 






;

int rhasset_localTx = 0 






;

float rhasset_TuningFactor = 15.0 






;

float rhasset_SnrMin = 15.0 






;

float rhasset_SnrMax = 75.0 






;

float rhasset_SnrScalar = 1.0 






;

/*
 * PURE cvs
 */
int oppure = 0 






;

int rhpure = 0 






; 

int oppurecal = 0 






;

int rhpurechannel = 0 






;

/*PURE filter selection*/ 
int rhpurefilter= 0 






;

float rhpure_scale_factor = 1.0 






;

int cfpure_filtering_mode = 1 






;

int rhpure_filtering_mode = 1 






;

float rhpure_lambda = 10.0 






;

float rhpure_tuning_factor_surface = 0.0 






;

float rhpure_tuning_factor_body = 1.0 






;

float rhpure_derived_cal_fraction = 0.0 






;

float rhpure_cal_reapodization = 12.0 






;

int opcalrequired = PSD_OFF 






;

int rhpure_blur_enable = 0 






;

float rhpure_blur = 0.0 






;

float rhpure_mix_lambda = 10.0 






;

float rhpure_mix_tuning_factor_surface = 0.0 






;

float rhpure_mix_tuning_factor_body = 1.0 






;

int rhpure_mix_blur_enable = 0 






;

float rhpure_mix_blur = 0.0 






;

float rhpure_mix_alpha = 0.0 






;

int rhpure_mix_otsu_class_qty = 2 






;

float rhpure_mix_exp_wt = 0.0 






;

int rhpure_mix_erode_dist = 0 






;

int rhpure_mix_dilate_dist = 0 






;

int rhpure_mix_aniso_blur = 0 






;

int rhpure_mix_aniso_erode_dist = 0 






;

int rhpure_mix_aniso_dilate_dist = 0 






;

int opcalmode = CAL_MODE_STANDARD 






;

int rhcalmode = 0 






;

int opcaldelay = 5000000 






;

int rhcal_pass_set_vector = 12 






;

int rhcal_nex_vector = 101 






;

int rhcal_weight_vector = 101 






;

int sifsetwokey = 0 





;

int opautosldelay = PSD_OFF 





;

/* *******************
    Spectroscopy CVs
   ******************* */
int specnuc = 1 






;

int specpts = 256 






;

int specwidth = 2000 






;

int specnavs = 1 






;

int specnex = 2 






;

int specdwells = 1 






;

int acquire_type = 0 






;

/* ********************
   Spectro Hardware 
   ******************** */

int pixmtband = AMP_ERBTEC 






;

int pibbandfilt = 0 






;


/* *********************
   Prescan CVs
   ********************* */

/* Flag for warm up mode CF prescan on Profile *//* MFO 10/16/98 YI */
int opwarmup = 0 





;

int pscahead = 0 





;

int opprescanopt = 0 





;

int autoadvtoscn = 0 





;

int opapa = 0 





;

int oppscapa = 0 





;

int PSslice_ind = 0 






; 

int oppscshimtg = 0 





;

int opdyntg = 0 





;

/*** DynTG ***/
float dynTG_fov = FOV_MAX 





;

int dynTG_slquant = 1 





;

float dynTG_flipangle = 60.0 





;

float dynTG_slthick = 10.0 





;

int dynTG_xres = 64 





;

int dynTG_yres = 64 





;

int dynTG_baseline = 0 





;

int dynTG_ptsize = 4 





;

float dynTG_b1factor = 1.0 





;

/*** RF Shim ***/
float rfshim_fov = FOV_MAX 





;

int rfshim_slquant = 1 





;

float rfshim_flipangle = 60.0 





;

float rfshim_slthick = 10.0 





;

int rfshim_xres = 64 





;

int rfshim_yres = 64 





;

int rfshim_baseline = 0 





;

int rfshim_ptsize = 4 





;

float rfshim_b1factor = 1.0 





;

/*** EXTCAL ***/
int cal_xres = 32 





;

int cal_yres = 32 





;

int cal_slq = 36 





;

int cal_nex = 2 





;

int cal_interleave = 0 





;

float cal_fov = FOV_MAX 





;

float cal_slthick = 15 





;

int cal_pass = 2 





;

/*** AUTOCOIL ***/
int coil_xres = 32 





;

int coil_yres = 32 





;

int coil_slq = 36 





;

int coil_nex = 2 





;

float coil_fov = FOV_MAX 





;

float coil_slthick = 15 





;

int coil_pass = 1 





;

int coil_interleave = 0 





;

/* *********************
   Autoshim CVs
   ********************* */
float asfov = FOV_MAX 





;

int asslquant = 1 





;

float asflip = 20 





;

float asslthick = 10 





;

int asxres = 256 





;

int asyres = 128 





;

int asbaseline = 8 





;

int asrhblank = 4 





;

int asptsize = 4 





;

int opascalcfov = 0 





;

/* ************************
   Transmit Gain CVs 
   ************************ */
float tgfov = FOV_MAX 





;

int tgcap = MAX_SYS_TG 





;

int tgwindow = MAX_SYS_TG 





;

/* ************************
   Multi-Volume Prescan CVs
   ************************ */

int oppscvquant = 0 





;

/* ************************
   Dual Drive CVs
   ************************ */
int opdrivemode = 1 





;

int pidrivemodenub = 7 





;

/* Excitation Mode CV */
int opexcitemode = 0 





;

/* ***************************
   Low power parameters  (GE)
   *************************** */
float lp_stretch = 2.0 






;

int lp_mode = 0 






;

float derateb1_body_factor = 1.0 






;

float SAR_bodyNV_weight_lim = 110.0 






;

float derateb1_NV_factor = 1.0 






;

float jstd_multiplier_body = 0.145 






;

float jstd_multiplier_NV = 0.0137 






;

float jstd_exponent_body = 0.763 






;

float jstd_exponent_NV = 1.154 






;


int pidiffmode = 0;

int pifmriscrn = 0; /* To control fmri screen */

/* pi values for spiral */
int piresol = 0 





;

int pioverlap = 0 





;

int piforkvrgf = 0;  /*  1 causes scan to spawn the vrgf process upon download */
int pinofreqoffset = 0; /*  1 disables fov offset in frequency direction */
/* Needed picvs for fmri */

int pirepactivenub = 0;
int pireprestnub = 0;
int piddanub = 0;
int piinitstatnub = 0;
int piviewordernub = 0;
int pisliceordnub = 0;
int pipsdtrignub = 0;

int pispssupnub = 1;  /* for water suppression button on Spectro Prescan UI */

/* **********************
   Lx: FMPVAS/FGRE CVs
   ********************** */
int pi_neg_sp = 0 





;

float piisvaldef = 2.0 





;

/* FGRE/2DMDE CV */
int pi2dmde = 0 





;

/* **********************
   Clock Operation CVs 
   ********************** */
int pidmode = 0 





;

int piviews = 0 





;

int piclckcnt = 1 





;

float avmintscan = 0.0 





;

float pitslice = 0.0 





;

float pitscan = 0.0 





;

/* ECTRICKS */
float pimscan = 0.0 





;

float pivsscan = 0.0 





;

/* AKR: Recon Lag Model output */
float pireconlag = -3.0 





;



float pitres = 0.0 





;

float pitres2 = 0.0 





;

/* **********************
   Image Creation CVs 
   ********************** */
int pisaveinter = 0 





;

int pivextras = 0 





;

int pinecho = 0 





;

/* *****************************
   TGT Needs for Table Position 
   ***************************** */
float piscancenter = 0.0 





;

float pilandmark = 0.0 





;

float pitableposition = 0.0 





;

/* ******************
   Service CVs
   ***************** */
int pismode = 0 





;

int pishldctrl = PSD_OFF 





;

int pinolr = PSD_ON 





;

int pinoadc = PSD_OFF 





;

int pimixtime = 0 





;

/* High order shim CVs */

int pishim2 = HO_SHIM_NO 





;

int pi1stshimb = HO_SHIM_1ST_BUTTON_ON 





;

/* Added for SNR Index */
float pifractecho = 1.0 





;

int nope = PSD_OFF 





;

/* *******************
   Custom Scan Schema CVs
   ****************** */
int opuser_usage_tag = 0x00000000 





;

int rhuser_usage_tag = 0x00000000 





;

int rhFillMapMSW = 0x00000000 





;

int rhFillMapLSW = 0x00000000 





;

/* *******************
   Recon Header CVs
   ****************** */
int rhbline = 0 





;

int rhblank = 4 





;

int rhnex  = 1 





;

int rhnavs = 1 





;

int rhnslices = 1 





;

int rhnrefslices = 0 





;

int rhnframes = 256 





;

int rhfrsize = 256 





;

int rhnecho = 1 





;

int rhnphases = 1 





;

int rhmphasetype = 0 





;

/* More bits may be added in the future*/
int rhtrickstype = 0 





;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   RHTYPCHP       1
   bit 0  Set if chopper data
   RHTYPCINE      2
   bit 1  Set if CINE
   RHTYPSHIM      4
   bit 2  Set if SHIM
   RHTYPGR        8
   bit 3  Set if GRASS
   RHTYPFRACTNEX  16
   bit 4  Set for fractional processing
   RHTYPSTRIP     32
   bit 5  Set for strip scan Y
   RHTYP3D        64
   bit 6  Set for 3-D processing
   RHTYPXOR       128
   bit 7  Set if exorcist
   RHTYPNPW       256
   bit 8  Set if NPW
   RHTYPNFW       512
   bit 9  Set if NFW
   RHTYPXSTRIP    1024
   bit 10 Set if strip scan X.
   RHTYPFRACTECHO 2048
   bit 12 No longer used.
   RHTYP75NEX     8192
   bit 13 Set if 3/4 nex.
   RHTYPPOMP      16384
   bit 14 Set if pomp
   RHTYPTURBO     32768
   ****************************** */
int rhtype = 0 





;

/* ********************************
   Bit patterns for rhtype1
   ------------------------------
   RHTYP1HOMODYNE      1
   bit 0  Unset (0) if regular recon, set (1) if homodyne recon
   RHTYP1NEXA          2
   bit 1  Set if nex table per echo is required
   RHTYP1CINEODDNEX    4
   bit 2  Set if odd NEX CINE
   RHTYP1SFRAME        8
   bit 3  Set if mulit-coil superframe
   RHTYP13DM           16
   bit 4  Set if 3D multi-slab
   RHTYP1MAXOVL        32
   bit 5 on, bit 6 off  Maximum intersity pixel collapse overlap processing
   RHTYP1MINOVL        64
   bit 5 off, bit 6 on  Minimum intersity pixel collapse overlap processing
   RHTYP1AVEOVL        96
   bit 5 on, bit 6 on   Average intersity pixel collapse overlap processing
   RHTYP1FPHASEOFF     128
   bit 7  Set for "fast phase off" in phase-contrast scans
   RHTYP1AUTOPASS      256
   bit 8  Set if automatic scan/pass detection scheme is enabled.  If set,
   *      then data acquisition will assert scan and pass packets based on
   *      frame counter limits.  These limits are set by:
   *      rhrefframes and rhrefframep for reference scan acquisitions
   *      rhscnframe and repasframe for other entry points (except prescan)
   RHTYP1IMGNEX        512
   bit 9
   RHTYP1SPIRAL        1024
   bit 10 Set if Spiral acquisition matrix
   RHTYP1FVRGF         2048
   bit 11 Set if Fast VRGF recon required
   RHTYP1RCALLPASS     4096
   bit 12 Set to instruct recon to allocate as many passes as possible
   *      in the BAM. BAM is also recycled in this case.
   RHTYP1LINE          8192
   RHTYP1LSDI          8192
   bit 13 Set to indicate Line Scan diffusion
   RHTYPECTRICKS       16384
   bit 14 Set for ECTRICKS reconstruction
   RHTYP1PCORVRGF      32768
   bit 15 Set so recon performs VRGF processing AFTER phase correction
   RHTYP10ROWENDS      65536
   bit 16 Set to zero out the ends of edges of kspace (fine line fix)
   RHTY1PRETRO_PC      131072
   bit 17 Set to do retrospective phase correction (FSE)
   RHTYP1BAM0FILL      262144
   bit 18 Set to zero-fill BAM before start of acquisition
   RHTYP13DGRADWARP    4194304
   bit 22 Set to 3d Gradwarp (0 off, 1 on) 
   ******************************** */
int rhtype1 = 0 





;

/* merged 55 bch into vmx.  YH  10/13/94 */
/* ******************************
   Bit patterns for rhformat
   -----------------------------
 RHF_NO_GRADWARP            1- bit 0 set if no grad warp is desired
 RHF_NO_FERMI               2- bit 1 set if no fermi filtering is desired
 RHF_ZCHOP                  4- bit 2 For 3D, set if RF is chopped Z-encode
 RHF_YCHOP                  8- bit 3 For 3D, set if RF is chopped on Y encode
 RHF_IIC                   16- bit 4 set if IIC (opscic == RHF_ON)
 RHF_CSI                   32- bit 5 set if acquiring spectroscopic data
 RHF_HS                    64- bit 6 set if epi dab packet is used
 RHF_SPECTRO              128- bit 7 set if acquiring non-CSI
                               spectroscopic data (Single voxel)
 RHF_IMAGE_CHECKSUM       256- bit 8 set if using image checksum
 RHF_NOREC_CHECKSUM       512- bit 9 set if using norec checksum
 RHF_GRADWARP_USE_FILE   1024- bit 10 set if using extern gradwarp file
 RHF_USE_FLIPTABLE       2048- bit 11 set if row flip file
                               (/usr/g/bin/rowflip.param) is used
 RHF_CERD_USE_FLIP_SSP   4096- bit 12 set if ??
 RHF_PSIR_CORRECTION     8192- bit 13 set if opphsen is set to 1
 RHF_SINGLE_PHASE_INFO  16384- bit 14 For > 1024 im/ser. Set if
                               data_acq_order table is filled only 
                               for a single phase in a multiphase scan.

   ********************************************* */
int rhformat = 0 





;

int rhptsize = 2 





;

int rhnpomp = 1 





;

/* ******************************
   Bit patterns for rhrcctrl
   ------------------------------
   bit 0 set for magnitude images   ; RHRCMAG  = 1
   bit 1 set for phase images       ; RHRCPHS  = 2
   bit 2 set for I magnitude images ; RHRCIMAG = 4
   bit 3 set for Q magnitude images ; RHRCQMAG = 8
   bit 4 set for compressed images  ; RHRCCOMP = 16
   bit 7 set for raw image recon    ; RHRCRAW  = 128
   changed for 7.0 from 17 to 1..gp
                                      RHRCGRID_ON           = 32
                                      RHRCSKIP_ALL_RECON    = 128
                                      RHRCSKIP_ROW_FFT      = 256
                                      RHRCSKIP_COL_FFT      = 512
                                      RHRCSKIP_HALF_FOURIER = 1024
                                      RHRCSKIP_FERMI        = 2048
                                      RHRCSKIP_NEX_SCALE    = 4096
                                      RHRCSKIP_IMAGE_SCALE  = 8192
                                      RHRCSKIP_3DJOB_FFT    = 16384
   ********************************************* */
int rhrcctrl = 1 





;

/* ******************************
   bit patterns for rhdacqctrl
   ----------------------------
   bit 0	0= NO_REC data, 1=RAW data
   bit 1	Set if even echo phase flip desired.
   bit 2	Set if odd echo phase flip desired.
   bit 3	Set if even echo frequency flip desired.
   bit 4	Set if odd echo frequency flip desired.
   bit 5	Set if RAW collection without DAB SSP packets is desired.
   bit 6	Set if RAW collection should wrap around to the top of the
		buffer if overflow occurs.
   bit 10       set if fcine echotrain data acq. mode is used.
                RH_FCINE_ET = 1024
   bit 11       Set if passthrough data acq. mode is used.; 
                                          RH_PASS_THROUGH_CERD_FLAG = 2048
   ********************************************* */
int rhdacqctrl = 2 





;

/* ******************************
   bit patterns for rhexecctrl
   ------------------------------
RHXC_AUTO_DISPLAY               1- Set if Auto display desired
RHXC_AUTO_LOCK                  2- Set if auto lock of raw/no_rec files desired
RHXC_AUTO_LOCK_ALLRECS          4- Set if auto lock of all recs desired
RHXC_XFER_IM                    8- Set if images should be transferred to disk
RHXC_SAVE_IM                    16- Set if images should be saved in BAM memory
RHXC_TAPE_LOCK                  32- Don't use
RHXC_INTERMEDIATE               64- Set if intermediate multi coil images
                                    are to be saved
RHXC_OVERRIDE_BROADCAST         128
RHXC_OVERRIDE_IMG_INSTALL       256
RHXC_OVERRIDE_AUTODISPLAY       512
RHXC_RTD_XFER_IM_REMOTE         1024
RHXC_RTD_SCAN                   2048
RHXC_REF_SCAN                   4096
RHXC_DONT_WRITE_OR_INSTALL      8192
RHXC_RTD_XFER_ALL_IM_PER_PASS   16384
RHXC_XFER_IMG_RIR               32768

 * ********************************************** */
int rhexecctrl = (RHXC_AUTO_DISPLAY | RHXC_XFER_IM) 





;

/* *********************************
   bit patterns for FEEDER control
   ---------------------------------
   bit 0	0= feed DAB, 1= feed filters.
   bit 1	0= locked, 1= unlocked
   bit 2	0= see bit 1, 1= use algorithm
   bit 3	Set if timing simulation desired
 * ********************************************** */
int rhfdctrl = 0 





;

float rhxoff = 0.0 





;

float rhyoff = 0.0 





;

int rhrecon = 0 





;

int rhdatacq = 0 





;

int rhvquant = 0 





;

int rhslblank = 2 





;

int rhhnover = 0 





;

/* RV: Needed for IDEAL minTE processing */
int rhfeextra = 0 





;

int rhheover = 0 





;

int rhoscans = 0 





;

int rhddaover = 0 





;

float rhzeroph = 128.5 





;

float rhalpha = 0.46 





;

float rhnwin = 0.0 





;

float rhntran = 2.0 





;

int rhherawflt = 0 





;

float rhherawflt_befnwin = 1.0 





;

float rhherawflt_befntran = 2.0 





;

float rhherawflt_befamp = 1.0 





;

float rhherawflt_hpfamp = 1.0 





;

float rhfermw = 10.0 





;

float rhfermr = 128.0 





;

float rhferme = 1.0 





;

float rhclipmin = 0.0 





;

float rhclipmax = 16383.0 





;

float rhdoffset = 0.0 





;

int rhudasave = 0 





;

int rhsspsave = 0 





;

float rh2dscale = 1.0 





;
 
float rh3dscale = 1.0 





;
 
int rhnpasses = 1 





;

int rhincrpass = 1 





;

int rhinitpass = 1 





;

int rhmethod = 0 





;

int rhdaxres = 256 





;

int rhdayres = 256 





;

int rhrcxres = 256 





;

int rhrcyres = 256 





;

int rhimsize = 256 





;

int rhnoncart_dual_traj = 0 





;

int rhnoncart_traj_kmax_ratio = 8 






;

int rhnspokes_lowres = 8192 






;

int rhnspokes_highres = 8192 






;

int rhnoncart_traj_merge_start = 3 






;

int rhnoncart_traj_merge_end = 5 






;

float rhoversamplingfactor = 1.0 





;

float rhnoncart_grid_factor = 2.0 





;

int rhnoncart_traj_mode = RADIAL3D_TRAJECTORY_MODE_MIN 





;

int rhviewSharing3D = 0 





;

int rhdaviewsPerBlade = 24 





;

float rhrotationThreshold = 2.0 





;

float rhshiftThreshold = 0.01 





;

float rhcorrelationThreshold = 0.50 





;

float rhnpwfactor = 1.0 





;





float rhuser0  = 0 ;
float rhuser1  = 0 ;
float rhuser2  = 0 ;
float rhuser3  = 0 ;
float rhuser4  = 0 ;
float rhuser5  = 0 ;
float rhuser6  = 0 ;
float rhuser7  = 0 ;
float rhuser8  = 0 ;
float rhuser9  = 0 ;
float rhuser10 = 0 ;
float rhuser11 = 0 ;
float rhuser12 = 0 ;
float rhuser13 = 0 ;
float rhuser14 = 0 ;
float rhuser15 = 0 ;
float rhuser16 = 0 ;
float rhuser17 = 0 ;
float rhuser18 = 0 ;
float rhuser19 = 0 ;
float rhuser20 = 0 ;
float rhuser21 = 0 ;
float rhuser22 = 0 ;
float rhuser23 = 0 ;
float rhuser24 = 0 ;
float rhuser25 = 0 ;
float rhuser26 = 0 ;
float rhuser27 = 0 ;
float rhuser28 = 0 ;
float rhuser29 = 0 ;
float rhuser30 = 0 ;
float rhuser31 = 0 ;
float rhuser32 = 0 ;
float rhuser33 = 0 ;
float rhuser34 = 0 ;
float rhuser35 = 0 ;
float rhuser36 = 0 ;
float rhuser37 = 0 ;
float rhuser38 = 0 ;
float rhuser39 = 0 ;
float rhuser40 = 0 ;
float rhuser41 = 0 ;
float rhuser42 = 0 ;
float rhuser43 = 0 ;
float rhuser44 = 0 ;
float rhuser45 = 0 ;
float rhuser46 = 0 ;
float rhuser47 = 0 ;
float rhuser48 = 0 ;

int rhdab0s = 0 





;

int rhdab0e = 0 





;

float rhctr = 1.0 





;

float rhcrrtime = 1.0 





;

int rhcphases = 1 





;

int rhaphases = 1 





;

int rhovl = 0 





;

/* **********************************
   Vascular Recon CVs 
   ********************************** */

/* **********************************
   Vascular Recon Types
   1: vascular
   2: phase contrast scan
   4: unused
   8: 2 set processing
   16: anti alias algorithm
   32: phase contrast bit 1
   64: phase contrast bit 2
   128: apply noise suppression mask
   256: display magnitude image
   512: display physical x location
   1024: display physical y location
   2048: display physical z location
   4096: collapse logical z
   8192: collapse logical x
   16384: collapse logical y
   32768: vinnie 1 slice, 2 set
   65536: vinnie 1 slice, 4 set
   131072: vinnie 2 slice, 2 set
   ****************************************** */
int rhvtype = 0 





;

float rhvenc = 0.0 





;

float rhvcoefxa = 0.0 





;

float rhvcoefxb = 0.0 





;

float rhvcoefxc = 0.0 





;

float rhvcoefxd = 0.0 





;

float rhvcoefya = 0.0 





;

float rhvcoefyb = 0.0 





;

float rhvcoefyc = 0.0 





;

float rhvcoefyd = 0.0 





;

float rhvcoefza = 0.0 





;

float rhvcoefzb = 0.0 





;

float rhvcoefzc = 0.0 





;

float rhvcoefzd = 0.0 





;

/* The following are flow to static translation for phase contrast 
   scans if the phase correction bits are set or noise suppression or display
   magnitude bits are set. */

float rhvmcoef1 = 0.0 





;

float rhvmcoef2 = 0.0 





;

float rhvmcoef3 = 0.0 





;

float rhvmcoef4 = 0.0 





;

/* *********************
   Asymmetric FOV cvs
   ********************* */
float rhphasescale = 1.0 





;

float rhfreqscale = 1.0 





;

/* Raw image recon */
int rawmode = 0 





;
						   
/* ****************************
   Reference Scan/EPI recon cvs
   **************************** */

int rhileaves = 1 





;

int rhkydir = 0 





;

int rhalt = 0 





;

int rhreps = 1 





;

int rhref = 1 





;

/****************************************/
/* EPI Phase Correction recon header CVs */
/****************************************/

int rhpcthrespts = 2 





;

int rhpcthrespct = 15 





;

int rhpcdiscbeg = 0 





;

int rhpcdiscmid = 0 





;

int rhpcdiscend = 0 





;

int rhpcileave = 0 





;

int rhpcextcorr = 0 





;

int rhrefframes = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcsnore = 0 





;
                                     
int rhpcspacial = 0 





;

int rhpctemporal = 0 





;

float rhpcbestky = 64.0 





;

int rhhdbestky = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpcinvft = 0 





;

int rhpcctrl = 0 





;

/* to avoid compiling error on IFCC   3/17/95 YI */
int rhpctest = 0 





;

int rhpcgraph = 0 





;

int rhpclin = 0 





;

int rhpclinnorm = 0 





;

int rhpclinnpts = 0 





;

int rhpclinorder = 2 





;

int rhpclinfitwt = 0 





;

int rhpclinavg = 0 





;

int rhpccon = 0 





;

int rhpcconnorm = 0 





;

int rhpcconnpts = 2 





;

int rhpcconorder = 2 





;

int rhpcconfitwt = 0 





;

/****************************************/
/* VRGF recon header CVs */
/****************************************/
 
int rhvrgfxres = 128 





;

int rhvrgf = 0 





;

/****************************************/
/* Bandpass correction recon header CVs */
/****************************************/
 
int rhbp_corr = 0 





;

float rhrecv_freq_s = 0.0 





;

float rhrecv_freq_e = 0.0 





;

int rhhniter = 0 





;

int rhfast_rec = 0 





;


/*************************************/
/* Spiral gridding recon related CVs */
/*************************************/
int rhgridcontrol = 0 





;

int rhb0map = 0 





;

int rhtediff = 0 





;

float rhradiusa = 0 





;

float rhradiusb = 0 





;

float rhmaxgrad = 0.0 





;

float rhslewmax = 0.0 





;

float rhscanfov = 0.0 





;

float rhtsamp = 0.0 





;

float rhdensityfactor = 0.0 





;

float rhdispfov = 0.0 





;

int rhmotioncomp = 0 





;

int grid_fov_factor = 2 





;

/***************************************/
/* Dynamic Frequency Monitor Recon CVs */
/***************************************/

int rhte = 25000 





;

int rhte2 = 50000 





;

int rhdfm = 0 





;

int rhdfmnavsperpass = 1 





; 

int rhdfmnavsperview = 1 





;

float rhdfmrbw = 4.0 





;

int rhdfmptsize = 2 





;

int rhdfmxres = 32 





;

int rhdfmdebug = 0 





;

float rhdfmthreshold = 0.0 





;

/* Following CVs are Added for Image Enhance */
int rh_rc_enhance_enable = 0 





;

int rh_ime_scic_enable = 0 





;

float rh_ime_scic_edge = 0.0 





;

float rh_ime_scic_smooth = 0.0 





;

float rh_ime_scic_focus = 0.0 





;

int rh_ime_clariview_type = 0 





;

float rh_ime_clariview_edge = 0.0 





;

float rh_ime_clariview_smooth = 0.0 





;

float rh_ime_clariview_focus = 0.0 





;

int rh_ime_definefilter_nr = 0 





;

int rh_ime_definefilter_sh = 0 





;

float rh_ime_scic_reduction = 0.0 





;

float rh_ime_scic_gauss = 0.0 





;	

float rh_ime_scic_threshold = 0.0 





;

float rh_ime_scic_contrast = 0.0 





;

int cfscic_allowed = 1 





;

float cfscic_edge = 0.0 





;

float cfscic_smooth = 0.0 





;

float cfscic_focus = 0.0 





;

float cfscic_reduction = 0.0 





;

float cfscic_gauss = 0.0 





;	

float cfscic_threshold = 0.0 





;

float cfscic_contrast = 0.0 





;

int piscic = 0 





;

/* CVs for SCENIC filter */
int cfscenic = 0 





;

int piscenic = 0 





;

int opscenic = 0 





;

int rhscenic_type = 0 





;

/* cf CVs for ITK N4 */
int cfn4_allowed = 1 





;

float cfn4_slice_down_sample_rate = 1.0 





;

float cfn4_inplane_down_sample_rate = 0.15 





;

int cfn4_num_levels_max = 4 





;

int cfn4_num_iterations_max = 50 





;

float cfn4_convergence_threshold = 0.001 





;

int cfn4_gain_clamp_mode = 0 





;

float cfn4_gain_clamp_value = 5.0 





;

/* rh CVs for ITK N4 */
float rhn4_slice_down_sample_rate = 1.0 





;

float rhn4_inplane_down_sample_rate = 0.15 





;

int rhn4_num_levels_max = 4 





;

int rhn4_num_iterations_max = 50 





;

float rhn4_convergence_threshold = 0.002 





;

int rhn4_gain_clamp_mode = 0 





;

float rhn4_gain_clamp_value = 5.0 





;

/* rh CVs for PURE gain clamp*/
int rhpure_gain_clamp_mode = 0 





;

float rhpure_gain_clamp_value = 5.0 





;

/* For PSMDE feature */
int rhphsen_pixel_offset = 0 





;

/* For SCIC++ Feature */

int rhapp = 0 






;

int rhapp_option = 0 






;

/* For N-coil selection routines in recon */

int rhncoilsel = 0 






;

int rhncoillimit = 45 






;

int rhrefframep = 0 






;

int rhscnframe = 0 






;

int rhpasframe = 0 






;

int rhpcfitorig = 1 






;

int rhpcshotfirst = 0 






;

int rhpcshotlast = 0 






;

int rhpcmultegrp = 0 






;

int rhpclinfix = 1 






;

float rhpclinslope = 0.0 






;

int rhpcconfix = 1 






;

float rhpcconslope = 0.0 






;

int rhpccoil = 1 






;

float rhmaxcoef1a = 0 






;

float rhmaxcoef1b = 0 






;

float rhmaxcoef1c = 0 






;

float rhmaxcoef1d = 0 






;

float rhmaxcoef2a = 0 






;

float rhmaxcoef2b = 0 






;

float rhmaxcoef2c = 0 






;

float rhmaxcoef2d = 0 






;

float rhmaxcoef3a = 0 






;

float rhmaxcoef3b = 0 






;

float rhmaxcoef3c = 0 






;

float rhmaxcoef3d = 0 






;

int rhdptype = 0 






;

int rhnumbvals = 1 





;

int rhdifnext2 = 1 





;

int rhnumdifdirs = 1 





;

int rhutctrl = 0 






;

float rhzipfact = 0 






;

int rhfcinemode = 0 






;

int rhfcinearw = 10 






;

int rhvps = 8 






;

int rhvvsaimgs = 1 






;

int rhvvstr = 0 






;

int rhvvsgender = 0 






;

/* to get opgradmode value into the raw header */
int rhgradmode = 0;

int rhfatwater = 0 






;

int rhfiesta = 0 






;

int rhlcfiesta = 0 






;

float rhlcfiesta_phase = 0.0 






;

/* *************************************************
   Recon Header CVs for Navigator Echo Correction on DW-EPI
   ************************************************ */
int rhdwnavview = 0 






;

int rhdwnavcorecho = 2 






;

int rhdwnavsview = 1 






;

int rhdwnaveview = 1 






;

int rhdwnavsshot = 1 






;

int rhdwnaveshot = 2 






;

float rhdwnavcoeff = 0.5 






;

/* ********************************
   Bit patterns for rhtype 
   ------------------------------
   bit 0  Set if navigator echo correction is on
   bit 1  Set if phase shifted navigator echo correction is on
   ****************************** */
int rhdwnavcor = 0 






;

/* Added new CVs for Slice ASSET */ 
float rhassetsl_R = 1.0 






;

float rhasset_slwrap = 0.0 






;

/* Added new CVs for FIESTA - C */

int rh3dwintype = 0 






;

float rh3dwina = 0.1 






;

float rh3dwinq = 0.0 






;

/* Recon Header CV's for TRICKS recon */
int rhectricks_num_regions = 0;

int rhectricks_input_regions = 0;

/* ************************************************* */
/* HFO3 merge 02/18/2003 YI */
/* FSE retrospective phase correction - RDP
   Bit patterns for rhretro_control
   ---------------------------------
   bit 0 set for Ahn/Cho fitting method
   bit 1 set for Least Squares fitting method
   bit 2 set for zeroth-order coefficient correction
   bit 3 set for first-order coefficient correction
   bit 4 set for one extra etl reference set
   bit 5 set for second extra etl reference set
   ***************************************************** */
int rhretro_control = 0 






;

int rhetl = 0 






;

/* RDP - rh CVs for fine line correction */
int rhleft_blank = 0 






;

int rhright_blank = 0 






;


/* Standardize spectroscopy recon header variables */

float rhspecwidth = 0.0 






;

int rhspeccsidims = 0 






;

int rhspecrescsix = 0 






;

int rhspecrescsiy = 0 






;

int rhspecrescsiz = 0 






;

float rhspecroilenx = 0.0 






;

float rhspecroileny = 0.0 






;

float rhspecroilenz = 0.0 






;

float rhspecroilocx = 0.0 






;

float rhspecroilocy = 0.0 






;

float rhspecroilocz = 0.0 






;

int rhexciterusage = 1 






;

int rhexciterfreqs = 1 






;

/* rh values for MART deblurring (NDG) */
int rhwiener = 0 





;

float rhwienera = 0.0 





;

float rhwienerb = 0.0 





;

float rhwienert2 = 0.0 





;

float rhwieneresp = 0.0 





;

int rhflipfilter = 0 





;

int rhdbgrecon = 0 





;

int rhech2skip = 0 





;

/* Recon header CVs for IDEAL processing */
/*----------------------------------------------------------------*/
/* Bit pattern for rhrcideal
bit 0 used for turning on/off IDEAL processing
bit 1 used for turning on/off IDEAL half-nex processing
bit 2 used for turning on/off IDEAL half-echo processing
bit 3 is on to indicate reversal of echo2 and echo3 order to recon
bit 4 is on to indicate that minTE is Rx'ed; this prompts recon to
center the echo in the readout direction during zero-filled recon
bit 5 used for turning on/off T2* correction
bit 6 used for turning on/off multi peak processing
bit 7 used for turning on/off magnitude based fitting
----------------------------------------------------------------*/
int rhrcideal = 0 






;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcdixproc
bit 0 is ON by default, indicating water image to be reconstructed
bit 1 used for indicating fat image to be reconstructed
bit 2 used for indicating in-phase image to be reconstructed
bit 3 used for indicating out-of-phase image to be reconstructed
bit 4 used for indicating field map image to be reconstructed
bit 5 used for indicating the original images to be reconstructed
bit 6 used for indicating fat fraction image to be reconstructed
bit 7 used for indicating R2* Map to be reconstructed
bit 8 used for indicating water fraction image to be reconstructed
bit 9 used for indicating water image before correction to be reconstructed
bit 10 used for indicating fat image before correction to be reconstructed
bit 11 used for indicating in-phase image before correction to be reconstructed
bit 12 used for indicating out-of-phase image before correction to be reconstructed
bit 13 used for indicating field map image before correction to be reconstructed
bit 14 used for indicating fat fraction image before correction to be reconstructed
bit 15 used for indicating water fraction image before correction to be reconstructed
bit 16 used for indicating the coil combined complex images to be reconstructed
----------------------------------------------------------------*/
int rhrcdixproc = 0 







;

/*----------------------------------------------------------------*/
/* Bit pattern for rhrcidealctrl
bit 0 used for dumping the raw data that is going to be used by IDEAL
bit 1 used for loading the raw data that is going to be used by IDEAL
bit 2 used for controlling IDEAL output before post-checker
bit 3 used for controlling IDEAL output after post-checker
bit 4 used for controlling the gradwarp operation that will be performed on each image before we perform the receiver combined
This operation is expensive but takes us closer the host recon implementation
bit 5 used for storing the data in shorts that will be used by IDEAL. This saves BAM as data is in BAM 
bit 6 used for performing IDEAL processing on receiver-combined images
bit 7 used for peforming clipping operation on the images that will be used by IDEAL
bit 8 used for performing gradwarp after receiver combine operation
bit 9 used for calling a function that does a chopper operation and a scaling  
bit 10 used for turning on/off post processing
bit 11 used for disabling chemical shift
bit 12 used for debugging image numbering
bit 13 used for disabling new finding CF
bit 14 used to reverse frequency axis direction
bit 15 used to reverse phase axis direction
bit 16 used to reverse homodyne
bit 17 used to reverse frequency direction
bit 18 used for generic debug
bit 19 used to choose type of multi-peak processing. 0:pre cal 1:self cal
----------------------------------------------------------------*/
int rhrcidealctrl = 0 







;

int rhdf = FATWATER_DIXFREQ_1_5T 





;

int rhmedal_mode = 0 






;

int rhmedal_nstack_size = 54 






;

int rhmedal_echo_order = 0 






;

int rhmedal_up_kernel_size = 15 






;

int rhmedal_down_kernel_size = 8 






;

int rhmedal_smooth_kernel_size = 8 






;

int rhmedal_starting_slice = 0 






;

int rhmedal_ending_slice = 10 






;

float rhmedal_param = 3.0 






;

int rhvibrant = 0 






;

int rhkacq_uid = 0 






;

/* NEX for unacquired encodes for when zero-fill BAM is enabled */
int rhnex_unacquired = 1 





;

/* Acquisition to Disk Control Bitmask
   Bit 0 (=1) is used to enable/disable acquisition to disk feature
   Bit 1 (=2) is used to capture raw frame and control data to disk
*/
int rhdiskacqctrl = 0 






;

/* IDEAL IQ Phase Correction Recon Header CV */
int rhechopc_extra_bot = 0 






;

int rhechopc_ylines = 0 






;

int rhechopc_primary_yfirst = 0 






;

int rhechopc_reverse_yfirst = 0 






;

int rhechopc_zlines = 0 






;

int rhechopc_yxfitorder = 1 






;

int rhechopc_ctrl = 0 






;

int rhchannel_combine_filter_type = RHCHANNEL_COMBINE_FILTER_TYPE_NONE 






;

float rhchannel_combine_filter_width = 0.3 






;

float rhchannel_combine_filter_beta = 2 






;

float rh_low_pass_nex_filter_width = 8.0 





;

int rh3dgw_interptype = 0 






;

/* 3dcine recon control bitmap */
int rhrc3dcinectrl = 0 






;

/* recon cv for total num of cardiac cycles in 3dcine */
int rhncycles_cine = 0 






;

/* recon cv for virtual coil channels with coil compression */
int rhnvircchannel = 0 






;

/* ********************************
   Bit patterns for rhrc_cardt1map_ctrl 
   ------------------------------
   bit 0  Set if T1 mapping recon mode is on
   bit 1  Set on = IR Prep (2), off = SR Prep (0)
   bit 2  Set on = TI must be updated in recon, off = skip update in recon,
          after recon, on = successful update, off = failed update
   ****************************** */
int rhrc_cardt1map_ctrl  = 0 






;

/* ********************************
   Bit patterns for rhrc_moco_ctrl
   ------------------------------
   bit 0  Set on = recon must apply motion correction, off = no MoCo      
          after recon, on = successful motion correction. off = failed MoCo
   ****************************** */
int rhrc_moco_ctrl  = 0 






;


/* ********************************
   Bit patterns for rhrc_algorithm_ctrl
   ------------------------------
   bit 0  Asset Custom Tuning 	Set on = 1 , off = 0      
   ****************************** */
int rhrc_algorithm_ctrl  = 0 






;

/* ******************
   Image header CVs
   ****************** */
int ihtr = TR_MIN 





;

int ihti = 0 





;

int ihtdel1 = MIN_TDEL1 





;

float ihnex = 1 





;

float ihflip = 90 





;

int ihte1 = 0 





;

int ihte2 = 0 





;

int ihte3 = 0 





;

int ihte4 = 0 





;

int ihte5 = 0 





;

int ihte6 = 0 





;

int ihte7 = 0 





;

int ihte8 = 0 





;

int ihte9 = 0 





;

int ihte10 = 0 





;

int ihte11 = 0 





;

int ihte12 = 0 





;

int ihte13 = 0 





;

int ihte14 = 0 





;

int ihte15 = 0 





;

int ihte16 = 0 





;

int ihdixonte = 0 





;

int ihdixonipte = 0 





;


int ihdixonoopte = 0 





;

float ihvbw1 = 16.0 





;

float ihvbw2 = 16.0 





;

float ihvbw3 = 16.0 





;

float ihvbw4 = 16.0 





;

float ihvbw5 = 16.0 





;

float ihvbw6 = 16.0 





;

float ihvbw7 = 16.0 





;

float ihvbw8 = 16.0 





;

float ihvbw9 = 16.0 





;

float ihvbw10 = 16.0 





;

float ihvbw11 = 16.0 





;

float ihvbw12 = 16.0 





;

float ihvbw13 = 16.0 





;

float ihvbw14 = 16.0 





;

float ihvbw15 = 16.0 





;

float ihvbw16 = 16.0 





;

int ihnegscanspacing = 0 






;

int ihoffsetfreq = 1200 






;

int ihbsoffsetfreq = 4000 






;

int iheesp = 0 






;

int ihfcineim = 0 






;

int ihfcinent = 0 






;

int ihbspti = TI_MIN 






;

float ihtagfa = 180.0 






;

float ihtagor = 45.0 






;

/* RV: IDEAL debug ihCV's */
float ih_idealdbg_cv1 = 0 ;
float ih_idealdbg_cv2 = 0 ;
float ih_idealdbg_cv3 = 0 ;
float ih_idealdbg_cv4 = 0 ;
float ih_idealdbg_cv5 = 0 ;
float ih_idealdbg_cv6 = 0 ;
float ih_idealdbg_cv7 = 0 ;
float ih_idealdbg_cv8 = 0 ;
float ih_idealdbg_cv9 = 0 ;
float ih_idealdbg_cv10 = 0 ;
float ih_idealdbg_cv11 = 0 ;
float ih_idealdbg_cv12 = 0 ;
float ih_idealdbg_cv13 = 0 ;
float ih_idealdbg_cv14 = 0 ;
float ih_idealdbg_cv15 = 0 ;
float ih_idealdbg_cv16 = 0 ;
float ih_idealdbg_cv17 = 0 ;
float ih_idealdbg_cv18 = 0 ;
float ih_idealdbg_cv19 = 0 ;
float ih_idealdbg_cv20 = 0 ;
float ih_idealdbg_cv21 = 0 ;
float ih_idealdbg_cv22 = 0 ;
float ih_idealdbg_cv23 = 0 ;
float ih_idealdbg_cv24 = 0 ;
float ih_idealdbg_cv25 = 0 ;
float ih_idealdbg_cv26 = 0 ;
float ih_idealdbg_cv27 = 0 ;
float ih_idealdbg_cv28 = 0 ;
float ih_idealdbg_cv29 = 0 ;
float ih_idealdbg_cv30 = 0 ;
float ih_idealdbg_cv31 = 0 ;
float ih_idealdbg_cv32 = 0 ;

/* 3dASL CVs for dicom header  */
int ihlabeltime = 0 






;

int ihpostlabeldelay = 0 






;

int ihnew_series = 0 






;

/* Heartbeat pattern for cardiac T1 mapping */
int ihcardt1map_hb_pattern = 0 






;

/* added for Multiple dB/dt Operation Modes - March 25, 2001 */

int dbdt_option_key_status = 0 






;

int dbdt_mode = 0 






;

int opsarmode = 0 






;

int cfdbdttype = 0 






;

float cfrinf = 23.4 






;

int cfrfact = 334 






;

float cfdbdtper_norm = 80.0 






;

float cfdbdtper_cont = 100.0 






;

float cfdbdtper_max = 200.0 






;


/* AKR Recon Lag Model input Parameters */

int cfnumicn = 1 






;  

int cfdppericn = 4 






;

/* ***********************
   System configuration CVs
   *********************** */

int cfgradcoil = 2;  /* Indicate gradient coil type : 1:CRD 2:Roemer
                        101:HGC 102:Vectra 103:Permanent */

/* dynamic Gradient Digitization Period CVs */
int cfswgut    = 4;
int cfswrfut   = 2;
int cfswssput  = 1;
                             
int cfhwgut    = 4;
int cfhwrfut   = 2;
int cfhwssput  = 1;

int cfoption = SEC_CODE_INIT 






;


/******************** 03/06/2003 YI  for DCERD support
 * RF Board Type
 *  0 : Remote RF
 *  1 : DCERD
 *******************/
int cfrfboardtype = RF_BOARD_RRF 






;

/* psd_board_type is the set of SSP commands to use for the current
 * hardware architecture.  For hardware introduced for DVMR, use
 * PSDDVMR.  For hardware introduced for 10.0-14.0, use PSDCERD */
int psd_board_type = PSDDVMR 






;

/* ********************************
   Dynamic Frequency Monitoring CVs
   ******************************** */
int opdfm         = 0 






;

int opdfmprescan  = 0 






;

int  cfdfm   =  0  






;

int  cfdfmTG = 70  






;

int  cfdfmR1 = 13  






;

int  cfdfmDX = 0   






;

/* For ACGD Compensation Feature */
int derate_ACGD = 0 






;

/* rh cvs for EPI internal ref scan */ 
int rhextra_frames_top = 0 






;

int rhextra_frames_bot = 0 






;

int rhpc_ref_start = 0 






;
int rhpc_ref_stop = 0 






;

int rhpc_ref_skip = 0 






;

int opaxial_slice=0 






;

int opsagittal_slice =0 






;

int opcoronal_slice=0 






;

int opvrg = 0 






;

int opmart = 0 






;

int piassetscrn = 0 






;

/*For multistation no. of station */
int opseriessave = 0 






;

/* T1Map CV */
int opt1map = 0 






;

/* T2Map CV */
int opt2map = 0 






;

/* R2* CV */
int opmer2 = 0 






;

/* New RH CVs for New WW/WL algorithm used by RECON */
int rhnew_wnd_level_flag = 1 






;

int rhwnd_image_hist_area = 60 






;

float rhwnd_high_hist = 1.0 






;

float rhwnd_lower_hist = 1.0 






;

/*DLH, New RH variables for MAVRIC-SL*/
int rhrcmavric_control = 0 






;
/*Definitions of rhrcmavric_control(Debugging and Research):
 *rhrcmavric_control bit 0: MAVRIC Recon ON/OFF
 *rhrcmavric_control bit 1: MAVRIC Recon with De-Blurring Algorithm
 *rhrcmavric_control bit 2: MAVRIC Recon with Jocobian Algorithm
 */
int rhrcmavric_image = 0 






;
/*Definitions of rhrcmavric_image(Debugging and Research):
 * rhrcmavric_image bit 0:    Echo Images (Bin Images)
 * rhrcmavric_image bit 1:    SOS Corrected Images (Default)
 * rhrcmavric_image bit 2:    Initial SOS Images
 * rhrcmavric_image bit 3:    FieldMap Image
 * rhrcmavric_image bit 4:    Threshold FieldMap Image
 * rhrcmavric_image bit 5:    FieldMap Blurred Image
 * rhrcmavric_image bit 6:    Gradient Ratio Image
 * rhrcmavric_image bit 7:    Blurred Gradient Ratio Image
 * rhrcmavric_image bit 8:    Capped & Normalized Blurred Gradient Map
 * */
int rhrcmavric_bin_separation = 1000 






;

/* New RF related Definitions.*/
int cfrfupa = -50 






;

int cfrfupd = 50 






;

int cfrfminblank = 200 






;

int cfrfminunblk = 200 






;

int cfrfminblanktorcv = 50 






;

float cfrfampftconst = 0.784 






;

float cfrfampftlinear = 0.0 






;

float cfrfampftquadratic = 15.125 






;

int opradialrx = 0 





;

int cfsupportreceivefreqbands = 0 






;

float cfcntfreefreqlow = 0.0 






;

float cfcntfreefreqhigh = 10000.0 






; 


int optracq = 0 






;

/* Additions for SWIFT */
int opswift = 0 






;

int rhswiftenable = 0 





;

int rhnumCoilConfigs = 0 





;

int rhnumslabs = 1 





;

/* The number of coil configurations in coilInfo and volRecCoilInfo */
int opncoils = 1 





;

/* New cvs for RT SAR Feature Move to @reqcv from @reqexport */
/* New cvs for RT SAR Feature */

int rtsar_first_series_flag = 0 





;

int rtsar_enable_flag = 0 





;

int measured_TG = -1 





;

int predicted_TG = -1 





;

float sar_correction_factor = 1.0 





;

int gradHeatMethod = PSD_OFF 






;

int gradHeatFile = PSD_OFF 






;

int gradCoilMethod = GRADIENT_COIL_METHOD_AUTO  






;

int gradHeatFlag = PSD_OFF 






;

int xgd_optimization = PSD_ON 






;

int gradChokeFlag = PSD_OFF 






;

/* Burst Mode */
int piburstmode = PSD_OFF 






;

int opburstmode = PSD_OFF 






;

int burstreps = 1 






;

float piburstcooltime = 0.0 






;

/* Parallel Imaging UI */
float opaccel_ph_stride = 1.0 






;

float opaccel_sl_stride = 1.0 






;

float opaccel_t_stride = 1.0 






;

int opaccel_mb_stride = 2 






;

/* Multiband on/off flag */
int opmb = PSD_OFF 






;

/* recon cv for Multiband slice acceleration factor */
int rhmb_factor = 1 






;


/* recon cv for Multiband blipped Slice FOV shift */
int rhmb_slice_fov_shift_factor = 1 






; 

/* recon cv for Multiband Slice Order Sign */
int rhmb_slice_order_sign = 1 






; 

/* recon cv for Muse */
int rhmuse = 0 






; 

/* recon cv for Muse with phase mapping second echo */
int rhmuse_nav = PSD_OFF 






; 

/* recon cv for Muse with phase acceleration */
int rhmuse_nav_accel = 1 






; 

/* recon cv for Muse number of overscans for phase mapping readout */
int rhmuse_nav_hnover = 16 






; 

/* recon cv for Muse phase mapping readout yres */
int rhmuse_nav_yres = 96 






; 

float opaccel_cs_stride = 1.0 






;

/* Compressed Sensing on/off flag */
int opcompressedsensing = PSD_OFF 






;

/* recon cv for Compressed Sensing acceleration factor */
float rhcs_factor = 1.0 






;

/* recon cv for Compressed Sensing flag */
int rhcs_flag = 0 






; 

/* recon cv for Compressed Sensing max iteration */
int rhcs_maxiter = 3 






;

/* recon cv for Compressed Sensing consistency flag */
float rhcs_consistency = 0 






; 

/* recon cv for ARC acceleration along phase */
int rhcs_ph_stride = 1 






; 

/* recon cv for ARC acceleration along slice */
int rhcs_sl_stride = 1 






; 

int oparc = PSD_OFF 






;

int opaccel_kt_stride = 8 






;

int rhkt_factor = 1 






;

/* recon cv for kt calibration acceleration factor */
int rhkt_cal_factor = 1 






;

/* recon cv for kt calibration size in ph */
int rhkt_calwidth_ph = 0 






;

/* recon cv for kt calibration size in sl */
int rhkt_calwidth_sl = 0 






;

/* Maximal RF Imaging Option
 * PSD_ON:  MRF imaging option is selected
 * PSD_OFF: MRF imaging option is not selected
 */
int opab1 = PSD_OFF 






;

int op3dgradwarp = 0 






;

int opauto3dgradwarp = 1 






;

int cfmaxtransmitoffsetfreq = 650000 






;

/* -250000 Hz for HD, 0 for DV */
int cfreceiveroffsetfreq = 0 






;

/* See COIL_SWITCH defines for bit definitions */
int cfcoilswitchmethod = COIL_SWITCH_SSP_HUB_INDEX 






;
/* TG_record store the appropriate TG value for adaptive B1 Max calculation */
int TG_record = 0 





;
/* ab1_enable is a control flag that is set by host and has three status:
 * 0 - adaptive B1max calculation is turned off and conventional B1max calculation is used
 * 1 - adaptive B1max is truned on
 * 2 - adaptive B1max calculation is turned off and previously calculated B1max is used
 */
int ab1_enable = 0 





;

int cfreceivertype = CFG_VAL_RECEIVER_RRX   






;

int cfreceiverswitchtype = CFG_VAL_RCV_SWITCH_RF_HUB 






;

int cfEllipticDriveEnable = 0 






;

int pi3dgradwarpnub = 1 






;

int cfDualDriveCapable = 0 






;

/* TRIP addition */
int optrip = 0 






;

/* RTB0 correction flag */
int oprtb0 = 0 






;

int pirtb0vis = 0 






;

int pirtb0nub = 0 






;


/* HOEC correction flag */
int ophoecc = 0 






;

/* recon cv for HOEC correction */
int rhhoecc = 0 






;

/* recon cv for fit order of HOEC */
int rhhoec_fit_order = 3 






;

/* EPI Distortion Correction flag */
int opdistcorr = 0 






;

/* EPI Distortion Correction UI control
   0: Hide, 1: Visible, grey-out, 2: Visible, active */
int pidistcorrnub = 0 






;

/* EPI Distortion Correction UI default value
   when not stored in protocol */
int pidistcorrdefval = 0 






;

/* EPI Distortion Correction Recon Control CV */
int rhdistcorr_ctrl = 0 






;

/* EPI Distortion Correction Recon kernel size. Unused in recon per DOC1872962 */
int rhdistcorr_B0_filter_size = 5 






;

/* EPI Distortion Correction Recon std dev. Unused in recon per DOC1872962 */
float rhdistcorr_B0_filter_std_dev = 1.5 






;

/* EPI Distortion Correction Image Header CV 
   Reflects rhdistcorr_ctrl */
int ihdistcorr = 0 






;

/* EPI Custom Diffusion Directions Tensor File number */
int rhtensor_file_number = 0 






;

/* Phase Encoding Polarity Image Header CV */
int ihpepolar = 0 






;

/* recon cv for echo spacing */
int rhesp = 500 






;

/*dual echo FSE view sharing copied k space lines number*/
int viewshd_num = 0 






;

/* The below variables are used for eC3 reconstruction for spine scan to reduce annefact. */
float grad_intensity_thres = 3.0 






;

int anne_mask_dilation_length = 2 






;

float anne_intensity_thres = 0.0 






;

float anne_channel_percentage = 0.4 






;

int ec3_iterations = 1 






;

float combined_coil_map_thres = 0.15 






;

float coil_map_smooth_factor = 0.02 






;

float coil_map_2_filter_width = 0.02 






;

int ec3_iteration_method = 0 






;

/* The CV will be used by epi application for controlling EDR on or off */
int edr_support = PSD_OFF 






;

float recon_bandwidth_factor = 1.0 






;

/* The CV will be set to different datatype (0: unknown, 1: short, 2: int, 3: float, 4: double) by Host based on system configuration,
 *  * then transfer to PSD. The default value will be 0 due to PSD not know about system configuration. PSD use the CV to get the system configuration */
int dacq_data_type = 0 






;

int rawmode_scaling = 0 






;

float rawmode_scaling_factor = 1.0 






;

/* RG calibration mode */
int oprgcalmode = RG_CAL_MODE_MEASURED 






;

/* number of MSMA groups */
int opnumgroups = 0 






;

/* System selection for allowing SAR burst mode */
int opsarburst = 0 






;

int opheadscout = PSD_OFF 






;

int rhposition_detection = PSD_OFF 






;

/* Focused Ultrasound */
int opfus = 0 






;

int opexamnum = 0 






;

int opseriesnum = 0 






;


/* Scan volume shift flag */
int vol_shift_type = 0 






;

int vol_shift_constraint_type = 0 






;

/* Scan volume scaling flag for image cut redution */
int vol_scale_type = 0 






;

int vol_scale_constraint_type = 0 






;

/* recon CVs for Channel Compression and Optimal Recon */
int rhsnrnoise = 0 






;

int rhvircpolicy = 0 






;

int rhvirsenstype = 1 






;

int rhvircoiltype = 1 






;

int rhvircoilunif = 0 






;

int rhvircoilchannels = 1 






;

int cffield = B0_15000 






;

float act_field_strength = 30000.0 






;

int enableReceiveFreqBands = 0 






;

int offsetReceiveFreqLower = 0 






;

int offsetReceiveFreqHigher = 0 






;

int cfrfamptyp = 0 






;

int cfssctype = 0 






;

int cfptxcapable = 0 






;

/* 750w body coil cable TG limit */
int cfbdcabletglimit = 1 






;

/* delta frequency for body coil cable mode, kHz */
int cfcablefreq = 226 






;

/* TG limit at cable resonance freq */
int cfcabletg = 175 






;

/* 3dB bw for body coil cable mode, kHz */
int cfcablebw = 500 






; 

int opgradshim = 2 






;

int track_flag = 0 






;



int prevent_scan_under_emul = 0 






;

/* MRIhc18338 */
int acqs = 1 






;

int avround = 1 






;

int baseline = 0 






;

/* CV nex has value 1 for .5 nex and .75 nex scans */
int nex = 1 






;

float trunex = 1.0 






;

int isOddNexGreaterThanOne = 0 






;

int isNonIntNexGreaterThanOne = 0 






;

/* ***************
 * fn 1 full kspace
 *    .5 half nex
 *    .75 3/4 nex 
 **************** */
float fn = 1.0 






;

int enablfracdec = 1 






;

int npw_flag = 0 






;

float nop = 1.0 






;

int acq_type = TYPSPIN 






;

int seq_type = TYPNCAT 






;

int num_images = 1 






;

/* Image Type CVs */
int recon_mag_image = 1 






;

int recon_pha_image = 0 






;

int recon_imag_image = 0 






;

int recon_qmag_image = 0 






;


int slquant1 = 1 






;

int psd_grd_wait = 56 






;

int psd_rf_wait = 0 






;

/* pos_moment_start holds the time in us from the start of the sequence
   to the middle of the alpha pulse.  This is used to automate flow
   compensation and zeroth moment graphing tests.   */
int pos_moment_start = 0 






;

/* mps1rf1_inst and scanrf1_inst are used to hold the index into
   the rf1 instruction for scan and mps1. This allows the code
   for MPS1Prescan to simply copy the rf1 waveform used in scan.
   Thus, MPS1 is simplified for non-typical rf pulses  */

int mps1rf1_inst = 0 






;

int scanrf1_inst = 0 






;

/* cfcarddelay holds the delay of the cardiac hardware  */
int cfcarddelay = 10 






;


int psd_card_hdwr_delay = 0 






;

/*Default to proton at 4257.59 */
float GAM = GAMMA_PROTON 






;

int off90 = 80 






;

int TR_SLOP = 2000 






;

int TR_PASS = 50000 






;

int TR_PASS3D = 550000 






;

int csweight= 100 






;

/* Nex can not be accumulated with exorcist running.  exnex
 * calculates the number of frames/view that must be stored in BAM */
int exnex = 1 






;

float truenex = 0.0 






;

int eg_phaseres = 128 






;

int sp_satcard_loc = 0 






;

int min_rfdycc = 0; /* minimum seq time based on duty cycle (us) */

int min_rfavgpow = 0; /* minimum seq time based on avg. power (us) */

int min_rfrmsb1 = 0; /* minimum seq time based on rms B1 limitation (us). */

int coll_prefls = 1 






;

/* following parameters are new for 55.  YH  10/14/94 */
int maxGradRes = 1 






;

float dfg = 2 






;

float pg_beta = 1.0 






;
     
int split_dab = 0 






;
 
float freq_scale = 1.0 






;

int numrecv = 1 






;
 
/* for phase encoding */
int pe_on = 1 






;
 
float psd_targetscale = 1.0; /* %fullscale for amps-set in obloptimize */
 
float psd_zero = 0.0 






;

/* gram pulse modulation width time per logical axis */
int lx_pwmtime = 0; 
int ly_pwmtime = 0;
int lz_pwmtime = 0;

/* gram pulse modulation width time per physical axis  */
int px_pwmtime = 0; 
int py_pwmtime = 0;
int pz_pwmtime = 0;

int min_seqgrad = 0;  /* minimum sequence time based on Gradient subsystem */
int min_seqrfamp = 0; /* minimum sequence time based on RF amplifier */

/* per axis loading in units of A^2*uSec */
float xa2s = 0;
float ya2s = 0;
float za2s = 0;

int minseqcoil_t = 0;         /* minseq time based on coil heating  */
int minseqcoilx_t = 0;         /* minseq time based on coil heating  */
int minseqcoily_t = 0;         /* minseq time based on coil heating  */
int minseqcoilz_t = 0;         /* minseq time based on coil heating  */
int minseqcoilburst_t = 0;    /* minseq time based on Burst Mode coil limit */
int minseqcoilvrms_t = 0;     /* minseq time based on coil RMS voltage limit */
int minseqgram_t = 0;         /* minseq time based on gram heating  */
int minseqchoke_t = 0;
int minseqcable_t = 0;        /* minseq time based on Irms */
int minseqcable_maxpow_t = 0; /* minseq time based on Irms of maximum power waveform */
int minseqcableburst_t = 0;   /* minseq time based on Burst Mode cable limit */
int minseqbusbar_t = 0;       /* minseq time based on bus bar limit */
int minseqps_t = 0;       /* minseq time based on power supply */
int minseqpdu_t = 0;      /* minseq time based on power distribution unit */
int minseqpdubreaker_t = 0; /* minseq time based on PDU breaker current limit */
int minseqcoilcool_t = 0; /* minseq time baed on coil cooling limit */
int minseqsyscool_t = 0;  /* minseq time based on system cooling limit */
int minseqccucool_t = 0;  /* minseq time based on CCU cooling limit */
int minseqxfmr_t = 0;     /* minseq time based on transformer RMS current limit */
int minseqresist_t = 0;   /* minseq time based on RC filter resistor wattage limit */

/* min seq time based on gradient driver heating  */
int minseqgrddrv_t = 0;      /* minseqtime based on gradient driver heating */
int minseqgrddrv_case_t = 0; /* minseqtime based on cold plate heanting in gradient driver */
int minseqgrddrvx_t = 0;     /* minseqtime based on X gradient driver heating */
int minseqgrddrvy_t = 0;     /* minseqtime based on Y gradient driver heating */
int minseqgrddrvz_t = 0;     /* minseqtime based on Z gradient driver heating */
float powerx = 0;             /* total scaled power in X in Ampere^2 usec     */
float powery = 0;             /* total scaled power in Y in Ampere^2 usec     */
float powerz = 0;             /* total scaled power in Z in Ampere^2 usec     */
float pospowerx = 0;          /* positive scaled power in X in Ampere^2 usec  */
float pospowery = 0;          /* positive scaled power in Y in Ampere^2 usec  */
float pospowerz = 0;          /* positive scaled power in Z in Ampere^2 usec  */
float negpowerx = 0;          /* negative scaled power in X in Ampere^2 usec  */
float negpowery = 0;          /* negative scaled power in Y in Ampere^2 usec  */
float negpowerz = 0;          /* negative scaled power in Z in Ampere^2 usec  */
float amptrans_lx = 0;          /* logical X ampere trans in (Amp/usec)*usec   */
float amptrans_ly = 0;          /* logical Y ampere trans in (Amp/usec)*usec   */
float amptrans_lz = 0;          /* logical Z ampere trans in (Amp/usec)*usec   */
float amptrans_px = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_py = 0;        /* physical X ampere trans in (Amp/usec)*usec   */
float amptrans_pz = 0;        /* physical Y ampere trans in (Amp/usec)*usec   */
float abspower_lx = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_ly = 0;          /* logical Y abs avrg ampere in Ampere * usec   */
float abspower_lz = 0;          /* logical Z abs avrg ampere in Ampere * usec   */
float abspower_px = 0;        /* physical X abs avrg amperere in Amp * usec   */
float abspower_py = 0;        /* physical Y abs avrg amperere in Amp * usec   */
float abspower_pz = 0;        /* physical Y abs avrg amperere in Amp * usec   */

/* SGD gradient heating */
int minseqpwm_x = 0;
int minseqpwm_y = 0;
int minseqpwm_z = 0;
int minseqgpm_t = 0;        /* minseq time based on power supply heating */
int minseqgpm_maxpow_t = 0; /* minseq time based on power supply capability */

/* ratio between estimated bus voltage and required bus voltage for gradient generation */
float vol_ratio_est_req = 2.0;

/* flag to skip waveform & rotation matrix check in minseq() */
int skip_waveform_rotmat_check = 0;

/* flag to search rotation matrix with highest duty in minseq() */
int set_realtime_rotmat = 0;

/* flag to skip rotation matrix search for highest duty in minseq() */
int skip_rotmat_search = 0;

/* flag to force minseqseg() to be called in minseq() */
int enforce_minseqseg = 0;

/* flag to force dbdt optimization to be called in calcOptimizaedPulses() */
int enforce_dbdtopt = 0;

/* flag to show if minseqseg() was skipped or not */
int skip_minseqseg = 0;

/* flag to show if dbdtopt initialization should be skipped or not */
int skip_initialize_dbdtopt = 0;

int time_pgen = 0;       /* timing variable added to monitor pulsegen execution time RK 6/11/96 */

int cont_debug = 0 






;

/* CVs added for Maxwell correction for phase-contrast */
int maxpc_cor = 0 






;

int maxpc_debug = 0 






;

int maxpc_points = 500 






;

/* Added for MGD for pass through filter */
int pass_thru_mode = 0 






;

/* Universally used timing CVs */
int tmin = 0 






;

int tmin_total = 0 






;

int psd_tol_value = 0 






;

/* Universally used board index CV */
int bd_index = PSD_XCVR2 






;

/* Error message data base flag */
int use_ermes = 0 






;

/* Added field strength CV to be able to use RSP.MFO 05/31/00 AY*/
float fieldstrength = 15000;

int asymmatrix = 0 






;

int psddebugcode = 0 






;

int psddebugcode2 = 0 






;

int serviceMode = 0 






;

/* UPM bit mask for disabling cross terms */
int upmxdisable = 16 






;

/*
 * MRIge47485 - Improved Gradient Duty Cycle
 */

/* Linear segment heating model */
int tsamp = 4 






;

int seg_debug = 0 






;

int CompositeRMS_method = PSD_OFF 






;

int gradDriverMethod = PSD_OFF 






;


/* gradDCsafeMethod selects Safe DC model for coil heating calculation MRIhc16090 */
int gradDCsafeMethod = PSD_ON 






;

/* stopwatchFlag for debugging */
int stopwatchFlag = 0 






;

int seqEntryIndex = 0 






;

/* dB/dtOpt CVs - RJF */
int dbdt_debug = 0 






;

int reilly_mode = 0 






;

/* Use this cv to manually turn on/off dB/dt feature */

int dbdt_disable = 0 






;

/* Add the following cv as a logic flag.  This depends on 3 conditions:
   1)Reilly Model being used, 2)CRM is present, 3)dB/dt feature is turned on.*/

int use_dbdt_opt = 1 






;

float srderate =  1.0 






;

int config_update_mode = 0 






;

int phys_record_flag = 0 






;

int phys_rec_resolution = 25 






;

/***********************************************************************
 * Bit control of channel selection for physiological data recording 
 * --------------------------------------------------------------
 * Bit 0 (1): respiratory trigger recording 
 * Bit 1 (2): respiratory waveform data recording
 * Bit 2 (4): PG trigger recording
 * Bit 3 (8): PG waveform data recording
 * Bit 4 (16): ECG 3 trigger recording
 * Bit 5 (32): ECG 3 waveform data recording 
 * Bit 6 (64): ECG 2 trigger recording 
 * Bit 7 (128): ECG 2 waveform data recording 
 ***********************************************************************/
int phys_record_channelsel = 15 






;

/* MRIge91983 */
int rotateflag = 0 






;

/* MRIge93114 */
int rhpcspacial_dynamic = 0 






;

int rhpc_rationalscale = 0 






;

int rhpcmag = 0 






;

int mild_note_support = 0 






;

int save_grad_spec_flag = 0 






;

int grad_spec_change_flag = 0 






;

int value_system_flag = 0 






;

int rectfov_npw_support = 0 






;

int pigeosrot = 0 






;


int minseqrf_cal = 1 






;

int min_rfampcpblty = 0 






;

int b1derate_flag = 0 






;

int oblmethod_dbdt_flag = 0 






; 

/* Non PGOH DC model CV parameters MRIhc16090 */
int minseqcoil_esp = 1000 






;

int aspir_flag = 0 






;

int rhrawsizeview = 0 






;

int chksum_scaninfo_view = 0 






;

int chksum_rhdacqctrl_view = 0 






;

float fnecho_lim = 1.0 






;

int psdcrucial_debug = 0 






;

float b1max_scale = 1.0 






;

int disable_exciter_unblank = 0 






;

int TGlimit = MAX_SYS_TG;      /* max TG limit based on offset */
int sat_TGlimit = MAX_SYS_TG;  /* max TG limit based on offset for SpSat */

int autoparams_debug = 0 






;

int num_autotr_cveval_iter = 1 






;

int apx_cveval_counter = 0 






;

int enforce_inrangetr = 0 






;

int passtime = 0 






;

int retropc_extra = 0 





;

int esp = 10000 






;

int echoint = 1 






;

int arc_flag = 0 






;

int arc_ph_calwidth = 24 






;

int arc_sl_calwidth = 24 






;

int vrgfsamp = 0 






;

float srate_x = 15.0 






;

float glimit_x = 3.6 






;

float srate_y = 15.0 






;

float glimit_y = 3.6 






;

float srate_z = 15.0 






;

float glimit_z = 3.6 






;

float act_srate_x = 10.0 






;

float act_srate_y = 10.0 






;

float act_srate_z = 10.0 






;

int mkgspec_x_sr_flag = 0 






;
int mkgspec_x_gmax_flag = 0 






;

int mkgspec_y_sr_flag = 0 






;

int mkgspec_y_gmax_flag = 0 






;

int mkgspec_z_sr_flag = 0 






;

int mkgspec_z_gmax_flag = 0 






;

int mkgspec_flag = 0 






;

int mkgspec_epi2_flag = 0 






;

int pfkz_total = 32 






;

/* Scan volume scaling for image cut reduction */
float fov_freq_scale = 1.0 






;

float fov_phase_scale = 1.0 






;

float slthick_scale = 1.0 






;

int silent_mode = PSD_OFF 






;

float silent_slew_rate = 3.0 






;

int rhpropellerCtrl = 0 






;

float prop_act_npwfactor = 1.0 






;

float prop_act_oversamplingfactor = 1.0 






;

int navtrig_wait_before_imaging = 200000 






;

int xtg_volRecCoil = 0 






;

int minseqseg_max_full = 0 






;
        
int sphericalGradient = 0 






;

int minseqcoil_option = 0 






;

int minseqgrad_option = 0 






;

int rtp_bodyCoilCombine = 1 






;

int ntxchannels = 1 






;

int napptxchannels = 1 






;

int seqcfgdebug = 0 






;

int enable_acoustic_model = 0 






;
int acoustic_seq_repeat_time = 4 






;
float avgSPL_non_weighted = -1 






;
int noisecal_in_scan_flag = 0 






;

/*
 * Copyright 2017 General Electric Company.  All rights reserved.
 */
 
/*
 * @ipgexport
 * Variables declared in this file are shared between groups of
 * PSDs and may be critical to the operation of all PSDs.
 * Contains the variable declarations that carry potentially complex
 * data from the host PSD to the target PSD during the
 * serialization/deserialization step of download. Standard CVs (the
 * other form of serializable information) are restricted to simple
 * primitive types. Add variables to this file when (1) they are
 * needed by a large subset of all PSDs for correct operation (vs.
 * an @ipgexport section in a PSD or inline file), and (2)
 * the data needs to be conveyed from the Host PSD to the Target PSD
 * during download (vs. an @rsp or @rspvar or @reqexport section), and
 * (3) the data type is more complicated than a signed single- or
 * double- length primitive type (vs. @cv or @reqcv). 
 *
 * This file is included in epic.h
 *
 */ 

int cs_sat = 0;
int cs_satstart = 0, cs_sattime = 0;
float a_rfcssatcfh = 0, flip_rfcssatcfh = 0;
int pw_rfcssatcfh = 0, ia_rfcssatcfh = 0;
int ChemSatPulse=CSM_PULSE;
float area_gxkcs = 0;
float area_gykcs = 0;
float area_gyakcs = 0;
float area_gzkcs = 0;
int csk_derate_factor = 1 ;

/* creating rf waveform directly, so need to declare these */
int pw_rfcssat = 0, pw_omega_hs_rfcssat = 0;
int off_rfcssat = 0;
int ia_rfcssat = 0, ia_omega_hs_rfcssat = 0; /* vmx 3/13/95 YI */
float cyc_rfcssat = 0;
float a_rfcssat = 0, a_omega_hs_rfcssat = 0;
float alpha_rfcssat = 0;
float gscale_rfcssat = 0;
float flip_rfcssat = 0;

/* SPSP fat sat pulse */
float a_gzrfcssat = 0;
int ia_gzrfcssat = 0;
int pw_gzrfcssat = 0;
int res_gzrfcssat = 0;
float a_gzrfcssat_wrf = 0;

float a_thetarfcssat = 0;
int ia_thetarfcssat = 0;
int pw_thetarfcssat = 0;
int res_thetarfcssat = 0;
int off_thetarfcssat = 0;

int bw_rfcssat = 0;

/* variables for selective Chemsat - Used with 3dtof */
int selectiveChemsat = 0 ;
float selectiveChemsatBWscaler = 1.0 ;
int offset_rfchemsat = 0;

int num_gzrfcssat_lobe = 0;
int pw_gzrfcssat_lobe = 0;
int pw_gzrfcssat_constant = 0;
int pw_gzrfcssat_rampz = 0;

int num_gzrfcssat_lobe_norf = 0;
int pw_gzrfcssat_lobe_norf = 0;
int pw_gzrfcssat_constant_norf = 0;
int pw_gzrfcssat_rampz_norf = 0;

int ext_pw_rfcssat = 0;
int ext_res_rfcssat = 0;
int ext_isodelay = 0;
int ext_water_freq_flag = 0;
int ext_pw_grad_sub_lobe = 0;
int ext_pw_grad_sub_lobe_ramp = 0;
int ext_num_grad_sub_lobe = 0;
int ext_pw_grad_sub_lobe_norf = 0;
int ext_pw_grad_sub_lobe_ramp_norf = 0;
int ext_num_grad_sub_lobe_norf = 0;
float ext_abswidth = 0;
float ext_effwidth = 0;
float ext_area = 0;
float ext_dtycyc = 0;
float ext_maxpw = 0;
float ext_max_b1 = 0;
float ext_max_int_b1_sq = 0;
float ext_max_rms_b1 = 0;
float ext_nom_fa = 0;
float ext_nom_pw = 0;
float ext_nom_bw = 0;
float ext_gzrfcssat_scale_fac = 0;
float ext_fatsat_min_slthick = 0;

/* HCSDM00091804:Duo Chem Sat Parameters */
#define DUO_NUM_FLIP 90        /* number of flip angles for Duo Chem Sat search */
#define DUO_LIPID_COMP 9       /* number of lipid components for Duo Chem Sat calculation */
#define DUO_SPECPROF_RANGE 180 /* Spectral profile range */
#define DUO_START_FIRST_FA 1   /* flip angle at which Duo Chem Sat will start to search for first ChemSat pulse */
#define DUO_END_FIRST_FA 90    /* flip angle at which Duo Chem Sat will finish to search for first ChemSat pulse */
#define DUO_START_SECOND_FA 1  /* flip angle at which Duo Chem Sat will start to search for second ChemSat pulse */
#define DUO_END_SECOND_FA 180  /* flip angle at which Duo Chem Sat will finish to search for second ChemSat pulse */
int duo_cs_flag = PSD_OFF;     /* flag for Duo ChemSat.*/
int w_debug_flag = 0;          /* debug flag */
int n_cspulses = 0;                /* number of chem sat pulses */
int flip_final_1 = 0;              /* determined flip angle for 1st chem sat pulse */
int flip_final_2 = 0;              /* determined flip angle for 2nd chem sat pulse */

float killer_scale = 1.0;      /* killer scale is used to scale killer area for 2 chem sat pulses. */
/* back up parameters. If these parameters are same as previous calling. ChemSatFlip_duo will not run.  *
 * Backup params are set to -1 for initial value to differ with calculated value.                       */
int delay_time_bkp = -1;
int tetime_bkp = -1;
int rc_time_bkp = -1;
int slquant_bkp = -1;
int tr_time_bkp = -1;
int sattime_bkp = -1;
int flip_final_1_bkp = -1;
int flip_final_2_bkp = -1;
float fatsat_factor_bkp = -1;

int phantom_test_flag = 0 ;
float phantom_fat_T1 = 300.0 ;

/* SVBranch HCSDM00260981 Multi-Band Fat Sat*/
/*Multi-Band Parameters*/
#define DB_OFF 0		/* Multi-Band is off */
#define DB_DUO_CS 1		/* Multi_band is off, duo CS is on */
#define DB_FE 2                 /* bands in frequency encoding direction */
#define DB_PE 3                 /* bands in phase encoding direction */
#define DB_SS 4                 /* bands in slice selection direction */
int DB_flag = 0 ;
float DB_shift_ratio = 0 ;
float DB_ChemShift = 0.75 ;
int DBgrad_flag = PSD_OFF ;

/* Multi-Band buffer between saturation bands to edge of FOV */
float DB_Buffer_X = 0.0;
float DB_Buffer_Y = 0.0;

float DB_Chemical_Shift = 0;	/* Frequency difference between water and fat */

float dbcenterlocx1 = 0,            /* center location of saturation bands */
      dbcenterlocx2 = 0,
      dbcenterlocy1 = 0,
      dbcenterlocy2 = 0,
      dbcenterlocz1 = 0,
      dbcenterlocz2 = 0;

float dbsatthickx = 0,              /* thickness of saturation bands */
      dbsatthicky = 0,
      dbsatthickz = 0;

float dbbandlocx1 = 0,              /* innner edge location of saturation bands */
      dbbandlocx2 = 0,
      dbbandlocy1 = 0,
      dbbandlocy2 = 0,
      dbbandlocz1 = 0,
      dbbandlocz2 = 0;

float off_rfcssat1 = 0,             /* center frequency of Multi-Band saturation pulses */
      off_rfcssat2 = 0;

float bw_rfcssat_nom = 0;
float bw_rfcssat_ramp = 0;          

float bw_ramp = 0;

/* FATSAT FACTOR addition - HH June 2005 */
float fatsat_factor = 1.0 ;

/* vmx 3/13/95 YI */
 int csat_rfupa    = -600 ;
 int csat_sys_type = 0  ;
/* end vmx */

/* AMR - FOR MRIhc27960 */
/* Adiablatic Spectral Inversion Recovery : SW/RFB 03-Nov-06, 27-Feb-07 */
int aspir_delay    = 0;
int aspir_cfoffset = 0;
int aspir_minti = 0;
float aspir_T1 = 0;
float aspir_TI = 0;
float aspir_TI_null = 0;
float aspir_TI_extra = 0;
float aspir_TI_min = 0;
float aspir_eff = 0;

int fatFlag = 0;
int cs_isodelay = 0;
int cs_delay = 0;
int recovery_time = 0;
float flip_sat = 0;		/* CV created to calculate ChemSat flip angle in SCAN, SGT */
float flip_satcfh = 0;	/* CV created to set ChemSat flip angle in CFH, SGT */
int   fStrength = 0;        /* FEC : Field strength temp variable for RF calculations */

/* SPSP fat sat pulse */
int use_spsp_fatsat = 0 ;
int debug_spsp_fatsat = 0;
float spsp_fatsat_slthick = 30.0 ;
int spsp_fatsat_pulse_extra_time = 0 ;
int spsp_fatsat_spatial_mode = 0 ;
float spsp_fatsat_spatial_offset = 0.0 ;
int spsp_fatsat_pulse_override = 0 ;

/* Omega Scale (8 bit shift = 256)*/
float spsp_fatsat_omega_scale= 256.0 ;

float max_aspir_fa = 0; /* max allowed flip angle for aspir pulse */

int fa_scale_debug = 0;

/* chemsat input parameters calculation */
int cs_tr = 0 ;
int cs_slquant =0 ;

int cs_dda_per_trig_flag = 0 ; /*dda chemsat pulse is always single chemsat*/
int psd_chemsat_seq_flag = 0 ;
int cs_dda_flip = 90 ;


float   ccs_dead = 3000000 ;
int     ccs_relaxers = 0;		/* number of ccs_relaxers sequences to play */
int     ccs_relaxtime = 0;		/* Time per scan to add for relaxers */
int     ccs_relaxseqtime = 0;		/* Time of a relaxer sequence */
int     SatRelaxers = 0;

    /* Pulse widths, sinc cylces and scaling for rf pulses */
float   gsat_scale = 0; 
float   cyc_rfs = 0;
int     pw_rfs = 0;
int     pw_satrampx = 0, pw_satrampy = 0, pw_satrampz = 0;

int     sat_rot_ex_num = 0;  /* number of explicit sats */
int     sat_rot_df_num = 0;  /* number of default sats */
int     sat_rot_index = 0;   /* index into sat rotation matrice array */
int     pw_isisat= 200   ;/* duration of isi interrupt */
int     pw_rotupdate = 12   ;   /* duration of rotation matrix update signal for WARP */
int     isi_satdelay = 100   ;    /* time back from end of killer decay ramp for ISI */
int     rot_delay = 12   ;       /* time back from end of killer decay ram for matrix
                            update signal for WARP */
int     isi_extra = 32   ;

int     sat_debug = 0;
int     spsat_host_debug = 0 ;
int     sp_first_scan = 0;  /* To determine if this is the first scan or not */

int     sat_obl_debug = 0;
int     sat_newgeo = 1;

/* vmx 3/13/95 YI */
 int spsat_rfupa    = -600 ;
 int spsat_sys_type = 0 ;
/* end vmx */

int     xkiller_set = 0;
int     maxkiller_time = 0;

    /* These are unlocked per applications 7/9/92 */
float   satgapxpos= 0 
;
float   satgapxneg= 0 
;
float   satgapypos= 0 
;
float   satgapyneg= 0 
;
float   satgapzpos= 0 
;
float   satgapzneg= 0 
;

    /* Sat spacing for use with Hadamard rf pulses */
float   satspacex1 = 0,   
        satspacex2 = 0,
        satspacey1 = 0,
        satspacey2 = 0,
        satspacez1 = 0,
        satspacez2 = 0,
        satspace1 = 0,
        satspace2 = 0,
        satspace3 = 0,
        satspace4 = 0,
        satspace5 = 0,
        satspace6 = 0;

   /* Sat thickness. x1, x2, y1, y2, z1, z2 are the default sats
                     e1, e2, e3, e4, e5, e6 are the explicit sats */
float   satthickx1 = 0, 
        satthickx2 = 0,
        satthickdfx = 0,
        satthicky1 = 0, 
        satthicky2 = 0,
        satthickdfy = 0,
        satthickz1 = 0, 
        satthickz2 = 0, 
        satthickdfz = 0,
        exsatthick1 = 0, 
        exsatthick2 = 0,
        exsatthick3 = 0, 
        exsatthick4 = 0,
        exsatthick5 = 0, 
        exsatthick6 = 0;

   /* Location of sat bands. 
         xlocneg, xlocpos, ylocneg, ylocpos, zlocneg, zlocpos are default sats
         loce1, loce2, loce3, loce4, loce5, loce6 are explicit sats */ 
           
float   satxlocpos = 0,
        satxlocneg = 0, 
        satylocpos = 0, 
        satylocneg = 0,
        satzlocpos = 0, 
        satzlocneg = 0,
        satzloca = 0,
        satzlocb = 0,
        satloce1 = 0,
        satloce2 = 0,
        satloce3 = 0,
        satloce4 = 0,
        satloce5 = 0,
        satloce6 = 0;

float   area_rfsx1 = 0 ;
float   area_rfsx2 = 0 ;
float   area_rfsy1 = 0 ;
float   area_rfsy2 = 0 ;
float   area_rfsz1 = 0 ;
float   area_rfsz2 = 0 ;
float   area_rfse1 = 0 ;
float   area_rfse2 = 0 ;
float   area_rfse3 = 0 ;
float   area_rfse4 = 0 ;
float   area_rfse5 = 0 ;
float   area_rfse6 = 0 ;

float area_gyksx1 = 0,area_gyksx2 = 0,area_gyksy1 = 0,area_gyksy2 = 0,area_gyksz1 = 0,
          area_gyksz2 = 0,area_gykse1 = 0,area_gykse2 = 0,area_gykse3 = 0,area_gykse4 = 0,
          area_gykse5 = 0,area_gykse6 = 0;

float area_gxksx1 = 0,area_gxksx2 = 0,area_gxksy1 = 0,area_gxksy2 = 0,area_gxksz1 = 0,
          area_gxksz2 = 0,area_gxkse1 = 0,area_gxkse2 = 0,area_gxkse3 = 0,area_gxkse4 = 0,
          area_gxkse5 = 0,area_gxkse6 = 0;

int     sp_sattime = 0 ;
int     sp_satstart = 0 ;

int     vrgsat = 2 ;
int     numsatramp = 0 ;
int     had_sat = 0 ;

float rtia3d_sat_flip = 70 
;

float rtia3d_sat_pos = 100.0 
;

int sat_pulse_type  = REAL_RF ;

int satgap_opt_flag = 0 ;

/***************************************************************************/

int autolock = 0 





; /* vmx 10/13/94 YI */

int blank = 4 





; /* vmx 10/3/94 YI */

int nograd = 0 





; /* vmx 10/13/94 YI */

int nofermi = 0 





; /* vmx 10/13/94 YI */

int rawdata = 0 





; /* vmx 10/13/94 YI */

int saveinter = 0 





; /* vmx 10/13/94 YI */

int zchop = 1 





;/* vmx 10/13/94 YI */

int eepf = 0 





; /* vmx 10/13/94 YI */

int oepf = 0 





; /* vmx 10/13/94 YI */

int eeff = 0 





; /* vmx 10/13/94 YI */

int oeff = 0 





; /* vmx 10/13/94 YI */

int cine_choplet = 0 





; /* vmx 10/13/94 YI */

/*** CVs for Fermi Filter ***/
float fermi_rc = 0.5 





;

float fermi_wc = 1.0 





;

int apodize_level_flag = 0 





;

float fermi_r_factor = 1.0 





;

float fermi_w_factor = 1.0 





;

float pure_mix_tx_scale = 1.0 






;

int channel_compression = PSD_OFF 






;

int optimal_channel_combine = PSD_OFF 






;

int enforce_cal_for_channel_combine = PSD_OFF 






;

int override_opcalrequired = PSD_OFF 






;

int dump_channel_comp_optimal_recon = PSD_OFF 






;

int dump_scenic_parameters = PSD_OFF 






;


/*********************************************************************
 *                     PRESCAN.E HOST SECTION                        *
 *                             PScvs                                 *
 *                                                                   *
 * Standard C variables of _limited_ types common for both the Host  *
 * and Tgt PSD processes. Declare here all the simple types, e.g,    *
 * int, float, and C structures containing the min and max values,   *
 * and ID description, etc.                                          *
 *                                                                   *
 * NOTE FOR Lx:                                                      *
 * Since the architectures between the Host and the Tgt sides are    *
 * different, the memory alignment for certain types varies. Hence,  *
 * the following types are "forbidden": short, char, and double.     *
 *********************************************************************/
float PSsr_derate_factor = 1.0 ;
float PSamp_derate_factor = 1.0 ;
float PSassr_derate_factor = 1.0 ;
float PSasamp_derate_factor = 1.0 ;
int PSTR_PASS = 20000;

/* ezi (GE) */
float mpsfov = 100  ;

int fastprescan = 0 ;
int pre_slice = 0 ;
int PSslice_num = 0;
float xmtaddAPS1 = 0, xmtaddCFL = 0, xmtaddCFH = 0, xmtaddFTG = 0, xmtadd = 0, xmtaddRCVN = 0;
float ps1scale = 0, cflscale = 0, cfhscale = 0, ftgscale = 0;
float extraScale = 0;  /* for external PSD use */
int PSdebugstate = 0 ;
int PSfield_strength = B0_5000 ;
int PScs_sat = 1 ;
int PSir = 1 ;
int PSmt = 1 ;
int ps1_rxcoil = 0 ;
int ps_seed = 21001;    /* spgr RF phase seed */

/* vmx 06/14/95 YI */
int tg_1_2_pw = 1 ;
int tg_axial = 1 ;
float coeff_pw_tg = 1.0;
float fov_lim_mps = 350.0 ;
/* end vmx */

int TGspf = 0 ;

float flip_rf2cfh = 0;
float flip_rf3cfh = 0; /* For presscfh MRIhc08321 */
float flip_rf4cfh = 0;
int ps1_tr=2000000;
int cfl_tr=398000;
int cfh_tr=398000;
int rcvn_tr=398000;

float cfh_ec_position = (16.0/256.0) ;
				/* vmx 05/02/95 YO */
int cfl_dda = 4 ;
int cfl_nex = 2 ;
int cfh_dda = 4 ;
int cfh_nex = 2 ;
int rcvn_dda = 0 ;
int rcvn_nex = 1 ;

/* PRESS XTG and APS1 */
int local_tg = 0 ;
float fov_scaling = 0.8 ;
float flip_rf1xtg = 90.0;
float gscale_rf1xtg = 1.0;
int init_xtg_deadtime = 0;
float flip_rf1mps1 = 90.0;
float gscale_rf1mps1 = 1.0;

/* presscfh  cvs -  For  MRIhc08321 */ 
/* Definitions in epic.h
 * PRESSCFH_SLICE 1      
 * PRESSCFH_SLAB 2                                              
 * PRESSCFH_SHIMVOL 3
 * PRESSCFH_SHIMVOL_SLICE 4
 * PRESSCFH_NONE          5
 * */
int presscfh_override = 0  ;
int presscfh = PRESSCFH_NONE  ;
int presscfh_ctrl = PRESSCFH_NONE  ;
int presscfh_outrange = 0;
int presscfh_cgate = 0;
int presscfh_debug = 0 ;
int presscfh_wait_rf12 = 0;
int presscfh_wait_rf23 = 0;
int presscfh_wait_rf34 = 0;
int presscfh_minte = 20000;
float presscfh_fov = 0.0;
float presscfh_fov_ratio = 1.0;
float presscfh_pfov_ratio = 1.0;
float presscfh_slab_ratio = 1.0;
float presscfh_pfov = 0.0; 
float presscfh_slthick = 10.0;
float presscfh_slice = 10.0;  /* for the third refocus pulse in presscfh_shimvol_slice*/
float presscfh_ir_slthick = 10.0;
int presscfh_ir_noselect = 1;
/* SXZ: change from 0.5 to 0.3 to make sure presscfh is more probably
 * used for PRESSCFH_SLICE mode */
float presscfh_minfov_ratio = 0.3; /* SXZ: change from 0.5 to 0.3 */ 

/* steam_flag */
int cfh_steam_flag = 0;
int steam_pg_gap = 8;

float area_gykcfl = 0;
float area_gykcfh = 0;
float area_xtgzkiller = 0;
float area_xtgykiller = 0;
int PSoff90=80  ;
int dummy_pw = 0;
int min180te = 0;

float PStloc = 0;
float PSrloc = 0;
float PSphasoff = 0;
int PStrigger = 0;

/* begin aps1_mod changes (GE) */
float PStloc_mod = 0;
float PSrloc_mod = 0;
float PSphasoff_mod = 0;
float thickPS_mod = 0;
/* end aps1_mod changes (GE) */

float asx_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float asz_killer_area = 840.0; /* based on 5.4:  .7 * ( 800 + 400 ) */
float cfhir_killer_area = 4086.0; /* based on 5.4:  .9 * ( 4000 + 540 ) */
float ps_crusher_area = 714.0; /* based on 5.4:  .7 * ( 600 + 420 ) */
float cfh_crusher_area = 4000.0; /* MRIhc57311: increased crusher area to kill signal from outside slice */
float target_cfh_crusher = 0;
float target_cfh_crusher2 = 0;  /* For presscfh MRIhc08321 */ 

int cfh_newmode = 1;
float cfh_rf1freq = 0 ;
float cfh_rf2freq = 0 ;
float cfh_rf3freq = 0 ; /* For presscfh MRIhc08321 */
float cfh_rf4freq = 0 ;
float cfh_fov = 0 ;
int cfh_ti = CFHTI_1HT;
int eff_cfh_te = CFHTE_1HT;
int PScfh_shimvol_debug = PSCFH_SHIMVOL_DEBUG_NONE ;
int debug_shimvol_slice = 0;

/* variables for sequencers in shimvol_slice mode */
int wg_cfh_rf3 = 0;
int wg_cfh_rf4 = 0;


/**** FastTG CVs   *******/
float FTGslthk = 20 ;

float FTGopslthickz1=80 ;
float FTGopslthickz2=80 ;
float FTGopslthickz3=20 ;
int   ftgtr = 2000000 ;
float FTGfov = 480.0 ;
float FTGau  = 4 ;
float FTGtecho = 4 ;
int FTGtau1   = 8192   ;
int FTGtau2   = 32768   ;
int FTGacq1   = 0 ;
int FTGacq2   = 1 ;
int epi_ir_on = 0 ;	/* ypd */
int ssfse_ir_on = 0 ;	/* MRIge66767 */
int ftg_dda = 0 ;

float FTGecho1bw = 3.90625 ;
int FTGtestpulse  = 0 ;
int FTGxres    = 256 ;
float FTGxmtadd = 0;
int pw_gxw2ftgleft = 4096; /* HCSDM00161809: time of 2nd readout window to S1 echo */

/**** eXpressTG CVs   *******/
int   xtgtr = 200000 ;
int XTGtau1   = 8192   ;
float XTGfov = 480.0 ;
int pw_bsrf = 4000;
int xtg_offres_freq = 2000; /* 2kHz off-resonance */
float XTGecho1bw = 15.625 ;
int XTGxres    = 256 ;
float xmtaddXTG = 0, xtgscale = 0;
int xtg_dda = 0 ;
int XTGacq1   = 0 ;
float TGopslthick = 10.0 ;
float TGopslthickx = 30.0 ;
float TGopslthicky = 30.0 ;
int XTG_minimizeYKillerGap = 0 ;

/* Dynamic TG */
int dynTG_etl = 2 ;
int dtg_iso_delay = 1280   ;
int dtg_off90 = 80;
int dtg_dda = 4 ;
int rf1dtg_type = 1 ;
float echo1bwdtg = 15.625 ;
int dtgt_exa = 0, dtgt_exb = 0, tleaddtg = 0, td0dtg = 0;
int dtgphorder = PH_CENTRIC_LOW;
int dtgspgr_flag = 0 ;
int pw_rf1dtg = 0;
float a_rf1dtg = 0;
int min_dtgte = 0, dtg_esp = 0;
int tr_dtg = 20000;
int time_ssidtg = 400;

/**** B1 Map CVs   *******/
int rsaxial_flag = 1 ;
int rsspgr_flag = 1 ;
int multi_channel = 1 ;
int minph_iso_delay = 1280   ;
int rs_off90 = 80;
int rs_iso_delay = 1280   ;
float echo1bwrs = 15.625 ;
int rsphorder = PH_CENTRIC_LOW;

int rs_dda = 4 ;
int rst_exa = 0, rst_exb = 0, tleadrs = 0, td0rs = 0;
int pw_rf1rs = 0;
int ia_rf1rs = 0;
float a_rf1rs = 0;
int rf1rs_type = 1 ;

float gscale_rf1rs = 0;
float flip_rf1rs = 0, flip_rfbrs = 0, cyc_rf1rs = 0;
float flip_rf1dtg = 0, flip_rfbdtg = 0, cyc_rf1dtg = 0, gscale_rf1dtg = 0;
int ia_rf1dtg = 0;
float rf1rs_scale = 0, rf1dtg_scale = 0;
float xmtaddrs = 0, xmtadddtg = 0;
int pw_acqrs1 = 0, pw_acqdtg1 = 0;
int min_rste = 0, rs_esp = 0;
int tr_rs = 0, tr_prep_rs = 0;
int rd_ext_rs = 0, rd_ext_dtg = 0;
int fast_xtr = 50;
int attenlen = ATTEN_UNLOCK_LENGTH;
int tns_len = 4;
int e2_delay_rs = 4;
int e2_delay_dtg = 4;
int time_ssirs = 400;

int rfshim_etl = 2;
int B1Cal_mode = 0 ;
int DD_delay = 2000 ;
int DD_channels = 2 ;
int DD_nCh = 1;
int DD_debug = 0 ;

int endview_iamprs = 0, endview_iampdtg = 0;
float endview_scalers = 0, endview_scaledtg = 0;


/**** ExtCal CVs ****/
float echo1bwcal = 62.5 ;
int cal_dda = 128 ;
int cal_delay = 4000000 ;
int cal_delay_dda = 0;
int calspgr_flag = 1 ;
int cal_tr_interleave = 0;
int cal_nex_interleave = 0;
float cal_xfov = 100.0;
float cal_yfov = 100.0;
float cal_vthick = 10.0;
int cal_btw_rf_rba_ssp = 0;
int cal_grd_rf_delays = 0;
int tleadcal = 0;
int td0cal = 0;
int calt_exa = 4;
int calt_exb = 4;
int tacq_cal = 4;
int te_cal = 4;
int tr_cal = 4;
float flip_rf1cal = 0.0;
int cal_iso_delay = 0;
int endview_iampcal = 0;
int endviewz_iampcal = 0;
float endview_scalecal = 1.0;
float endviewz_scalecal = 1.0;
float a_combcal = 1.0;
float a_endcal = 1.0;
float a_combcal2 = 1.0;
float a_endcal2 = 1.0;
int time_ssical = 160;
float xmtaddcal = 0.0;
float cal_amplimit = 0.0;
float cal_slewrate = 100.0;
float cal_freq_scale = 1.0;
float cal_phase_scale = 1.0;
float area_gzkcal = 300.0;
float cal_ampscale = 1.05;
int cal_pfkr_flag = 1;
float cal_pfkr_fraction = 1.0;
int cal_sampledPts = 0;

/**** AutoCoil CVs ****/
float echo1bwcoil = 62.5 ;
int coil_dda = 4 ;
int coilspgr_flag = 1 ;
int coil_nex_interleave = 0;
float coil_xfov = 100.0;
float coil_yfov = 100.0;
float coil_vthick = 10.0;
int tleadcoil = 0;
int td0coil = 0;
int coilt_exa = 4;
int coilt_exb = 4;
int tacq_coil = 4;
int te_coil = 4;
int tr_coil = 4;
float flip_rf1coil = 0.0;
int coil_iso_delay = 0;
int endview_iampcoil = 0;
int endviewz_iampcoil = 0;
float endview_scalecoil = 1.0;
float endviewz_scalecoil = 1.0;
float a_combcoil = 1.0;
float a_endcoil = 1.0;
float a_combcoil2 = 1.0;
float a_endcoil2 = 1.0;
int time_ssicoil = 160;
float xmtaddcoil = 0.0;
float coil_amplimit = 0.0;
float coil_slewrate = 100.0;
float coil_freq_scale = 1.0;
float coil_phase_scale = 1.0;
int coil_pfkr_flag = 1;
float coil_pfkr_fraction = 1.0;
int coil_sampledPts = 0;

/**** CFL/CFH CVs   *******/
int CFLxres = 256 ; /* MRIhc54366 */
int CFHxres = 256 ;
 
float echo1bwcfl = 2.016129 ;
float echo1bwcfh = 0.50 ;

float echo1bwrcvn = 15.625 ;
int rcvn_xres   = 4096 ;
int rcvn_loops  = 10;  /* number of iterations RCVN entry point will loop */
int pw_grdtrig= 8   ;    /* trigger for grad diagnostic */

int wait_time_before_cfh = 1000000 ;

/**** AutoShim CVs *******/

float echo1bwas = 15.625 ;

int off90as  = 80   ;
int td0as  = 4 ;
int t_exaas = 0 ;
int time_ssias = 400   ;
int tleadas = 25   ;

int te_as = 0;
int tr_as = 0;
int as_dda = 4 ;

int pw_isislice= 200   ;    /* duration of isi interrupt */
int pw_rotslice= 12   ;   /* duration of rotation matrix update signal for WARP */
int isi_sliceextra = 32   ;


/**** Receive Gain CVs ****/

int rgfeature_enable  = PSD_OFF ;

/********** Required for mrsaps/opt prescan ****************/
/********** pimrsapsflg must be on *************************/
float aslenap = 200 ;
float aslenrl = 200 ;
float aslensi = 200 ;

float aslocap = 0 ;
float aslocrl = 0 ;
float aslocsi = 0 ;
/***********************************************************/

/* temp crusher amplitudes */
float area_gxwas = 0;                  /* readout pulse area */
float area_gz1as = 0;
float area_readrampas = 0;             /* area of left readout ramp */
int avail_pwgx1as = 0;                 /* avail time for gx1as pulse */
int avail_pwgz1as = 0;               /* avail time for gz1as pulse */
int bw_rf1as = 0;                    /* bandwidth of rf pulses */

/* filter info for 1st, 2nd echo */
float flip_pctas=1.0;                 /* flip angle % for rf scaling */

int dix_timeas = 0;              /* dixon delay for even excitations */
float xmtaddas = 0,xmtlogas = 0;     /* rf attenuation */
int ps1obl_debug = 0 
;
int asobl_debug = 0 
;
int ps1_newgeo = 1;

int as_newgeo = 1;
int pw_gy1as_tot = 0;
int endview_iampas = 0;
float endview_scaleas = 0;

/* YMSmr09211  04/26/2006 YI */
int cfh_newgeo = 1; 
int cfhobl_debug = 0 
;

float deltf = 1.0 ;

int IRinCFH = 0 ;
int cfh_each = 0 ;
int cfh_slquant = 0 ;

int noswitch_slab_psc = 0 ;
int noswitch_coil_psc = 0 ;
int PStest_slab = 1 ;
/******************** Communication cv's (Prescan)**********/
int pimrsapsflg = 0 ;
int pimrsaps1 = MRSAPS_CFL 



;
int pimrsaps2 = MRSAPS_FTG 



;
int pimrsaps3 = MRSAPS_AS 



;
int pimrsaps4 = MRSAPS_TR 



;
int pimrsaps5 = MRSAPS_RCVN 



;
int pimrsaps6 = MRSAPS_CFH 



;
int pimrsaps7 = MRSAPS_OFF 



;
int pimrsaps8 = MRSAPS_OFF 



;
int pimrsaps9 = MRSAPS_OFF 



;
int pimrsaps10 = MRSAPS_OFF 



;
int pimrsaps11 = MRSAPS_OFF 



;
int pimrsaps12 = MRSAPS_OFF 



;
int pimrsaps13 = MRSAPS_OFF 



;
int pimrsaps14 = MRSAPS_OFF 



;
int pimrsaps15 = MRSAPS_OFF 



;

/* MRIhc15304: CVs related to coil switching
 * By changing the hub index for the coil and sending
 * it through SSP packet (RFHUB ssp packet)
 */
int pw_contrfhubsel = 4 ;
int delay_rfhubsel = 20;
int pw_contrfsel = 4 ;
int csw_tr = 0 ;
int csw_wait_sethubindeximm = 250000 
;
int csw_wait_setrcvportimm = 100000 
;
int csw_wait_before = 10000 ;
int csw_time_ssi = 50   
;

/* MRIhc47602/MRIhc47515/GEHmr03545 : Killer gradient in the RCVN sequence */
float area_gxkrcvn = 10000;
float area_gykrcvn = 10000;
float area_gzkrcvn = 10000;
int pre_rcvn_tr = 20000 ;
int rcvn_flag = 1 ;

/* Prescan PSD controls */
int psd_startta_override = 0 ;
int psd_psctg = APS_CONTROL_PSC 
;
int psd_pscshim = APS_CONTROL_PSC 
;
int psd_pscall = APS_CONTROL_PSC 
;

/* temp cvs, to be removed */
int bw_rf1cal = 0, bw_rf1coil = 0;

/***********************************************************/


float yk0_killer_area = 4140.0;
/* based on 5.4 .9*4600us */
int ir_on        = 0 ;
int ir_start     = 0 ;
int irk_start    = 0 ;
int ir_grad_time = 0 ;
int ir_time      = 0 ;
int ir_time_total= 0 ;
int ext_ir_pulse = 1 ;
float rf0_phase  = 0 ;
int irslquant = 0;
int pos_ir_start = 0; /* irprep_support */

int bw_rf0     = 0 ;
int hrf0       = 0 ; 
int ir_index = 0;	/* index for ir pulsegen */
float csf_fact=0.5;	/* gscale_rf0 scale factor for flair2  */

int ir_fa_scaling_flag = 0 ;

/* t1flair_stir */
int inner_spacing = 0;
int post_spacing = 0;

int invseqlen = 0;     /* min time played out for inversion sequence */

/* **********************************************************
 These cvs are defined by sliceselz, and trapezoid macro in epic.h 
int pw_rf0        "Pulse width of IR pulse"
float a_rf0       "Amplitude of RF0 for IR"
float cyc_rf0     "# of cyc of RF0 for IR"
int pw_gzrf0      "Pulse width of GZ for IR"
int pw_gzrf0a     "Pulse width of ramps on GZ for IR"
int pw_gzrf0d     "Pulse width of ramps on GZ for IR"
float a_gzrf0     "Amplitude of GZ for IR"
short res_rf0     "Resolution of IR pulse"  
float gscale_rf0  "G scale factor for SLR-IR pulse"
int pw_gyk0       "Pulse width of killer for IR on Y"
int pw_gyk0a      "Pulse width of ramps for IR killer"
int pw_gyk0d      "Pulse width of ramps for IR killer"
float a_gyk0      "Amplitude of killer for IR on Y"
********************************************************** */

/* vmx 3/13/95 YI */
 int ir_rfupa    = -600 ;
 int ir_sys_type = 0  ;
/* end vmx */

/* dummy CVs */
int invThickOpt = 0 ;
int invThickOpt_seqtime = 0 ;
int t2flair_extra_ir_flag = 0 ;
int packs = 0 ;

/* FA scaling */
int ir_fa_scale_debug = 0 ;
 

int ss_rf1 = 0 ;
int fat_flag = 0 ;
float fat_delta = -230.0 
; 
int fat_offset = -386 ;
int sszchop = 0 
;
int pw_gzrf1lobe = 0;  /* pw of gradient lobe in ss_pulse */
int pw_constant = 0;
int num_rf1lobe = 0;        /* number of lobes in ss_pulse */
int gradient_mode = 1 ;
int ss_rf_wait = 0 
;
int pw_ss_rampz = 0;
int ss_override = 0 ;
int whichss = 0;
float nbw_ssrf = 0;         /* nominal bandwidth of spectral spacial rf pulse */
float ss_min_slthk = 0, ss_maxoff = 0, ss_minslthk1 = 0;

int ss_convolution_flag = 0 ;

int breast_spsp_flag = 0 ;
int ss_fa_scaling_flag = 0 ;
int ss_fa_scale_debug = 0 ;
float max_ss_fa = 0; /* max allowed flip angle for spsp pulse */

int ss_maxoffex = 0;
int off90minor = 0;
float omega_amp = 0;
float gz1_zero_moment = 0;
float gz1_first_moment = 0;

/* SVBranch: HCSDM00193936:
   moved here from ssEval2(), so that
   it can be used in ssCheck(); */
float a_gzrf1_ss_max = 0;

/* BJM: added freqSign so the freq offset can be modulated */
/* in in the core section if the gradient is flipped       */
int freqSign = 1;

/******************************ssIPGexport*******************************/
/* Inline this section in a ipgexport section of your source, e.g.
@ipgexport
@inline ss.e ssIPGexport
*/

 int cv_rfupa          = -600 ;
 int system_type = 0  ;
 int cvlock = 1 ;
 int psd_taps = -1 
;
 int fix_fermi = 0 
;
 int grad_spec_ctrl = 0 
  ;
 float srate = 1.651 ;
 float glimit = 1.0 ;
 float save_gmax = 1.0;
 float save_srate = 2.551;
 int save_cfxfull = 32752;
 int save_cfyfull = 32752;
 int save_cfzfull = 32752;
 float save_cfxipeak = 194.0;
 float save_cfyipeak = 194.0;
 float save_cfzipeak = 194.0;
 int save_ramptime = 600;
 int debug_grad_spec = 0 ;
 float act_srate=1.651;
 int val15_lock = 0 
  ;
/* flag to calculate average power for Smart Burst Mode with XFD */
 int avecrushpepowscale_for_SBM_XFD = 0;  
 

/*convolution model addition*/
int dbdt_model = 0 ;
float dbdtper_new = 0; /* new dbdtper parameter for epigradopt */
int esprange_check = 0 ;
int espamp_check = 0 ;
int espopt = 1 ;
int espincway = 0 ;

int epigradopt_debug = 0;
int epigradopt_output = 0;
int disable_crc_check_for_esp = 0 ;

float dbdtperx = 0;
float dbdtpery = 0;
float dbdtperz = 0;

int max_dbdtper_hb_zblips = 1 
;


float scale_ramp = 1.0 ;

int debugTensor = 0 ;
int tensor_flag = 0 ;
int num_tensor = MIN_DTI_DIRECTIONS ;
int validTensorFile = 0; /* HCSDM00476194 */
int validTensorFileAndEntry = 0; /* HCSDM00476194 */
int num_B0 = 1 ;
int sep_time = 0 ;
int min180_echo_tim = 2000 ;
int min180_echo_tim2 = 2000 ;
int calc_bmatrix_flag = 0 ;
int bmax_fixed = 0;              /* maximum b-value given fixed diffusion timing */
int pgen_calc_bval_flag = 0 ;

int tensor_host_sort_flag = 0 ;
int tensor_host_sort_debug = 0;

int sse_manualte_derating = 1 ;
int sse_manualte_derating_debug = 0;

float spherical_derating_limit = 5.0 ;
/* BJM: added cv's for each axis */
int collect_six_sigma = 0;   /* flag to dump exact b-value calcs and errors */
float per_err_orig_x = 0.0;  /* Error between target bvalue  */
float per_err_orig_y = 0.0;  /* and integrated result before scaling the dif lobe amps */
float per_err_orig_z = 0.0;  
float per_err_corr_x = 0.0;  /* Error between target bval and integrated result */
float per_err_corr_y = 0.0;  /* after scaling dif lobe amps and using bistection */
float per_err_corr_z = 0.0;  /* Will be less than the specified tolerance */

int sse_enh = PSD_ON ;

int optimizedTEFlag = 0 ;

int act_numdir_clinical = MAX_DTI_LEGACY ;


/* BJM - added Maxwell compensation phase encode also */
int maxwell_flag = PSD_ON;    /* user variable for turning on maxwell correction (read) */	
int maxwell_blip = PSD_ON;    /* user variable for turning on maxwell correction (phase) */	
float B0_field = 0;         /* B0 field in Gauss */
float pw_gxw_MAX_l = 0;     /* total Maxwell timing for the left half of trapezoid */
float pw_gxw_MAX_r = 0;     /* total Maxwell timing for the right half of trapezoid */
float pw_gyb_MAX_l = 0;     /* total Maxwell timing for the left half of phase trapezoid */
float pw_gyb_MAX_r = 0;     /* total Maxwell timing for the right half phase trapezoid */
int max_debug=0;        /* print flag  */


int nodelay=0;                  
int nodelayesp=0;
int b0dither_new = 1 ;

int nob0dither=0;	        /* File existence flags for b0_dither.cal and delay.dat */
int nob0dither_interpo=0;       /* File existence flags for b0vectors.dat.body<head>.
				   b0vectors.dat.body<head> is created during the 
				   B0 dither calibration procedure. It holds the phase 
				   dither values for each axis for 30 different esp 
				   values. The epi psd reads this file to determine 
				   how much phase dither to apply to the receiver to 
				   count act the uncompensated short time constant 
				   B0 eddy current effects. */

				/* bcrvf1.dat: Created during Bandpass Asymmetry cal.
				   It comtains mag. and phase correction vector data 
				   that is applied to epi raw data after the first FFT 
				   to correct for mag. and phase asymmetries induced
				   by the 100kHz LPF in the faster receiver.

                                   bcrvs1.dat: Created during Bandpass Asymmetry cal.
                                   It comtains mag. and phase correction vector data 
                                   that is applied to epi raw data after the first FFT 
                                   to correct for mag. and phase asymmetries induced
                                   by the standard receiver 0. */

int nobcfile=0;		

int number_of_bc_files = 0;                  
int activeReceivers=-1;                  
int flagWarning = TRUE;


/* Main CVs for reduced FOV with 2DRF pulse feature control */
int rfov_flag = PSD_OFF ;
int rfov_type = 0 ;
int rfov_override = 0 ;
int rfov_cmplx_avg_flag = PSD_ON ;
int debug_rfov  = PSD_OFF ;

/* Prescan center frequency lower bounds on FOV and slice thickness */
float psminfov = 120 ;
float psminslthick = 10.0 ;
float temp_slthick = 10.0 ;

/* Overall max # of slices */
int rfov_maxnslices = DEFAULT_MAXNSLICES_RFOV;

/* Flip angle scaling, since pulse stretching is not permitted */
int rfov_fa_scaling_flag = 1;
float max_rfov_fa = 0;

/* dbdt checking */
float rfov_dbdtper  = 0.0 ;
int rfov_dbdt_debug = PSD_OFF ;

/* RF related CVs */
int start_rf1 = 0;
float thky_rf1 = 0;
float a_gyrf1 = 0;
int ia_gyrf1 = 0;
int pw_gyrf1 = 0;
int pw_gyrf1a = 0;
int pw_gyrf1d = 0;
int res_gyrf1 = 0;
int ia_thrf1 = 0;
int addrfdel = 0;

/* Gy refocusing area */
float area_gyex1 = 0.0;
int pw_gyex1_tot = 0;

/* CVs: for reading in external RF1 and gradient info */
int ex_res = 0;
int ex_pw = 0;
int ex_ttipdown = 0;
float ex_nom_flip = 0;
float ex_abswidth = 0;
float ex_effwidth = 0;
float ex_area = 0;
float ex_dtycyc = 0;
float ex_maxpw = 0;
float ex_max_b1 = 0;
float ex_max_int_b1_sqr = 0;
float ex_max_rms_b1 = 0;
float ex_a_gzs = 0;
float ex_nom_thkz = 0;
float ex_a_gys = 0;
float ex_nom_thky = 0;
float ex_maxnslices = 0;
int ex_num_gylobe = 0;
int ex_num_gzlobe = 0;
int ex_pw_gyrf1lobe = 0;
int ex_pw_rampy = 0;
int ex_pw_rampz = 0;
int ex_pw_constanty = 0;
int ex_pw_constantz = 0;
float ex_refocus_ratioy = 0;
float ex_refocus_ratioz = 0;
float ex_tbwy = 0;
float ex_tbwz = 0;
int freqSign_ex = 1;

/* CVs: image shifting */
float shift_to_freq = 0.0;
float y_shift = 0.0;
float y_to_freq = 0.0;
float z_shift = 0.0;
float z_to_freq = 0.0;

/* SVBranch HCSDM00155611 CVs: for SV Type I pulse */
int   type1_support       = 0 ;
int   type1_flag          = 0;
int   homogeneity_flag    = 0 ;  /*HCSDM00388769*/
float ex_a_gys_pos        = 0.0;
float a_gys_pos           = 0.0;
int   ia_gys_pos          = 0;
int   ex_pw_rampy_pos     = 0;
int   ex_pw_constanty_pos = 0;
/* actual excite pFOV / desired excite pFOV, 
   increase to get better profile */
float excite_ratio        = 1.0; 

/* CV: for walk sat */
int walk_sat_flag = 0;
int pw_wksat_tot = 0;
/* selective grad */
float a_gyrfwk   = 0.0;
int   ia_gyrfwk  = 0;
int   pw_gyrfwk  = 0;
int   pw_gyrfwka = 0;
int   pw_gyrfwkd = 0; 
/* spoiler */
int   pw_gwksp  = 0;
int   pw_gwkspa = 0;
int   pw_gwkspd = 0;
float a_gwksp   = 0.0;
int   pos_sp_wk = 0;
int   walk_sat_cycle = 16 ;
/* RF */
int   wg_rfwk        = 0;
int   res_rfwk_orig  = 0;
int   res_rfwk       = 0; 
int   pw_rfwk        = 0; 
int   hrfwka         = 0;
int   hrfwkb         = 0;
float flip_rfwk      = 90.0;  
int   bw_rfwk        = 0;
float cyc_rfwk       = 3.0; /* used in generating hadamard pulse */
float a_rfwk         = 0.0;
int   ia_rfwk        = 0;
int   ia_thrfwk      = 0;
int   pos_rfwk       = 0;
int   off_rfwk       = 0; /* Offset for the frequency bit array */ 
int   off_thrfwk     = 0; /* Offset for the frequency bit array */ 
float loc_satcen_cm  = 0.0;
float loc_satcen_Hz  = 0.0;
float sat_thk_factor = 0.4 ;
/* Hadamard */
float sep_sat_ratio = 0.0;

float rfov_max_freq_shift = 0.0 ;

/*****************************************/
int mux_flag = 0 ;
float mux_phase_step = 0;
int thetarf2_flag = 0 ;
int use_omegatheta = 1 ;
int omegatheta_pol = -1 ;
int rf2_isodelay= 0 ;

int mux_slquant = 1;

int res_thetarf2 = 0, res_gzrf2 = 0, pw_thetarf2 = 0, ia_thetarf2 = 0;
int ia_thetarf2left=MAX_PG_IAMP;
int ia_thetarf2right=MAX_PG_IAMP;

int pw_thetarf2a = 0;
int pw_thetarf2d = 0;

int pw_thetarf2left = 0;
int pw_thetarf2lefta = 0;
int pw_thetarf2leftd = 0;

int pw_thetarf2right = 0;
int pw_thetarf2righta = 0;
int pw_thetarf2rightd = 0;

int verse_rf2 = 1 ;
int sltune_rf2 = 0;

int mux_slices_rf2  = 2 ;
int phase_cycle_rf2 = PSD_ON ;
int mux_band_gap_warning_flag = PSD_ON;

/* CVs for multiplexed excitation pulses */
float tbwp_rf1 = 1.0 ;
int window_type_rf1 = 1 ;
float gauss_width_rf1 = 1.0 ;

int mux_slices_rf1 = 2 ;
float mux_slice_shift_mm_rf1 = 30.0 ;

/* save parameters to avoid recalculating waveforms unnecessarily */
int save_res_rf1 = 0;
float save_tbwp_rf1 = 0.0;
int save_window_type_rf1 = 0;
float save_gauss_width_rf1 = 0.0;
int save_mux_slices_rf1 = 0;
float save_mux_slice_shift_mm_rf1 = 0.0;
float save_thk_rf1 = 0.0;
int save_mux_mode_rf1 = 0;

int dwell_rf_rf1 = 2;

int debug_mux_rf = PSD_OFF ;

/* Flip angle scaling, since pulse stretching is not permitted */
int multiband_fa_scaling_flag = PSD_ON ;
float max_multiband_rf1_fa = 0.0;
float max_multiband_rf2_fa = 0.0;
float mux_rf1_scale = 1.0 ; 
float mux_rf2_scale = 1.0 ; 

/* FOV shift CVs */
int slice_fov_shift = 0 ;
int use_slice_fov_shift_blips = 1 ;
float slice_fov_shift_area = 0.0 ;
float slice_fov_shift_cycles = 0.0 ;
int slice_fov_shift_blip_start = 0 ;
int slice_fov_shift_blip_inc = 1 ;
float factor_gz1 = 1.0 ;
float gzb_amp = 0.0 ;
int slice_fov_shift_extra_gap = 0 ;
int slice_fov_shift_calc_new_esp = 0 ;
int slice_fov_shift_extra_gap_flag = 0 ;

float mux_min_verserf2_slthk = 1.0 ;

/**********************************************/

/* t1flair_stir */

int seqtime_t1flair = 0;
int act_ti = 0;
int dda_t1flair = 0;

int dummyslices = 0 ;

int autoti_model = T1FLAIR_EFFECTIVE_T1_MODEL ;

/* YT, GEHmr01540: In-range autoTR & autoTI support in T1FLAIR */
int t1flair_autotr_flag = PSD_ON;
int t2flair_autotr_flag = PSD_ON;

int t1flair_seqtime_method = ANALYTICAL_SEQTIME ;

int tmin_total_acq_seq = 0, tmin_total_ir = 0;
float dtr1_tolerance = 0;
float dtr2_tolerance = 0;
int max_slice_num_reduction = -1;
float t1flair_mint1 = 0, t1flair_mint2 = 0;
int avminti_t1flair = 0, avmaxti_t1flair = 0;

int debug_t1flairenh = PSD_OFF;
int t1flair_chop_flag = 0 ;
int req_edge_slice_enh_flag = 0 ;
int act_edge_slice_enh_flag = 0 ;
int t1flair_slice_uniformity_flag = 1 ;
int force_odd_even_slquant= 1 ;
int enht2flairacqs = 0;
int enht2flair_highsort = 0 ;
int avmintr_autotr_t1flair =1500000;
int incinv = 1; /* 1->increase inversion slice thicknes in T2FLAIR */


/* epi_t1flair_stir: to make it thru compilation */
int slquant_in_ti = 0;
int act_esp = 4000;
int autotr_flair_debug = PSD_OFF;

int T1FLAIR_MIN_TI = 50000;

/* MRIge70354 - Changed to 2000ms from 1300ms */
int T1FLAIR_MAX_TI = 2000000;

int ir_prep_manual_tr_mode = 0 ;


/* AssetCVs  inlined from Asset.e */
float asset_factor = 0.5 ;
float assetsl_factor = 1.0 ;
int assetph_flag = PSD_OFF ;
int assetsl_flag = PSD_OFF ;
int asset_supported_direction = ASSET_SUPPORT_PHASE 





;
/* HCSDM00363815 */
int fov_advisory_ignore_mslices = PSD_OFF ;

/* AssetCVs  inlined from Asset.e */

/* ARCCV  inlined from ARC.e */
int   arc_research_flag = 0 ;
int   arc_split_method  = 0 ;  
int   arc_fullbam_flag  = 1 ;  

int   arc_extCal        = 0 ;

/* ARC phase acceleration CVs */
int   arc_ph_flag       = 0   ;  
float arc_ph_factor     = 1.0 ;
float arc_ph_maxstride  = 1.0 ;
float arc_ph_recstride  = 1.0 ;
float arc_ph_userstride  = 1.0 ;
int   arc_ph_stride     = 1 ;
float arc_ph_maxnetaccel = 1.0 ;
float arc_ph_recnetaccel = 1.0 ;
int   arc_ph_acs        = 12  ;
int   arc_ph_acs_min    = 12  ;
int   arc_ph_fullencode = 256 ;     
int   arc_ph_spanned    = 256 ; 
int   arc_ph_acquired   = 128 ; 
int arc_ph_intaccel  = 1 ;

/* ARC 1/2 NEX CVs */
int   arc_ph_halfnex    = 0 ;
int   arc_ph_hnover     = 0 ;
int   arc_ph_minover    = 8 ;

/* ARC slice acceleration CVs */
int   arc_sl_flag       = 0   ;  
float arc_sl_factor     = 1.0 ;
float arc_sl_maxstride  = 1.0 ;
float arc_sl_recstride  = 1.0 ;
float arc_sl_userstride  = 1.0 ;
int   arc_sl_stride     = 1   ;
float arc_sl_maxnetaccel = 1.0 ;
float arc_sl_recnetaccel = 1.0 ;
int   arc_sl_acs        = 12  ;
int   arc_sl_acs_min    = 12  ;
int   arc_sl_fullencode = 128 ;     
int   arc_sl_spanned    = 128 ; 
int   arc_sl_acquired   = 64  ; 
int arc_sl_intaccel  = 1 ;

/* ARC partial Fourier CVs */
int   arc_sl_halfnex    = 0 ;
int   arc_sl_hnover     = 0 ;
int   arc_sl_minover    = 8 ;
float arc_sl_fn         = 1.0 ;
int   arc_kx_peak_pos   = 0 ;
int   arc_ky_peak_pos   = -1 ;

int arc_syn_pts = 0 ;

int ARCKey = 0;

/* ARCCV  inlined from ARC.e */


int readmonloc = 0; /* Read from /tmp/monloc.dat */
int loopdelay = 1000000 ;
int loopdelay2 = 100000 ;
int navgs = 20 ;
float sigma1 = 5.0  ;
float sigma2 = 1.0  ;
int savedata = 1 ;
int max_avg_time = 40000000 ;
float monloc_shift = 0.0 ; 
int tracker_quant = 0 ;

int acq_data_only = 0 ;

int mon_tr = 20000 ;
int smartprep_flag = 0 ;
int min_delay_time = 0 ;
int num_audibles = 2 ;
int audible_loop = 16; /* audible loop size */
int data_type = 1 ;
int save_fft = 0;

/* NAV */
int swap_monplane = 0 ;
int swap_mon_zy = 0 ;
int detector_mode = 0 ;
float fov_factor = 1.0 ;
int nav_angle_adj = 0 ;
float mon_angle = 0.0 ;
float nav_tipup_ratio = 2.0 ;

/* CYL */
int cylr_rf_type = 0 ;
int pw_rfcylr = 0,ia_rfcylr = 0;
float a_rfcylr = 0;
int pw_thcylr = 0,ia_thcylr = 0;
float a_thcylr = 0;
int pw_gycylr = 0,ia_gycylr = 0;
float a_gycylr = 0;
int pw_gzcylr = 0,ia_gzcylr = 0;
float a_gzcylr = 0;
int pw_rfcylrtipup = 0,ia_rfcylrtipup = 0;
float a_rfcylrtipup = 0;
int pw_thcylrtipup = 0,ia_thcylrtipup = 0;
float a_thcylrtipup = 0;
int pw_gycylrtipup = 0,ia_gycylrtipup = 0;
float a_gycylrtipup = 0;
int pw_gzcylrtipup = 0,ia_gzcylrtipup = 0;
float a_gzcylrtipup = 0;

float min_delay_sec = 0;
int delay_dda = 0;
int delay_quiet_dda = 0;
int total_quiet_dda = 0; /*MRIhc05287*/
int rtpend_quiet_dda = 0 ; /*MRIhc05287*/
int delay_quiet_time = 0;
int debug_monrot=0;
int debug_monrotphi=0;
int debug_monloc=0;
int transpose_monloc = 0;
int write_spinfo = 0;
int oblique_monplane=0;
int monitor_axis = 0;
float theta = 0;
int ta_180sp = 0, tb_180sp = 0,te_180sp = 0;
int min_montr = 0,tlead_monitor = 0,tlead_montipup = 0,mon_ssi_time = 0;
int non_tetime_mon = 0, tmin_mon = 0, tmin_montipup = 0;
int rda_mon = 0;

int minseqcoilmon_t = 0; 
int minseqgrddrvmon_t = 0;
int minseqgrddrvxmon_t = 0;
int minseqgrddrvymon_t = 0; 
int minseqgrddrvzmon_t = 0; 
int minseqcablemon_t = 0;
int minseqbusbarmon_t = 0;
int max_seqsarmon = 0;
int min_seqrfampmon = 0;

/* obloptimize */
int monnewgeo = 1;
int monobl_debug = 0 
;
int monobl_method = 1 
;

int monitor_page = 1 ;


float monave_sar = 0, monpeak_sar = 0;	  /* sar values based on monitor sequence */
float moncave_sar = 0;                /* Coil SAR */

/* localized monitor excitation control variables */

int mon_xres = 128 ;
float rf1mon_shift = 0.0 ;
float rf2mon_shift = 0.0 ;
int bw_rf1mon = 0, bw_rf2mon = 0, bw_rfmontipup = 0;
float mon_fov = 200.0 ;
float mon_acqfov = 200.0 ;
float echo1monbw = 0;
float mon_vthickz = 40.0 ;
float mon_vthicky = 40.0 ;
float mon_vthick = 40.0 ;
float area_gzkmon = 2500.0 ;
float area_gzkmontipup = 2500.0 ;
int mon_fcomp = 1 ;
float fnecho_frac = 0.6 ;
int monitor_test = 0;
int get_fullecho = 0;
int numpts2pass = 0;

int reverse_views = 0 ;
int mon_trigger_delay = 0;
int smartprep_was_on=0;
float scanclocktime = 0;
int mon_dabdelay = 1000;
int xres2use = DEFAULT_FFT_LENGTH;
int num_avg_bline = NUM_AVG_BLINE;
int num_throwaways = NUM_THROWAWAYS;
int num_baseline_pts = (NUM_AVG_BLINE + NUM_THROWAWAYS);

float tmpbw1 = 0;
/* FOR MERGE */
int debug_sp_rtp = 0;
int debug_sp_agp = 0;

/* Updating receiver port variables */
int cerdtype = 002 ;

int mon_run_setrcvportimm = 1 ;

/* SmartPrep debug cvs */
int sprep_save_raw_data = 0 ;
int sprep_debug_flag = 0 ;
int sprep_timing_flag = 1 ;

/* TR of wait pulse for Navigator feedback */
int rtpresultwait = 1000;

int navend_time = 20000 ;
int nav_dual_mode = 1 ;

int nav_irprep_flag = 0 ;
int nav_tseq_irprep = 0 ;
int nav_min_tseq_irprep = 0 ;

int pw_nomcyl = 5500  ;
float a_nomcyl = 1.44 ;

int smartPrepEdrFlag = 1 ;

int slabtracking_flag = 0 ;
int corr_mode = 2 
;

float corr_factor_z = 1.0 
;
float corr_factor_y = 1.0 
;
float corr_factor_x = 1.0 
;

int corr_x = 1 
;
int corr_y = 1 
;
int corr_z = 1 
;



/* 2009-Mar-10, Lai, GEHmr01484: In-range autoTR support */
int fixed_acqs_debug = DEBUG_NONE ;
int sl_acq      = 1 ;
int sl_acq_val2 = 1 ;
int sl_acq_val3 = 1 ;
int sl_acq_val4 = 1 ;
int tr_acq      = 10000 ;
int tr_acq_val2 = 10000 ;
int tr_acq_val3 = 10000 ;
int tr_acq_val4 = 10000 ;
int tr_limit = 30 ;
int temp_trval =10000 ;
int temp_tmin_total = 1000 ;
int keep_opti = 0;


/*RTB0 correction*/
/*MF B0 correction: add mode for integrated b0 corr into ref scan*/
int rtb0_flag = 0 ;
int rtb0_enable = 0 ;
int rtb0_support = 0 ;
int rtb0_first_skip = 20 ;
int rtb0_last_skip = 20 ;
int rtb0_movAvg = 5 ;
int rtb0_min_points = 10 ;
int rtb0DebugFlag = PSD_OFF;
int rtb0SaveRaw = PSD_OFF;
int rtb0_phase_method = 1 ;
int rtb0_coil_combine = 1 ;
int rtb0_timing_flag = PSD_OFF ;

/*PG timing related*/
int rtb0dummy_time = 1200000;
int rtb0fittingwaittime = 1000000;
int rtb0resultwaittime = 1000;
int rtb0fittingwaittimeLoop = 1; /*number of fitting time to play*/
int rtb0dummyseq = 1 ;

/*RTB0 compensation & debug flags*/
int rtb0_comp_flag = 0 ;
int rtb0_acq_delay = 0 ;
int rtb0_minintervalb4acq = 0;
int rtb0_r1_delta = 2 ;
int pw_dynr1=4;
int rtb0_filter_cf_flag = 1 ;
int rtb0_recvphase_comp_flag = 0 ;
int rtb0_comp_debug_flag = 0 ;
float rtb0_cfoffset_debug = 0.0;
int rtb0_slice_shift = 0 ;/*???*/

/*RTB0 weighted fit related*/
int cf_interpolation = 4 ;
float rtb0_max_range = 300.0 ;
int rtb0_rejectnoise = 1 ;
int rtb0_smooth_kernel_size = 9 ;
int rtb0_smooth_cf_flag = 0 ;
int rtb0_median_kernel_size = 3 ;
int rtb0_min_kernel_keep_edge = 1 ;
float rtb0_max_kernel_percent = 50.0 ;
int rtb0_max_kernel_keep_edge = 1 ;
int rtb0_confidence_method = 1 ;
float rtb0_cfstddev_threshold    = 100.0 ;
float rtb0_cfresidual_threshold  = 100.0 ;
float rtb0_confidence_thresh_val = 100.0 ;
int rtb0_gzrf0_off = 1 ;
int rtb0_spsp_flag = 0 ;
int rtb0_dda = 0 ;
int rtb0_debug = 0 ;

/*RTB0 from epi.e*/
int rtb0_midsliceindex = -1 ;
float rtb0_outlier_threshold = 10.0 ;
float rtb0_outlier_duration = 30.0 ;
int rtb0_outlier_nTRs = 0;


/* HCSDM00361682 */
int focus_eval_oscil = 0 ;
int focus_eval_oscil_hist = 0 ;
int isPredownload = 0 ;
int keep_focus_eval_oscil = 0 ;
int reset_oscil_in_eval = 0 ;
int force_acqs = 0 ;
int force_avmaxslquant = 0 ;
int oscil_eval_count = 0;
int optr_save = 0 ;
int opslquant_save = 0 ;
int save_avmintr = 0;
int save_pitracqval4 = 0;

/* external waveforms for qti granty 9/28/2017 */
int res_gd1 = 0; /* number of points in the diffusion waveform before refocusing pulse */
int res_gd2 = 0; /* number of points in the diffusion waveform after the refocusing pulse */

int pw_gd1 = 0;
int pw_gd2 = 0;


float a_gxdl = 0;
float a_gxdr = 0;

int ia_gxdl = 0;
int ia_gxdr = 0;

int res_gxdl = 0;
int res_gxdr = 0;

int pw_gxdr = 0;
int pw_gxdl = 0;

int wg_gxdr = 0 ;
int wg_gxdl = 0 ;
/* Y-diffusion pulses */
float a_gydl = 0;
float a_gydr = 0;

int ia_gydl = 0;
int ia_gydr = 0;

int res_gydl = 0;
int res_gydr = 0;

int pw_gydr = 0;
int pw_gydl = 0;

int wg_gydr = 0 ;
int wg_gydl = 0 ;

/* Z-diffusion pulses */
float a_gzdl = 0;
float a_gzdr = 0;

int ia_gzdl = 0;
int ia_gzdr = 0;

int res_gzdl = 0;
int res_gzdr = 0;

int pw_gzdr = 0;
int pw_gzdl = 0;

int wg_gzdr = 0 ;
int wg_gzdl = 0 ;

/* keep support routines happy */
float a_gxdla = 0;
float a_gxdld = 0;
float a_gxdra = 0;
float a_gxdrd = 0;
int ia_gxdla = 0;
int ia_gxdld = 0;
int ia_gxdra = 0;
int ia_gxdrd = 0;
int pw_gxdla = 0;
int pw_gxdld = 0;
int pw_gxdra = 0;
int pw_gxdrd = 0;

float a_gydla = 0;
float a_gydld = 0;
float a_gydra = 0;
float a_gydrd = 0;
int ia_gydla = 0;
int ia_gydld = 0;
int ia_gydra = 0;
int ia_gydrd = 0;
int pw_gydla = 0;
int pw_gydld = 0;
int pw_gydra = 0;
int pw_gydrd = 0;

float a_gzdla = 0;
float a_gzdld = 0;
float a_gzdra = 0;
float a_gzdrd = 0;
int ia_gzdla = 0;
int ia_gzdld = 0;
int ia_gzdra = 0;
int ia_gzdrd = 0;
int pw_gzdla = 0;
int pw_gzdld = 0;
int pw_gzdra = 0;
int pw_gzdrd = 0;


/* MRIhc09116 */
int num_passdelay = 1 ;

int use_maxloggrad = 0 ;
int max_grad = 0;
float scale_dif = 0.0;

int debug_core = 0 ;
int debug_unitTest = 0 ; /*RTB0 correction*/

/* SXZ::MRIge72411: top area vs. total area ratio */
float taratio = 0.0 ;
int rampopt = 1 ;

/* SXZ::MRIge72411: following cvs show useful info */
float totarea = 0;       /* G*usec/cm */
float actratio = 0;

/* internref: internal reference scan */
int dpc_flag = 0 ;
int sndpc_flag = 1 ;
int iref_etl = 0 ;
int iref_frames = 0;
int tot_etl = 1 ;
int pw_gxiref1_tot = 0;
int pw_gxiref_tot = 0;
int pw_gxirefr_tot = 0;

int MinFram2FramTime =  30  ;

int maxslice_per_ti = 0 ;
int invseqtime = 0;

int false_acqs = 0;         /* psuedo acquisitions for flair slice ordering */
/* number of slices in first psuedo pass for flair */
int false_slquant1 = 1 ;  
int max_slice_ti = 0;        /* maximum # slices that can fit in ti */
int flair_min_tr = 10000000;  /* minimum TR for flair option */
int dda_packb = 0, dda_pack = 0, dda_packe = 0; /*range of false_acqs for disdaq loop */
int dda_passb = 0, dda_pass = 0; /* range of act_acqs for disdaq loop */
int deadlast = 0;            /*deadtime for last slice in pack */
int tmp_deadlast = 0;        /* extra time to be added to scan time  */

float phase_dither = 0.0 ;
int spgr_flag = 0 ;

int rhhnover_max = 0;	 /* Maximum allowed rhhnovers due to physical space on the boards */
int rhhnover_min = 16;   /* minimum number of overscans *//*LX - 8*/
int rhhnover_min_per_ilv = 16;   /* minimum number of overscans per shot */
int newyres= 0;		 /* New yres if opnshots/opte/opyres is incompatible. */
int num_overscan = 8;    /* BJM: this was added for multi-shot EPI */

int smart_numoverscan = 1 ;

int avmintefull = 0 ;   
int cvrefindex1 = 0;
float gx1_area = 0;
int avmintetemp = 0; 

int fast_rec = 0 
;

/* Given n baselines, use bl_acq_tr1 for first n-1 baselines, bl_acq_tr2
   for nth baseline.  This is to minimize baseline acq. time while
   avoiding sequence preparation failures for the scan that follows. */

int bl_acq_tr1 = 1000 ;
int bl_acq_tr2 = 300000 ;

float fecho_factor = 0; /*SNR*/
float tsp   =  2.0 ;
int intleaves =  1 ;

int ky_dir = 2 ;
int kx_dir = 0 ;

int dc_chop   =  1 ;
/*	  0 = same start polarity (+) for all intleaves.
 	  1 = odd intleaves start +, even start -
 	  2 = 1st half of intleaves start +, second half interleaves start -
 	  3 = 1st & 3rd quarters start +, 2nd & 4th quarters start -.  */


int etot = 0 ;
int emid = 0 ;
int e1st = 0 ;

int seq_data  = 0 ;

float msamp = 0.0 ;
float dsamp = 0.0 ;
float delpw = 0;

int num_dif=0 ; /*MRIhc05854*/
int incr = 0 ;
int df_encode = 0 ;
int i_bval = 0 ;
int df_refscn = 0 ;
int dwi_fphases = 0;
int max_slice_dfaxall = 256; /* YMSmr06650 */
int dualspinecho_flag = 0 ;

/* BJM: USER CV's for DW-EPI in NO */
int derate_amp = 1 ;
/* MRIge58521 */
float scale_difx = 1.0 ;
/* MRIhc05854*/
float scale_dify = 1.0 ;
float scale_difz = 1.0 ;
int unbalanceCrusher = 1 ;
float crusherFactorLeft = 1.0 ;
float crusherFactorRight = 2.0 ;

/* for 3in1, tetrahedral and gradient optimization for diffusion ALL if needed */
int invertSliceSelectZ = 0 ;
/* for S/I, A/P, R/L, Slice, and ALL */
int invertSliceSelectZ2 = 0 ;

/* MRIhc05227 Flags for X and Y crushers on left and right 180s */
int xygradRightCrusherFlag = 0 ;
int xygradLeftCrusherFlag = 0 ;
int xygradCrusherFlag = 0 ;

/* MRIhc49589 */
int invertCrusherXY = 0 ;

int ssgr_mux = 0 ;
int ssgr_flag = 0 ;
int ssgr_bw_update = 0 ;
int freqSign_rf2right = 1;
int freqSign_rf2left = 1;
int freqSign_rf2 = 1;
float fat_cs = 220.0; /* fat offset in Hz on 1.5T */
float rf1_bw_ratio = 2.0;  /* relative to fat offset */
float rf2_bw_ratio = 2.0;  /* relative to fat offset */
float b0_offset = 100.0; /* in Hz */

/* MRIhc05259 Bookkeeping for additional time caused by X, Y crushers */
int RightCrusherLSlop = 0 ; 
int RightCrusherRSlop = 0 ; 
int LeftCrusherLSlop = 0 ; 
int LeftCrusherRSlop = 0 ;
int CrusherRSlop = 0 ;
int CrusherLSlop = 0 ;

int epi2spec_mode = 0 ;

int weighted_avg_grad = 1 ;
int weighted_avg_debug = 0 ;


float DELTAx = 0;
float DELTAy = 0;
float DELTAz = 0;

float deltax = 0;
float deltay = 0;
float deltaz = 0;

/***********************************************************************************/
/*      eddy correction variables for Zhou cross term correction                   */
/***********************************************************************************/

float a_gx_dwi=0.0000;
                        /* the read-out gradient correction value in Gauss/cm */

float a_gy_dwi = 0.0000 ;
                         /*encoding direction.  unit: g/cm.ms */
float a_gz_dwi = 0.0000 ;
                         /*encoding direction.  unit: g/cm.ms */

float freq_dwi = 0.0 ;
                      /* the B0 freq. correction value unit: Hz */
 
float phase_dwi = 0.0 ;
                      /* the B0 phase correction value unit: radian */

int ia_gx_dwi = 0;
int ia_gy_dwi = 0;
int ia_gz_dwi = 0;

int dwicntrl=0;                /*control cvs for dwicorrcal    */
int dwidebug=0;                /*control cvs for dwicorrcal    */
int tmp_ileave = 0;
int tmp_ygrad_sw = 0;
float t4_tmp = 0;
/***********************************************************************************/



float incdifx = 1.0 ;
float incdify = 1.0 ;
float incdifz = 1.0 ;
int ia_incdifx = 0, ia_incdify = 0, ia_incdifz = 0;
int waveform_type = 0; /* specifies whether to play isotropic or linear encoding */
float ide_max_bval = 2500; /* s/mm^2 b-value of ide waveform at full gradient amplitude */
float sde_max_bval = 11344; /* b-value of sde waveform at full gradient amplitude */ 

float bincr = 0; /* increment of b-value for each repetition */
float invthick = 1.0; /* thickness of inversion slice */
float xerror = 0, yerror = 0, zerror = 0;

/* Obl 3in1 opt */
int obl_3in1_opt_debug
  = 0 ;
int obl_3in1_opt
  = 0 ;
float norot_incdifx = 0;
float norot_incdify = 0;
float norot_incdifz = 0;
float target_mpg_inv = 0;
float target_mpg = 0;
float amp_difx_bverify = 0,amp_dify_bverify = 0,amp_difz_bverify = 0;

int different_mpg_amp_flag = 0;

int act_acqs = 1;               /* true number of passes needed; acts/packs */
int min_acqs = 0;                   /* min number of acqs; insure inv thickness */
int maxslq_titime = 0;              /* time in opti time available to interleave sliles */
int maxslq_ilir = 0;

int epi_flair = 0 ;		
int flair_flag = PSD_OFF; /* pass_rep specific flag for flair inversion */
float dda_fact = 0;       /* multiplier to correct scan time for lack of disdaqs durring dwi and flair  */
 
/* Number of repeated scans at each slice */ 
int reps        = 1 ;
int pass_reps   = 1 ;
int max_dsht    = 7 ;
int avg_at_loc  = 0 ;

int filtfix = 0 ;
int rf_chop = 1 ;

 /*spsp*/
int rftype = 1 ;
int thetatype = 0 ;
int gztype = 1 ;

int hsdab   = 1 ;
int slice_num = 1 ;
int rep_num = 1 ;

int endview_iamp = 0;  /* end instruction phase amp */
int endview_scale = 0; /* ratio of last instruction amp to maximum value */

int gx1pos   = 1 ;
int gy1pos   = 1 ;

int eosxkiller  = 0 ;
int eosykiller  = 1 ;
int eoszkiller  = 1 ;
int eoskillers  = 1 ;
int eosrhokiller  = 1 ;

int gyctrl = 1 ;
int gxctrl = 1 ;
int gzctrl = 1 ;

int ygmn_type = 0;   /* specifies degree of FC on Y */
int zgmn_type = 0;   /* specifies degree of FC on Z */

int   rampsamp  = 0 ;
int   final_xres = 0 ;
int   autovrgf = 1 ;
float vrgf_targ = 2.0 ;
int vrgf_reorder = 1 ;

float fbhw = 1.0 ;

/* Note this should always be ZERO for MGD */
int osamp = 0 ;

int etl = 1 ;
int eesp = 0 ;
int nblips = 0, blips2cent = 0;   /* total number of blips and number of blips
							  to the center of ky offset */
int ep_alt = 0 ;

int tia_gx1 = 0, tia_gxw = 0, tia_gxk = 0;  /*temp internal amps that flip in polarity*/
int tia_gxiref1 = 0, tia_gxirefr = 0;
float ta_gxwn = 0; /* temp value for negative a_gxw value */
float rbw = 0; /* in Hz */
int   avminxa = 0, avminxb = 0, avminx = 0, avminya = 0, avminyb = 0, avminy = 0;
int   avminza = 0, avminzb = 0, avminz = 0, avminssp = 0;
float avminfovx = 0, avminfovy = 0;

int   hrdwr_period =  4   ;
int   samp_period = 8   ;
int   pwmin_gap = 2*4; /*=2*GRAD_UPDATE_TIME*/

float frqx = 200.0 ;
float frqy = 2.0   ;

int dacq_offset = 14   ;

int   pepolar = 0 ;
int rpg_flag = 0 ;
/* We have rpg_in_scan_flag here because rpg_flag can potentially have more choices */
int rpg_in_scan_flag = 0 ;
/* In case of DWI with zero T2s, we add two shots for one reverse and one forward */
int rpg_in_scan_num = 1 ; 

int   tdaqhxa = 0, tdaqhxb = 0;
int   xdiff_time1 = 0, xdiff_time2 = 0;
int   ydiff_time1 = 0, ydiff_time2 = 0;
int   zdiff_time1 = 0, zdiff_time2 = 0;
float delt = 0;

/* ASPIR auto TI model */
int T1eff = 0;
float bcoeff = 0;
int aspir_auto_ti_model = 0;

/* sliding data acquisition window control: */
int   tfon = 1 ;

int   fract_ky = 0 ;
float ky_offset = 0.0 ;
float gy1_offset = 0.0 ;

/* needed for Inversion.e */
int satdelay = 0000 ;

int   td0       = 4 ;
int   t_exa     = 0 ;
int   te_time   = 0 ;
int   pos_start = 0 ;
int   pos_start_init = 0 ; /* HCSDM00361682 */
int   post_echo_time = 0 ;
int   psd_tseq = 0 ;
int   time_ssi  = 1000   ;

float dacq_adjust = 0.0 ;

int   watchdogcount = 10 ;
int   dabdelay = 0 ;
int   tlead     = 25   ;
int   act_tr    = 0 ;
int   rfconf    = ENBL_RHO1 + ENBL_THETA + ENBL_OMEGA + ENBL_OMEGA_FREQ_XTR1;
int   ctlend = 0 ;
int dda = 0 ;/*LX - short to int*/
int debug = 0 ;
int debug_dbdt = 0 ;
int debugipg = 0 ;
int debugepc = 0 ;
int debugdither = 0 ;
int debugdelay = 0 ;
int dex = 0 ;
int   gating = 0 ;
int   ipg_trigtest = 1 ;

int   gxktime = 0 ;
int   gyktime = 0 ;
int   gzktime = 0 ;
int   gktime = 0 ;
int   gkdelay = 100   ;

float scanbw = 62.5 ;
int   scanslot = 0 ;/*LX - 4 in epi2*/

/* temp crusher amplitudes */
float a_lcrush_cfh = 0;              /* amp of left crush */
float area_gxw = 0;                  /* readout pulse area of constant portion */
float area_gx1 = 0;                  /* readout dephaser pulse area */
float area_readramp = 0;             /* area of left readout ramp */
float area_r1 = 0, area_gz1 = 0, area_gzrf2l1 = 0, area_r1_cfh = 0; 
float area_std = 0, area_stde = 0;       /* crusher calcs */

/* gradient echo refocus */
int avail_pwgz1 = 0;		/* avail time for gz1 pulse */

int   prescan1_tr = 2000000 ;
int ps2_dda     =  0 ;
int   avail_pwgx1 = 0;               /* avail time for gx1 pulse */
int   avail_image_time = 0;          /* act_tr for norm scans*/
int   beg_nontetime = 0;             /* effect time zero of 90 rf pulse */
int   pos_start_rf0 = 0;             /* time of start of inv pulse */
int   beg_nontitime = 0;             /* effect time zero of inv pulse */
int   avail_se_time = 0;		 /* tr - inversion times */
int   avail_tdaqhxa = 0;             /* available time for sampling prior
									to te point */
int   full_irtime = 0;                 /* ti - lead time difference of se and inv sequence */
int   avail_yflow_time=0;        /* time available for gymn1, gymn2 pulses */
int   avail_zflow_time = 0;          /* time available for gz1, gzmn pulses */
int   nviews = 0;                    /* # views in readout train prior to te point */

int test_getecg = 1;
int premid_rf90 = 0 ;

float c1_scale = 0, c2_scale = 0;        /* crusher ratio */
float crusher_cycles = 4.0;

/*    min sequence times based on coil heating */
int   max_seqtime = 0;               /* nax time/slice for max av panel routines */
int   max_slicesar = 0;              /* min slices based on sar */
int   max_seqsar = 0;
float myrloc = 0 ;
int   other_slice_limit = 0;         /* temp av panel value */

float target_area = 0;      /* temp area */
float start_amp = 0;       /* temp amp */
float end_amp = 0;         /* temp amp */

int pre_pass  = 0 ;
int nreps     = 0 ;

/* Scaling CVs */
float xmtaddScan = 0;

/* needed for Inversion.e */
float rfscale = 1.0 ;

/* Offset from end of excitation pulse to magnetic isocenter */
int rfExIso = 0;

/* CV's for echo train phase correction */
int frq2sync_dly = 9 ;
float rf1_phase = 0 ;
float rf2_phase = 0 ;
int hrf1a = 0, hrf1b = 0;               /* location of rf1 center */
int hrf2a = 0, hrf2b = 0;               /* location of rf2 center */

/* Inner volume flag */
int innerVol = 0 ;
float ivslthick = 5 ;

/* These CVs are used to override the triggering scheme in testing. */
int psd_mantrig = 0 ;
int trig_mps2 = TRIG_LINE ;
int trig_aps2 = TRIG_LINE ;
int trig_scan = TRIG_LINE ;
int trig_prescan = TRIG_LINE ;
int read_truncate = 1 ;

int tmin_flair = 0;		/* tmin used for maxslquant when flair is used */
int trigger_time = 0 ;
int use_myscan = 0 ;

/* needed for Inversion.e */
int t_postreadout = 0;

int initnewgeo = PSD_ON;    /* force obloptimize_epi() call in cvinit */
int obl_debug = 0 ;
int obl_method = 1 ;
int debug_order = 0 ;
int debug_tdel = 0 ;
int debug_scan = 0 ;
int postsat = 0;
int order_routine = 0 ;
int scan_offset = 0;		 /* adds 'x' mm to all scan locations */

int dither_control = 0;		 /* 1 means turn dither on  */
int dither_value = 0 ;

int slquant_per_trig = 0 ;

int non_tetime = 0;                  /* time outside te time */
int slice_size = 0;                  /* bytes per slice */
int max_bamslice = 0;                /* max slices that can fit into bam */

/* Switch for RF 2 pulse shape */
int rf2PulseType = 0;

int bw_rf1 = 0, bw_rf2 = 0;      /* bandwidth of rf pulses */

/* x dephaser attributes */
float a_gx1 = 0;
int ia_gx1 = 0;
int pw_gx1a = 0;
int pw_gx1d = 0;
int pw_gx1 = 0;
int single_ramp_gx1d = 0;      /* "bridge" decay ramp of gx1 into echo train */

/* y dephaser attributes */
float area_gy1 = 0;

/* Blip attributes */
float area_gyb = 0;

/* Omega Pulse Attributes */
float a_omega = 0;
int ia_omega = 0;

float bline_time = 0;  /* time to play baseline acquistions */
float scan_time = 0;   /* time to play out scan (without burst recovery) */
float t1flair_disdaq_time = 0.0; /* time for t1flair disdaq */

int pw_gx1_tot = 0;
int pw_gy1_tot = 0;
int pw_gymn1_tot = 0, pw_gymn2_tot = 0;
float gyb_tot_0thmoment = 0;
float gyb_tot_1stmoment = 0;

int pw_gz1_tot = 0;
int pw_gzrf2l1_tot = 0;
int pw_gzrf2r1_tot = 0;
int pw_gzrf2l1_tot_bval = 0;
int pw_gzrf2l2_tot_bval = 0; /*MRIhc05259 added to include l2 crusher time*/
int pw_gzrf2r1_tot_bval = 0;
int pw_gzrf2r2_tot_bval = 0;

int dab_offset = 0;
int xtr_offset = -56;
int rcvr_ub_off = -100;  /* receiver unblank offset from beg of echo0000 packet */

int temprhfrsize = 0;

int pw_wgxdl = 0;
int pw_wgxdr = 0;
int pw_wgydl = 0;
int pw_wgydr = 0;
int pw_wgzdl = 0;
int pw_wgzdr = 0;

/* DTI BJM: dual spin echo (dsp) */
int pw_wgxdl1 = 4;
int pw_wgxdr1 = 4;
int pw_wgydl1 = 4;
int pw_wgydr1 = 4;
int pw_wgzdl1 = 4;
int pw_wgzdr1 = 4;

int pw_wgxdl2 = 4;
int pw_wgxdr2 = 4;
int pw_wgydl2 = 4;
int pw_wgydr2 = 4;
int pw_wgzdl2 = 4;
int pw_wgzdr2 = 4;
/* end dsp changes */

/* variables used in gradient moment nulling */
float zeromoment = 0;
float firstmoment = 0;
float zeromomentsum = 0;
float firstmomentsum = 0;
int pulsepos = 0;
int invertphase = 0;

float xtarg = 1.0 ;
float ytarg = 1.0 ;
float ztarg = 1.0 ;

int ditheron = 1 ;
float dx = 0.0 ;
float dy = 0.0 ;
float dz = 0.0 ;

/* Used by dwepiq tool */
int b0calmode = 0 ;
/* Slice reset - ability to perform multi-slice scans all at a single location.  Needed for testing. */
int slice_reset = 0 ;
float slice_loc = 0.0 ;

int delayon = 1 ;

/* Gradient Delays */
int   gxdelay = 0   ;
int   gydelay = 0   ;

/* Logical Delays */
float gldelayx = 0   ;
float gldelayy = 0   ;
float gldelayz = 0   ;
float pckeeppct = 100.0 ;
int pkt_delay = 0   ;

/* multi-phase */
int mph_flag = 1 ;
int acqmode = 0 ;
int max_phases  = 0;
int opslquant_old = 1 ;
int piphases  = 0;

/* echo spacing and gap */
int reqesp = 0 ;
int autogap = 0 ;
int minesp = 0;

/* reduced image size */
int fft_xsize = 0 ;
int fft_ysize = 0 ;
int image_size = 0 ;
             
/* off-center FOV control */
float xtr_rba_time = XTRSETLNG + XTR_TAIL ;
float frtime = 0.0 ;
int readpolar = 1 ;
int blippolar = 1 ;

/* ref scan control */
int ref_mode = 1 ;
int refnframes = 256 ;

/* ref correction */
/* This variable is pass to epiRecvFrqPhs() and enables/disables the freq offset in the */
/* receiver (to offset the FOV) for ref scanning */
int ref_with_xoffset = 1 ;
int noRefPrePhase = 0 ;
int setDataAcqDelays = 1 ;
int refSliceNum = -1 ;

int core_shots = 0;
int disdaq_shots = 0;
int pass_shots = 0;
int passr_shots = 0;
int pass_time = 0;    /* total time for pass packets */
int scan_deadtime = 0; /* deadtime in scan entry point */

int pw_gxwl1 = 0;
int pw_gxwl2 = 0;
int pw_gxwr1 = 0;
int pw_gxwr2 = 0;
int pw_gxw_total = 0 ;

int pass_delay = 1   ;

int nshots_locks  = 0 ;
int min_nshots = 1 ;
int max_nshots = 1 ;

/* phase-encoding blip oblique correction (for oblique scan planes) cvs */
float da_gyboc = 0.0 ;

/*Ghosting lower with oc_fact of 2 - VB */
float oc_fact = 2.0 ;
int oblcorr_on = 0 ;

/* default oblcorr_perslice off because ipg sequence update times become
   prohibitively long when updating blip instruction amplitudes on a per-slice
   basis */
int oblcorr_perslice = 0 ;
int debug_oblcorr = 0 ;
float bc_delx = 0.0 ;
float bc_dely = 0.0 ;
float bc_delz = 0.0 ;
int   cvxfull = MAX_PG_IAMP;
int   cvyfull = MAX_PG_IAMP;
int   cvzfull = MAX_PG_IAMP;

/* cvs for modified rbw annotation for vrgf */
/* Deleted the definition of 3 unused CVs. ufi2_ypd */
float bw_flattop = 0;
float area_usedramp = 0;
float pw_usedramp = 0;
float area_usedtotal = 0;

int EZflag = PSD_OFF ;

/* Omega Scale (8 bit shift = 256)*/
float omega_scale= 256.0 ;
int rba_act_start = 0;

/* APS2 rsp settings */
int aps2_rspslq = 0;
int aps2_rspslqb = 0;

/* Value1.5T May 2005 KK */
int ghost_check = 0 ;
int gck_offset_fov = 1 ;

/* IR Prep Support Jun 2005 KK */
int irprep_flag = 0 ;
int irprep_support = 0 ;

int enhanced_fat_suppression = 0 ;
int global_shim_method = 0 ;
int d_cf = 0; 

/* RTG support Nov 2005 KK */
int rt_opphases = 1 
;

int debugileave = 0;

float rup_factor = 2.0; /* MRIhc19114: round factor for asset */
float min_phasefov = 0.5 ;

/* MRIhc28734: core_time CV to check single axis dwell time */
float core_time = 0 ;

/* high patient weight */
int override_fatsat_high_weight = 0 ;

/* eDWI CVs */
float scale_all = 1.0 ;
float default_bvalue = 1000;
int default_difnex = 1;
int use_phygrad=1;
int total_difnex = 0;
int max_difnex = 0;
int max_nex = 0;
float max_bval = 0;
int gradopt_diffall = PSD_OFF;
int ADC_warning_flag = PSD_ON;
int edwi_extra_time = 40000; 
int bigpat_warning_flag = PSD_ON;
float avg_bval = 0.0; /* including T2 */
int max_difnex_limit = MAX_DIFF_NEX;

/* Synthtic DWI */
int syndwi_flag = PSD_OFF ;
float prescribed_max_bval=0;
float prescribed_min_bval=1000000;
float prescribed_bval_range=0.0;

int fullk_nframes = 1;

/* SVBranch: HCSDM00102521 */
float xfd_power_limit = 8.5 ;
float xfd_temp_limit = 8.5  ;

float TGenh = 0.0 ;

int vrgf_bwctrl = PSD_OFF ;

/* Refless EPI */
/* we have ref_in_scan_flag here because refless_option can potentially have more choices
   where multiple choices can correspond to the same ref_in_scan_flag value */
int ref_in_scan_flag = PSD_OFF ;
int refless_option = 1 ;
int ref_dda = 0 ;
int scan_dda = 0 ;

int pc_enh = PSD_OFF ;
int ref_volrecvcoil_flag = PSD_OFF ;

int hopc_flag = PSD_OFF ;

/*To evenly distribute power on 3 axes for diffusion gradient, diffusion direction and bval is alternating slice by slice within each TR.*/
int diff_order_flag = 0 ;
int diff_order_debug = 0;
int diff_order_verify = 0;
int diff_order_nslices = 0;
int diff_order_size = 0;
int diff_pass_counter = 0;
int diff_pass_counter_save = 0;

int skip_ir = 0;

int num_iters = 0 ;
/* margin scaling factor to avoid Under-Voltage for SV system -HCSDM00379157 HCSDM00394803 */
float dti_dse_ecoon_scaling_factor = 1.07;                 /* scaling_factor for DTI with dual spin echo and Eco_mpg on */
float dti_sse_ecoon_scaling_factor = 1.03;                 /* scaling_factor for DTI with single spin echo and Eco_mpg on */
float dti_sse_ecooff_scaling_factor = 1.0175;              /* scaling_factor for DTI with single spin echo and Eco_mpg off */
float dwi_single_all_dse_ecoon_scaling_factor = 1.04;      /* scaling_factor for DWI R_L A_P S_I SLICE ALL with dual spin echo and Eco_mpg on */
float dwi_single_all_sse_ecoon_scaling_factor = 1.01;      /* scaling_factor for DWI R_L A_P S_I SLICE ALL with single spin echo and Eco_mpg on */
float dwi_3in1_dse_ecoon_scaling_factor = 1.03;            /* scaling_factor for DWI 3in1 with dual spin echo and Eco_mpg on */

/* Kizuna 1.5T system flag */
int k15_system_flag = 0 ;       
 
/* HOEC */

int hoecc_flag = 0 ;
int hoecc_psd_flag = 0 ;
int hoecc_recon_flag = 0 ;
int hoecc_debug = 0 ;
int hoecc_support = 0 ;
int hoecc_enable = 0 ;

int necho_before_te = 0 ;

int psd_per_echo_corr = 1 ;
int read_corr_option = 1 ;

int psd_debug_echo_index = -1 ;
int psd_echo_for_debug = 0;  /* actual echo index for debug, depending on psd_debug_echo_index */
int psd_ileave_for_debug = 0;  /* actual interleave index for debug, depending on psd_debug_echo_index */
int psd_slice_for_debug = 0; /* actual slice index for debug */
float hoec_cal_data_sign = 1.0 ;
int hoecc_manual_mode_warning_flag = 0 ;
int hoecc_manual_mode_psd_override_flag = 0 ;


/* MuseCV  inlined from Muse.e */
int muse_flag = 0 ;
int muse_support = 0 ;



/* Gmax and SR control for EPI readout gradient */
float epi_srderate_factor = 1.0;
int epi_loggrd_glim_flag = PSD_OFF;
float epi_loggrd_glim = 0.0;

/* Adaptive Gmax control for MPG */
int adaptive_mpg_glim_flag = PSD_OFF;
float adaptive_mpg_glim = 0.0;

int avmaxpasses = MAX_DTI_LEGACY+MAX_T2 ; 

int nav_image_interval = 0;

int focus_B0_robust_mode = 0 ;
float focus_unwanted_delta_f = 440 ;

/***SVBranch: HCSDM00259119  eco mpg ***/

/* Control CVs */
int eco_mpg_support = 0 ;
int eco_mpg_flag = PSD_OFF ;
int mpg_opt_flag = PSD_OFF ;
int dse_enh_flag = PSD_OFF ;
int dse_opt_flag = PSD_OFF ;
int bval_arbitrary_flag = PSD_OFF ;

/* CVs for DSE opt */
float pw_d1 = 0.0 ;
float pw_d2 = 0.0 ;
float b_tol = 0.015 ;

/* CVs for MPG shape opt */
int   mpg_opt_margin = 200 ;
float mpg_opt_derate = 1.0 ;
float mpg_opt_glimit_orig = 2.8 ;

/*** end of CVs ***/



/****** host ******/
/*********************/

/****************************************************************************/


/* Navigator CVs */
int nav_type = 0 ;
int nav_sr = 10 ;
float nav_window = 2.0 ;
int navigator_flag = PSD_OFF ;
int nav_ss = 3 ;
int nav_dda = 48 ; 
int nav_pause_after_prescan = 0 ;
int enhanced_nav_flag = 1 ;
int skip_navigator_prescan = 0 ;

/* Navigator testing/debugging flag (MRIhc07063) */
int nav_test = 0 ;
int nav_alg  = 3 ;
int nav_dir = 1 ; /*MRIhc12741*/
int nav_channel = -3 ;
int nav_coilsel_index = 2 ;
int nav_normalization = 1 ;
int mon_navgs = 1;
int hist_wait_time = 1000000 ;
int nav_dump_time = 1000000 ;
float curr_eff = 0.3 ;

/* Navigator rotation cvs */
float monrot_phi = -45.0 ;

/* Navigator trigger cvs */
int navtrig_flag = PSD_OFF ;
int navgate_flag = PSD_OFF ;
int calc_rate = PSD_OFF ;
int num_slice_rr = 1 ;
int nav_prescan_tr = 200000 ;
int nav_coilsel_tr = 200000 ;
int mon_tr_nav = 20000 ;
int mon_tr_wait = 100000 ;
int navtrig_target_tr = 200000 ;
int navgate_target_tr = 20000 ;
int wait_pts = 3 ;
int navtrig_waittime = 500000 ;
float navtrig_factor = 0.5 ;
int nav_scantime_refresh = 1000000 ;
int nav_scantime_refresh_pts = 5 ;

/* Navigator debug cvs */
int nav_save_raw_data = 0 ;
int nav_debug_flag = PSD_OFF ;
int nav_timing_flag = PSD_OFF ;

int navigatorCYL_flag = PSD_OFF ;
int tlead_cylnav   = 200   ; 
int navsat_flag = PSD_OFF ;
float flip_rfcylr_navsat = 90.0 ;
float flip_rfmon_navsat = 90.0 ;
float navscale = 1.0 ;
float flip_rfcylr = 30.0 ;
float flip_rfcylrtipup = 120.0 ;
float cylr_xoff = 0.0 ;
float cylr_yoff = 0.0 ;
int cylr_manoff = 0 ;
float cylr_skew = 1.0 ;
float cylr_dtheta = 0.0 ; /* 0.1974 */

int act_te_cylr = 0;
int t_exa_cylr = 0 ;
int t_exb_cylr = 0 ;
int t_rdb_cylr = 0 ;

/* Below CV is used are used with Dynaplan + Navigator */
int rtp_mode_for_nav_dynaplan = 1 ; /* 0 - RTP_END called every dynaplan phase,1 - RTP_END called only once after the end of dynaplan*/


  float a_gxwksp = 0;
  int ia_gxwksp = 0;
  int pw_gxwkspa = 0;
  int pw_gxwkspd = 0;
  int pw_gxwksp = 0;
  int wg_gxwksp  = 0;


  float a_gywksp = 0;
  int ia_gywksp = 0;
  int pw_gywkspa = 0;
  int pw_gywkspd = 0;
  int pw_gywksp = 0;
  int wg_gywksp  = 0;


  float a_gzwksp = 0;
  int ia_gzwksp = 0;
  int pw_gzwkspa = 0;
  int pw_gzwkspd = 0;
  int pw_gzwksp = 0;
  int wg_gzwksp  = 0;


  float a_gyex1 = 0;
  int ia_gyex1 = 0;
  int pw_gyex1a = 0;
  int pw_gyex1d = 0;
  int pw_gyex1 = 0;
  int wg_gyex1  = 0;


    /* CV variables added */
    int res_omthrf2 = 0 ;


    /* CV variables added */
    int res_omthrf2left = 0 ;


    /* CV variables added */
    int res_omthrf2right = 0 ;


  int res_rf2_gradient_waveform = 0;
  int wg_rf2_gradient_waveform  = 0;


  int ia_dynr1 = 0;


  int pw_x_td0 = 0;
  int wg_x_td0  = 0;


  int pw_y_td0 = 0;
  int wg_y_td0  = 0;


  int pw_z_td0 = 0;
  int wg_z_td0  = 0;


  int pw_rho_td0 = 0;
  int wg_rho_td0  = 0;


  int pw_theta_td0 = 0;
  int wg_theta_td0  = 0;


  int pw_omega_td0 = 0;
  int wg_omega_td0  = 0;


  int pw_ssp_td0 = 0;
  int wg_ssp_td0  = 0;


    float a_gzrf1 = 0;
    int ia_gzrf1 = 0;
    int pw_gzrf1a = 0;
    int pw_gzrf1d = 0;
    int pw_gzrf1 = 0;
    int res_gzrf1 = 0;
    float a_rf1 = 0;
    int ia_rf1 = 0;
    int pw_rf1 = 0;
    int res_rf1 = 0;
    float cyc_rf1 = 0;
    int off_rf1 = 0;
    float alpha_rf1 = 0.46;
    float thk_rf1 = 0;
    float gscale_rf1 = 1.0;
    float flip_rf1 = 0;
    float a_thetarf1 = 0;
    int ia_thetarf1 = 0;
    int pw_thetarf1 = 0;
    int res_thetarf1 = 0;
    int off_thetarf1 = 0;
    int wg_rf1 = TYPRHO1 
;


  float a_gzrf2 = 0;
  int ia_gzrf2 = 0;
  int pw_gzrf2a = 0;
  int pw_gzrf2d = 0;
  int pw_gzrf2 = 0;
  float a_rf2 = 0;
  int ia_rf2 = 0;
  int pw_rf2 = 0;
  int res_rf2 = 0;
  float cyc_rf2 = 0;
  int off_rf2 = 0;
  float alpha_rf2 = 0.46;
  float thk_rf2 = 0;
  float gscale_rf2 = 1.0;
  float flip_rf2 = 0;
  int wg_rf2 = TYPRHO1 
;


  float a_gzrf2left = 0;
  int ia_gzrf2left = 0;
  int pw_gzrf2lefta = 0;
  int pw_gzrf2leftd = 0;
  int pw_gzrf2left = 0;
  float a_rf2left = 0;
  int ia_rf2left = 0;
  int pw_rf2left = 0;
  int res_rf2left = 0;
  float cyc_rf2left = 0;
  int off_rf2left = 0;
  float alpha_rf2left = 0.46;
  float thk_rf2left = 0;
  float gscale_rf2left = 1.0;
  float flip_rf2left = 0;
  int wg_rf2left = TYPRHO1 
;


  float a_gzrf2right = 0;
  int ia_gzrf2right = 0;
  int pw_gzrf2righta = 0;
  int pw_gzrf2rightd = 0;
  int pw_gzrf2right = 0;
  float a_rf2right = 0;
  int ia_rf2right = 0;
  int pw_rf2right = 0;
  int res_rf2right = 0;
  float cyc_rf2right = 0;
  int off_rf2right = 0;
  float alpha_rf2right = 0.46;
  float thk_rf2right = 0;
  float gscale_rf2right = 1.0;
  float flip_rf2right = 0;
  int wg_rf2right = TYPRHO1 
;


  int res_rf2se1b4 = 0;
  int wg_rf2se1b4  = 0;


  float a_gyrf2iv = 0;
  int ia_gyrf2iv = 0;
  int pw_gyrf2iva = 0;
  int pw_gyrf2ivd = 0;
  int pw_gyrf2iv = 0;
  int wg_gyrf2iv  = 0;


  float a_gzrf2l1 = 0;
  int ia_gzrf2l1 = 0;
  int pw_gzrf2l1a = 0;
  int pw_gzrf2l1d = 0;
  int pw_gzrf2l1 = 0;
  int wg_gzrf2l1  = 0;


  float a_gzrf2r1 = 0;
  int ia_gzrf2r1 = 0;
  int pw_gzrf2r1a = 0;
  int pw_gzrf2r1d = 0;
  int pw_gzrf2r1 = 0;
  int wg_gzrf2r1  = 0;


  float a_xgradCrusherL = 0;
  int ia_xgradCrusherL = 0;
  int pw_xgradCrusherLa = 0;
  int pw_xgradCrusherLd = 0;
  int pw_xgradCrusherL = 0;
  int wg_xgradCrusherL  = 0;


  float a_xgradCrusherR = 0;
  int ia_xgradCrusherR = 0;
  int pw_xgradCrusherRa = 0;
  int pw_xgradCrusherRd = 0;
  int pw_xgradCrusherR = 0;
  int wg_xgradCrusherR  = 0;


  float a_ygradCrusherL = 0;
  int ia_ygradCrusherL = 0;
  int pw_ygradCrusherLa = 0;
  int pw_ygradCrusherLd = 0;
  int pw_ygradCrusherL = 0;
  int wg_ygradCrusherL  = 0;


  float a_ygradCrusherR = 0;
  int ia_ygradCrusherR = 0;
  int pw_ygradCrusherRa = 0;
  int pw_ygradCrusherRd = 0;
  int pw_ygradCrusherR = 0;
  int wg_ygradCrusherR  = 0;


  float a_gzrf2leftl1 = 0;
  int ia_gzrf2leftl1 = 0;
  int pw_gzrf2leftl1a = 0;
  int pw_gzrf2leftl1d = 0;
  int pw_gzrf2leftl1 = 0;
  int wg_gzrf2leftl1  = 0;


  float a_gzrf2leftr1 = 0;
  int ia_gzrf2leftr1 = 0;
  int pw_gzrf2leftr1a = 0;
  int pw_gzrf2leftr1d = 0;
  int pw_gzrf2leftr1 = 0;
  int wg_gzrf2leftr1  = 0;


  float a_gzrf2rightl1 = 0;
  int ia_gzrf2rightl1 = 0;
  int pw_gzrf2rightl1a = 0;
  int pw_gzrf2rightl1d = 0;
  int pw_gzrf2rightl1 = 0;
  int wg_gzrf2rightl1  = 0;


  float a_gzrf2rightr1 = 0;
  int ia_gzrf2rightr1 = 0;
  int pw_gzrf2rightr1a = 0;
  int pw_gzrf2rightr1d = 0;
  int pw_gzrf2rightr1 = 0;
  int wg_gzrf2rightr1  = 0;


  float a_xgradRightCrusherL = 0;
  int ia_xgradRightCrusherL = 0;
  int pw_xgradRightCrusherLa = 0;
  int pw_xgradRightCrusherLd = 0;
  int pw_xgradRightCrusherL = 0;
  int wg_xgradRightCrusherL  = 0;


  float a_xgradRightCrusherR = 0;
  int ia_xgradRightCrusherR = 0;
  int pw_xgradRightCrusherRa = 0;
  int pw_xgradRightCrusherRd = 0;
  int pw_xgradRightCrusherR = 0;
  int wg_xgradRightCrusherR  = 0;


  float a_ygradRightCrusherL = 0;
  int ia_ygradRightCrusherL = 0;
  int pw_ygradRightCrusherLa = 0;
  int pw_ygradRightCrusherLd = 0;
  int pw_ygradRightCrusherL = 0;
  int wg_ygradRightCrusherL  = 0;


  float a_ygradRightCrusherR = 0;
  int ia_ygradRightCrusherR = 0;
  int pw_ygradRightCrusherRa = 0;
  int pw_ygradRightCrusherRd = 0;
  int pw_ygradRightCrusherR = 0;
  int wg_ygradRightCrusherR  = 0;


  float a_xgradLeftCrusherL = 0;
  int ia_xgradLeftCrusherL = 0;
  int pw_xgradLeftCrusherLa = 0;
  int pw_xgradLeftCrusherLd = 0;
  int pw_xgradLeftCrusherL = 0;
  int wg_xgradLeftCrusherL  = 0;


  float a_xgradLeftCrusherR = 0;
  int ia_xgradLeftCrusherR = 0;
  int pw_xgradLeftCrusherRa = 0;
  int pw_xgradLeftCrusherRd = 0;
  int pw_xgradLeftCrusherR = 0;
  int wg_xgradLeftCrusherR  = 0;


  float a_ygradLeftCrusherL = 0;
  int ia_ygradLeftCrusherL = 0;
  int pw_ygradLeftCrusherLa = 0;
  int pw_ygradLeftCrusherLd = 0;
  int pw_ygradLeftCrusherL = 0;
  int wg_ygradLeftCrusherL  = 0;


  float a_ygradLeftCrusherR = 0;
  int ia_ygradLeftCrusherR = 0;
  int pw_ygradLeftCrusherRa = 0;
  int pw_ygradLeftCrusherRd = 0;
  int pw_ygradLeftCrusherR = 0;
  int wg_ygradLeftCrusherR  = 0;


    float a_gxcl = 0;
    float a_gxw = 0;
    float a_gxcr = 0;
    float a_gyb = 0;
    float a_gzb = 0;
    int   ia_gxcl = 0;
    int   ia_gxw = 0;
    int   ia_gxcr = 0;
    int   ia_gyb = 0;
    int   ia_gzb = 0;
    int   pw_gxcla = 0;
    int   pw_gxcl = 0;
    int   pw_gxcld = 0;
    int   pw_gxwl = 0;
    int   pw_gxw = 0;
    int   pw_gxwr = 0;
    int   pw_gxwad = 0;
    int   pw_gxgap = 0;
    int   pw_gxcra = 0;
    int   pw_gxcr = 0;
    int   pw_gxcrd = 0;
    int   pw_gyba = 0;
    int   pw_gyb = 0;
    int   pw_gybd = 0;
    int   pw_gzba = 0;
    int   pw_gzb = 0;
    int   pw_gzbd = 0;
    int   pw_iref_gxwait = 0;
  

  int ia_rec_unblank = 0;


  int ia_rec_unblank3 = 0;


  int filter_rtb0echo = 0;


  int ia_rec_unblank2 = 0;

   




  float a_gxiref1 = 0;
  int ia_gxiref1 = 0;
  int pw_gxiref1a = 0;
  int pw_gxiref1d = 0;
  int pw_gxiref1 = 0;
  int wg_gxiref1  = 0;


  float a_gxirefr = 0;
  int ia_gxirefr = 0;
  int pw_gxirefra = 0;
  int pw_gxirefrd = 0;
  int pw_gxirefr = 0;
  int wg_gxirefr  = 0;


  float a_gy1 = 0;
  float a_gy1a = 0;
  float a_gy1b = 0;
  int ia_gy1 = 0;
  int ia_gy1wa = 0;
  int ia_gy1wb = 0;
  int pw_gy1a = 0;
  int pw_gy1d = 0;
  int pw_gy1 = 0;
  int wg_gy1  = 0;


  float a_gymn2 = 0;
  int ia_gymn2 = 0;
  int pw_gymn2a = 0;
  int pw_gymn2d = 0;
  int pw_gymn2 = 0;
  int wg_gymn2  = 0;


  float a_gymn1 = 0;
  int ia_gymn1 = 0;
  int pw_gymn1a = 0;
  int pw_gymn1d = 0;
  int pw_gymn1 = 0;
  int wg_gymn1  = 0;


  float a_gz1 = 0;
  int ia_gz1 = 0;
  int pw_gz1a = 0;
  int pw_gz1d = 0;
  int pw_gz1 = 0;
  int wg_gz1  = 0;


  float a_gzmn = 0;
  int ia_gzmn = 0;
  int pw_gzmna = 0;
  int pw_gzmnd = 0;
  int pw_gzmn = 0;
  int wg_gzmn  = 0;


  int res_rf2se1 = 0;
  int wg_rf2se1  = 0;


  float a_gxdl1 = 0;
  int ia_gxdl1 = 0;
  int pw_gxdl1a = 0;
  int pw_gxdl1d = 0;
  int pw_gxdl1 = 0;
  int wg_gxdl1  = 0;


  float a_gxdr1 = 0;
  int ia_gxdr1 = 0;
  int pw_gxdr1a = 0;
  int pw_gxdr1d = 0;
  int pw_gxdr1 = 0;
  int wg_gxdr1  = 0;


  float a_gxdl2 = 0;
  int ia_gxdl2 = 0;
  int pw_gxdl2a = 0;
  int pw_gxdl2d = 0;
  int pw_gxdl2 = 0;
  int wg_gxdl2  = 0;


  float a_gxdr2 = 0;
  int ia_gxdr2 = 0;
  int pw_gxdr2a = 0;
  int pw_gxdr2d = 0;
  int pw_gxdr2 = 0;
  int wg_gxdr2  = 0;


  float a_gxk = 0;
  int ia_gxk = 0;
  int pw_gxka = 0;
  int pw_gxkd = 0;
  int pw_gxk = 0;
  int wg_gxk  = 0;


  float a_gydl1 = 0;
  int ia_gydl1 = 0;
  int pw_gydl1a = 0;
  int pw_gydl1d = 0;
  int pw_gydl1 = 0;
  int wg_gydl1  = 0;


  float a_gydr1 = 0;
  int ia_gydr1 = 0;
  int pw_gydr1a = 0;
  int pw_gydr1d = 0;
  int pw_gydr1 = 0;
  int wg_gydr1  = 0;


  float a_gydl2 = 0;
  int ia_gydl2 = 0;
  int pw_gydl2a = 0;
  int pw_gydl2d = 0;
  int pw_gydl2 = 0;
  int wg_gydl2  = 0;


  float a_gydr2 = 0;
  int ia_gydr2 = 0;
  int pw_gydr2a = 0;
  int pw_gydr2d = 0;
  int pw_gydr2 = 0;
  int wg_gydr2  = 0;


  float a_gyk = 0;
  int ia_gyk = 0;
  int pw_gyka = 0;
  int pw_gykd = 0;
  int pw_gyk = 0;
  int wg_gyk  = 0;


  float a_gzdl1 = 0;
  int ia_gzdl1 = 0;
  int pw_gzdl1a = 0;
  int pw_gzdl1d = 0;
  int pw_gzdl1 = 0;
  int wg_gzdl1  = 0;


  float a_gzdr1 = 0;
  int ia_gzdr1 = 0;
  int pw_gzdr1a = 0;
  int pw_gzdr1d = 0;
  int pw_gzdr1 = 0;
  int wg_gzdr1  = 0;


  float a_gzdl2 = 0;
  int ia_gzdl2 = 0;
  int pw_gzdl2a = 0;
  int pw_gzdl2d = 0;
  int pw_gzdl2 = 0;
  int wg_gzdl2  = 0;


  float a_gzdr2 = 0;
  int ia_gzdr2 = 0;
  int pw_gzdr2a = 0;
  int pw_gzdr2d = 0;
  int pw_gzdr2 = 0;
  int wg_gzdr2  = 0;


  float a_gzk = 0;
  int ia_gzk = 0;
  int pw_gzka = 0;
  int pw_gzkd = 0;
  int pw_gzk = 0;
  int wg_gzk  = 0;


  int pw_wgx = 0;
  int wg_wgx  = 0;


  int pw_wgy = 0;
  int wg_wgy  = 0;


  int pw_wgz = 0;
  int wg_wgz  = 0;


  int pw_wssp = 0;
  int wg_wssp  = 0;


  int pw_sspdelay = 0;
  int wg_sspdelay  = 0;


  int pw_omegadelay = 0;
  int wg_omegadelay  = 0;


  int pw_womega = 0;
  int wg_womega  = 0;


  int pw_sspshift = 0;
  int wg_sspshift  = 0;


  int pw_ssp_pass_delay = 0;
  int wg_ssp_pass_delay  = 0;


  float a_gzrf0 = 0;
  int ia_gzrf0 = 0;
  int pw_gzrf0a = 0;
  int pw_gzrf0d = 0;
  int pw_gzrf0 = 0;
  int res_gzrf0 = 0;
  float a_rf0 = 0;
  int ia_rf0 = 0;
  int pw_rf0 = 0;
  int res_rf0 = 0;
  float cyc_rf0 = 0;
  int off_rf0 = 0;
  float alpha_rf0 = 0.46;
  float thk_rf0 = 0;
  float gscale_rf0 = 1.0;
  float flip_rf0 = 0;
  int wg_rf0 = TYPRHO1 
;


  float a_omegarf0 = 0;
  int ia_omegarf0 = 0;
  int pw_omegarf0 = 0;
  int res_omegarf0 = 0;
  int off_omegarf0 = 0;
  int rfslot_omegarf0 = 0;

  float gscale_omegarf0 = 1.0;
  int n_omegarf0 = 0;
  int wg_omegarf0  = 0;


  float a_gyk0 = 0;
  int ia_gyk0 = 0;
  int pw_gyk0a = 0;
  int pw_gyk0d = 0;
  int pw_gyk0 = 0;
  int wg_gyk0  = 0;


  int ia_bline_unblank = 0;


  int filter_blineacq1 = 0;

   




  int res_rfcssat = 0;
  int wg_rfcssat  = 0;


  float a_dbgxrfcssat = 0;
  int ia_dbgxrfcssat = 0;
  int pw_dbgxrfcssata = 0;
  int pw_dbgxrfcssatd = 0;
  int pw_dbgxrfcssat = 0;
  int wg_dbgxrfcssat  = 0;


  float a_dbgyrfcssat = 0;
  int ia_dbgyrfcssat = 0;
  int pw_dbgyrfcssata = 0;
  int pw_dbgyrfcssatd = 0;
  int pw_dbgyrfcssat = 0;
  int wg_dbgyrfcssat  = 0;


  float a_dbgzrfcssat = 0;
  int ia_dbgzrfcssat = 0;
  int pw_dbgzrfcssata = 0;
  int pw_dbgzrfcssatd = 0;
  int pw_dbgzrfcssat = 0;
  int wg_dbgzrfcssat  = 0;


  int res_omega_hs_rfcssat = 0;
  int wg_omega_hs_rfcssat  = 0;


  float a_gzrfcs = 0;
  int ia_gzrfcs = 0;
  int pw_gzrfcsa = 0;
  int pw_gzrfcsd = 0;
  int pw_gzrfcs = 0;
  int wg_gzrfcs  = 0;


  float a_gykcs = 0;
  int ia_gykcs = 0;
  int pw_gykcsa = 0;
  int pw_gykcsd = 0;
  int pw_gykcs = 0;
  int wg_gykcs  = 0;


  float a_gxkcs = 0;
  int ia_gxkcs = 0;
  int pw_gxkcsa = 0;
  int pw_gxkcsd = 0;
  int pw_gxkcs = 0;
  int wg_gxkcs  = 0;


  float a_gzkcs = 0;
  int ia_gzkcs = 0;
  int pw_gzkcsa = 0;
  int pw_gzkcsd = 0;
  int pw_gzkcs = 0;
  int wg_gzkcs  = 0;


  int pw_isi_cardiacsat = 0;
  int wg_isi_cardiacsat  = 0;


  int pw_rot_update_cardiacsat = 0;
  int wg_rot_update_cardiacsat  = 0;


  float a_gzrfse1 = 0;
  int ia_gzrfse1 = 0;
  int pw_gzrfse1a = 0;
  int pw_gzrfse1d = 0;
  int pw_gzrfse1 = 0;
  float a_rfse1 = 0;
  int ia_rfse1 = 0;
  int pw_rfse1 = 0;
  int res_rfse1 = 0;
  int temp_res_rfse1 = 0;
  float cyc_rfse1 = 0;
  int off_rfse1 = 0;
  float alpha_rfse1 = 0.46;
  float thk_rfse1 = 0;
  float gscale_rfse1 = 1.0;
  float flip_rfse1 = 0;
  int wg_rfse1 = TYPRHO1 
;


  int pw_isi_sate1 = 0;
  int wg_isi_sate1  = 0;


  int pw_rot_update_e1 = 0;
  int wg_rot_update_e1  = 0;


  float a_gykse1 = 0;
  int ia_gykse1 = 0;
  int pw_gykse1a = 0;
  int pw_gykse1d = 0;
  int pw_gykse1 = 0;
  int wg_gykse1  = 0;


  float a_gxkse1 = 0;
  int ia_gxkse1 = 0;
  int pw_gxkse1a = 0;
  int pw_gxkse1d = 0;
  int pw_gxkse1 = 0;
  int wg_gxkse1  = 0;


  int pw_isi_satek1 = 0;
  int wg_isi_satek1  = 0;


  int pw_rot_update_ek1 = 0;
  int wg_rot_update_ek1  = 0;


  float a_gzrfse2 = 0;
  int ia_gzrfse2 = 0;
  int pw_gzrfse2a = 0;
  int pw_gzrfse2d = 0;
  int pw_gzrfse2 = 0;
  float a_rfse2 = 0;
  int ia_rfse2 = 0;
  int pw_rfse2 = 0;
  int res_rfse2 = 0;
  int temp_res_rfse2 = 0;
  float cyc_rfse2 = 0;
  int off_rfse2 = 0;
  float alpha_rfse2 = 0.46;
  float thk_rfse2 = 0;
  float gscale_rfse2 = 1.0;
  float flip_rfse2 = 0;
  int wg_rfse2 = TYPRHO1 
;


  int pw_isi_sate2 = 0;
  int wg_isi_sate2  = 0;


  int pw_rot_update_e2 = 0;
  int wg_rot_update_e2  = 0;


  float a_gykse2 = 0;
  int ia_gykse2 = 0;
  int pw_gykse2a = 0;
  int pw_gykse2d = 0;
  int pw_gykse2 = 0;
  int wg_gykse2  = 0;


  float a_gxkse2 = 0;
  int ia_gxkse2 = 0;
  int pw_gxkse2a = 0;
  int pw_gxkse2d = 0;
  int pw_gxkse2 = 0;
  int wg_gxkse2  = 0;


  int pw_isi_satek2 = 0;
  int wg_isi_satek2  = 0;


  int pw_rot_update_ek2 = 0;
  int wg_rot_update_ek2  = 0;


  float a_gzrfse3 = 0;
  int ia_gzrfse3 = 0;
  int pw_gzrfse3a = 0;
  int pw_gzrfse3d = 0;
  int pw_gzrfse3 = 0;
  float a_rfse3 = 0;
  int ia_rfse3 = 0;
  int pw_rfse3 = 0;
  int res_rfse3 = 0;
  int temp_res_rfse3 = 0;
  float cyc_rfse3 = 0;
  int off_rfse3 = 0;
  float alpha_rfse3 = 0.46;
  float thk_rfse3 = 0;
  float gscale_rfse3 = 1.0;
  float flip_rfse3 = 0;
  int wg_rfse3 = TYPRHO1 
;


  int pw_isi_sate3 = 0;
  int wg_isi_sate3  = 0;


  int pw_rot_update_e3 = 0;
  int wg_rot_update_e3  = 0;


  float a_gykse3 = 0;
  int ia_gykse3 = 0;
  int pw_gykse3a = 0;
  int pw_gykse3d = 0;
  int pw_gykse3 = 0;
  int wg_gykse3  = 0;


  float a_gxkse3 = 0;
  int ia_gxkse3 = 0;
  int pw_gxkse3a = 0;
  int pw_gxkse3d = 0;
  int pw_gxkse3 = 0;
  int wg_gxkse3  = 0;


  int pw_isi_satek3 = 0;
  int wg_isi_satek3  = 0;


  int pw_rot_update_ek3 = 0;
  int wg_rot_update_ek3  = 0;


  float a_gzrfse4 = 0;
  int ia_gzrfse4 = 0;
  int pw_gzrfse4a = 0;
  int pw_gzrfse4d = 0;
  int pw_gzrfse4 = 0;
  float a_rfse4 = 0;
  int ia_rfse4 = 0;
  int pw_rfse4 = 0;
  int res_rfse4 = 0;
  int temp_res_rfse4 = 0;
  float cyc_rfse4 = 0;
  int off_rfse4 = 0;
  float alpha_rfse4 = 0.46;
  float thk_rfse4 = 0;
  float gscale_rfse4 = 1.0;
  float flip_rfse4 = 0;
  int wg_rfse4 = TYPRHO1 
;


  int pw_isi_sate4 = 0;
  int wg_isi_sate4  = 0;


  int pw_rot_update_e4 = 0;
  int wg_rot_update_e4  = 0;


  float a_gykse4 = 0;
  int ia_gykse4 = 0;
  int pw_gykse4a = 0;
  int pw_gykse4d = 0;
  int pw_gykse4 = 0;
  int wg_gykse4  = 0;


  float a_gxkse4 = 0;
  int ia_gxkse4 = 0;
  int pw_gxkse4a = 0;
  int pw_gxkse4d = 0;
  int pw_gxkse4 = 0;
  int wg_gxkse4  = 0;


  int pw_isi_satek4 = 0;
  int wg_isi_satek4  = 0;


  int pw_rot_update_ek4 = 0;
  int wg_rot_update_ek4  = 0;


  float a_gzrfse5 = 0;
  int ia_gzrfse5 = 0;
  int pw_gzrfse5a = 0;
  int pw_gzrfse5d = 0;
  int pw_gzrfse5 = 0;
  float a_rfse5 = 0;
  int ia_rfse5 = 0;
  int pw_rfse5 = 0;
  int res_rfse5 = 0;
  int temp_res_rfse5 = 0;
  float cyc_rfse5 = 0;
  int off_rfse5 = 0;
  float alpha_rfse5 = 0.46;
  float thk_rfse5 = 0;
  float gscale_rfse5 = 1.0;
  float flip_rfse5 = 0;
  int wg_rfse5 = TYPRHO1 
;


  int pw_isi_sate5 = 0;
  int wg_isi_sate5  = 0;


  int pw_rot_update_e5 = 0;
  int wg_rot_update_e5  = 0;


  float a_gykse5 = 0;
  int ia_gykse5 = 0;
  int pw_gykse5a = 0;
  int pw_gykse5d = 0;
  int pw_gykse5 = 0;
  int wg_gykse5  = 0;


  float a_gxkse5 = 0;
  int ia_gxkse5 = 0;
  int pw_gxkse5a = 0;
  int pw_gxkse5d = 0;
  int pw_gxkse5 = 0;
  int wg_gxkse5  = 0;


  int pw_isi_satek5 = 0;
  int wg_isi_satek5  = 0;


  int pw_rot_update_ek5 = 0;
  int wg_rot_update_ek5  = 0;


  float a_gzrfse6 = 0;
  int ia_gzrfse6 = 0;
  int pw_gzrfse6a = 0;
  int pw_gzrfse6d = 0;
  int pw_gzrfse6 = 0;
  float a_rfse6 = 0;
  int ia_rfse6 = 0;
  int pw_rfse6 = 0;
  int res_rfse6 = 0;
  int temp_res_rfse6 = 0;
  float cyc_rfse6 = 0;
  int off_rfse6 = 0;
  float alpha_rfse6 = 0.46;
  float thk_rfse6 = 0;
  float gscale_rfse6 = 1.0;
  float flip_rfse6 = 0;
  int wg_rfse6 = TYPRHO1 
;


  int pw_isi_sate6 = 0;
  int wg_isi_sate6  = 0;


  int pw_rot_update_e6 = 0;
  int wg_rot_update_e6  = 0;


  float a_gykse6 = 0;
  int ia_gykse6 = 0;
  int pw_gykse6a = 0;
  int pw_gykse6d = 0;
  int pw_gykse6 = 0;
  int wg_gykse6  = 0;


  float a_gxkse6 = 0;
  int ia_gxkse6 = 0;
  int pw_gxkse6a = 0;
  int pw_gxkse6d = 0;
  int pw_gxkse6 = 0;
  int wg_gxkse6  = 0;


  int pw_isi_satek6 = 0;
  int wg_isi_satek6  = 0;


  int pw_rot_update_ek6 = 0;
  int wg_rot_update_ek6  = 0;


  float a_gxrfsx1 = 0;
  int ia_gxrfsx1 = 0;
  int pw_gxrfsx1a = 0;
  int pw_gxrfsx1d = 0;
  int pw_gxrfsx1 = 0;
  float a_rfsx1 = 0;
  int ia_rfsx1 = 0;
  int pw_rfsx1 = 0;
  int res_rfsx1 = 0;
  int temp_res_rfsx1 = 0;
  float cyc_rfsx1 = 0;
  int off_rfsx1 = 0;
  float alpha_rfsx1 = 0.46;
  float gscale_rfsx1 = 1.0;
  float thk_rfsx1 = 0;
  float flip_rfsx1 = 0;
  int wg_rfsx1 = TYPRHO1 
;


  int pw_isi_satx1 = 0;
  int wg_isi_satx1  = 0;


  int pw_rot_update_x1 = 0;
  int wg_rot_update_x1  = 0;


  float a_gyksx1 = 0;
  int ia_gyksx1 = 0;
  int pw_gyksx1a = 0;
  int pw_gyksx1d = 0;
  int pw_gyksx1 = 0;
  int wg_gyksx1  = 0;


  float a_gxksx1 = 0;
  int ia_gxksx1 = 0;
  int pw_gxksx1a = 0;
  int pw_gxksx1d = 0;
  int pw_gxksx1 = 0;
  int wg_gxksx1  = 0;


  int pw_isi_satxk1 = 0;
  int wg_isi_satxk1  = 0;


  int pw_rot_update_xk1 = 0;
  int wg_rot_update_xk1  = 0;


  float a_gxrfsx2 = 0;
  int ia_gxrfsx2 = 0;
  int pw_gxrfsx2a = 0;
  int pw_gxrfsx2d = 0;
  int pw_gxrfsx2 = 0;
  float a_rfsx2 = 0;
  int ia_rfsx2 = 0;
  int pw_rfsx2 = 0;
  int res_rfsx2 = 0;
  int temp_res_rfsx2 = 0;
  float cyc_rfsx2 = 0;
  int off_rfsx2 = 0;
  float alpha_rfsx2 = 0.46;
  float gscale_rfsx2 = 1.0;
  float thk_rfsx2 = 0;
  float flip_rfsx2 = 0;
  int wg_rfsx2 = TYPRHO1 
;


  int pw_isi_satx2 = 0;
  int wg_isi_satx2  = 0;


  int pw_rot_update_x2 = 0;
  int wg_rot_update_x2  = 0;


  float a_gyksx2 = 0;
  int ia_gyksx2 = 0;
  int pw_gyksx2a = 0;
  int pw_gyksx2d = 0;
  int pw_gyksx2 = 0;
  int wg_gyksx2  = 0;


  float a_gxksx2 = 0;
  int ia_gxksx2 = 0;
  int pw_gxksx2a = 0;
  int pw_gxksx2d = 0;
  int pw_gxksx2 = 0;
  int wg_gxksx2  = 0;


  int pw_isi_satxk2 = 0;
  int wg_isi_satxk2  = 0;


  int pw_rot_update_xk2 = 0;
  int wg_rot_update_xk2  = 0;


  float a_gyrfsy1 = 0;
  int ia_gyrfsy1 = 0;
  int pw_gyrfsy1a = 0;
  int pw_gyrfsy1d = 0;
  int pw_gyrfsy1 = 0;
  float a_rfsy1 = 0;
  int ia_rfsy1 = 0;
  int pw_rfsy1 = 0;
  int res_rfsy1 = 0;
  int temp_res_rfsy1 = 0;
  float cyc_rfsy1 = 0;
  int off_rfsy1 = 0;
  float alpha_rfsy1 = 0.46;
  float thk_rfsy1 = 0;
  float gscale_rfsy1 = 1.0;
  float flip_rfsy1 = 0;
  int wg_rfsy1 = TYPRHO1 
;


  int pw_isi_saty1 = 0;
  int wg_isi_saty1  = 0;


  int pw_rot_update_y1 = 0;
  int wg_rot_update_y1  = 0;


  float a_gyksy1 = 0;
  int ia_gyksy1 = 0;
  int pw_gyksy1a = 0;
  int pw_gyksy1d = 0;
  int pw_gyksy1 = 0;
  int wg_gyksy1  = 0;


  float a_gxksy1 = 0;
  int ia_gxksy1 = 0;
  int pw_gxksy1a = 0;
  int pw_gxksy1d = 0;
  int pw_gxksy1 = 0;
  int wg_gxksy1  = 0;


  int pw_isi_satyk1 = 0;
  int wg_isi_satyk1  = 0;


  int pw_rot_update_yk1 = 0;
  int wg_rot_update_yk1  = 0;


  float a_gyrfsy2 = 0;
  int ia_gyrfsy2 = 0;
  int pw_gyrfsy2a = 0;
  int pw_gyrfsy2d = 0;
  int pw_gyrfsy2 = 0;
  float a_rfsy2 = 0;
  int ia_rfsy2 = 0;
  int pw_rfsy2 = 0;
  int res_rfsy2 = 0;
  int temp_res_rfsy2 = 0;
  float cyc_rfsy2 = 0;
  int off_rfsy2 = 0;
  float alpha_rfsy2 = 0.46;
  float thk_rfsy2 = 0;
  float gscale_rfsy2 = 1.0;
  float flip_rfsy2 = 0;
  int wg_rfsy2 = TYPRHO1 
;


  int pw_isi_saty2 = 0;
  int wg_isi_saty2  = 0;


  int pw_rot_update_y2 = 0;
  int wg_rot_update_y2  = 0;


  float a_gyksy2 = 0;
  int ia_gyksy2 = 0;
  int pw_gyksy2a = 0;
  int pw_gyksy2d = 0;
  int pw_gyksy2 = 0;
  int wg_gyksy2  = 0;


  float a_gxksy2 = 0;
  int ia_gxksy2 = 0;
  int pw_gxksy2a = 0;
  int pw_gxksy2d = 0;
  int pw_gxksy2 = 0;
  int wg_gxksy2  = 0;


  int pw_isi_satyk2 = 0;
  int wg_isi_satyk2  = 0;


  int pw_rot_update_yk2 = 0;
  int wg_rot_update_yk2  = 0;


  float a_gzrfsz1 = 0;
  int ia_gzrfsz1 = 0;
  int pw_gzrfsz1a = 0;
  int pw_gzrfsz1d = 0;
  int pw_gzrfsz1 = 0;
  float a_rfsz1 = 0;
  int ia_rfsz1 = 0;
  int pw_rfsz1 = 0;
  int res_rfsz1 = 0;
  int temp_res_rfsz1 = 0;
  float cyc_rfsz1 = 0;
  int off_rfsz1 = 0;
  float alpha_rfsz1 = 0.46;
  float thk_rfsz1 = 0;
  float gscale_rfsz1 = 1.0;
  float flip_rfsz1 = 0;
  int wg_rfsz1 = TYPRHO1 
;


  int pw_isi_satz1 = 0;
  int wg_isi_satz1  = 0;


  int pw_rot_update_z1 = 0;
  int wg_rot_update_z1  = 0;


  float a_gyksz1 = 0;
  int ia_gyksz1 = 0;
  int pw_gyksz1a = 0;
  int pw_gyksz1d = 0;
  int pw_gyksz1 = 0;
  int wg_gyksz1  = 0;


  float a_gxksz1 = 0;
  int ia_gxksz1 = 0;
  int pw_gxksz1a = 0;
  int pw_gxksz1d = 0;
  int pw_gxksz1 = 0;
  int wg_gxksz1  = 0;


  int pw_isi_satzk1 = 0;
  int wg_isi_satzk1  = 0;


  int pw_rot_update_zk1 = 0;
  int wg_rot_update_zk1  = 0;


  float a_gzrfsz2 = 0;
  int ia_gzrfsz2 = 0;
  int pw_gzrfsz2a = 0;
  int pw_gzrfsz2d = 0;
  int pw_gzrfsz2 = 0;
  float a_rfsz2 = 0;
  int ia_rfsz2 = 0;
  int pw_rfsz2 = 0;
  int res_rfsz2 = 0;
  int temp_res_rfsz2 = 0;
  float cyc_rfsz2 = 0;
  int off_rfsz2 = 0;
  float alpha_rfsz2 = 0.46;
  float thk_rfsz2 = 0;
  float gscale_rfsz2 = 1.0;
  float flip_rfsz2 = 0;
  int wg_rfsz2 = TYPRHO1 
;


  int pw_isi_satz2 = 0;
  int wg_isi_satz2  = 0;


  int pw_rot_update_z2 = 0;
  int wg_rot_update_z2  = 0;


  float a_gyksz2 = 0;
  int ia_gyksz2 = 0;
  int pw_gyksz2a = 0;
  int pw_gyksz2d = 0;
  int pw_gyksz2 = 0;
  int wg_gyksz2  = 0;


  float a_gxksz2 = 0;
  int ia_gxksz2 = 0;
  int pw_gxksz2a = 0;
  int pw_gxksz2d = 0;
  int pw_gxksz2 = 0;
  int wg_gxksz2  = 0;


  int pw_isi_satzk2 = 0;
  int wg_isi_satzk2  = 0;


  int pw_rot_update_zk2 = 0;
  int wg_rot_update_zk2  = 0;


  int pw_y_ccs_null = 0;
  int wg_y_ccs_null  = 0;


  float a_rf1mps1 = 0;
  int ia_rf1mps1 = 0;
  int pw_rf1mps1 = 0;
  int res_rf1mps1 = 0;
  float cyc_rf1mps1 = 0;
  int off_rf1mps1 = 0;
  float alpha_rf1mps1 = 0;
  int wg_rf1mps1  = 0;


  float a_gyrf1mps1 = 0;
  int ia_gyrf1mps1 = 0;
  int pw_gyrf1mps1a = 0;
  int pw_gyrf1mps1d = 0;
  int pw_gyrf1mps1 = 0;
  int wg_gyrf1mps1  = 0;


  float a_gy1mps1 = 0;
  int ia_gy1mps1 = 0;
  int pw_gy1mps1a = 0;
  int pw_gy1mps1d = 0;
  int pw_gy1mps1 = 0;
  int wg_gy1mps1  = 0;


  float a_gzrf1mps1 = 0;
  int ia_gzrf1mps1 = 0;
  int pw_gzrf1mps1a = 0;
  int pw_gzrf1mps1d = 0;
  int pw_gzrf1mps1 = 0;
  int wg_gzrf1mps1  = 0;


  float a_gz1mps1 = 0;
  int ia_gz1mps1 = 0;
  int pw_gz1mps1a = 0;
  int pw_gz1mps1d = 0;
  int pw_gz1mps1 = 0;
  int wg_gz1mps1  = 0;


  float a_gx1mps1 = 0;
  int ia_gx1mps1 = 0;
  int pw_gx1mps1a = 0;
  int pw_gx1mps1d = 0;
  int pw_gx1mps1 = 0;
  int wg_gx1mps1  = 0;


  float a_gzrf2mps1 = 0;
  int ia_gzrf2mps1 = 0;
  int pw_gzrf2mps1a = 0;
  int pw_gzrf2mps1d = 0;
  int pw_gzrf2mps1 = 0;
  float a_rf2mps1 = 0;
  int ia_rf2mps1 = 0;
  int pw_rf2mps1 = 0;
  int res_rf2mps1 = 0;
  int temp_res_rf2mps1 = 0;
  float cyc_rf2mps1 = 0;
  int off_rf2mps1 = 0;
  float alpha_rf2mps1 = 0.46;
  float thk_rf2mps1 = 0;
  float gscale_rf2mps1 = 1.0;
  float flip_rf2mps1 = 0;
  int wg_rf2mps1 = TYPRHO1 
;


  float a_gzrf2lmps1 = 0;
  int ia_gzrf2lmps1 = 0;
  int pw_gzrf2lmps1a = 0;
  int pw_gzrf2lmps1d = 0;
  int pw_gzrf2lmps1 = 0;
  int wg_gzrf2lmps1  = 0;


  float a_gzrf2rmps1 = 0;
  int ia_gzrf2rmps1 = 0;
  int pw_gzrf2rmps1a = 0;
  int pw_gzrf2rmps1d = 0;
  int pw_gzrf2rmps1 = 0;
  int wg_gzrf2rmps1  = 0;


  float a_gxwmps1 = 0;
  int ia_gxwmps1 = 0;
  int pw_gxwmps1a = 0;
  int pw_gxwmps1d = 0;
  int pw_gxwmps1 = 0;
  int wg_gxwmps1  = 0;


  int filter_echo1mps1 = 0;


  float a_gzrf1cfl = 0;
  int ia_gzrf1cfl = 0;
  int pw_gzrf1cfla = 0;
  int pw_gzrf1cfld = 0;
  int pw_gzrf1cfl = 0;
  float a_rf1cfl = 0;
  int ia_rf1cfl = 0;
  int pw_rf1cfl = 0;
  int res_rf1cfl = 0;
  int temp_res_rf1cfl = 0;
  float cyc_rf1cfl = 0;
  int off_rf1cfl = 0;
  float alpha_rf1cfl = 0.46;
  float thk_rf1cfl = 0;
  float gscale_rf1cfl = 1.0;
  float flip_rf1cfl = 0;
  int wg_rf1cfl = TYPRHO1 
;


  float a_gz1cfl = 0;
  int ia_gz1cfl = 0;
  int pw_gz1cfla = 0;
  int pw_gz1cfld = 0;
  int pw_gz1cfl = 0;
  int wg_gz1cfl  = 0;


  int filter_cfl_fid = 0;


  float a_gykcfl = 0;
  int ia_gykcfl = 0;
  int pw_gykcfla = 0;
  int pw_gykcfld = 0;
  int pw_gykcfl = 0;
  int wg_gykcfl  = 0;


  float a_gxkrcvn = 0;
  int ia_gxkrcvn = 0;
  int pw_gxkrcvna = 0;
  int pw_gxkrcvnd = 0;
  int pw_gxkrcvn = 0;
  int wg_gxkrcvn  = 0;


  float a_gykrcvn = 0;
  int ia_gykrcvn = 0;
  int pw_gykrcvna = 0;
  int pw_gykrcvnd = 0;
  int pw_gykrcvn = 0;
  int wg_gykrcvn  = 0;


  float a_gzkrcvn = 0;
  int ia_gzkrcvn = 0;
  int pw_gzkrcvna = 0;
  int pw_gzkrcvnd = 0;
  int pw_gzkrcvn = 0;
  int wg_gzkrcvn  = 0;


  int pw_grd_trig = 0;
  int wg_grd_trig  = 0;


  float a_gxk2rcvn = 0;
  int ia_gxk2rcvn = 0;
  int pw_gxk2rcvna = 0;
  int pw_gxk2rcvnd = 0;
  int pw_gxk2rcvn = 0;
  int wg_gxk2rcvn  = 0;


  float a_gyk2rcvn = 0;
  int ia_gyk2rcvn = 0;
  int pw_gyk2rcvna = 0;
  int pw_gyk2rcvnd = 0;
  int pw_gyk2rcvn = 0;
  int wg_gyk2rcvn  = 0;


  float a_gzk2rcvn = 0;
  int ia_gzk2rcvn = 0;
  int pw_gzk2rcvna = 0;
  int pw_gzk2rcvnd = 0;
  int pw_gzk2rcvn = 0;
  int wg_gzk2rcvn  = 0;


  int pw_rcvn_wait = 0;
  int wg_rcvn_wait  = 0;


  int ia_rcvrbl = 0;


  int filter_rcvn_fid = 0;


  int ia_rcvrbl2 = 0;


  float a_gzrf0cfh = 0;
  int ia_gzrf0cfh = 0;
  int pw_gzrf0cfha = 0;
  int pw_gzrf0cfhd = 0;
  int pw_gzrf0cfh = 0;
  int res_gzrf0cfh = 0;
  float a_rf0cfh = 0;
  int ia_rf0cfh = 0;
  int pw_rf0cfh = 0;
  int res_rf0cfh = 0;
  float cyc_rf0cfh = 0;
  int off_rf0cfh = 0;
  float alpha_rf0cfh = 0.46;
  float thk_rf0cfh = 0;
  float gscale_rf0cfh = 1.0;
  float flip_rf0cfh = 0;
  int wg_rf0cfh = TYPRHO1 
;


  float a_omegarf0cfh = 0;
  int ia_omegarf0cfh = 0;
  int pw_omegarf0cfh = 0;
  int res_omegarf0cfh = 0;
  int off_omegarf0cfh = 0;
  int rfslot_omegarf0cfh = 0;

  float gscale_omegarf0cfh = 1.0;
  int n_omegarf0cfh = 0;
  int wg_omegarf0cfh  = 0;


  float a_gyrf0kcfh = 0;
  int ia_gyrf0kcfh = 0;
  int pw_gyrf0kcfha = 0;
  int pw_gyrf0kcfhd = 0;
  int pw_gyrf0kcfh = 0;
  int wg_gyrf0kcfh  = 0;


  int pw_zticfh = 0;
  int wg_zticfh  = 0;


  int pw_rticfh = 0;
  int wg_rticfh  = 0;


  int pw_xticfh = 0;
  int wg_xticfh  = 0;


  int pw_yticfh = 0;
  int wg_yticfh  = 0;


  int pw_sticfh = 0;
  int wg_sticfh  = 0;


  float a_gzrf1cfh = 0;
  int ia_gzrf1cfh = 0;
  int pw_gzrf1cfha = 0;
  int pw_gzrf1cfhd = 0;
  int pw_gzrf1cfh = 0;
  float a_rf1cfh = 0;
  int ia_rf1cfh = 0;
  int pw_rf1cfh = 0;
  int res_rf1cfh = 0;
  int temp_res_rf1cfh = 0;
  float cyc_rf1cfh = 0;
  int off_rf1cfh = 0;
  float alpha_rf1cfh = 0.46;
  float thk_rf1cfh = 0;
  float gscale_rf1cfh = 1.0;
  float flip_rf1cfh = 0;
  int wg_rf1cfh = TYPRHO1 
;


  float a_rf2cfh = 0;
  int ia_rf2cfh = 0;
  int pw_rf2cfh = 0;
  int res_rf2cfh = 0;
  float cyc_rf2cfh = 0;
  int off_rf2cfh = 0;
  float alpha_rf2cfh = 0;
  int wg_rf2cfh  = 0;


  float a_rf3cfh = 0;
  int ia_rf3cfh = 0;
  int pw_rf3cfh = 0;
  int res_rf3cfh = 0;
  float cyc_rf3cfh = 0;
  int off_rf3cfh = 0;
  float alpha_rf3cfh = 0;
  int wg_rf3cfh  = 0;


  float a_rf4cfh = 0;
  int ia_rf4cfh = 0;
  int pw_rf4cfh = 0;
  int res_rf4cfh = 0;
  float cyc_rf4cfh = 0;
  int off_rf4cfh = 0;
  float alpha_rf4cfh = 0;
  int wg_rf4cfh  = 0;


  float a_gxrf2cfh = 0;
  int ia_gxrf2cfh = 0;
  int pw_gxrf2cfha = 0;
  int pw_gxrf2cfhd = 0;
  int pw_gxrf2cfh = 0;
  int wg_gxrf2cfh  = 0;


  float a_gyrf2cfh = 0;
  int ia_gyrf2cfh = 0;
  int pw_gyrf2cfha = 0;
  int pw_gyrf2cfhd = 0;
  int pw_gyrf2cfh = 0;
  int wg_gyrf2cfh  = 0;


  float a_gzrf2lcfh = 0;
  int ia_gzrf2lcfh = 0;
  int pw_gzrf2lcfha = 0;
  int pw_gzrf2lcfhd = 0;
  int pw_gzrf2lcfh = 0;
  int wg_gzrf2lcfh  = 0;


  float a_gzrf2rcfh = 0;
  int ia_gzrf2rcfh = 0;
  int pw_gzrf2rcfha = 0;
  int pw_gzrf2rcfhd = 0;
  int pw_gzrf2rcfh = 0;
  int wg_gzrf2rcfh  = 0;


  float a_gyrf3cfh = 0;
  int ia_gyrf3cfh = 0;
  int pw_gyrf3cfha = 0;
  int pw_gyrf3cfhd = 0;
  int pw_gyrf3cfh = 0;
  int wg_gyrf3cfh  = 0;


  float a_gzrf3lcfh = 0;
  int ia_gzrf3lcfh = 0;
  int pw_gzrf3lcfha = 0;
  int pw_gzrf3lcfhd = 0;
  int pw_gzrf3lcfh = 0;
  int wg_gzrf3lcfh  = 0;


  float a_gzrf3rcfh = 0;
  int ia_gzrf3rcfh = 0;
  int pw_gzrf3rcfha = 0;
  int pw_gzrf3rcfhd = 0;
  int pw_gzrf3rcfh = 0;
  int wg_gzrf3rcfh  = 0;


  float a_gy1cfh = 0;
  int ia_gy1cfh = 0;
  int pw_gy1cfha = 0;
  int pw_gy1cfhd = 0;
  int pw_gy1cfh = 0;
  int wg_gy1cfh  = 0;


  float a_gx1cfh = 0;
  int ia_gx1cfh = 0;
  int pw_gx1cfha = 0;
  int pw_gx1cfhd = 0;
  int pw_gx1cfh = 0;
  int wg_gx1cfh  = 0;


  float a_gzrf4cfh = 0;
  int ia_gzrf4cfh = 0;
  int pw_gzrf4cfha = 0;
  int pw_gzrf4cfhd = 0;
  int pw_gzrf4cfh = 0;
  int wg_gzrf4cfh  = 0;


  int pw_isi_slice1 = 0;
  int wg_isi_slice1  = 0;


  int pw_rot_slice1 = 0;
  int wg_rot_slice1  = 0;


  int pw_isi_slice2 = 0;
  int wg_isi_slice2  = 0;


  int pw_rot_slice2 = 0;
  int wg_rot_slice2  = 0;


  float a_gzrf4lcfh = 0;
  int ia_gzrf4lcfh = 0;
  int pw_gzrf4lcfha = 0;
  int pw_gzrf4lcfhd = 0;
  int pw_gzrf4lcfh = 0;
  int wg_gzrf4lcfh  = 0;


  float a_gzrf4rcfh = 0;
  int ia_gzrf4rcfh = 0;
  int pw_gzrf4rcfha = 0;
  int pw_gzrf4rcfhd = 0;
  int pw_gzrf4rcfh = 0;
  int wg_gzrf4rcfh  = 0;


  int filter_cfh_fid = 0;


  float a_gykcfh = 0;
  int ia_gykcfh = 0;
  int pw_gykcfha = 0;
  int pw_gykcfhd = 0;
  int pw_gykcfh = 0;
  int wg_gykcfh  = 0;


  int ia_contrfhubsel = 0;


  int ia_contrfsel = 0;


  int pw_csw_wait = 0;
  int wg_csw_wait  = 0;


  float a_gzrf1ftg = 0;
  int ia_gzrf1ftg = 0;
  int pw_gzrf1ftga = 0;
  int pw_gzrf1ftgd = 0;
  int pw_gzrf1ftg = 0;
  float a_rf1ftg = 0;
  int ia_rf1ftg = 0;
  int pw_rf1ftg = 0;
  int res_rf1ftg = 0;
  int temp_res_rf1ftg = 0;
  float cyc_rf1ftg = 0;
  int off_rf1ftg = 0;
  float alpha_rf1ftg = 0.46;
  float thk_rf1ftg = 0;
  float gscale_rf1ftg = 1.0;
  float flip_rf1ftg = 0;
  int wg_rf1ftg = TYPRHO1 
;


  float a_gz1ftg = 0;
  int ia_gz1ftg = 0;
  int pw_gz1ftga = 0;
  int pw_gz1ftgd = 0;
  int pw_gz1ftg = 0;
  int wg_gz1ftg  = 0;


  float a_gzrf2ftg = 0;
  int ia_gzrf2ftg = 0;
  int pw_gzrf2ftga = 0;
  int pw_gzrf2ftgd = 0;
  int pw_gzrf2ftg = 0;
  float a_rf2ftg = 0;
  int ia_rf2ftg = 0;
  int pw_rf2ftg = 0;
  int res_rf2ftg = 0;
  int temp_res_rf2ftg = 0;
  float cyc_rf2ftg = 0;
  int off_rf2ftg = 0;
  float alpha_rf2ftg = 0.46;
  float thk_rf2ftg = 0;
  float gscale_rf2ftg = 1.0;
  float flip_rf2ftg = 0;
  int wg_rf2ftg = TYPRHO1 
;


  float a_gz2ftg = 0;
  int ia_gz2ftg = 0;
  int pw_gz2ftga = 0;
  int pw_gz2ftgd = 0;
  int pw_gz2ftg = 0;
  int wg_gz2ftg  = 0;


  float a_gzrf3ftg = 0;
  int ia_gzrf3ftg = 0;
  int pw_gzrf3ftga = 0;
  int pw_gzrf3ftgd = 0;
  int pw_gzrf3ftg = 0;
  float a_rf3ftg = 0;
  int ia_rf3ftg = 0;
  int pw_rf3ftg = 0;
  int res_rf3ftg = 0;
  int temp_res_rf3ftg = 0;
  float cyc_rf3ftg = 0;
  int off_rf3ftg = 0;
  float alpha_rf3ftg = 0.46;
  float thk_rf3ftg = 0;
  float gscale_rf3ftg = 1.0;
  float flip_rf3ftg = 0;
  int wg_rf3ftg = TYPRHO1 
;


  float a_gz3ftg = 0;
  int ia_gz3ftg = 0;
  int pw_gz3ftga = 0;
  int pw_gz3ftgd = 0;
  int pw_gz3ftg = 0;
  int wg_gz3ftg  = 0;


  float a_gx1ftg = 0;
  int ia_gx1ftg = 0;
  int pw_gx1ftga = 0;
  int pw_gx1ftgd = 0;
  int pw_gx1ftg = 0;
  int wg_gx1ftg  = 0;


  float a_gx1bftg = 0;
  int ia_gx1bftg = 0;
  int pw_gx1bftga = 0;
  int pw_gx1bftgd = 0;
  int pw_gx1bftg = 0;
  int wg_gx1bftg  = 0;


  float a_gxw1ftg = 0;
  int ia_gxw1ftg = 0;
  int pw_gxw1ftga = 0;
  int pw_gxw1ftgd = 0;
  int pw_gxw1ftg = 0;
  int wg_gxw1ftg  = 0;


  float a_postgxw1ftg = 0;
  int ia_postgxw1ftg = 0;
  int pw_postgxw1ftga = 0;
  int pw_postgxw1ftgd = 0;
  int pw_postgxw1ftg = 0;
  int wg_postgxw1ftg  = 0;


  int filter_echo1ftg = 0;


  float a_gz2bftg = 0;
  int ia_gz2bftg = 0;
  int pw_gz2bftga = 0;
  int pw_gz2bftgd = 0;
  int pw_gz2bftg = 0;
  int wg_gz2bftg  = 0;


  float a_gx2ftg = 0;
  int ia_gx2ftg = 0;
  int pw_gx2ftga = 0;
  int pw_gx2ftgd = 0;
  int pw_gx2ftg = 0;
  int wg_gx2ftg  = 0;


  float a_gxw2ftg = 0;
  int ia_gxw2ftg = 0;
  int pw_gxw2ftga = 0;
  int pw_gxw2ftgd = 0;
  int pw_gxw2ftg = 0;
  int wg_gxw2ftg  = 0;


  float a_gx2test = 0;
  int ia_gx2test = 0;
  int pw_gx2testa = 0;
  int pw_gx2testd = 0;
  int pw_gx2test = 0;
  int wg_gx2test  = 0;


  int filter_echo2ftg = 0;


  float a_rf1xtg = 0;
  int ia_rf1xtg = 0;
  int pw_rf1xtg = 0;
  int res_rf1xtg = 0;
  float cyc_rf1xtg = 0;
  int off_rf1xtg = 0;
  float alpha_rf1xtg = 0;
  int wg_rf1xtg  = 0;


  float a_gyrf1xtg = 0;
  int ia_gyrf1xtg = 0;
  int pw_gyrf1xtga = 0;
  int pw_gyrf1xtgd = 0;
  int pw_gyrf1xtg = 0;
  int wg_gyrf1xtg  = 0;


  float a_gzrf1xtg = 0;
  int ia_gzrf1xtg = 0;
  int pw_gzrf1xtga = 0;
  int pw_gzrf1xtgd = 0;
  int pw_gzrf1xtg = 0;
  int wg_gzrf1xtg  = 0;


  float a_gykxtgl = 0;
  int ia_gykxtgl = 0;
  int pw_gykxtgla = 0;
  int pw_gykxtgld = 0;
  int pw_gykxtgl = 0;
  int wg_gykxtgl  = 0;


       /* off-res B1 prep pulse */
       float a_rf3xtg = 0;
       int ia_rf3xtg = 0;
       int pw_rf3xtg = 0;
       int res_rf3xtg = 0;
       int off_rf3xtg = 0;
       float alpha_rf3xtg = 0.46;
       float gscale_rf3xtg = 1.0;
       float flip_rf3xtg = 0;
       int ia_phs_rf3xtg = 0;
       int wg_rf3xtg = TYPRHO1 
;


  float a_gz1xtg = 0;
  int ia_gz1xtg = 0;
  int pw_gz1xtga = 0;
  int pw_gz1xtgd = 0;
  int pw_gz1xtg = 0;
  int wg_gz1xtg  = 0;


  float a_gzrf2xtg = 0;
  int ia_gzrf2xtg = 0;
  int pw_gzrf2xtga = 0;
  int pw_gzrf2xtgd = 0;
  int pw_gzrf2xtg = 0;
  float a_rf2xtg = 0;
  int ia_rf2xtg = 0;
  int pw_rf2xtg = 0;
  int res_rf2xtg = 0;
  int temp_res_rf2xtg = 0;
  float cyc_rf2xtg = 0;
  int off_rf2xtg = 0;
  float alpha_rf2xtg = 0.46;
  float thk_rf2xtg = 0;
  float gscale_rf2xtg = 1.0;
  float flip_rf2xtg = 0;
  int wg_rf2xtg = TYPRHO1 
;


  float a_gz2xtg = 0;
  int ia_gz2xtg = 0;
  int pw_gz2xtga = 0;
  int pw_gz2xtgd = 0;
  int pw_gz2xtg = 0;
  int wg_gz2xtg  = 0;


       /* off-res B1 prep pulse */
       float a_rf4xtg = 0;
       int ia_rf4xtg = 0;
       int pw_rf4xtg = 0;
       int res_rf4xtg = 0;
       int off_rf4xtg = 0;
       float alpha_rf4xtg = 0.46;
       float gscale_rf4xtg = 1.0;
       float flip_rf4xtg = 0;
       int ia_phs_rf4xtg = 0;
       int wg_rf4xtg = TYPRHO1 
;


  float a_gykxtgr = 0;
  int ia_gykxtgr = 0;
  int pw_gykxtgra = 0;
  int pw_gykxtgrd = 0;
  int pw_gykxtgr = 0;
  int wg_gykxtgr  = 0;


  float a_gx1bxtg = 0;
  int ia_gx1bxtg = 0;
  int pw_gx1bxtga = 0;
  int pw_gx1bxtgd = 0;
  int pw_gx1bxtg = 0;
  int wg_gx1bxtg  = 0;


  float a_gxw1xtg = 0;
  int ia_gxw1xtg = 0;
  int pw_gxw1xtga = 0;
  int pw_gxw1xtgd = 0;
  int pw_gxw1xtg = 0;
  int wg_gxw1xtg  = 0;


  int filter_echo1xtg = 0;


  float a_gzrf1as = 0;
  int ia_gzrf1as = 0;
  int pw_gzrf1asa = 0;
  int pw_gzrf1asd = 0;
  int pw_gzrf1as = 0;
  float a_rf1as = 0;
  int ia_rf1as = 0;
  int pw_rf1as = 0;
  int res_rf1as = 0;
  int temp_res_rf1as = 0;
  float cyc_rf1as = 0;
  int off_rf1as = 0;
  float alpha_rf1as = 0.46;
  float thk_rf1as = 0;
  float gscale_rf1as = 1.0;
  float flip_rf1as = 0;
  int wg_rf1as = TYPRHO1 
;


  float a_gz1as = 0;
  int ia_gz1as = 0;
  int pw_gz1asa = 0;
  int pw_gz1asd = 0;
  int pw_gz1as = 0;
  int wg_gz1as  = 0;


  float a_gxwas = 0;
  int ia_gxwas = 0;
  int pw_gxwasa = 0;
  int pw_gxwasd = 0;
  int pw_gxwas = 0;
  int wg_gxwas  = 0;


  int filter_echo1as = 0;


  float a_gx1as = 0;
  int ia_gx1as = 0;
  int pw_gx1asa = 0;
  int pw_gx1asd = 0;
  int pw_gx1as = 0;
  int wg_gx1as  = 0;


  float a_gy1as = 0;
  float a_gy1asa = 0;
  float a_gy1asb = 0;
  int ia_gy1as = 0;
  int ia_gy1aswa = 0;
  int ia_gy1aswb = 0;
  int pw_gy1asa = 0;
  int pw_gy1asd = 0;
  int pw_gy1as = 0;
  int wg_gy1as  = 0;


  float a_gy1ras = 0;
  float a_gy1rasa = 0;
  float a_gy1rasb = 0;
  int ia_gy1ras = 0;
  int ia_gy1raswa = 0;
  int ia_gy1raswb = 0;
  int pw_gy1rasa = 0;
  int pw_gy1rasd = 0;
  int pw_gy1ras = 0;
  int wg_gy1ras  = 0;


  float a_gxkas = 0;
  int ia_gxkas = 0;
  int pw_gxkasa = 0;
  int pw_gxkasd = 0;
  int pw_gxkas = 0;
  int wg_gxkas  = 0;


  float a_gzkas = 0;
  int ia_gzkas = 0;
  int pw_gzkasa = 0;
  int pw_gzkasd = 0;
  int pw_gzkas = 0;
  int wg_gzkas  = 0;


  float a_xdixon = 0;
  int ia_xdixon = 0;
  int pw_xdixon = 0;
  int wg_xdixon  = 0;


  float a_ydixon = 0;
  int ia_ydixon = 0;
  int pw_ydixon = 0;
  int wg_ydixon  = 0;


  float a_zdixon = 0;
  int ia_zdixon = 0;
  int pw_zdixon = 0;
  int wg_zdixon  = 0;


  float a_sdixon = 0;
  int ia_sdixon = 0;
  int pw_sdixon = 0;
  int wg_sdixon  = 0;


  float a_sdixon2 = 0;
  int ia_sdixon2 = 0;
  int pw_sdixon2 = 0;
  int wg_sdixon2  = 0;


  int ia_dDDIQ = 0;


  int res_rf1rs = 0;
  int wg_rf1rs  = 0;


  float a_gzrf1rs = 0;
  int ia_gzrf1rs = 0;
  int pw_gzrf1rsa = 0;
  int pw_gzrf1rsd = 0;
  int pw_gzrf1rs = 0;
  int wg_gzrf1rs  = 0;


  float a_gxkbsrs = 0;
  int ia_gxkbsrs = 0;
  int pw_gxkbsrsa = 0;
  int pw_gxkbsrsd = 0;
  int pw_gxkbsrs = 0;
  int wg_gxkbsrs  = 0;


  float a_gz1rs = 0;
  int ia_gz1rs = 0;
  int pw_gz1rsa = 0;
  int pw_gz1rsd = 0;
  int pw_gz1rs = 0;
  int wg_gz1rs  = 0;


  float a_rfbrs = 0;
  int ia_rfbrs = 0;
  int pw_rfbrs = 0;
  int res_rfbrs = 0;
  int off_rfbrs = 0;
  int rfslot_rfbrs = 0;

  float gscale_rfbrs = 1.0;
  int n_rfbrs = 0;
  int wg_rfbrs  = 0;


  float a_thetarfbrs = 0;
  int ia_thetarfbrs = 0;
  int pw_thetarfbrs = 0;
  int res_thetarfbrs = 0;
  int off_thetarfbrs = 0;
  int rfslot_thetarfbrs = 0;

  float gscale_thetarfbrs = 1.0;
  int n_thetarfbrs = 0;
  int wg_thetarfbrs  = 0;


  float a_gzkbsrs = 0;
  int ia_gzkbsrs = 0;
  int pw_gzkbsrsa = 0;
  int pw_gzkbsrsd = 0;
  int pw_gzkbsrs = 0;
  int wg_gzkbsrs  = 0;


  float a_gxwrs = 0;
  int ia_gxwrs = 0;
  int pw_gxwrsa = 0;
  int pw_gxwrsd = 0;
  int pw_gxwrs = 0;
  int wg_gxwrs  = 0;


  int filter_echo1rs = 0;


  float a_gx2rs = 0;
  int ia_gx2rs = 0;
  int pw_gx2rsa = 0;
  int pw_gx2rsd = 0;
  int pw_gx2rs = 0;
  int wg_gx2rs  = 0;


  float a_gy2rs = 0;
  float a_gy2rsa = 0;
  float a_gy2rsb = 0;
  int ia_gy2rs = 0;
  int ia_gy2rswa = 0;
  int ia_gy2rswb = 0;
  int pw_gy2rsa = 0;
  int pw_gy2rsd = 0;
  int pw_gy2rs = 0;
  int wg_gy2rs  = 0;


  float a_gxw2rs = 0;
  int ia_gxw2rs = 0;
  int pw_gxw2rsa = 0;
  int pw_gxw2rsd = 0;
  int pw_gxw2rs = 0;
  int wg_gxw2rs  = 0;


  float a_gx1rs = 0;
  int ia_gx1rs = 0;
  int pw_gx1rsa = 0;
  int pw_gx1rsd = 0;
  int pw_gx1rs = 0;
  int wg_gx1rs  = 0;


  float a_gy1rrs = 0;
  float a_gy1rrsa = 0;
  float a_gy1rrsb = 0;
  int ia_gy1rrs = 0;
  int ia_gy1rrswa = 0;
  int ia_gy1rrswb = 0;
  int pw_gy1rrsa = 0;
  int pw_gy1rrsd = 0;
  int pw_gy1rrs = 0;
  int wg_gy1rrs  = 0;


  float a_gy1rs = 0;
  float a_gy1rsa = 0;
  float a_gy1rsb = 0;
  int ia_gy1rs = 0;
  int ia_gy1rswa = 0;
  int ia_gy1rswb = 0;
  int pw_gy1rsa = 0;
  int pw_gy1rsd = 0;
  int pw_gy1rs = 0;
  int wg_gy1rs  = 0;


  float a_gzkrs = 0;
  int ia_gzkrs = 0;
  int pw_gzkrsa = 0;
  int pw_gzkrsd = 0;
  int pw_gzkrs = 0;
  int wg_gzkrs  = 0;


  float a_gxkrs = 0;
  int ia_gxkrs = 0;
  int pw_gxkrsa = 0;
  int pw_gxkrsd = 0;
  int pw_gxkrs = 0;
  int wg_gxkrs  = 0;


  int res_rf1dtg = 0;
  int wg_rf1dtg  = 0;


  float a_gzrf1dtg = 0;
  int ia_gzrf1dtg = 0;
  int pw_gzrf1dtga = 0;
  int pw_gzrf1dtgd = 0;
  int pw_gzrf1dtg = 0;
  int wg_gzrf1dtg  = 0;


  float a_gxkbsdtg = 0;
  int ia_gxkbsdtg = 0;
  int pw_gxkbsdtga = 0;
  int pw_gxkbsdtgd = 0;
  int pw_gxkbsdtg = 0;
  int wg_gxkbsdtg  = 0;


  float a_gz1dtg = 0;
  int ia_gz1dtg = 0;
  int pw_gz1dtga = 0;
  int pw_gz1dtgd = 0;
  int pw_gz1dtg = 0;
  int wg_gz1dtg  = 0;


  float a_rfbdtg = 0;
  int ia_rfbdtg = 0;
  int pw_rfbdtg = 0;
  int res_rfbdtg = 0;
  int off_rfbdtg = 0;
  int rfslot_rfbdtg = 0;

  float gscale_rfbdtg = 1.0;
  int n_rfbdtg = 0;
  int wg_rfbdtg  = 0;


  float a_thetarfbdtg = 0;
  int ia_thetarfbdtg = 0;
  int pw_thetarfbdtg = 0;
  int res_thetarfbdtg = 0;
  int off_thetarfbdtg = 0;
  int rfslot_thetarfbdtg = 0;

  float gscale_thetarfbdtg = 1.0;
  int n_thetarfbdtg = 0;
  int wg_thetarfbdtg  = 0;


  float a_gzkbsdtg = 0;
  int ia_gzkbsdtg = 0;
  int pw_gzkbsdtga = 0;
  int pw_gzkbsdtgd = 0;
  int pw_gzkbsdtg = 0;
  int wg_gzkbsdtg  = 0;


  float a_gxwdtg = 0;
  int ia_gxwdtg = 0;
  int pw_gxwdtga = 0;
  int pw_gxwdtgd = 0;
  int pw_gxwdtg = 0;
  int wg_gxwdtg  = 0;


  int filter_echo1dtg = 0;


  float a_gx2dtg = 0;
  int ia_gx2dtg = 0;
  int pw_gx2dtga = 0;
  int pw_gx2dtgd = 0;
  int pw_gx2dtg = 0;
  int wg_gx2dtg  = 0;


  float a_gy2dtg = 0;
  float a_gy2dtga = 0;
  float a_gy2dtgb = 0;
  int ia_gy2dtg = 0;
  int ia_gy2dtgwa = 0;
  int ia_gy2dtgwb = 0;
  int pw_gy2dtga = 0;
  int pw_gy2dtgd = 0;
  int pw_gy2dtg = 0;
  int wg_gy2dtg  = 0;


  float a_gxw2dtg = 0;
  int ia_gxw2dtg = 0;
  int pw_gxw2dtga = 0;
  int pw_gxw2dtgd = 0;
  int pw_gxw2dtg = 0;
  int wg_gxw2dtg  = 0;


  float a_gx1dtg = 0;
  int ia_gx1dtg = 0;
  int pw_gx1dtga = 0;
  int pw_gx1dtgd = 0;
  int pw_gx1dtg = 0;
  int wg_gx1dtg  = 0;


  float a_gy1rdtg = 0;
  float a_gy1rdtga = 0;
  float a_gy1rdtgb = 0;
  int ia_gy1rdtg = 0;
  int ia_gy1rdtgwa = 0;
  int ia_gy1rdtgwb = 0;
  int pw_gy1rdtga = 0;
  int pw_gy1rdtgd = 0;
  int pw_gy1rdtg = 0;
  int wg_gy1rdtg  = 0;


  float a_gy1dtg = 0;
  float a_gy1dtga = 0;
  float a_gy1dtgb = 0;
  int ia_gy1dtg = 0;
  int ia_gy1dtgwa = 0;
  int ia_gy1dtgwb = 0;
  int pw_gy1dtga = 0;
  int pw_gy1dtgd = 0;
  int pw_gy1dtg = 0;
  int wg_gy1dtg  = 0;


  float a_gzkdtg = 0;
  int ia_gzkdtg = 0;
  int pw_gzkdtga = 0;
  int pw_gzkdtgd = 0;
  int pw_gzkdtg = 0;
  int wg_gzkdtg  = 0;


  float a_gxkdtg = 0;
  int ia_gxkdtg = 0;
  int pw_gxkdtga = 0;
  int pw_gxkdtgd = 0;
  int pw_gxkdtg = 0;
  int wg_gxkdtg  = 0;


  float a_rf1cal = 0;
  int ia_rf1cal = 0;
  int pw_rf1cal = 0;
  int res_rf1cal = 0;
  int off_rf1cal = 0;
  int rfslot_rf1cal = 0;

  float gscale_rf1cal = 1.0;
  int n_rf1cal = 0;
  int wg_rf1cal  = 0;


  float a_gzrf1cal = 0;
  int ia_gzrf1cal = 0;
  int pw_gzrf1cala = 0;
  int pw_gzrf1cald = 0;
  int pw_gzrf1cal = 0;
  int wg_gzrf1cal  = 0;


  float a_gzcombcal = 0;
  float a_gzcombcala = 0;
  float a_gzcombcalb = 0;
  int ia_gzcombcal = 0;
  int ia_gzcombcalwa = 0;
  int ia_gzcombcalwb = 0;
  int pw_gzcombcala = 0;
  int pw_gzcombcald = 0;
  int pw_gzcombcalf = 0;    /* pulse width of leading edge */
  int pw_gzcombcal = 0;
  int res_gzcombcal = 0;
  int per_gzcombcal = 0;
  int wg_gzcombcal  = 0;


  float a_gzprcal = 0;
  float a_gzprcala = 0;
  float a_gzprcalb = 0;
  int ia_gzprcal = 0;
  int ia_gzprcalwa = 0;
  int ia_gzprcalwb = 0;
  int pw_gzprcala = 0;
  int pw_gzprcald = 0;
  int pw_gzprcalf = 0;    /* pulse width of leading edge */
  int pw_gzprcal = 0;
  int res_gzprcal = 0;
  int per_gzprcal = 0;
  int wg_gzprcal  = 0;


  float a_gxwcal = 0;
  int ia_gxwcal = 0;
  int pw_gxwcala = 0;
  int pw_gxwcald = 0;
  int pw_gxwcal = 0;
  int wg_gxwcal  = 0;


  int filter_echo1cal = 0;


  float a_gx1cal = 0;
  float a_gx1cala = 0;
  float a_gx1calb = 0;
  int ia_gx1cal = 0;
  int ia_gx1calwa = 0;
  int ia_gx1calwb = 0;
  int pw_gx1cala = 0;
  int pw_gx1cald = 0;
  int pw_gx1calf = 0;    /* pulse width of leading edge */
  int pw_gx1cal = 0;
  int res_gx1cal = 0;
  int per_gx1cal = 0;
  int wg_gx1cal  = 0;


  float a_gy1cal = 0;
  float a_gy1cala = 0;
  float a_gy1calb = 0;
  int ia_gy1cal = 0;
  int ia_gy1calwa = 0;
  int ia_gy1calwb = 0;
  int pw_gy1cala = 0;
  int pw_gy1cald = 0;
  int pw_gy1calf = 0;    /* pulse width of leading edge */
  int pw_gy1cal = 0;
  int res_gy1cal = 0;
  int per_gy1cal = 0;
  int wg_gy1cal  = 0;


  float a_gy1rcal = 0;
  float a_gy1rcala = 0;
  float a_gy1rcalb = 0;
  int ia_gy1rcal = 0;
  int ia_gy1rcalwa = 0;
  int ia_gy1rcalwb = 0;
  int pw_gy1rcala = 0;
  int pw_gy1rcald = 0;
  int pw_gy1rcalf = 0;    /* pulse width of leading edge */
  int pw_gy1rcal = 0;
  int res_gy1rcal = 0;
  int per_gy1rcal = 0;
  int wg_gy1rcal  = 0;


  float a_rf1coil = 0;
  int ia_rf1coil = 0;
  int pw_rf1coil = 0;
  int res_rf1coil = 0;
  int off_rf1coil = 0;
  int rfslot_rf1coil = 0;

  float gscale_rf1coil = 1.0;
  int n_rf1coil = 0;
  int wg_rf1coil  = 0;


  float a_gzrf1coil = 0;
  int ia_gzrf1coil = 0;
  int pw_gzrf1coila = 0;
  int pw_gzrf1coild = 0;
  int pw_gzrf1coil = 0;
  int wg_gzrf1coil  = 0;


  float a_gzcombcoil = 0;
  float a_gzcombcoila = 0;
  float a_gzcombcoilb = 0;
  int ia_gzcombcoil = 0;
  int ia_gzcombcoilwa = 0;
  int ia_gzcombcoilwb = 0;
  int pw_gzcombcoila = 0;
  int pw_gzcombcoild = 0;
  int pw_gzcombcoilf = 0;    /* pulse width of leading edge */
  int pw_gzcombcoil = 0;
  int res_gzcombcoil = 0;
  int per_gzcombcoil = 0;
  int wg_gzcombcoil  = 0;


  float a_gzprcoil = 0;
  float a_gzprcoila = 0;
  float a_gzprcoilb = 0;
  int ia_gzprcoil = 0;
  int ia_gzprcoilwa = 0;
  int ia_gzprcoilwb = 0;
  int pw_gzprcoila = 0;
  int pw_gzprcoild = 0;
  int pw_gzprcoilf = 0;    /* pulse width of leading edge */
  int pw_gzprcoil = 0;
  int res_gzprcoil = 0;
  int per_gzprcoil = 0;
  int wg_gzprcoil  = 0;


  float a_gxwcoil = 0;
  int ia_gxwcoil = 0;
  int pw_gxwcoila = 0;
  int pw_gxwcoild = 0;
  int pw_gxwcoil = 0;
  int wg_gxwcoil  = 0;


  int filter_echo1coil = 0;


  float a_gx1coil = 0;
  float a_gx1coila = 0;
  float a_gx1coilb = 0;
  int ia_gx1coil = 0;
  int ia_gx1coilwa = 0;
  int ia_gx1coilwb = 0;
  int pw_gx1coila = 0;
  int pw_gx1coild = 0;
  int pw_gx1coilf = 0;    /* pulse width of leading edge */
  int pw_gx1coil = 0;
  int res_gx1coil = 0;
  int per_gx1coil = 0;
  int wg_gx1coil  = 0;


  float a_gy1coil = 0;
  float a_gy1coila = 0;
  float a_gy1coilb = 0;
  int ia_gy1coil = 0;
  int ia_gy1coilwa = 0;
  int ia_gy1coilwb = 0;
  int pw_gy1coila = 0;
  int pw_gy1coild = 0;
  int pw_gy1coilf = 0;    /* pulse width of leading edge */
  int pw_gy1coil = 0;
  int res_gy1coil = 0;
  int per_gy1coil = 0;
  int wg_gy1coil  = 0;


  float a_gy1rcoil = 0;
  float a_gy1rcoila = 0;
  float a_gy1rcoilb = 0;
  int ia_gy1rcoil = 0;
  int ia_gy1rcoilwa = 0;
  int ia_gy1rcoilwb = 0;
  int pw_gy1rcoila = 0;
  int pw_gy1rcoild = 0;
  int pw_gy1rcoilf = 0;    /* pulse width of leading edge */
  int pw_gy1rcoil = 0;
  int res_gy1rcoil = 0;
  int per_gy1rcoil = 0;
  int wg_gy1rcoil  = 0;


  float start_gycylra = 0;
  float end_gycylra = 0;
  int ia_stgycylra = 0;
  int ia_endgycylra = 0;
  int pw_gycylra = 0;
  int res_gycylra = 0;
  int wg_gycylra  = 0;


  float start_gzcylra = 0;
  float end_gzcylra = 0;
  int ia_stgzcylra = 0;
  int ia_endgzcylra = 0;
  int pw_gzcylra = 0;
  int res_gzcylra = 0;
  int wg_gzcylra  = 0;


  int res_rfcylr = 0;
  int wg_rfcylr  = 0;


  int res_thcylr = 0;
  int wg_thcylr  = 0;


  int res_gycylr = 0;
  int wg_gycylr  = 0;


  int res_gzcylr = 0;
  int wg_gzcylr  = 0;


  float a_gzrf1mon = 0;
  int ia_gzrf1mon = 0;
  int pw_gzrf1mona = 0;
  int pw_gzrf1mond = 0;
  int pw_gzrf1mon = 0;
  float a_rf1mon = 0;
  int ia_rf1mon = 0;
  int pw_rf1mon = 0;
  int res_rf1mon = 0;
  int temp_res_rf1mon = 0;
  float cyc_rf1mon = 0;
  int off_rf1mon = 0;
  float alpha_rf1mon = 0.46;
  float thk_rf1mon = 0;
  float gscale_rf1mon = 1.0;
  float flip_rf1mon = 0;
  int wg_rf1mon = TYPRHO1 
;


  float a_gyrf1mon = 0;
  int ia_gyrf1mon = 0;
  int pw_gyrf1mona = 0;
  int pw_gyrf1mond = 0;
  int pw_gyrf1mon = 0;
  int wg_gyrf1mon  = 0;


  float a_gz1mon = 0;
  int ia_gz1mon = 0;
  int pw_gz1mona = 0;
  int pw_gz1mond = 0;
  int pw_gz1mon = 0;
  int wg_gz1mon  = 0;


  float a_gy1mon = 0;
  int ia_gy1mon = 0;
  int pw_gy1mona = 0;
  int pw_gy1mond = 0;
  int pw_gy1mon = 0;
  int wg_gy1mon  = 0;


  float a_gyrf2mon = 0;
  int ia_gyrf2mon = 0;
  int pw_gyrf2mona = 0;
  int pw_gyrf2mond = 0;
  int pw_gyrf2mon = 0;
  float a_rf2mon = 0;
  int ia_rf2mon = 0;
  int pw_rf2mon = 0;
  int res_rf2mon = 0;
  int temp_res_rf2mon = 0;
  float cyc_rf2mon = 0;
  int off_rf2mon = 0;
  float alpha_rf2mon = 0.46;
  float thk_rf2mon = 0;
  float gscale_rf2mon = 1.0;
  float flip_rf2mon = 0;
  int wg_rf2mon = TYPRHO1 
;


  float a_gyrf2lmon = 0;
  int ia_gyrf2lmon = 0;
  int pw_gyrf2lmona = 0;
  int pw_gyrf2lmond = 0;
  int pw_gyrf2lmon = 0;
  int wg_gyrf2lmon  = 0;


  float a_gyrf2rmon = 0;
  int ia_gyrf2rmon = 0;
  int pw_gyrf2rmona = 0;
  int pw_gyrf2rmond = 0;
  int pw_gyrf2rmon = 0;
  int wg_gyrf2rmon  = 0;


  float a_gxwmon = 0;
  int ia_gxwmon = 0;
  int pw_gxwmona = 0;
  int pw_gxwmond = 0;
  int pw_gxwmon = 0;
  int wg_gxwmon  = 0;


  float a_gx1mon = 0;
  int ia_gx1mon = 0;
  int pw_gx1mona = 0;
  int pw_gx1mond = 0;
  int pw_gx1mon = 0;
  int wg_gx1mon  = 0;


  float a_gxfcmon = 0;
  int ia_gxfcmon = 0;
  int pw_gxfcmona = 0;
  int pw_gxfcmond = 0;
  int pw_gxfcmon = 0;
  int wg_gxfcmon  = 0;


  int filter_echo1mon = 0;


  float a_gzkmon = 0;
  int ia_gzkmon = 0;
  int pw_gzkmona = 0;
  int pw_gzkmond = 0;
  int pw_gzkmon = 0;
  int wg_gzkmon  = 0;


  float start_gycylratipup = 0;
  float end_gycylratipup = 0;
  int ia_stgycylratipup = 0;
  int ia_endgycylratipup = 0;
  int pw_gycylratipup = 0;
  int res_gycylratipup = 0;
  int wg_gycylratipup  = 0;


  float start_gzcylratipup = 0;
  float end_gzcylratipup = 0;
  int ia_stgzcylratipup = 0;
  int ia_endgzcylratipup = 0;
  int pw_gzcylratipup = 0;
  int res_gzcylratipup = 0;
  int wg_gzcylratipup  = 0;


  int res_rfcylrtipup = 0;
  int wg_rfcylrtipup  = 0;


  int res_thcylrtipup = 0;
  int wg_thcylrtipup  = 0;


  int res_gycylrtipup = 0;
  int wg_gycylrtipup  = 0;


  int res_gzcylrtipup = 0;
  int wg_gzcylrtipup  = 0;


  float a_gyrfmontipup = 0;
  int ia_gyrfmontipup = 0;
  int pw_gyrfmontipupa = 0;
  int pw_gyrfmontipupd = 0;
  int pw_gyrfmontipup = 0;
  float a_rfmontipup = 0;
  int ia_rfmontipup = 0;
  int pw_rfmontipup = 0;
  int res_rfmontipup = 0;
  int temp_res_rfmontipup = 0;
  float cyc_rfmontipup = 0;
  int off_rfmontipup = 0;
  float alpha_rfmontipup = 0.46;
  float thk_rfmontipup = 0;
  float gscale_rfmontipup = 1.0;
  float flip_rfmontipup = 0;
  int wg_rfmontipup = TYPRHO1 
;


  float a_gzkmontipup = 0;
  int ia_gzkmontipup = 0;
  int pw_gzkmontipupa = 0;
  int pw_gzkmontipupd = 0;
  int pw_gzkmontipup = 0;
  int wg_gzkmontipup  = 0;

long _lastcv = 0;

#endif /* h_epi2_allcv_h */

