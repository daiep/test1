/*
 * GE Medical Systems
 * Copyright (C) 1998 The General Electric Company
 * 
 * $Source: %M% $
 * $Revision: %I% $  $Date: %G% %U% $
 * 
 * This file will use gradient and time cornerpoint vectors generated by
 * pulsegen on the host, and timing parameters passed to the function
 * to calculate the bvalue on each axis of a given sequence. 
 *
 * Assumptions: Instantaneous 180s
 *              Piecewise linear gradients
 * 
 * Language : ANSI C
 * Author   : Charles Michelich
 * Date     : 2000/12/07
 */
/* do not edit anything above this line */

/*
 Version      Date      Author      Description
------------------------------------------------------------------------------
 1.0        2000/12/07  CRM         Initial version.
 1.1        2000/12/21  CRM         Corrected error in interface comments.
 1.2        2004/03/24  HK/AK       MRIge91352 - SAR/dbdt changes for E3.
 PX25       2014/Apr/22 YT          HCSDM00282488 - Added max_encode_mode flag as input parameter

*/

/* System header files */
#include <stdio.h>

/* Local header files */
#include "support_decl.h"
#include "epicfuns.h"       /* Included for FreeNode() */
#include "calcbval.h"
#include "pgen_calcbval.h"
#include "psdutil.h"

/** CODE **/

/* 
 * pgen_calcbvalue
 * 
 * Type: Public Function
 *
 * Description:
 * This function uses gradient and time cornerpoint vectors generated by
 * pulsegen on the host, and timing parameters passed to the function
 * to calculate the bvalue on each axis of a given sequence. 
 *
 * pulsegen on the host is called through getCornerPoints to merge the gradient
 * cornerpoints, cleanup the output of analyzeGradients, and provide a mechanism
 * to output the cornerPoints files.  If performance becomes a concern,
 * analyzeGradients could be called directly without modification to the interface 
 * of this function.
 *
 * Prototype:
 * STATUS pgen_calcbvalue( FLOAT *bvalue,
 *                        const FLOAT rf_excite_location,
 *                        const FLOAT *rf_180_location,
 *                        const INT num_180s,
 *                        const FLOAT te,
 *                        const FLOAT gam,
 *                        const LOG_GRAD *log_grad,
 *                        const seq_entry_index,
 *                        const INT samp_rate,
 *                        const INT pgen_tr,
 *                        const INT e_flag,
 *                        const INT debug_flag
 *                        const INT bmat_flag);

 * Outputs: 
 *   FLOAT *bvalue,                  => b-value for gradient waveform (sec/mm^2)
 *   STATUS (returned)               => SUCCESS or FAILURE
 * 
 * Inputs:
 *   const FLOAT rf_excite_location, => Location of isocenter of excitation pulse (usec)
 *   const FLOAT *rf_180_location,   => Location of isocenter of 180 pulses (usec) pulses after
 *                                      excitation (NULL pointer for none)
 *   const INT num_180s,             => Number of 180s
 *   const FLOAT te,                 => Echo time - Time from magnetic isocenter of excitation 
 *                                      pulse to the collection of the center of kspace (usec)
 *   const FLOAT gam                 => Gyromagnetic ratio (Hz/Gauss)
 *   const LOG_GRAD *log_grad        => gradient structure
 *   const INT seq_entry_index       => Sequence entry point
 *   const INT samp_rate             => Gradient sampling rate
 *   const INT pgen_tr               => TR used for pulsegen on the host
 *   const INT e_flag                => EPIC error flag
 *   const INT debug_flag            => Debuging level flag
 *   const INT bmat_flag             => Flag for full bmatrix or on-diagonal calc
 *
 * FROM calcbvalue():
 * Potential strange behavior:(1) Could add a very short linear segment due to round off errors.  
 *                                No divisions by this length, so it should be safe. 
 *                            (2) bvalue is scaled by 10^20 at the end for unit conversion.  
 *                                DOUBLEs used for calculatation to avoid roundoff errors
 *
 * Assumptions: Instantaneous 180s
 *              Piecewise linear gradients
 */

STATUS pgen_calcbvalue( FLOAT *bvalue,
                       const FLOAT rf_excite_location,
                       const FLOAT *rf_180_location,
                       const INT num_180s,
                       const FLOAT te,
                       const FLOAT gam,
                       const LOG_GRAD *log_grad,
                       const INT seq_entry_index,
                       const INT samp_rate,
                       const INT pgen_tr,
                       const INT e_flag,
                       const INT debug_flag,
                       const INT bmat_flag)
{
    /* Declare variables */
    FLOAT *time;        /* Vectors of times for each gradient waveform */
    FLOAT *ampl[3];     /* Vector of gradient waveforms */
    FLOAT *pul_type[3]; /* Vector of pulse types */
    INT totpoints;      /* Number of time points in gradient,pulse_types,and time vectors */ 
    INT num_iters; /*number of iterations in cornerPoints*/
    STATUS status;      /* Status variable to catch errors from function calls */
    INT i,ngrad, num_axis, grad_axis1, grad_axis2;      /* Counter & gradient axis */
    const CHAR funcName[] = "pulsegenbvalue";  /* Current function name for debugging */
    const CHAR supfailfmt[] = "Support routine %s failed";
    FLOAT efflength=0.0;
    INT dbdtinf = 0;
    INT dbdtfactor = 0;
    INT max_encode_mode = AVERAGE_POWER;

    /* Initialize stuff */
    time = NULL;
    ampl[0] = ampl[1] = ampl[2] = NULL;
    pul_type[0] = pul_type[1] = pul_type[2] = NULL;
    totpoints = 0;

    /*---------------- Generate gradient waveforms ----------------*/
    /* Determine the digitized waveforms using pulsegen on the host */
    /* Get waveform corner points */

    /* Add more arguments to get a 
     * dbdt-cornerpoints file MRIge87006 --Venkat*/

    /* MRIge91352 - SAR/dbdt changes for E3 */

    dbdtinf = cfrinf;
    dbdtfactor = cfrfact;

    efflength = FMax(3, cfdbdtdx, cfdbdtdy, cfdbdtdz);

    mss_flags_t flags;
    flags.debug = (dbLevel_t)debug_flag;
    setupdBdtFlags( &flags );

    status = getCornerPoints( &time, ampl, pul_type, &totpoints, &num_iters,
                              &loggrd, seq_entry_index, samp_rate,
                              pgen_tr, dbdtinf, dbdtfactor,
                              efflength, max_encode_mode, &flags );

    if ( (SKIP == status) || (FAILURE == status) ) { /* Cleanup on error */
        printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                    "Freeing time, ampl and pul_type lists...\n" );
        FreeNode( time );
        for ( i = X ; i <= Z ; i++ ) {
            FreeNode( ampl[i] );
            FreeNode( pul_type[i] );
        }
        printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                    "Freeing external wave table...\n" );
        destroyExtWave();
        
        /* Generate an error for FAILURE or SKIP 
           SKIP is not acceptable for calculating the b-value */
        epic_error( e_flag, supfailfmt, EM_PSD_SUPPORT_FAILURE, 
                    1, STRING_ARG, "getCornerPoints" );
        return FAILURE;
    }
    
    /* Calculate b-value on each axis */
    num_axis = (bmat_flag == TRUE) ? 6 : 3;

    for(ngrad = 0; ngrad < num_axis; ngrad++){ 
  
        if(ngrad < 3) {
            grad_axis1 = ngrad;
            grad_axis2 = ngrad;           /* on diagonal b-matrix elements (i=j) */
        } else {
            grad_axis1 = ((ngrad<num_axis-1) ? 0 : 1);       /* off diagonal elements (i != j) */
            grad_axis2 = ((ngrad<num_axis-1) ? (ngrad+1 - 3) : 2); 
        }       
        
        status = calcbvalue(&bvalue[ngrad],rf_excite_location,rf_180_location,
                            num_180s,te,time,ampl[grad_axis1],ampl[grad_axis2],totpoints,gam);
        
        if ( (SKIP == status) || (FAILURE == status) ) { /* Cleanup on error */
            printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                        "Freeing time, ampl and pul_type lists...\n" );
            FreeNode( time );
            for ( i = X ; i <= Z ; i++ ) {
                FreeNode( ampl[i] );
                FreeNode( pul_type[i] );
            }
            printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                        "Freeing external wave table...\n" );
            destroyExtWave();
            
            /* Generate an error for FAILURE or SKIP 
               SKIP is not acceptable for calculating the b-value */
            epic_error( e_flag, supfailfmt, EM_PSD_SUPPORT_FAILURE, 
                        1, STRING_ARG, "getCornerPoints" );
            return FAILURE;
        }   
    }

    /* Print b-values for debugging */
    printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                "X bvalue = %12.8f, Y bvalue = %12.8f, Z bvalue = %12.8f, XY bvalue = %12.8f, XZ bvalue = %12.8f, YZ bvalue = %12.8f sec/mm^2\n", bvalue[0],bvalue[1],bvalue[2],bvalue[3],bvalue[4],bvalue[5]);

    /* Success!  Cleanup and return */
    printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                "Freeing time, ampl and pul_type lists...\n" );
    FreeNode( time );
    for ( i = X ; i <= Z ; i++ ) {
        FreeNode( ampl[i] );
        FreeNode( pul_type[i] );
    }
    printDebug( DBLEVEL2, (dbLevel_t)debug_flag, funcName,
                "Freeing external wave table...\n" );
    destroyExtWave();
    
    return SUCCESS;

}   /* end pgen_calcbvalue */
